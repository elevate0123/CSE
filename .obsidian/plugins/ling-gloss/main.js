/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => LingGlossPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian2 = require("obsidian");

// src/utils.ts
var resultOk = (data) => ({ success: true, data });
var resultErr = (errors) => ({ success: false, errors });
var isObject = (value) => value !== null && typeof value === "object" && !Array.isArray(value);
var deepMerge = (target, source) => {
  const result = { ...target };
  if (source == null)
    return result;
  for (const key of Object.keys(source)) {
    if (isObject(source[key])) {
      result[key] = isObject(result[key]) ? deepMerge(result[key], source[key]) : { ...source[key] };
    } else {
      result[key] = source[key];
    }
  }
  return result;
};
var deepCopy = (source, arrays = true) => {
  if (isObject(source)) {
    const result = {};
    for (const key of Object.keys(source)) {
      result[key] = deepCopy(source[key], arrays);
    }
    return result;
  }
  if (arrays && Array.isArray(source)) {
    return source.map((el) => deepCopy(el, arrays));
  }
  return source;
};
function* range(limit, start = 0) {
  for (let index = start; index < limit; index += 1)
    yield index;
}
var arrayFill = (array, limit, func) => {
  if (array.length < limit) {
    const from = array.length;
    array.length = limit;
    for (const index of range(limit, from)) {
      array[index] = func(index);
    }
  }
  return array;
};
var CssClassRegex = /[^a-z0-9_-]+/ig;
var sanitizeCssClass = (classes) => Array.isArray(classes) ? classes.map((cls) => cls.replace(CssClassRegex, "-")) : classes.replace(CssClassRegex, "-");

// src/data/gloss.ts
var getDefaultGlossOptions = () => ({
  useMarkup: false,
  altSpaces: false,
  styles: {
    global: [],
    levelA: [],
    levelB: [],
    levelC: [],
    levelX: [],
    preamble: [],
    translation: [],
    source: []
  }
});
var createGlossElement = () => ({
  levels: []
});
var createGlossData = (nlevel, options) => {
  var _a;
  return {
    nlevel,
    options: (_a = deepCopy(options)) != null ? _a : getDefaultGlossOptions(),
    number: {
      value: ""
    },
    label: "",
    preamble: "",
    translation: "",
    source: "",
    elements: []
  };
};

// src/parser/helpers.ts
var checkAssertion = (assert, errorType) => {
  if (!assert)
    throw `${errorType} provided to \u201C@@\u201D command`;
};
var checkNoValues = (params) => checkAssertion(params.length > 0, "no values");
var checkMultiValues = (params) => checkAssertion(params.length < 2, "more than one value");
var checkAnyValues = (params) => checkAssertion(params.length < 1, "more than no values");
var checkValueSimple = (param, errorType) => checkAssertion((param == null ? void 0 : param.type) === "simple", errorType);
var paramsJoin = (params) => {
  checkNoValues(params);
  return params.map((p) => p.value).join(" ");
};
var paramsOne = (params) => {
  var _a, _b;
  checkNoValues(params);
  checkMultiValues(params);
  return (_b = (_a = params.first()) == null ? void 0 : _a.value) != null ? _b : "";
};
var gatherValuesQuoted = (params) => {
  const result = [];
  for (const param of params) {
    if (param.type === "quoted") {
      const group = result.last();
      if (group == null)
        continue;
      group.push(param.value);
    } else {
      result.push([param.value]);
    }
  }
  return result;
};
var updateObjectField = (object, keys, func) => {
  if (keys.length < 1)
    return;
  for (const index of range(keys.length - 1)) {
    object = object[keys[index]];
  }
  const key = keys.at(-1);
  object[key] = func(object[key]);
};

// src/parser/tokenize.ts
var NewLineRegex = /\r\n|[\r\n\u2028\u2029]/;
var IndentRegex = /^[ \t\v\f\u00A0]+/;
function* iterateLines(input) {
  let lineNo = 0;
  for (let line of input.split(NewLineRegex)) {
    const indent = IndentRegex.test(line);
    line = line.trim();
    lineNo += 1;
    if (line.startsWith("#"))
      continue;
    if (line.length > 0) {
      yield { line, lineNo, indent };
    }
  }
}
function tokenizeLine(lineNo, line) {
  let isEscape = false;
  let isQuoted = false;
  const buffer = [];
  const tokens = [];
  for (const char of line) {
    if (isEscape) {
      isEscape = false;
      switch (char) {
        case "[":
        case "]":
        case "^":
          buffer.push(char);
          break;
        default:
          buffer.push("^");
          buffer.push(char);
          break;
      }
    } else if (isQuoted) {
      switch (char) {
        case "[":
          throw `found an invalid \u201C[\u201D (line ${lineNo})`;
        case "^":
          isEscape = true;
          break;
        case "]":
          tokens.push({
            type: "quoted",
            value: buffer.join("")
          });
          buffer.length = 0;
          isQuoted = false;
          break;
        default:
          buffer.push(char);
          break;
      }
    } else {
      switch (char) {
        case "]":
          throw `found an invalid \u201C]\u201D (line ${lineNo})`;
        case "^":
          isEscape = true;
          break;
        case "[":
        case " ":
        case "	":
        case "\v":
        case "\f":
        case "\xA0":
          if (buffer.length > 0) {
            tokens.push({
              type: "simple",
              value: buffer.join("")
            });
          }
          buffer.length = 0;
          isQuoted = char === "[";
          break;
        default:
          buffer.push(char);
          break;
      }
    }
  }
  if (isQuoted) {
    throw `found a \u201C[\u201D without a matching \u201C]\u201D (line ${lineNo})`;
  }
  if (buffer.length > 0) {
    tokens.push({
      type: "simple",
      value: buffer.join("")
    });
  }
  return tokens;
}
function tryGetCommand(lineNo, token) {
  if ((token == null ? void 0 : token.type) !== "simple")
    return null;
  if (!token.value.startsWith("\\"))
    return null;
  const star = token.value.endsWith("*");
  const name = star ? token.value.slice(1, -1) : token.value.slice(1);
  return { lineNo, name, star, params: [] };
}
var tokenize = (input) => {
  const commands = [];
  let errors = null;
  for (const { lineNo, line, indent } of iterateLines(input)) {
    try {
      const tokens = tokenizeLine(lineNo, line);
      const command = indent ? commands.last() : tryGetCommand(lineNo, tokens.shift());
      if (command == null)
        throw `found values without a command (line ${lineNo})`;
      command.params.push(...tokens);
      if (!indent) {
        commands.push(command);
      }
    } catch (error) {
      errors != null ? errors : errors = [];
      errors.push(error);
    }
  }
  return errors !== null ? resultErr(errors) : resultOk(commands);
};

// src/parser/main.ts
var GlossParser = class {
  constructor(settings) {
    this.settings = settings;
    this.commandTable = {
      // Simple string value commands
      ex: (data, params, _) => data.preamble = paramsJoin(params),
      ft: (data, params, _) => data.translation = paramsJoin(params),
      lbl: (data, params, _) => data.label = paramsJoin(params),
      src: (data, params, _) => data.source = paramsJoin(params),
      num: (data, params, _) => data.number.value = paramsOne(params),
      // Individual gloss level commands
      gla: (data, params, _) => this.handleGlossCommand(data, params, 0),
      glb: (data, params, _) => this.handleGlossCommand(data, params, 1),
      glc: (data, params, _) => this.handleGlossCommand(data, params, 2),
      // Combined n-level gloss command
      gl: (data, params, _) => this.handleMultiGlossCommand(data, params),
      // Gloss option changing command
      set: (data, params, star) => this.handleSetCommand(data, params, star)
    };
    this.setOptionTable = {
      // Assign CSS style classes
      style: { type: "list", key: ["styles", "global"] },
      exstyle: { type: "list", key: ["styles", "preamble"] },
      glastyle: { type: "list", key: ["styles", "levelA"] },
      glbstyle: { type: "list", key: ["styles", "levelB"] },
      glcstyle: { type: "list", key: ["styles", "levelC"] },
      glxstyle: { type: "list", key: ["styles", "levelX"] },
      ftstyle: { type: "list", key: ["styles", "translation"] },
      srcstyle: { type: "list", key: ["styles", "source"] },
      // Replace underscores with spaces
      glaspaces: { type: "flag", key: ["altSpaces"] },
      // Enable advanced text markup
      markup: { type: "flag", key: ["useMarkup"] }
    };
  }
  parse(input, nlevel) {
    const tokenized = tokenize(input);
    if (!tokenized.success)
      return resultErr(tokenized.errors);
    const glossData = createGlossData(nlevel, this.settings.get("gloss"));
    const procErrors = this.processCommands(tokenized.data, glossData);
    if (procErrors !== null)
      return resultErr(procErrors);
    return resultOk(glossData);
  }
  processCommands(commands, data) {
    var _a, _b;
    let errors = null;
    for (const command of commands) {
      try {
        const action = this.commandTable[command.name];
        if (action == null)
          throw "command \u201C@@\u201D is not known";
        action(data, command.params, command.star);
      } catch (error) {
        error = `${error} (line ${command.lineNo})`.replace("@@", command.name).replace("@1", (_b = (_a = command.params[0]) == null ? void 0 : _a.value) != null ? _b : "");
        errors != null ? errors : errors = [];
        errors.push(error);
      }
    }
    return errors;
  }
  handleGlossCommand(data, params, level) {
    var _a, _b;
    checkNoValues(params);
    arrayFill(data.elements, params.length, () => createGlossElement());
    for (const [index, elem] of data.elements.entries()) {
      arrayFill(elem.levels, level + 1, () => "");
      elem.levels[level] = (_b = (_a = params[index]) == null ? void 0 : _a.value) != null ? _b : "";
    }
  }
  handleMultiGlossCommand(data, params) {
    checkNoValues(params);
    checkValueSimple(params.first(), "invalid gloss element");
    const bits = gatherValuesQuoted(params);
    const maxLevel = bits.reduce((acc, el) => Math.max(acc, el.length), 0);
    arrayFill(data.elements, bits.length, () => createGlossElement());
    for (const [index, elem] of data.elements.entries()) {
      arrayFill(elem.levels, maxLevel, (bit) => {
        var _a;
        return (_a = bits[index][bit]) != null ? _a : "";
      });
    }
  }
  handleSetCommand(data, params, star) {
    const [optionParam, ...valueParams] = params;
    checkValueSimple(optionParam, "no option name");
    const option = this.setOptionTable[optionParam.value];
    checkAssertion(option != null, "unknown option \u201C@1\u201D");
    const object = data.options;
    const objectKeys = option.key;
    switch (option.type) {
      case "flag":
        checkAnyValues(valueParams);
        updateObjectField(object, objectKeys, () => !star);
        break;
      case "one":
        checkNoValues(valueParams);
        checkMultiValues(valueParams);
        updateObjectField(object, objectKeys, () => valueParams[0].value);
        break;
      case "list":
        if (!star)
          checkNoValues(valueParams);
        updateObjectField(object, objectKeys, (value) => {
          const newValue = valueParams.map((p) => p.value);
          return star ? newValue : [...value, ...newValue];
        });
        break;
    }
  }
};

// src/render/helpers.ts
var getStyleKind = (kind) => kind.length > 0 ? `ling-gloss-${kind}` : "ling-gloss";
var getStyleClasses = (classes) => sanitizeCssClass(classes).filter((cls) => cls.length > 0).map((cls) => `ling-style-${cls}`);
var getLevelMetadata = (level) => {
  switch (level) {
    case 0:
      return ["level-a", "levelA"];
    case 1:
      return ["level-b", "levelB"];
    case 2:
      return ["level-c", "levelC"];
    default:
      return ["level-x", "levelX"];
  }
};
var formatWhitespace = (text) => text.replace(/\s+/g, "\xA0");
var renderBlock = (target, options) => {
  var _a, _b, _c;
  if (options.text.length < 1 && !options.always)
    return;
  target.createDiv({
    text: (_b = (_a = options.format) == null ? void 0 : _a.call(options, options.text)) != null ? _b : formatWhitespace(options.text),
    cls: [getStyleKind(options.kind), ...getStyleClasses((_c = options.cls) != null ? _c : [])]
  });
};

// src/render/main.ts
var GlossRenderer = class {
  renderErrors(target, errors) {
    target.empty();
    for (const error of errors) {
      renderBlock(target, { kind: "error", text: error });
    }
  }
  renderGloss(target, data) {
    const { styles, altSpaces, useMarkup } = data.options;
    if (useMarkup) {
      return this.renderErrors(target, ["advanced markup is not supported at the time"]);
    }
    target.empty();
    const container = target.createDiv({ cls: getStyleKind("") });
    renderBlock(container, {
      kind: "number",
      text: data.number.value,
      always: true
    });
    const gloss = container.createDiv({
      cls: [getStyleKind("body"), ...getStyleClasses(styles.global)]
    });
    renderBlock(gloss, {
      kind: "label",
      text: data.label
    });
    renderBlock(gloss, {
      kind: "preamble",
      cls: styles.preamble,
      text: data.preamble,
      format: (text) => this.formatText(text, false, useMarkup)
    });
    if (data.elements.length > 0) {
      const elements = gloss.createDiv({ cls: getStyleKind("elements") });
      for (const { levels } of data.elements) {
        const element = elements.createDiv({ cls: getStyleKind("element") });
        for (const [levelNo, level] of levels.entries()) {
          const [levelKind, styleKey] = getLevelMetadata(levelNo);
          const glaSpaces = altSpaces && levelNo === 0;
          renderBlock(element, {
            kind: levelKind,
            cls: styles[styleKey],
            text: level,
            always: true,
            format: (text) => this.formatText(text, glaSpaces, useMarkup)
          });
        }
      }
    }
    if (data.translation.length > 0 || data.source.length > 0) {
      const postamble = gloss.createDiv({ cls: getStyleKind("postamble") });
      renderBlock(postamble, {
        kind: "translation",
        cls: styles.translation,
        text: data.translation,
        format: (text) => this.formatText(text, false, useMarkup)
      });
      renderBlock(postamble, {
        kind: "source",
        cls: styles.source,
        text: data.source
      });
    }
    if (!gloss.hasChildNodes()) {
      return this.renderErrors(target, ["this gloss contains no elements"]);
    }
  }
  formatText(text, altSpaces, useMarkup) {
    if (altSpaces) {
      text = text.replace(/[_]+/, " ");
    }
    if (useMarkup) {
      throw "not implemented yet";
    }
    return formatWhitespace(text);
  }
};

// src/settings/main.ts
var import_obsidian = require("obsidian");
var PluginSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(plugin, settings) {
    super(plugin.app, plugin);
    this.settings = settings;
  }
  display() {
    this.containerEl.empty();
    this.addSwitchSettings();
    this.addStyleSettings();
  }
  addSwitchSettings() {
    const desc = new DocumentFragment();
    desc.appendText("Default feature switch settings for all glosses.");
    desc.createEl("br");
    desc.appendText("To unset the enabled ones, the ");
    desc.createEl("code", { text: " \\set*" });
    desc.appendText(" command can be used.");
    new import_obsidian.Setting(this.containerEl).setName("Feature switches").setDesc(desc).setHeading();
    this.addSwitchSettingByKey("altSpaces", "Alternate spaces", "glaspaces");
    this.addSwitchSettingByKey("useMarkup", "Process markup", "markup");
  }
  addStyleSettings() {
    const desc = new DocumentFragment();
    desc.appendText("Default style classes for all glosses. The ");
    desc.createEl("code", { text: "\\set" });
    desc.appendText(" command will append to these.");
    desc.createEl("br");
    desc.appendText("To replace or remove these, the ");
    desc.createEl("code", { text: "\\set*" });
    desc.appendText(" command can be used instead.");
    new import_obsidian.Setting(this.containerEl).setName("Style classes").setDesc(desc).setHeading();
    this.addStyleSettingByKey("global", "Global styles", "style");
    this.addStyleSettingByKey("levelA", "Gloss level A", "glastyle");
    this.addStyleSettingByKey("levelB", "Gloss level B", "glbstyle");
    this.addStyleSettingByKey("levelC", "Gloss level C", "glcstyle");
    this.addStyleSettingByKey("levelX", "Other gloss levels", "glxstyle");
    this.addStyleSettingByKey("preamble", "Preamble/example text", "exstyle");
    this.addStyleSettingByKey("translation", "Translation text", "ftstyle");
    this.addStyleSettingByKey("source", "Gloss source", "srcstyle");
  }
  addStyleSettingByKey(style, label, command) {
    const { styles } = this.settings.get("gloss");
    const desc = new DocumentFragment();
    desc.appendText("Default style classes for the ");
    desc.createEl("code", { text: `\\set ${command}` });
    desc.appendText(" option.");
    new import_obsidian.Setting(this.containerEl).setName(label).setDesc(desc).addText((component) => {
      component.setPlaceholder("class1 class2 ...").setValue(styles[style].join(" ")).onChange(async (value) => {
        await this.settings.update({
          gloss: {
            styles: {
              [style]: sanitizeCssClass(value.split(/\s+/))
            }
          }
        });
      });
      component.inputEl.addClass("ling-gloss-settings-wide");
    });
  }
  addSwitchSettingByKey(flag, label, command) {
    const gloss = this.settings.get("gloss");
    const desc = new DocumentFragment();
    desc.appendText("Default switch setting for the ");
    desc.createEl("code", { text: `\\set ${command}` });
    desc.appendText(" option.");
    new import_obsidian.Setting(this.containerEl).setName(label).setDesc(desc).addToggle((component) => {
      component.setValue(gloss[flag]).onChange(async (value) => {
        await this.settings.update({
          gloss: {
            [flag]: value
          }
        });
      });
    });
  }
};

// src/data/settings.ts
var getDefaultPluginSettings = () => ({
  gloss: getDefaultGlossOptions()
});

// src/settings/wrapper.ts
var PluginSettingsWrapper = class {
  constructor(plugin) {
    this.plugin = plugin;
  }
  async load() {
    this.settings = deepMerge(
      getDefaultPluginSettings(),
      await this.plugin.loadData()
    );
  }
  async save() {
    await this.plugin.saveData(this.settings);
  }
  async update(newSettings) {
    this.settings = deepMerge(this.settings, newSettings);
    await this.save();
  }
  get(key) {
    return this.settings[key];
  }
  set(key, value) {
    this.settings[key] = value;
  }
};

// src/main.ts
var LingGlossPlugin = class extends import_obsidian2.Plugin {
  constructor() {
    super(...arguments);
    this.settings = new PluginSettingsWrapper(this);
    this.parser = new GlossParser(this.settings);
    this.renderer = new GlossRenderer();
  }
  async onload() {
    await this.settings.load();
    this.addSettingTab(new PluginSettingsTab(this, this.settings));
    this.registerMarkdownCodeBlockProcessor("gloss", (src, el, _) => this.processGlossMarkdown(src, el, false));
    this.registerMarkdownCodeBlockProcessor("ngloss", (src, el, _) => this.processGlossMarkdown(src, el, true));
  }
  processGlossMarkdown(source, el, nlevel) {
    const glossData = this.parser.parse(source, nlevel);
    if (glossData.success) {
      this.renderer.renderGloss(el, glossData.data);
    } else {
      this.renderer.renderErrors(el, glossData.errors);
    }
  }
};

/* nosourcemap */