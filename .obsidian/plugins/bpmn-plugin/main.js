/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all2) => {
  for (var name2 in all2)
    __defProp(target, name2, { get: all2[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/classnames/index.js
var require_classnames = __commonJS({
  "node_modules/classnames/index.js"(exports, module2) {
    (function() {
      "use strict";
      var hasOwn = {}.hasOwnProperty;
      function classNames() {
        var classes3 = "";
        for (var i7 = 0; i7 < arguments.length; i7++) {
          var arg = arguments[i7];
          if (arg) {
            classes3 = appendClass(classes3, parseValue(arg));
          }
        }
        return classes3;
      }
      function parseValue(arg) {
        if (typeof arg === "string" || typeof arg === "number") {
          return arg;
        }
        if (typeof arg !== "object") {
          return "";
        }
        if (Array.isArray(arg)) {
          return classNames.apply(null, arg);
        }
        if (arg.toString !== Object.prototype.toString && !arg.toString.toString().includes("[native code]")) {
          return arg.toString();
        }
        var classes3 = "";
        for (var key in arg) {
          if (hasOwn.call(arg, key) && arg[key]) {
            classes3 = appendClass(classes3, key);
          }
        }
        return classes3;
      }
      function appendClass(value, newClass) {
        if (!newClass) {
          return value;
        }
        if (value) {
          return value + " " + newClass;
        }
        return value + newClass;
      }
      if (typeof module2 !== "undefined" && module2.exports) {
        classNames.default = classNames;
        module2.exports = classNames;
      } else if (typeof define === "function" && typeof define.amd === "object" && define.amd) {
        define("classnames", [], function() {
          return classNames;
        });
      } else {
        window.classNames = classNames;
      }
    })();
  }
});

// node_modules/randomcolor/randomColor.js
var require_randomColor = __commonJS({
  "node_modules/randomcolor/randomColor.js"(exports, module2) {
    (function(root, factory) {
      if (typeof exports === "object") {
        var randomColor2 = factory();
        if (typeof module2 === "object" && module2 && module2.exports) {
          exports = module2.exports = randomColor2;
        }
        exports.randomColor = randomColor2;
      } else if (typeof define === "function" && define.amd) {
        define([], factory);
      } else {
        root.randomColor = factory();
      }
    })(exports, function() {
      var seed = null;
      var colorDictionary = {};
      loadColorBounds();
      var colorRanges = [];
      var randomColor2 = function(options) {
        options = options || {};
        if (options.seed !== void 0 && options.seed !== null && options.seed === parseInt(options.seed, 10)) {
          seed = options.seed;
        } else if (typeof options.seed === "string") {
          seed = stringToInteger(options.seed);
        } else if (options.seed !== void 0 && options.seed !== null) {
          throw new TypeError("The seed value must be an integer or string");
        } else {
          seed = null;
        }
        var H3, S3, B6;
        if (options.count !== null && options.count !== void 0) {
          var totalColors = options.count, colors2 = [];
          for (var i7 = 0; i7 < options.count; i7++) {
            colorRanges.push(false);
          }
          options.count = null;
          while (totalColors > colors2.length) {
            var color = randomColor2(options);
            if (seed !== null) {
              options.seed = seed;
            }
            colors2.push(color);
          }
          options.count = totalColors;
          return colors2;
        }
        H3 = pickHue(options);
        S3 = pickSaturation(H3, options);
        B6 = pickBrightness(H3, S3, options);
        return setFormat([H3, S3, B6], options);
      };
      function pickHue(options) {
        if (colorRanges.length > 0) {
          var hueRange = getRealHueRange(options.hue);
          var hue = randomWithin(hueRange);
          var step = (hueRange[1] - hueRange[0]) / colorRanges.length;
          var j6 = parseInt((hue - hueRange[0]) / step);
          if (colorRanges[j6] === true) {
            j6 = (j6 + 2) % colorRanges.length;
          } else {
            colorRanges[j6] = true;
          }
          var min5 = (hueRange[0] + j6 * step) % 359, max8 = (hueRange[0] + (j6 + 1) * step) % 359;
          hueRange = [min5, max8];
          hue = randomWithin(hueRange);
          if (hue < 0) {
            hue = 360 + hue;
          }
          return hue;
        } else {
          var hueRange = getHueRange(options.hue);
          hue = randomWithin(hueRange);
          if (hue < 0) {
            hue = 360 + hue;
          }
          return hue;
        }
      }
      function pickSaturation(hue, options) {
        if (options.hue === "monochrome") {
          return 0;
        }
        if (options.luminosity === "random") {
          return randomWithin([0, 100]);
        }
        var saturationRange = getSaturationRange(hue);
        var sMin = saturationRange[0], sMax = saturationRange[1];
        switch (options.luminosity) {
          case "bright":
            sMin = 55;
            break;
          case "dark":
            sMin = sMax - 10;
            break;
          case "light":
            sMax = 55;
            break;
        }
        return randomWithin([sMin, sMax]);
      }
      function pickBrightness(H3, S3, options) {
        var bMin = getMinimumBrightness(H3, S3), bMax = 100;
        switch (options.luminosity) {
          case "dark":
            bMax = bMin + 20;
            break;
          case "light":
            bMin = (bMax + bMin) / 2;
            break;
          case "random":
            bMin = 0;
            bMax = 100;
            break;
        }
        return randomWithin([bMin, bMax]);
      }
      function setFormat(hsv, options) {
        switch (options.format) {
          case "hsvArray":
            return hsv;
          case "hslArray":
            return HSVtoHSL(hsv);
          case "hsl":
            var hsl = HSVtoHSL(hsv);
            return "hsl(" + hsl[0] + ", " + hsl[1] + "%, " + hsl[2] + "%)";
          case "hsla":
            var hslColor = HSVtoHSL(hsv);
            var alpha = options.alpha || Math.random();
            return "hsla(" + hslColor[0] + ", " + hslColor[1] + "%, " + hslColor[2] + "%, " + alpha + ")";
          case "rgbArray":
            return HSVtoRGB(hsv);
          case "rgb":
            var rgb = HSVtoRGB(hsv);
            return "rgb(" + rgb.join(", ") + ")";
          case "rgba":
            var rgbColor = HSVtoRGB(hsv);
            var alpha = options.alpha || Math.random();
            return "rgba(" + rgbColor.join(", ") + ", " + alpha + ")";
          default:
            return HSVtoHex(hsv);
        }
      }
      function getMinimumBrightness(H3, S3) {
        var lowerBounds = getColorInfo(H3).lowerBounds;
        for (var i7 = 0; i7 < lowerBounds.length - 1; i7++) {
          var s1 = lowerBounds[i7][0], v1 = lowerBounds[i7][1];
          var s22 = lowerBounds[i7 + 1][0], v22 = lowerBounds[i7 + 1][1];
          if (S3 >= s1 && S3 <= s22) {
            var m6 = (v22 - v1) / (s22 - s1), b4 = v1 - m6 * s1;
            return m6 * S3 + b4;
          }
        }
        return 0;
      }
      function getHueRange(colorInput) {
        if (typeof parseInt(colorInput) === "number") {
          var number = parseInt(colorInput);
          if (number < 360 && number > 0) {
            return [number, number];
          }
        }
        if (typeof colorInput === "string") {
          if (colorDictionary[colorInput]) {
            var color = colorDictionary[colorInput];
            if (color.hueRange) {
              return color.hueRange;
            }
          } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
            var hue = HexToHSB(colorInput)[0];
            return [hue, hue];
          }
        }
        return [0, 360];
      }
      function getSaturationRange(hue) {
        return getColorInfo(hue).saturationRange;
      }
      function getColorInfo(hue) {
        if (hue >= 334 && hue <= 360) {
          hue -= 360;
        }
        for (var colorName in colorDictionary) {
          var color = colorDictionary[colorName];
          if (color.hueRange && hue >= color.hueRange[0] && hue <= color.hueRange[1]) {
            return colorDictionary[colorName];
          }
        }
        return "Color not found";
      }
      function randomWithin(range) {
        if (seed === null) {
          var golden_ratio = 0.618033988749895;
          var r7 = Math.random();
          r7 += golden_ratio;
          r7 %= 1;
          return Math.floor(range[0] + r7 * (range[1] + 1 - range[0]));
        } else {
          var max8 = range[1] || 1;
          var min5 = range[0] || 0;
          seed = (seed * 9301 + 49297) % 233280;
          var rnd = seed / 233280;
          return Math.floor(min5 + rnd * (max8 - min5));
        }
      }
      function HSVtoHex(hsv) {
        var rgb = HSVtoRGB(hsv);
        function componentToHex(c5) {
          var hex2 = c5.toString(16);
          return hex2.length == 1 ? "0" + hex2 : hex2;
        }
        var hex = "#" + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);
        return hex;
      }
      function defineColor(name2, hueRange, lowerBounds) {
        var sMin = lowerBounds[0][0], sMax = lowerBounds[lowerBounds.length - 1][0], bMin = lowerBounds[lowerBounds.length - 1][1], bMax = lowerBounds[0][1];
        colorDictionary[name2] = {
          hueRange,
          lowerBounds,
          saturationRange: [sMin, sMax],
          brightnessRange: [bMin, bMax]
        };
      }
      function loadColorBounds() {
        defineColor(
          "monochrome",
          null,
          [[0, 0], [100, 0]]
        );
        defineColor(
          "red",
          [-26, 18],
          [[20, 100], [30, 92], [40, 89], [50, 85], [60, 78], [70, 70], [80, 60], [90, 55], [100, 50]]
        );
        defineColor(
          "orange",
          [18, 46],
          [[20, 100], [30, 93], [40, 88], [50, 86], [60, 85], [70, 70], [100, 70]]
        );
        defineColor(
          "yellow",
          [46, 62],
          [[25, 100], [40, 94], [50, 89], [60, 86], [70, 84], [80, 82], [90, 80], [100, 75]]
        );
        defineColor(
          "green",
          [62, 178],
          [[30, 100], [40, 90], [50, 85], [60, 81], [70, 74], [80, 64], [90, 50], [100, 40]]
        );
        defineColor(
          "blue",
          [178, 257],
          [[20, 100], [30, 86], [40, 80], [50, 74], [60, 60], [70, 52], [80, 44], [90, 39], [100, 35]]
        );
        defineColor(
          "purple",
          [257, 282],
          [[20, 100], [30, 87], [40, 79], [50, 70], [60, 65], [70, 59], [80, 52], [90, 45], [100, 42]]
        );
        defineColor(
          "pink",
          [282, 334],
          [[20, 100], [30, 90], [40, 86], [60, 84], [80, 80], [90, 75], [100, 73]]
        );
      }
      function HSVtoRGB(hsv) {
        var h5 = hsv[0];
        if (h5 === 0) {
          h5 = 1;
        }
        if (h5 === 360) {
          h5 = 359;
        }
        h5 = h5 / 360;
        var s5 = hsv[1] / 100, v5 = hsv[2] / 100;
        var h_i = Math.floor(h5 * 6), f6 = h5 * 6 - h_i, p5 = v5 * (1 - s5), q6 = v5 * (1 - f6 * s5), t7 = v5 * (1 - (1 - f6) * s5), r7 = 256, g6 = 256, b4 = 256;
        switch (h_i) {
          case 0:
            r7 = v5;
            g6 = t7;
            b4 = p5;
            break;
          case 1:
            r7 = q6;
            g6 = v5;
            b4 = p5;
            break;
          case 2:
            r7 = p5;
            g6 = v5;
            b4 = t7;
            break;
          case 3:
            r7 = p5;
            g6 = q6;
            b4 = v5;
            break;
          case 4:
            r7 = t7;
            g6 = p5;
            b4 = v5;
            break;
          case 5:
            r7 = v5;
            g6 = p5;
            b4 = q6;
            break;
        }
        var result = [Math.floor(r7 * 255), Math.floor(g6 * 255), Math.floor(b4 * 255)];
        return result;
      }
      function HexToHSB(hex) {
        hex = hex.replace(/^#/, "");
        hex = hex.length === 3 ? hex.replace(/(.)/g, "$1$1") : hex;
        var red = parseInt(hex.substr(0, 2), 16) / 255, green = parseInt(hex.substr(2, 2), 16) / 255, blue = parseInt(hex.substr(4, 2), 16) / 255;
        var cMax = Math.max(red, green, blue), delta2 = cMax - Math.min(red, green, blue), saturation = cMax ? delta2 / cMax : 0;
        switch (cMax) {
          case red:
            return [60 * ((green - blue) / delta2 % 6) || 0, saturation, cMax];
          case green:
            return [60 * ((blue - red) / delta2 + 2) || 0, saturation, cMax];
          case blue:
            return [60 * ((red - green) / delta2 + 4) || 0, saturation, cMax];
        }
      }
      function HSVtoHSL(hsv) {
        var h5 = hsv[0], s5 = hsv[1] / 100, v5 = hsv[2] / 100, k6 = (2 - s5) * v5;
        return [
          h5,
          Math.round(s5 * v5 / (k6 < 1 ? k6 : 2 - k6) * 1e4) / 100,
          k6 / 2 * 100
        ];
      }
      function stringToInteger(string) {
        var total = 0;
        for (var i7 = 0; i7 !== string.length; i7++) {
          if (total >= Number.MAX_SAFE_INTEGER) break;
          total += string.charCodeAt(i7);
        }
        return total;
      }
      function getRealHueRange(colorHue) {
        if (!isNaN(colorHue)) {
          var number = parseInt(colorHue);
          if (number < 360 && number > 0) {
            return getColorInfo(colorHue).hueRange;
          }
        } else if (typeof colorHue === "string") {
          if (colorDictionary[colorHue]) {
            var color = colorDictionary[colorHue];
            if (color.hueRange) {
              return color.hueRange;
            }
          } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {
            var hue = HexToHSB(colorHue)[0];
            return getColorInfo(hue).hueRange;
          }
        }
        return [0, 360];
      }
      return randomColor2;
    });
  }
});

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ObsidianBPMNPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian3 = require("obsidian");

// src/settings.ts
var import_obsidian = require("obsidian");
var ObsidianBpmnPluginSettings = class {
  constructor() {
    this.opendiagram_by_default = true;
    this.showzoom_by_default = true;
    this.enablepanzoom_by_default = true;
    this.height_by_default = 400;
    this.force_white_background_by_default = true;
    this.enable_token_simulator = true;
    this.enable_simulation_heatmap = false;
    this.enable_minimap = true;
    this.enable_grid = true;
    this.enable_sketchy = false;
  }
};
var BPMNParameterInfoModal = class extends import_obsidian.Modal {
  constructor(app) {
    super(app);
  }
  onOpen() {
    let { contentEl } = this;
    contentEl.createEl("h1", { text: "BPMN code block parameter" });
    let table = contentEl.createEl("div");
    import_obsidian.MarkdownRenderer.render(
      this.app,
      `| Parameter            | Description                                    | Values                                                    |
|----------------------|------------------------------------------------|-----------------------------------------------------------|
| url                  | The url of the *.bpmn file (required).         | Relative/Absolute path, or as "[[*.bpmn]]" markdown link. |
| height               | The height of the rendered canvas.             | [200..1000]                                               |
| opendiagram          | Show a link to the *.bpmn file.                | True/False                                                |
| showzoom             | Show the zoom buttons below the canvas.        | True/False                                                |
| enablepanzoom        | Enable pan and zoom.                           | True/False                                                |
| zoom                 | Set the zoom level. Default is 'fit-viewport'. | 0.0 - 10.0                                                |
| x                    | Set the x coordinate, if a zoom value is set.  | 0 - ... (default: 0)                                      |
| y                    | Set the y coordinate, if a zoom value is set.  | 0 - ... (default: 0)                                      |
| forcewhitebackground | Force a white background.                      | True/False                                                |`,
      table,
      ".",
      new import_obsidian.Component()
    );
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var ObsidianBpmnPluginSettingsTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    let { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("General").setHeading();
    new import_obsidian.Setting(containerEl).setName("Default force white background").setDesc("Set the default for forcing a white background").setTooltip("forcewhitebackground: True/False", { delay: 200 }).addToggle((toggle2) => toggle2.setValue(this.plugin.settings.force_white_background_by_default).onChange((value) => {
      this.plugin.settings.force_white_background_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Use sketchy visualization").setDesc("The visualization of the BPMN is like a sketch.").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.enable_sketchy).onChange((value) => {
      this.plugin.settings.enable_sketchy = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("BPMN Block").setHeading();
    new import_obsidian.Setting(containerEl).setName("Default height").setDesc("Set the default height of the rendered BPMN.").setTooltip("height: x", { delay: 200 }).addSlider(
      (slider) => slider.setValue(this.plugin.settings.height_by_default).onChange((value) => {
        this.plugin.settings.height_by_default = value;
        this.plugin.saveData(this.plugin.settings);
      }).setLimits(200, 1e3, 20).setDynamicTooltip()
    );
    new import_obsidian.Setting(containerEl).setName("Default show open diagram").setTooltip("opendiagram: True/False", { delay: 200 }).setDesc("Set the default for showing the 'Open diagram' link").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.opendiagram_by_default).onChange((value) => {
      this.plugin.settings.opendiagram_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Default show zoom buttons").setDesc("Set the default for showing the zoom buttons").setTooltip("showzoom: True/False", { delay: 200 }).addToggle((toggle2) => toggle2.setValue(this.plugin.settings.showzoom_by_default).onChange((value) => {
      this.plugin.settings.showzoom_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Default enable pan zoom").setDesc("Set the default for enable pan & zoom").setTooltip("enablepanzoom: True/False", { delay: 200 }).addToggle((toggle2) => toggle2.setValue(this.plugin.settings.enablepanzoom_by_default).onChange((value) => {
      this.plugin.settings.enablepanzoom_by_default = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("BPMN block parameters").addButton((button) => {
      button.setButtonText("Show parameter");
      button.onClick(
        (evt) => {
          new BPMNParameterInfoModal(this.app).open();
        }
      );
    });
    new import_obsidian.Setting(containerEl).setName("BPMN Modeler").setHeading();
    new import_obsidian.Setting(containerEl).setName("Enable token simulator").setDesc("Add a token simulator to the BPMN modeler.").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.enable_token_simulator).onChange((value) => {
      this.plugin.settings.enable_token_simulator = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Enable heatmap").setDesc("Add a heatmap to the token simulation (Attention: Beta feature!)").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.enable_simulation_heatmap).onChange((value) => {
      this.plugin.settings.enable_simulation_heatmap = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Enable minimap").setDesc("Add a minimap to the BPMN modeler.").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.enable_minimap).onChange((value) => {
      this.plugin.settings.enable_minimap = value;
      this.plugin.saveData(this.plugin.settings);
    }));
    new import_obsidian.Setting(containerEl).setName("Enable grid").setDesc("Add a grid to the BPMN modeler").addToggle((toggle2) => toggle2.setValue(this.plugin.settings.enable_grid).onChange((value) => {
      this.plugin.settings.enable_grid = value;
      this.plugin.saveData(this.plugin.settings);
    }));
  }
};

// node_modules/inherits-browser/dist/index.es.js
function e(e8, t7) {
  t7 && (e8.super_ = t7, e8.prototype = Object.create(t7.prototype, { constructor: { value: e8, enumerable: false, writable: true, configurable: true } }));
}

// node_modules/min-dash/dist/index.esm.js
function flatten(arr) {
  return Array.prototype.concat.apply([], arr);
}
var nativeToString = Object.prototype.toString;
var nativeHasOwnProperty = Object.prototype.hasOwnProperty;
function isUndefined(obj) {
  return obj === void 0;
}
function isDefined(obj) {
  return obj !== void 0;
}
function isNil(obj) {
  return obj == null;
}
function isArray(obj) {
  return nativeToString.call(obj) === "[object Array]";
}
function isObject(obj) {
  return nativeToString.call(obj) === "[object Object]";
}
function isNumber(obj) {
  return nativeToString.call(obj) === "[object Number]";
}
function isFunction(obj) {
  const tag = nativeToString.call(obj);
  return tag === "[object Function]" || tag === "[object AsyncFunction]" || tag === "[object GeneratorFunction]" || tag === "[object AsyncGeneratorFunction]" || tag === "[object Proxy]";
}
function isString(obj) {
  return nativeToString.call(obj) === "[object String]";
}
function ensureArray(obj) {
  if (isArray(obj)) {
    return;
  }
  throw new Error("must supply array");
}
function has(target, key) {
  return !isNil(target) && nativeHasOwnProperty.call(target, key);
}
function find(collection, matcher) {
  const matchFn = toMatcher(matcher);
  let match;
  forEach(collection, function(val, key) {
    if (matchFn(val, key)) {
      match = val;
      return false;
    }
  });
  return match;
}
function findIndex(collection, matcher) {
  const matchFn = toMatcher(matcher);
  let idx = isArray(collection) ? -1 : void 0;
  forEach(collection, function(val, key) {
    if (matchFn(val, key)) {
      idx = key;
      return false;
    }
  });
  return idx;
}
function filter(collection, matcher) {
  const matchFn = toMatcher(matcher);
  let result = [];
  forEach(collection, function(val, key) {
    if (matchFn(val, key)) {
      result.push(val);
    }
  });
  return result;
}
function forEach(collection, iterator) {
  let val, result;
  if (isUndefined(collection)) {
    return;
  }
  const convertKey = isArray(collection) ? toNum : identity;
  for (let key in collection) {
    if (has(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function without(arr, matcher) {
  if (isUndefined(arr)) {
    return [];
  }
  ensureArray(arr);
  const matchFn = toMatcher(matcher);
  return arr.filter(function(el, idx) {
    return !matchFn(el, idx);
  });
}
function reduce(collection, iterator, result) {
  forEach(collection, function(value, idx) {
    result = iterator(result, value, idx);
  });
  return result;
}
function every(collection, matcher) {
  return !!reduce(collection, function(matches3, val, key) {
    return matches3 && matcher(val, key);
  }, true);
}
function some(collection, matcher) {
  return !!find(collection, matcher);
}
function map(collection, fn2) {
  let result = [];
  forEach(collection, function(val, key) {
    result.push(fn2(val, key));
  });
  return result;
}
function keys(collection) {
  return collection && Object.keys(collection) || [];
}
function size(collection) {
  return keys(collection).length;
}
function values(collection) {
  return map(collection, (val) => val);
}
function groupBy(collection, extractor, grouped = {}) {
  extractor = toExtractor(extractor);
  forEach(collection, function(val) {
    let discriminator = extractor(val) || "_";
    let group = grouped[discriminator];
    if (!group) {
      group = grouped[discriminator] = [];
    }
    group.push(val);
  });
  return grouped;
}
function uniqueBy(extractor, ...collections) {
  extractor = toExtractor(extractor);
  let grouped = {};
  forEach(collections, (c5) => groupBy(c5, extractor, grouped));
  let result = map(grouped, function(val, key) {
    return val[0];
  });
  return result;
}
var unionBy = uniqueBy;
function sortBy(collection, extractor) {
  extractor = toExtractor(extractor);
  let sorted = [];
  forEach(collection, function(value, key) {
    let disc = extractor(value, key);
    let entry = {
      d: disc,
      v: value
    };
    for (var idx = 0; idx < sorted.length; idx++) {
      let { d: d5 } = sorted[idx];
      if (disc < d5) {
        sorted.splice(idx, 0, entry);
        return;
      }
    }
    sorted.push(entry);
  });
  return map(sorted, (e8) => e8.v);
}
function matchPattern(pattern) {
  return function(el) {
    return every(pattern, function(val, key) {
      return el[key] === val;
    });
  };
}
function toExtractor(extractor) {
  return isFunction(extractor) ? extractor : (e8) => {
    return e8[extractor];
  };
}
function toMatcher(matcher) {
  return isFunction(matcher) ? matcher : (e8) => {
    return e8 === matcher;
  };
}
function identity(arg) {
  return arg;
}
function toNum(arg) {
  return Number(arg);
}
function debounce(fn2, timeout) {
  let timer;
  let lastArgs;
  let lastThis;
  let lastNow;
  function fire(force) {
    let now = Date.now();
    let scheduledDiff = force ? 0 : lastNow + timeout - now;
    if (scheduledDiff > 0) {
      return schedule(scheduledDiff);
    }
    fn2.apply(lastThis, lastArgs);
    clear3();
  }
  function schedule(timeout2) {
    timer = setTimeout(fire, timeout2);
  }
  function clear3() {
    if (timer) {
      clearTimeout(timer);
    }
    timer = lastNow = lastArgs = lastThis = void 0;
  }
  function flush() {
    if (timer) {
      fire(true);
    }
    clear3();
  }
  function callback(...args) {
    lastNow = Date.now();
    lastArgs = args;
    lastThis = this;
    if (!timer) {
      schedule(timeout);
    }
  }
  callback.flush = flush;
  callback.cancel = clear3;
  return callback;
}
function bind(fn2, target) {
  return fn2.bind(target);
}
function assign(target, ...others) {
  return Object.assign(target, ...others);
}
function set(target, path, value) {
  let currentTarget = target;
  forEach(path, function(key, idx) {
    if (typeof key !== "number" && typeof key !== "string") {
      throw new Error("illegal key type: " + typeof key + ". Key should be of type number or string.");
    }
    if (key === "constructor") {
      throw new Error("illegal key: constructor");
    }
    if (key === "__proto__") {
      throw new Error("illegal key: __proto__");
    }
    let nextKey = path[idx + 1];
    let nextTarget = currentTarget[key];
    if (isDefined(nextKey) && isNil(nextTarget)) {
      nextTarget = currentTarget[key] = isNaN(+nextKey) ? {} : [];
    }
    if (isUndefined(nextKey)) {
      if (isUndefined(value)) {
        delete currentTarget[key];
      } else {
        currentTarget[key] = value;
      }
    } else {
      currentTarget = nextTarget;
    }
  });
  return target;
}
function get(target, path, defaultValue) {
  let currentTarget = target;
  forEach(path, function(key) {
    if (isNil(currentTarget)) {
      currentTarget = void 0;
      return false;
    }
    currentTarget = currentTarget[key];
  });
  return isUndefined(currentTarget) ? defaultValue : currentTarget;
}
function pick(target, properties) {
  let result = {};
  let obj = Object(target);
  forEach(properties, function(prop) {
    if (prop in obj) {
      result[prop] = target[prop];
    }
  });
  return result;
}
function omit(target, properties) {
  let result = {};
  let obj = Object(target);
  forEach(obj, function(prop, key) {
    if (properties.indexOf(key) === -1) {
      result[key] = prop;
    }
  });
  return result;
}

// node_modules/diagram-js/lib/draw/BaseRenderer.js
var DEFAULT_RENDER_PRIORITY = 1e3;
function BaseRenderer(eventBus, renderPriority) {
  var self2 = this;
  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY;
  eventBus.on(["render.shape", "render.connection"], renderPriority, function(evt, context) {
    var type = evt.type, element = context.element, visuals = context.gfx, attrs = context.attrs;
    if (self2.canRender(element)) {
      if (type === "render.shape") {
        return self2.drawShape(visuals, element, attrs);
      } else {
        return self2.drawConnection(visuals, element, attrs);
      }
    }
  });
  eventBus.on(["render.getShapePath", "render.getConnectionPath"], renderPriority, function(evt, element) {
    if (self2.canRender(element)) {
      if (evt.type === "render.getShapePath") {
        return self2.getShapePath(element);
      } else {
        return self2.getConnectionPath(element);
      }
    }
  });
}
BaseRenderer.prototype.canRender = function(element) {
};
BaseRenderer.prototype.drawShape = function(visuals, shape) {
};
BaseRenderer.prototype.drawConnection = function(visuals, connection) {
};
BaseRenderer.prototype.getShapePath = function(shape) {
};
BaseRenderer.prototype.getConnectionPath = function(connection) {
};

// node_modules/bpmn-js/lib/util/ModelUtil.js
function is(element, type) {
  var bo = getBusinessObject(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}
function isAny(element, types3) {
  return some(types3, function(t7) {
    return is(element, t7);
  });
}
function getBusinessObject(element) {
  return element && element.businessObject || element;
}
function getDi(element) {
  return element && element.di;
}

// node_modules/bpmn-js/lib/util/DiUtil.js
function isExpanded(element, di) {
  if (is(element, "bpmn:CallActivity")) {
    return false;
  }
  if (is(element, "bpmn:SubProcess")) {
    di = di || getDi(element);
    if (di && is(di, "bpmndi:BPMNPlane")) {
      return true;
    }
    return di && !!di.isExpanded;
  }
  if (is(element, "bpmn:Participant")) {
    return !!getBusinessObject(element).processRef;
  }
  return true;
}
function isHorizontal(element) {
  if (!is(element, "bpmn:Participant") && !is(element, "bpmn:Lane")) {
    return void 0;
  }
  var isHorizontal5 = getDi(element).isHorizontal;
  if (isHorizontal5 === void 0) {
    return true;
  }
  return isHorizontal5;
}
function isInterrupting(element) {
  return element && getBusinessObject(element).isInterrupting !== false;
}
function isEventSubProcess(element) {
  return element && !!getBusinessObject(element).triggeredByEvent;
}
function hasEventDefinition(element, eventType) {
  var eventDefinitions = getBusinessObject(element).eventDefinitions;
  return some(eventDefinitions, function(event2) {
    return is(event2, eventType);
  });
}
function hasErrorEventDefinition(element) {
  return hasEventDefinition(element, "bpmn:ErrorEventDefinition");
}
function hasEscalationEventDefinition(element) {
  return hasEventDefinition(element, "bpmn:EscalationEventDefinition");
}
function hasCompensateEventDefinition(element) {
  return hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}

// node_modules/diagram-js/lib/util/ModelUtil.js
function isConnection(value) {
  return isObject(value) && has(value, "waypoints");
}
function isLabel(value) {
  return isObject(value) && has(value, "labelTarget");
}

// node_modules/bpmn-js/lib/util/LabelUtil.js
var DEFAULT_LABEL_SIZE = {
  width: 90,
  height: 20
};
var FLOW_LABEL_INDENT = 15;
function isLabelExternal(semantic) {
  return is(semantic, "bpmn:Event") || is(semantic, "bpmn:Gateway") || is(semantic, "bpmn:DataStoreReference") || is(semantic, "bpmn:DataObjectReference") || is(semantic, "bpmn:DataInput") || is(semantic, "bpmn:DataOutput") || is(semantic, "bpmn:SequenceFlow") || is(semantic, "bpmn:MessageFlow") || is(semantic, "bpmn:Group");
}
function hasExternalLabel(element) {
  return isLabel(element.label);
}
function getFlowLabelPosition(waypoints) {
  var mid4 = waypoints.length / 2 - 1;
  var first2 = waypoints[Math.floor(mid4)];
  var second = waypoints[Math.ceil(mid4 + 0.01)];
  var position = getWaypointsMid(waypoints);
  var angle = Math.atan((second.y - first2.y) / (second.x - first2.x));
  var x6 = position.x, y5 = position.y;
  if (Math.abs(angle) < Math.PI / 2) {
    y5 -= FLOW_LABEL_INDENT;
  } else {
    x6 += FLOW_LABEL_INDENT;
  }
  return { x: x6, y: y5 };
}
function getWaypointsMid(waypoints) {
  var mid4 = waypoints.length / 2 - 1;
  var first2 = waypoints[Math.floor(mid4)];
  var second = waypoints[Math.ceil(mid4 + 0.01)];
  return {
    x: first2.x + (second.x - first2.x) / 2,
    y: first2.y + (second.y - first2.y) / 2
  };
}
function getExternalLabelMid(element) {
  if (element.waypoints) {
    return getFlowLabelPosition(element.waypoints);
  } else if (is(element, "bpmn:Group")) {
    return {
      x: element.x + element.width / 2,
      y: element.y + DEFAULT_LABEL_SIZE.height / 2
    };
  } else {
    return {
      x: element.x + element.width / 2,
      y: element.y + element.height + DEFAULT_LABEL_SIZE.height / 2
    };
  }
}
function getExternalLabelBounds(di, element) {
  var mid4, size2, bounds, label = di.label;
  if (label && label.bounds) {
    bounds = label.bounds;
    size2 = {
      width: Math.max(DEFAULT_LABEL_SIZE.width, bounds.width),
      height: bounds.height
    };
    mid4 = {
      x: bounds.x + bounds.width / 2,
      y: bounds.y + bounds.height / 2
    };
  } else {
    mid4 = getExternalLabelMid(element);
    size2 = DEFAULT_LABEL_SIZE;
  }
  return assign({
    x: mid4.x - size2.width / 2,
    y: mid4.y - size2.height / 2
  }, size2);
}
function getLabelAttr(semantic) {
  if (is(semantic, "bpmn:FlowElement") || is(semantic, "bpmn:Participant") || is(semantic, "bpmn:Lane") || is(semantic, "bpmn:SequenceFlow") || is(semantic, "bpmn:MessageFlow") || is(semantic, "bpmn:DataInput") || is(semantic, "bpmn:DataOutput")) {
    return "name";
  }
  if (is(semantic, "bpmn:TextAnnotation")) {
    return "text";
  }
  if (is(semantic, "bpmn:Group")) {
    return "categoryValueRef";
  }
}
function getCategoryValue(semantic) {
  var categoryValueRef = semantic["categoryValueRef"];
  if (!categoryValueRef) {
    return "";
  }
  return categoryValueRef.value || "";
}
function getLabel(element) {
  var semantic = element.businessObject, attr3 = getLabelAttr(semantic);
  if (attr3) {
    if (attr3 === "categoryValueRef") {
      return getCategoryValue(semantic);
    }
    return semantic[attr3] || "";
  }
}
function setLabel(element, text) {
  var semantic = element.businessObject, attr3 = getLabelAttr(semantic);
  if (attr3) {
    if (attr3 === "categoryValueRef") {
      if (!semantic[attr3]) {
        return element;
      }
      semantic[attr3].value = text;
    } else {
      semantic[attr3] = text;
    }
  }
  return element;
}

// node_modules/tiny-svg/dist/index.esm.js
function ensureImported(element, target) {
  if (element.ownerDocument !== target.ownerDocument) {
    try {
      return target.ownerDocument.importNode(element, true);
    } catch (e8) {
    }
  }
  return element;
}
function appendTo(element, target) {
  return target.appendChild(ensureImported(element, target));
}
function append(target, node2) {
  appendTo(node2, target);
  return target;
}
var LENGTH_ATTR = 2;
var CSS_PROPERTIES = {
  "alignment-baseline": 1,
  "baseline-shift": 1,
  "clip": 1,
  "clip-path": 1,
  "clip-rule": 1,
  "color": 1,
  "color-interpolation": 1,
  "color-interpolation-filters": 1,
  "color-profile": 1,
  "color-rendering": 1,
  "cursor": 1,
  "direction": 1,
  "display": 1,
  "dominant-baseline": 1,
  "enable-background": 1,
  "fill": 1,
  "fill-opacity": 1,
  "fill-rule": 1,
  "filter": 1,
  "flood-color": 1,
  "flood-opacity": 1,
  "font": 1,
  "font-family": 1,
  "font-size": LENGTH_ATTR,
  "font-size-adjust": 1,
  "font-stretch": 1,
  "font-style": 1,
  "font-variant": 1,
  "font-weight": 1,
  "glyph-orientation-horizontal": 1,
  "glyph-orientation-vertical": 1,
  "image-rendering": 1,
  "kerning": 1,
  "letter-spacing": 1,
  "lighting-color": 1,
  "marker": 1,
  "marker-end": 1,
  "marker-mid": 1,
  "marker-start": 1,
  "mask": 1,
  "opacity": 1,
  "overflow": 1,
  "pointer-events": 1,
  "shape-rendering": 1,
  "stop-color": 1,
  "stop-opacity": 1,
  "stroke": 1,
  "stroke-dasharray": 1,
  "stroke-dashoffset": 1,
  "stroke-linecap": 1,
  "stroke-linejoin": 1,
  "stroke-miterlimit": 1,
  "stroke-opacity": 1,
  "stroke-width": LENGTH_ATTR,
  "text-anchor": 1,
  "text-decoration": 1,
  "text-rendering": 1,
  "unicode-bidi": 1,
  "visibility": 1,
  "word-spacing": 1,
  "writing-mode": 1
};
function getAttribute(node2, name2) {
  if (CSS_PROPERTIES[name2]) {
    return node2.style[name2];
  } else {
    return node2.getAttributeNS(null, name2);
  }
}
function setAttribute(node2, name2, value) {
  var hyphenated = name2.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
  var type = CSS_PROPERTIES[hyphenated];
  if (type) {
    if (type === LENGTH_ATTR && typeof value === "number") {
      value = String(value) + "px";
    }
    node2.style[hyphenated] = value;
  } else {
    node2.setAttributeNS(null, name2, value);
  }
}
function setAttributes(node2, attrs) {
  var names = Object.keys(attrs), i7, name2;
  for (i7 = 0, name2; name2 = names[i7]; i7++) {
    setAttribute(node2, name2, attrs[name2]);
  }
}
function attr(node2, name2, value) {
  if (typeof name2 === "string") {
    if (value !== void 0) {
      setAttribute(node2, name2, value);
    } else {
      return getAttribute(node2, name2);
    }
  } else {
    setAttributes(node2, name2);
  }
  return node2;
}
var toString = Object.prototype.toString;
function classes(el) {
  return new ClassList(el);
}
function ClassList(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList.prototype.add = function(name2) {
  this.list.add(name2);
  return this;
};
ClassList.prototype.remove = function(name2) {
  if ("[object RegExp]" == toString.call(name2)) {
    return this.removeMatching(name2);
  }
  this.list.remove(name2);
  return this;
};
ClassList.prototype.removeMatching = function(re) {
  const arr = this.array();
  for (let i7 = 0; i7 < arr.length; i7++) {
    if (re.test(arr[i7])) {
      this.remove(arr[i7]);
    }
  }
  return this;
};
ClassList.prototype.toggle = function(name2, force) {
  if ("undefined" !== typeof force) {
    if (force !== this.list.toggle(name2, force)) {
      this.list.toggle(name2);
    }
  } else {
    this.list.toggle(name2);
  }
  return this;
};
ClassList.prototype.array = function() {
  return Array.from(this.list);
};
ClassList.prototype.has = ClassList.prototype.contains = function(name2) {
  return this.list.contains(name2);
};
function clear(element) {
  var child;
  while (child = element.firstChild) {
    element.removeChild(child);
  }
  return element;
}
function clone(element) {
  return element.cloneNode(true);
}
var ns = {
  svg: "http://www.w3.org/2000/svg"
};
var SVG_START = '<svg xmlns="' + ns.svg + '"';
function parse(svg) {
  var unwrap = false;
  if (svg.substring(0, 4) === "<svg") {
    if (svg.indexOf(ns.svg) === -1) {
      svg = SVG_START + svg.substring(4);
    }
  } else {
    svg = SVG_START + ">" + svg + "</svg>";
    unwrap = true;
  }
  var parsed = parseDocument(svg);
  if (!unwrap) {
    return parsed;
  }
  var fragment = document.createDocumentFragment();
  var parent = parsed.firstChild;
  while (parent.firstChild) {
    fragment.appendChild(parent.firstChild);
  }
  return fragment;
}
function parseDocument(svg) {
  var parser4;
  parser4 = new DOMParser();
  parser4.async = false;
  return parser4.parseFromString(svg, "text/xml");
}
function create(name2, attrs) {
  var element;
  name2 = name2.trim();
  if (name2.charAt(0) === "<") {
    element = parse(name2).firstChild;
    element = document.importNode(element, true);
  } else {
    element = document.createElementNS(ns.svg, name2);
  }
  if (attrs) {
    attr(element, attrs);
  }
  return element;
}
var node = null;
function getNode() {
  if (node === null) {
    node = create("svg");
  }
  return node;
}
function extend(object, props) {
  var i7, k6, keys2 = Object.keys(props);
  for (i7 = 0; k6 = keys2[i7]; i7++) {
    object[k6] = props[k6];
  }
  return object;
}
function createMatrix(a6, b4, c5, d5, e8, f6) {
  var matrix = getNode().createSVGMatrix();
  switch (arguments.length) {
    case 0:
      return matrix;
    case 1:
      return extend(matrix, a6);
    case 6:
      return extend(matrix, {
        a: a6,
        b: b4,
        c: c5,
        d: d5,
        e: e8,
        f: f6
      });
  }
}
function createTransform(matrix) {
  if (matrix) {
    return getNode().createSVGTransformFromMatrix(matrix);
  } else {
    return getNode().createSVGTransform();
  }
}
var TEXT_ENTITIES = /([&<>]{1})/g;
var ATTR_ENTITIES = /([&<>\n\r"]{1})/g;
var ENTITY_REPLACEMENT = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "'"
};
function escape(str, pattern) {
  function replaceFn(match, entity) {
    return ENTITY_REPLACEMENT[entity] || entity;
  }
  return str.replace(pattern, replaceFn);
}
function serialize(node2, output) {
  var i7, len, attrMap, attrNode, childNodes;
  switch (node2.nodeType) {
    // TEXT
    case 3:
      output.push(escape(node2.textContent, TEXT_ENTITIES));
      break;
    // ELEMENT
    case 1:
      output.push("<", node2.tagName);
      if (node2.hasAttributes()) {
        attrMap = node2.attributes;
        for (i7 = 0, len = attrMap.length; i7 < len; ++i7) {
          attrNode = attrMap.item(i7);
          output.push(" ", attrNode.name, '="', escape(attrNode.value, ATTR_ENTITIES), '"');
        }
      }
      if (node2.hasChildNodes()) {
        output.push(">");
        childNodes = node2.childNodes;
        for (i7 = 0, len = childNodes.length; i7 < len; ++i7) {
          serialize(childNodes.item(i7), output);
        }
        output.push("</", node2.tagName, ">");
      } else {
        output.push("/>");
      }
      break;
    // COMMENT
    case 8:
      output.push("<!--", escape(node2.nodeValue, TEXT_ENTITIES), "-->");
      break;
    // CDATA
    case 4:
      output.push("<![CDATA[", node2.nodeValue, "]]>");
      break;
    default:
      throw new Error("unable to handle node " + node2.nodeType);
  }
  return output;
}
function set2(element, svg) {
  var parsed = parse(svg);
  clear(element);
  if (!svg) {
    return;
  }
  if (!isFragment(parsed)) {
    parsed = parsed.documentElement;
  }
  var nodes = slice(parsed.childNodes);
  for (var i7 = 0; i7 < nodes.length; i7++) {
    appendTo(nodes[i7], element);
  }
}
function get2(element) {
  var child = element.firstChild, output = [];
  while (child) {
    serialize(child, output);
    child = child.nextSibling;
  }
  return output.join("");
}
function isFragment(node2) {
  return node2.nodeName === "#document-fragment";
}
function innerSVG(element, svg) {
  if (svg !== void 0) {
    try {
      set2(element, svg);
    } catch (e8) {
      throw new Error("error parsing SVG: " + e8.message);
    }
    return element;
  } else {
    return get2(element);
  }
}
function slice(arr) {
  return Array.prototype.slice.call(arr);
}
function remove(element) {
  var parent = element.parentNode;
  if (parent) {
    parent.removeChild(element);
  }
  return element;
}
function wrapMatrix(transformList, transform4) {
  if (transform4 instanceof SVGMatrix) {
    return transformList.createSVGTransformFromMatrix(transform4);
  }
  return transform4;
}
function setTransforms(transformList, transforms) {
  var i7, t7;
  transformList.clear();
  for (i7 = 0; t7 = transforms[i7]; i7++) {
    transformList.appendItem(wrapMatrix(transformList, t7));
  }
}
function transform(node2, transforms) {
  var transformList = node2.transform.baseVal;
  if (transforms) {
    if (!Array.isArray(transforms)) {
      transforms = [transforms];
    }
    setTransforms(transformList, transforms);
  }
  return transformList.consolidate();
}

// node_modules/diagram-js/lib/util/RenderUtil.js
function componentsToPath(elements) {
  return elements.flat().join(",").replace(/,?([A-Za-z]),?/g, "$1");
}
function move(point) {
  return ["M", point.x, point.y];
}
function lineTo(point) {
  return ["L", point.x, point.y];
}
function curveTo(p1, p22, p32) {
  return ["C", p1.x, p1.y, p22.x, p22.y, p32.x, p32.y];
}
function drawPath(waypoints, cornerRadius) {
  const pointCount = waypoints.length;
  const path = [move(waypoints[0])];
  for (let i7 = 1; i7 < pointCount; i7++) {
    const pointBefore = waypoints[i7 - 1];
    const point = waypoints[i7];
    const pointAfter = waypoints[i7 + 1];
    if (!pointAfter || !cornerRadius) {
      path.push(lineTo(point));
      continue;
    }
    const effectiveRadius = Math.min(
      cornerRadius,
      vectorLength(point.x - pointBefore.x, point.y - pointBefore.y),
      vectorLength(pointAfter.x - point.x, pointAfter.y - point.y)
    );
    if (!effectiveRadius) {
      path.push(lineTo(point));
      continue;
    }
    const beforePoint = getPointAtLength(point, pointBefore, effectiveRadius);
    const beforePoint2 = getPointAtLength(point, pointBefore, effectiveRadius * 0.5);
    const afterPoint = getPointAtLength(point, pointAfter, effectiveRadius);
    const afterPoint2 = getPointAtLength(point, pointAfter, effectiveRadius * 0.5);
    path.push(lineTo(beforePoint));
    path.push(curveTo(beforePoint2, afterPoint2, afterPoint));
  }
  return path;
}
function getPointAtLength(start, end, length2) {
  const deltaX = end.x - start.x;
  const deltaY = end.y - start.y;
  const totalLength = vectorLength(deltaX, deltaY);
  const percent = length2 / totalLength;
  return {
    x: start.x + deltaX * percent,
    y: start.y + deltaY * percent
  };
}
function vectorLength(x6, y5) {
  return Math.sqrt(Math.pow(x6, 2) + Math.pow(y5, 2));
}
function createLine(points, attrs, radius) {
  if (isNumber(attrs)) {
    radius = attrs;
    attrs = null;
  }
  if (!attrs) {
    attrs = {};
  }
  const line2 = create("path", attrs);
  if (isNumber(radius)) {
    line2.dataset.cornerRadius = String(radius);
  }
  return updateLine(line2, points);
}
function updateLine(gfx, points) {
  const cornerRadius = parseInt(gfx.dataset.cornerRadius, 10) || 0;
  attr(gfx, {
    d: componentsToPath(drawPath(points, cornerRadius))
  });
  return gfx;
}

// node_modules/bpmn-js/lib/draw/BpmnRenderUtil.js
var black = "hsl(225, 10%, 15%)";
var white = "white";
function isTypedEvent(event2, eventDefinitionType) {
  return some(event2.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType;
  });
}
function isThrowEvent(event2) {
  return event2.$type === "bpmn:IntermediateThrowEvent" || event2.$type === "bpmn:EndEvent";
}
function isCollection(element) {
  var dataObject = element.dataObjectRef;
  return element.isCollection || dataObject && dataObject.isCollection;
}
function getFillColor(element, defaultColor, overrideColor) {
  var di = getDi(element);
  return overrideColor || di.get("color:background-color") || di.get("bioc:fill") || defaultColor || white;
}
function getStrokeColor(element, defaultColor, overrideColor) {
  var di = getDi(element);
  return overrideColor || di.get("color:border-color") || di.get("bioc:stroke") || defaultColor || black;
}
function getLabelColor(element, defaultColor, defaultStrokeColor, overrideColor) {
  var di = getDi(element), label = di.get("label");
  return overrideColor || label && label.get("color:color") || defaultColor || getStrokeColor(element, defaultStrokeColor);
}
function getCirclePath(shape) {
  var cx = shape.x + shape.width / 2, cy = shape.y + shape.height / 2, radius = shape.width / 2;
  var circlePath2 = [
    ["M", cx, cy],
    ["m", 0, -radius],
    ["a", radius, radius, 0, 1, 1, 0, 2 * radius],
    ["a", radius, radius, 0, 1, 1, 0, -2 * radius],
    ["z"]
  ];
  return componentsToPath(circlePath2);
}
function getRoundRectPath(shape, borderRadius) {
  var x6 = shape.x, y5 = shape.y, width = shape.width, height = shape.height;
  var roundRectPath = [
    ["M", x6 + borderRadius, y5],
    ["l", width - borderRadius * 2, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ["l", 0, height - borderRadius * 2],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ["l", borderRadius * 2 - width, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ["l", 0, borderRadius * 2 - height],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ["z"]
  ];
  return componentsToPath(roundRectPath);
}
function getDiamondPath(shape) {
  var width = shape.width, height = shape.height, x6 = shape.x, y5 = shape.y, halfWidth = width / 2, halfHeight = height / 2;
  var diamondPath = [
    ["M", x6 + halfWidth, y5],
    ["l", halfWidth, halfHeight],
    ["l", -halfWidth, halfHeight],
    ["l", -halfWidth, -halfHeight],
    ["z"]
  ];
  return componentsToPath(diamondPath);
}
function getRectPath(shape) {
  var x6 = shape.x, y5 = shape.y, width = shape.width, height = shape.height;
  var rectPath = [
    ["M", x6, y5],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(rectPath);
}
function getBounds(bounds, overrides = {}) {
  return {
    width: getWidth(bounds, overrides),
    height: getHeight(bounds, overrides)
  };
}
function getWidth(bounds, overrides = {}) {
  return has(overrides, "width") ? overrides.width : bounds.width;
}
function getHeight(bounds, overrides = {}) {
  return has(overrides, "height") ? overrides.height : bounds.height;
}

// node_modules/min-dom/dist/index.esm.js
function _mergeNamespaces(n4, m6) {
  m6.forEach(function(e8) {
    e8 && typeof e8 !== "string" && !Array.isArray(e8) && Object.keys(e8).forEach(function(k6) {
      if (k6 !== "default" && !(k6 in n4)) {
        var d5 = Object.getOwnPropertyDescriptor(e8, k6);
        Object.defineProperty(n4, k6, d5.get ? d5 : {
          enumerable: true,
          get: function() {
            return e8[k6];
          }
        });
      }
    });
  });
  return Object.freeze(n4);
}
var nativeToString2 = Object.prototype.toString;
var nativeHasOwnProperty2 = Object.prototype.hasOwnProperty;
function isUndefined2(obj) {
  return obj === void 0;
}
function isArray2(obj) {
  return nativeToString2.call(obj) === "[object Array]";
}
function has2(target, key) {
  return nativeHasOwnProperty2.call(target, key);
}
function forEach2(collection, iterator) {
  let val, result;
  if (isUndefined2(collection)) {
    return;
  }
  const convertKey = isArray2(collection) ? toNum2 : identity2;
  for (let key in collection) {
    if (has2(collection, key)) {
      val = collection[key];
      result = iterator(val, convertKey(key));
      if (result === false) {
        return val;
      }
    }
  }
}
function identity2(arg) {
  return arg;
}
function toNum2(arg) {
  return Number(arg);
}
function assign2(element, ...styleSources) {
  const target = element.style;
  forEach2(styleSources, function(style) {
    if (!style) {
      return;
    }
    forEach2(style, function(value, key) {
      target[key] = value;
    });
  });
  return element;
}
function attr2(el, name2, val) {
  if (arguments.length == 2) {
    return el.getAttribute(name2);
  }
  if (val === null) {
    return el.removeAttribute(name2);
  }
  el.setAttribute(name2, val);
  return el;
}
var toString2 = Object.prototype.toString;
function classes2(el) {
  return new ClassList2(el);
}
function ClassList2(el) {
  if (!el || !el.nodeType) {
    throw new Error("A DOM element reference is required");
  }
  this.el = el;
  this.list = el.classList;
}
ClassList2.prototype.add = function(name2) {
  this.list.add(name2);
  return this;
};
ClassList2.prototype.remove = function(name2) {
  if ("[object RegExp]" == toString2.call(name2)) {
    return this.removeMatching(name2);
  }
  this.list.remove(name2);
  return this;
};
ClassList2.prototype.removeMatching = function(re) {
  const arr = this.array();
  for (let i7 = 0; i7 < arr.length; i7++) {
    if (re.test(arr[i7])) {
      this.remove(arr[i7]);
    }
  }
  return this;
};
ClassList2.prototype.toggle = function(name2, force) {
  if ("undefined" !== typeof force) {
    if (force !== this.list.toggle(name2, force)) {
      this.list.toggle(name2);
    }
  } else {
    this.list.toggle(name2);
  }
  return this;
};
ClassList2.prototype.array = function() {
  return Array.from(this.list);
};
ClassList2.prototype.has = ClassList2.prototype.contains = function(name2) {
  return this.list.contains(name2);
};
function clear2(element) {
  var child;
  while (child = element.firstChild) {
    element.removeChild(child);
  }
  return element;
}
function closest(element, selector, checkYourSelf) {
  var actualElement = checkYourSelf ? element : element.parentNode;
  return actualElement && typeof actualElement.closest === "function" && actualElement.closest(selector) || null;
}
var componentEvent = {};
var bind$1;
var unbind$1;
var prefix;
function detect() {
  bind$1 = window.addEventListener ? "addEventListener" : "attachEvent";
  unbind$1 = window.removeEventListener ? "removeEventListener" : "detachEvent";
  prefix = bind$1 !== "addEventListener" ? "on" : "";
}
var bind_1 = componentEvent.bind = function(el, type, fn2, capture) {
  if (!bind$1) detect();
  el[bind$1](prefix + type, fn2, capture || false);
  return fn2;
};
var unbind_1 = componentEvent.unbind = function(el, type, fn2, capture) {
  if (!unbind$1) detect();
  el[unbind$1](prefix + type, fn2, capture || false);
  return fn2;
};
var event = /* @__PURE__ */ _mergeNamespaces({
  __proto__: null,
  bind: bind_1,
  unbind: unbind_1,
  "default": componentEvent
}, [componentEvent]);
var forceCaptureEvents = ["focus", "blur"];
function bind2(el, selector, type, fn2, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return event.bind(el, type, function(e8) {
    var target = e8.target || e8.srcElement;
    e8.delegateTarget = closest(target, selector, true);
    if (e8.delegateTarget) {
      fn2.call(el, e8);
    }
  }, capture);
}
function unbind(el, type, fn2, capture) {
  if (forceCaptureEvents.indexOf(type) !== -1) {
    capture = true;
  }
  return event.unbind(el, type, fn2, capture);
}
var delegate = {
  bind: bind2,
  unbind
};
var domify = parse2;
var innerHTMLBug = false;
var bugTestDiv;
if (typeof document !== "undefined") {
  bugTestDiv = document.createElement("div");
  bugTestDiv.innerHTML = '  <link/><table></table><a href="/a">a</a><input type="checkbox"/>';
  innerHTMLBug = !bugTestDiv.getElementsByTagName("link").length;
  bugTestDiv = void 0;
}
var map2 = {
  legend: [1, "<fieldset>", "</fieldset>"],
  tr: [2, "<table><tbody>", "</tbody></table>"],
  col: [2, "<table><tbody></tbody><colgroup>", "</colgroup></table>"],
  // for script/link/style tags to work in IE6-8, you have to wrap
  // in a div with a non-whitespace character in front, ha!
  _default: innerHTMLBug ? [1, "X<div>", "</div>"] : [0, "", ""]
};
map2.td = map2.th = [3, "<table><tbody><tr>", "</tr></tbody></table>"];
map2.option = map2.optgroup = [1, '<select multiple="multiple">', "</select>"];
map2.thead = map2.tbody = map2.colgroup = map2.caption = map2.tfoot = [1, "<table>", "</table>"];
map2.polyline = map2.ellipse = map2.polygon = map2.circle = map2.text = map2.line = map2.path = map2.rect = map2.g = [1, '<svg xmlns="http://www.w3.org/2000/svg" version="1.1">', "</svg>"];
function parse2(html, doc) {
  if ("string" != typeof html) throw new TypeError("String expected");
  if (!doc) doc = document;
  var m6 = /<([\w:]+)/.exec(html);
  if (!m6) return doc.createTextNode(html);
  html = html.replace(/^\s+|\s+$/g, "");
  var tag = m6[1];
  if (tag == "body") {
    var el = doc.createElement("html");
    el.innerHTML = html;
    return el.removeChild(el.lastChild);
  }
  var wrap2 = Object.prototype.hasOwnProperty.call(map2, tag) ? map2[tag] : map2._default;
  var depth = wrap2[0];
  var prefix3 = wrap2[1];
  var suffix = wrap2[2];
  var el = doc.createElement("div");
  el.innerHTML = prefix3 + html + suffix;
  while (depth--) el = el.lastChild;
  if (el.firstChild == el.lastChild) {
    return el.removeChild(el.firstChild);
  }
  var fragment = doc.createDocumentFragment();
  while (el.firstChild) {
    fragment.appendChild(el.removeChild(el.firstChild));
  }
  return fragment;
}
var domify$1 = domify;
function matches(element, selector) {
  return element && typeof element.matches === "function" && element.matches(selector) || false;
}
function query(selector, el) {
  el = el || document;
  return el.querySelector(selector);
}
function all(selector, el) {
  el = el || document;
  return el.querySelectorAll(selector);
}
function remove2(el) {
  el.parentNode && el.parentNode.removeChild(el);
}

// node_modules/diagram-js/lib/util/SvgTransformUtil.js
function transform2(gfx, x6, y5, angle, amount) {
  var translate4 = createTransform();
  translate4.setTranslate(x6, y5);
  var rotate3 = createTransform();
  rotate3.setRotate(angle || 0, 0, 0);
  var scale = createTransform();
  scale.setScale(amount || 1, amount || 1);
  transform(gfx, [translate4, rotate3, scale]);
}
function translate(gfx, x6, y5) {
  var translate4 = createTransform();
  translate4.setTranslate(x6, y5);
  transform(gfx, translate4);
}
function rotate(gfx, angle) {
  var rotate3 = createTransform();
  rotate3.setRotate(angle, 0, 0);
  transform(gfx, rotate3);
}

// node_modules/ids/dist/index.esm.js
function createCommonjsModule(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var hat_1 = createCommonjsModule(function(module2) {
  var hat = module2.exports = function(bits, base) {
    if (!base) base = 16;
    if (bits === void 0) bits = 128;
    if (bits <= 0) return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i7 = 2; digits === Infinity; i7 *= 2) {
      digits = Math.log(Math.pow(2, bits / i7)) / Math.log(base) * i7;
    }
    var rem = digits - Math.floor(digits);
    var res = "";
    for (var i7 = 0; i7 < Math.floor(digits); i7++) {
      var x6 = Math.floor(Math.random() * base).toString(base);
      res = x6 + res;
    }
    if (rem) {
      var b4 = Math.pow(base, rem);
      var x6 = Math.floor(Math.random() * b4).toString(base);
      res = x6 + res;
    }
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
      return hat(bits, base);
    } else return res;
  };
  hat.rack = function(bits, base, expandBy) {
    var fn2 = function(data) {
      var iters = 0;
      do {
        if (iters++ > 10) {
          if (expandBy) bits += expandBy;
          else throw new Error("too many ID collisions, use more bits");
        }
        var id = hat(bits, base);
      } while (Object.hasOwnProperty.call(hats, id));
      hats[id] = data;
      return id;
    };
    var hats = fn2.hats = {};
    fn2.get = function(id) {
      return fn2.hats[id];
    };
    fn2.set = function(id, value) {
      fn2.hats[id] = value;
      return fn2;
    };
    fn2.bits = bits || 128;
    fn2.base = base || 16;
    return fn2;
  };
});
function Ids(seed) {
  if (!(this instanceof Ids)) {
    return new Ids(seed);
  }
  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_1.rack(seed[0], seed[1], seed[2]) : seed;
}
Ids.prototype.next = function(element) {
  return this._seed(element || true);
};
Ids.prototype.nextPrefixed = function(prefix3, element) {
  var id;
  do {
    id = prefix3 + this.next(true);
  } while (this.assigned(id));
  this.claim(id, element);
  return id;
};
Ids.prototype.claim = function(id, element) {
  this._seed.set(id, element || true);
};
Ids.prototype.assigned = function(id) {
  return this._seed.get(id) || false;
};
Ids.prototype.unclaim = function(id) {
  delete this._seed.hats[id];
};
Ids.prototype.clear = function() {
  var hats = this._seed.hats, id;
  for (id in hats) {
    this.unclaim(id);
  }
};
var index_esm_default = Ids;

// node_modules/bpmn-js/lib/draw/BpmnRenderer.js
var markerIds = new index_esm_default();
var ELEMENT_LABEL_DISTANCE = 10;
var INNER_OUTER_DIST = 3;
var PARTICIPANT_STROKE_WIDTH = 1.5;
var TASK_BORDER_RADIUS = 10;
var DEFAULT_OPACITY = 0.95;
var FULL_OPACITY = 1;
var LOW_OPACITY = 0.25;
function BpmnRenderer(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {
  BaseRenderer.call(this, eventBus, priority);
  var defaultFillColor = config && config.defaultFillColor, defaultStrokeColor = config && config.defaultStrokeColor, defaultLabelColor = config && config.defaultLabelColor;
  function shapeStyle(attrs) {
    return styles.computeStyle(attrs, {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: black,
      strokeWidth: 2,
      fill: "white"
    });
  }
  function lineStyle(attrs) {
    return styles.computeStyle(attrs, ["no-fill"], {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: black,
      strokeWidth: 2
    });
  }
  function addMarker(id, options) {
    var {
      ref = { x: 0, y: 0 },
      scale = 1,
      element,
      parentGfx = canvas._svg
    } = options;
    var marker2 = create("marker", {
      id,
      viewBox: "0 0 20 20",
      refX: ref.x,
      refY: ref.y,
      markerWidth: 20 * scale,
      markerHeight: 20 * scale,
      orient: "auto"
    });
    append(marker2, element);
    var defs = query(":scope > defs", parentGfx);
    if (!defs) {
      defs = create("defs");
      append(parentGfx, defs);
    }
    append(defs, marker2);
  }
  function marker(parentGfx, type, fill, stroke) {
    var id = markerIds.nextPrefixed("marker-");
    createMarker(parentGfx, id, type, fill, stroke);
    return "url(#" + id + ")";
  }
  function createMarker(parentGfx, id, type, fill, stroke) {
    if (type === "sequenceflow-end") {
      var sequenceflowEnd = create("path", {
        d: "M 1 5 L 11 10 L 1 15 Z",
        ...shapeStyle({
          fill: stroke,
          stroke,
          strokeWidth: 1
        })
      });
      addMarker(id, {
        element: sequenceflowEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5,
        parentGfx
      });
    }
    if (type === "messageflow-start") {
      var messageflowStart = create("circle", {
        cx: 6,
        cy: 6,
        r: 3.5,
        ...shapeStyle({
          fill,
          stroke,
          strokeWidth: 1,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: messageflowStart,
        ref: { x: 6, y: 6 },
        parentGfx
      });
    }
    if (type === "messageflow-end") {
      var messageflowEnd = create("path", {
        d: "m 1 5 l 0 -3 l 7 3 l -7 3 z",
        ...shapeStyle({
          fill,
          stroke,
          strokeWidth: 1,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: messageflowEnd,
        ref: { x: 8.5, y: 5 },
        parentGfx
      });
    }
    if (type === "association-start") {
      var associationStart = create("path", {
        d: "M 11 5 L 1 10 L 11 15",
        ...lineStyle({
          fill: "none",
          stroke,
          strokeWidth: 1.5,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: associationStart,
        ref: { x: 1, y: 10 },
        scale: 0.5,
        parentGfx
      });
    }
    if (type === "association-end") {
      var associationEnd = create("path", {
        d: "M 1 5 L 11 10 L 1 15",
        ...lineStyle({
          fill: "none",
          stroke,
          strokeWidth: 1.5,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: associationEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5,
        parentGfx
      });
    }
    if (type === "conditional-flow-marker") {
      var conditionalFlowMarker = create("path", {
        d: "M 0 10 L 8 6 L 16 10 L 8 14 Z",
        ...shapeStyle({
          fill,
          stroke
        })
      });
      addMarker(id, {
        element: conditionalFlowMarker,
        ref: { x: -1, y: 10 },
        scale: 0.5,
        parentGfx
      });
    }
    if (type === "conditional-default-flow-marker") {
      var defaultFlowMarker = create("path", {
        d: "M 6 4 L 10 16",
        ...shapeStyle({
          stroke,
          fill: "none"
        })
      });
      addMarker(id, {
        element: defaultFlowMarker,
        ref: { x: 0, y: 10 },
        scale: 0.5,
        parentGfx
      });
    }
  }
  function drawCircle(parentGfx, width, height, offset, attrs = {}) {
    if (isObject(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = shapeStyle(attrs);
    var cx = width / 2, cy = height / 2;
    var circle = create("circle", {
      cx,
      cy,
      r: Math.round((width + height) / 4 - offset),
      ...attrs
    });
    append(parentGfx, circle);
    return circle;
  }
  function drawRect(parentGfx, width, height, r7, offset, attrs) {
    if (isObject(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = shapeStyle(attrs);
    var rect = create("rect", {
      x: offset,
      y: offset,
      width: width - offset * 2,
      height: height - offset * 2,
      rx: r7,
      ry: r7,
      ...attrs
    });
    append(parentGfx, rect);
    return rect;
  }
  function drawDiamond(parentGfx, width, height, attrs) {
    var x_2 = width / 2;
    var y_2 = height / 2;
    var points = [
      { x: x_2, y: 0 },
      { x: width, y: y_2 },
      { x: x_2, y: height },
      { x: 0, y: y_2 }
    ];
    var pointsString = points.map(function(point) {
      return point.x + "," + point.y;
    }).join(" ");
    attrs = shapeStyle(attrs);
    var polygon2 = create("polygon", {
      ...attrs,
      points: pointsString
    });
    append(parentGfx, polygon2);
    return polygon2;
  }
  function drawLine(parentGfx, waypoints, attrs, radius) {
    attrs = lineStyle(attrs);
    var line2 = createLine(waypoints, attrs, radius);
    append(parentGfx, line2);
    return line2;
  }
  function drawConnectionSegments(parentGfx, waypoints, attrs) {
    return drawLine(parentGfx, waypoints, attrs, 5);
  }
  function drawPath2(parentGfx, d5, attrs) {
    attrs = lineStyle(attrs);
    var path = create("path", {
      ...attrs,
      d: d5
    });
    append(parentGfx, path);
    return path;
  }
  function drawMarker(type, parentGfx, path, attrs) {
    return drawPath2(parentGfx, path, assign({ "data-marker": type }, attrs));
  }
  function renderer(type) {
    return handlers[type];
  }
  function as(type) {
    return function(parentGfx, element, attrs) {
      return renderer(type)(parentGfx, element, attrs);
    };
  }
  var eventIconRenderers = {
    "bpmn:MessageEventDefinition": function(parentGfx, element, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MESSAGE", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.235,
          my: 0.315
        }
      });
      var fill = isThrowing ? getStrokeColor(element, defaultStrokeColor, attrs.stroke) : getFillColor(element, defaultFillColor, attrs.fill);
      var stroke = isThrowing ? getFillColor(element, defaultFillColor, attrs.fill) : getStrokeColor(element, defaultStrokeColor, attrs.stroke);
      var messagePath = drawPath2(parentGfx, pathData, {
        fill,
        stroke,
        strokeWidth: 1
      });
      return messagePath;
    },
    "bpmn:TimerEventDefinition": function(parentGfx, element, attrs = {}) {
      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2
      });
      var pathData = pathMap.getScaledPath("EVENT_TIMER_WH", {
        xScaleFactor: 0.75,
        yScaleFactor: 0.75,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.5,
          my: 0.5
        }
      });
      drawPath2(parentGfx, pathData, {
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2
      });
      for (var i7 = 0; i7 < 12; i7++) {
        var linePathData = pathMap.getScaledPath("EVENT_TIMER_LINE", {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });
        var width = element.width / 2, height = element.height / 2;
        drawPath2(parentGfx, linePathData, {
          strokeWidth: 1,
          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          transform: "rotate(" + i7 * 30 + "," + height + "," + width + ")"
        });
      }
      return circle;
    },
    "bpmn:EscalationEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ESCALATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:ConditionalEventDefinition": function(parentGfx, event2, attrs = {}) {
      var pathData = pathMap.getScaledPath("EVENT_CONDITIONAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.222
        }
      });
      return drawPath2(parentGfx, pathData, {
        fill: getFillColor(event2, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:LinkEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_LINK", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.57,
          my: 0.263
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:ErrorEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ERROR", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.2,
          my: 0.722
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:CancelEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_CANCEL_45", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.638,
          my: -0.055
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : "none";
      var path = drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      rotate(path, 45);
      return path;
    },
    "bpmn:CompensateEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.22,
          my: 0.5
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:SignalEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_SIGNAL", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke)
      });
    },
    "bpmn:MultipleEventDefinition": function(parentGfx, event2, attrs = {}, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MULTIPLE", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.222,
          my: 0.36
        }
      });
      var fill = isThrowing ? getStrokeColor(event2, defaultStrokeColor, attrs.stroke) : getFillColor(event2, defaultFillColor, attrs.fill);
      return drawPath2(parentGfx, pathData, {
        fill,
        strokeWidth: 1
      });
    },
    "bpmn:ParallelMultipleEventDefinition": function(parentGfx, event2, attrs = {}) {
      var pathData = pathMap.getScaledPath("EVENT_PARALLEL_MULTIPLE", {
        xScaleFactor: 1.2,
        yScaleFactor: 1.2,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.458,
          my: 0.194
        }
      });
      return drawPath2(parentGfx, pathData, {
        fill: getFillColor(event2, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(event2, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
    },
    "bpmn:TerminateEventDefinition": function(parentGfx, element, attrs = {}) {
      var circle = drawCircle(parentGfx, element.width, element.height, 8, {
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 4
      });
      return circle;
    }
  };
  function renderEventIcon(element, parentGfx, attrs = {}) {
    var semantic = getBusinessObject(element), isThrowing = isThrowEvent(semantic);
    if (semantic.get("eventDefinitions") && semantic.get("eventDefinitions").length > 1) {
      if (semantic.get("parallelMultiple")) {
        return eventIconRenderers["bpmn:ParallelMultipleEventDefinition"](parentGfx, element, attrs, isThrowing);
      } else {
        return eventIconRenderers["bpmn:MultipleEventDefinition"](parentGfx, element, attrs, isThrowing);
      }
    }
    if (isTypedEvent(semantic, "bpmn:MessageEventDefinition")) {
      return eventIconRenderers["bpmn:MessageEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:TimerEventDefinition")) {
      return eventIconRenderers["bpmn:TimerEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:ConditionalEventDefinition")) {
      return eventIconRenderers["bpmn:ConditionalEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:SignalEventDefinition")) {
      return eventIconRenderers["bpmn:SignalEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:EscalationEventDefinition")) {
      return eventIconRenderers["bpmn:EscalationEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:LinkEventDefinition")) {
      return eventIconRenderers["bpmn:LinkEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:ErrorEventDefinition")) {
      return eventIconRenderers["bpmn:ErrorEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:CancelEventDefinition")) {
      return eventIconRenderers["bpmn:CancelEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:CompensateEventDefinition")) {
      return eventIconRenderers["bpmn:CompensateEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    if (isTypedEvent(semantic, "bpmn:TerminateEventDefinition")) {
      return eventIconRenderers["bpmn:TerminateEventDefinition"](parentGfx, element, attrs, isThrowing);
    }
    return null;
  }
  var taskMarkerRenderers = {
    "ParticipantMultiplicityMarker": function(parentGfx, element, attrs = {}) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 - 6) / width,
          my: (height - 15) / height
        }
      });
      drawMarker("participant-multiplicity", parentGfx, markerPath, {
        strokeWidth: 2,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "SubProcessMarker": function(parentGfx, element, attrs = {}) {
      var markerRect = drawRect(parentGfx, 14, 14, 0, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
      translate(markerRect, element.width / 2 - 7.5, element.height - 20);
      var markerPath = pathMap.getScaledPath("MARKER_SUB_PROCESS", {
        xScaleFactor: 1.5,
        yScaleFactor: 1.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 - 7.5) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("sub-process", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "ParallelMarker": function(parentGfx, element, attrs) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 + attrs.parallel) / width,
          my: (height - 20) / height
        }
      });
      drawMarker("parallel", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "SequentialMarker": function(parentGfx, element, attrs) {
      var markerPath = pathMap.getScaledPath("MARKER_SEQUENTIAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + attrs.seq) / element.width,
          my: (element.height - 19) / element.height
        }
      });
      drawMarker("sequential", parentGfx, markerPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "CompensationMarker": function(parentGfx, element, attrs) {
      var markerMath = pathMap.getScaledPath("MARKER_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + attrs.compensation) / element.width,
          my: (element.height - 13) / element.height
        }
      });
      drawMarker("compensation", parentGfx, markerMath, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
    },
    "LoopMarker": function(parentGfx, element, attrs) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_LOOP", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 + attrs.loop) / width,
          my: (height - 7) / height
        }
      });
      drawMarker("loop", parentGfx, markerPath, {
        strokeWidth: 1.5,
        fill: "none",
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeMiterlimit: 0.5
      });
    },
    "AdhocMarker": function(parentGfx, element, attrs) {
      var width = getWidth(element, attrs), height = getHeight(element, attrs);
      var markerPath = pathMap.getScaledPath("MARKER_ADHOC", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: (width / 2 + attrs.adhoc) / width,
          my: (height - 15) / height
        }
      });
      drawMarker("adhoc", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
    }
  };
  function renderTaskMarker(type, parentGfx, element, attrs) {
    taskMarkerRenderers[type](parentGfx, element, attrs);
  }
  function renderTaskMarkers(parentGfx, element, taskMarkers, attrs = {}) {
    attrs = {
      fill: attrs.fill,
      stroke: attrs.stroke,
      width: getWidth(element, attrs),
      height: getHeight(element, attrs)
    };
    var semantic = getBusinessObject(element);
    var subprocess = taskMarkers && taskMarkers.includes("SubProcessMarker");
    if (subprocess) {
      attrs = {
        ...attrs,
        seq: -21,
        parallel: -22,
        compensation: -42,
        loop: -18,
        adhoc: 10
      };
    } else {
      attrs = {
        ...attrs,
        seq: -5,
        parallel: -6,
        compensation: -27,
        loop: 0,
        adhoc: 10
      };
    }
    forEach(taskMarkers, function(marker2) {
      renderTaskMarker(marker2, parentGfx, element, attrs);
    });
    if (semantic.get("isForCompensation")) {
      renderTaskMarker("CompensationMarker", parentGfx, element, attrs);
    }
    if (is(semantic, "bpmn:AdHocSubProcess")) {
      renderTaskMarker("AdhocMarker", parentGfx, element, attrs);
    }
    var loopCharacteristics = semantic.get("loopCharacteristics"), isSequential = loopCharacteristics && loopCharacteristics.get("isSequential");
    if (loopCharacteristics) {
      if (isSequential === void 0) {
        renderTaskMarker("LoopMarker", parentGfx, element, attrs);
      }
      if (isSequential === false) {
        renderTaskMarker("ParallelMarker", parentGfx, element, attrs);
      }
      if (isSequential === true) {
        renderTaskMarker("SequentialMarker", parentGfx, element, attrs);
      }
    }
  }
  function renderLabel(parentGfx, label, attrs = {}) {
    attrs = assign({
      size: {
        width: 100
      }
    }, attrs);
    var text = textRenderer.createText(label || "", attrs);
    classes(text).add("djs-label");
    append(parentGfx, text);
    return text;
  }
  function renderEmbeddedLabel(parentGfx, element, align, attrs = {}) {
    var semantic = getBusinessObject(element);
    var box = getBounds({
      x: element.x,
      y: element.y,
      width: element.width,
      height: element.height
    }, attrs);
    return renderLabel(parentGfx, semantic.name, {
      align,
      box,
      padding: 7,
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
      }
    });
  }
  function renderExternalLabel(parentGfx, element, attrs = {}) {
    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };
    return renderLabel(parentGfx, getLabel(element), {
      box,
      fitBox: true,
      style: assign(
        {},
        textRenderer.getExternalStyle(),
        {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        }
      )
    });
  }
  function renderLaneLabel(parentGfx, text, element, attrs = {}) {
    var isHorizontalLane = isHorizontal(element);
    var textBox = renderLabel(parentGfx, text, {
      box: {
        height: 30,
        width: isHorizontalLane ? getHeight(element, attrs) : getWidth(element, attrs)
      },
      align: "center-middle",
      style: {
        fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
      }
    });
    if (isHorizontalLane) {
      var top = -1 * getHeight(element, attrs);
      transform2(textBox, 0, -top, 270);
    }
  }
  function renderActivity(parentGfx, element, attrs = {}) {
    var {
      width,
      height
    } = getBounds(element, attrs);
    return drawRect(parentGfx, width, height, TASK_BORDER_RADIUS, {
      ...attrs,
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      fillOpacity: DEFAULT_OPACITY,
      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
    });
  }
  function renderAssociation(parentGfx, element, attrs = {}) {
    var semantic = getBusinessObject(element);
    var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);
    if (semantic.get("associationDirection") === "One" || semantic.get("associationDirection") === "Both") {
      attrs.markerEnd = marker(parentGfx, "association-end", fill, stroke);
    }
    if (semantic.get("associationDirection") === "Both") {
      attrs.markerStart = marker(parentGfx, "association-start", fill, stroke);
    }
    attrs = pickAttrs(attrs, [
      "markerStart",
      "markerEnd"
    ]);
    return drawConnectionSegments(parentGfx, element.waypoints, {
      ...attrs,
      stroke,
      strokeDasharray: "0, 5"
    });
  }
  function renderDataObject(parentGfx, element, attrs = {}) {
    var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);
    var pathData = pathMap.getScaledPath("DATA_OBJECT_PATH", {
      xScaleFactor: 1,
      yScaleFactor: 1,
      containerWidth: element.width,
      containerHeight: element.height,
      position: {
        mx: 0.474,
        my: 0.296
      }
    });
    var dataObject = drawPath2(parentGfx, pathData, {
      fill,
      fillOpacity: DEFAULT_OPACITY,
      stroke
    });
    var semantic = getBusinessObject(element);
    if (isCollection(semantic)) {
      var collectionPathData = pathMap.getScaledPath("DATA_OBJECT_COLLECTION_PATH", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.33,
          my: (element.height - 18) / element.height
        }
      });
      drawPath2(parentGfx, collectionPathData, {
        strokeWidth: 2,
        fill,
        stroke
      });
    }
    return dataObject;
  }
  function renderEvent(parentGfx, element, attrs = {}) {
    return drawCircle(parentGfx, element.width, element.height, {
      fillOpacity: DEFAULT_OPACITY,
      ...attrs,
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
    });
  }
  function renderGateway(parentGfx, element, attrs = {}) {
    return drawDiamond(parentGfx, element.width, element.height, {
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      fillOpacity: DEFAULT_OPACITY,
      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
    });
  }
  function renderLane(parentGfx, element, attrs = {}) {
    var lane = drawRect(parentGfx, getWidth(element, attrs), getHeight(element, attrs), 0, {
      fill: getFillColor(element, defaultFillColor, attrs.fill),
      fillOpacity: attrs.fillOpacity || DEFAULT_OPACITY,
      stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
      strokeWidth: 1.5
    });
    var semantic = getBusinessObject(element);
    if (is(semantic, "bpmn:Lane")) {
      var text = semantic.get("name");
      renderLaneLabel(parentGfx, text, element, attrs);
    }
    return lane;
  }
  function renderSubProcess(parentGfx, element, attrs = {}) {
    var activity = renderActivity(parentGfx, element, attrs);
    if (isEventSubProcess(element)) {
      attr(activity, {
        strokeDasharray: "0, 5.5",
        strokeWidth: 2.5
      });
    }
    var expanded = isExpanded(element);
    renderEmbeddedLabel(parentGfx, element, expanded ? "center-top" : "center-middle", attrs);
    if (expanded) {
      renderTaskMarkers(parentGfx, element, void 0, attrs);
    } else {
      renderTaskMarkers(parentGfx, element, ["SubProcessMarker"], attrs);
    }
    return activity;
  }
  function renderTask(parentGfx, element, attrs = {}) {
    var activity = renderActivity(parentGfx, element, attrs);
    renderEmbeddedLabel(parentGfx, element, "center-middle", attrs);
    renderTaskMarkers(parentGfx, element, void 0, attrs);
    return activity;
  }
  var handlers = this.handlers = {
    "bpmn:AdHocSubProcess": function(parentGfx, element, attrs = {}) {
      if (isExpanded(element)) {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke",
          "width",
          "height"
        ]);
      } else {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke"
        ]);
      }
      return renderSubProcess(parentGfx, element, attrs);
    },
    "bpmn:Association": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderAssociation(parentGfx, element, attrs);
    },
    "bpmn:BoundaryEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element), cancelActivity = semantic.get("cancelActivity");
      attrs = {
        strokeWidth: 1.5,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: FULL_OPACITY,
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      };
      if (!cancelActivity) {
        attrs.strokeDasharray = "6";
      }
      var event2 = renderEvent(parentGfx, element, attrs);
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        ...attrs,
        fill: "none"
      });
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return event2;
    },
    "bpmn:BusinessRuleTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var headerData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_MAIN", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessPath = drawPath2(parentGfx, headerData);
      attr(businessPath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      var headerPathData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_HEADER", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      var businessHeaderPath = drawPath2(parentGfx, headerPathData);
      attr(businessHeaderPath, {
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:CallActivity": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderSubProcess(parentGfx, element, {
        strokeWidth: 5,
        ...attrs
      });
    },
    "bpmn:ComplexGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var gateway = renderGateway(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("GATEWAY_COMPLEX", {
        xScaleFactor: 0.5,
        yScaleFactor: 0.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.26
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return gateway;
    },
    "bpmn:DataInput": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var dataObject = renderDataObject(parentGfx, element, attrs);
      drawPath2(parentGfx, arrowPathData, {
        fill: "none",
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return dataObject;
    },
    "bpmn:DataInputAssociation": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderAssociation(parentGfx, element, {
        ...attrs,
        markerEnd: marker(parentGfx, "association-end", getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor(element, defaultStrokeColor, attrs.stroke))
      });
    },
    "bpmn:DataObject": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderDataObject(parentGfx, element, attrs);
    },
    "bpmn:DataObjectReference": as("bpmn:DataObject"),
    "bpmn:DataOutput": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var dataObject = renderDataObject(parentGfx, element, attrs);
      drawPath2(parentGfx, arrowPathData, {
        strokeWidth: 1,
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
      return dataObject;
    },
    "bpmn:DataOutputAssociation": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderAssociation(parentGfx, element, {
        ...attrs,
        markerEnd: marker(parentGfx, "association-end", getFillColor(element, defaultFillColor, attrs.fill), getStrokeColor(element, defaultStrokeColor, attrs.stroke))
      });
    },
    "bpmn:DataStoreReference": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var dataStorePath = pathMap.getScaledPath("DATA_STORE", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0.133
        }
      });
      return drawPath2(parentGfx, dataStorePath, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        fillOpacity: DEFAULT_OPACITY,
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2
      });
    },
    "bpmn:EndEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var event2 = renderEvent(parentGfx, element, {
        ...attrs,
        strokeWidth: 4
      });
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return event2;
    },
    "bpmn:EventBasedGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element);
      var diamond = renderGateway(parentGfx, element, attrs);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.2, {
        fill: getFillColor(element, "none", attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      var type = semantic.get("eventGatewayType"), instantiate = !!semantic.get("instantiate");
      function drawEvent() {
        var pathData2 = pathMap.getScaledPath("GATEWAY_EVENT_BASED", {
          xScaleFactor: 0.18,
          yScaleFactor: 0.18,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.36,
            my: 0.44
          }
        });
        drawPath2(parentGfx, pathData2, {
          fill: "none",
          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 2
        });
      }
      if (type === "Parallel") {
        var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
          xScaleFactor: 0.4,
          yScaleFactor: 0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        });
        drawPath2(parentGfx, pathData, {
          fill: "none",
          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      } else if (type === "Exclusive") {
        if (!instantiate) {
          drawCircle(parentGfx, element.width, element.height, element.height * 0.26, {
            fill: "none",
            stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
            strokeWidth: 1
          });
        }
        drawEvent();
      }
      return diamond;
    },
    "bpmn:ExclusiveGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var gateway = renderGateway(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("GATEWAY_EXCLUSIVE", {
        xScaleFactor: 0.4,
        yScaleFactor: 0.4,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.32,
          my: 0.3
        }
      });
      var di = getDi(element);
      if (di.get("isMarkerVisible")) {
        drawPath2(parentGfx, pathData, {
          fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
      }
      return gateway;
    },
    "bpmn:Gateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderGateway(parentGfx, element, attrs);
    },
    "bpmn:Group": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      return drawRect(parentGfx, element.width, element.height, TASK_BORDER_RADIUS, {
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5,
        strokeDasharray: "10, 6, 0, 6",
        fill: "none",
        pointerEvents: "none",
        width: getWidth(element, attrs),
        height: getHeight(element, attrs)
      });
    },
    "bpmn:InclusiveGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var gateway = renderGateway(parentGfx, element, attrs);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.24, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 2.5
      });
      return gateway;
    },
    "bpmn:IntermediateEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var outer = renderEvent(parentGfx, element, {
        ...attrs,
        strokeWidth: 1.5
      });
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST, {
        fill: "none",
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5
      });
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return outer;
    },
    "bpmn:IntermediateCatchEvent": as("bpmn:IntermediateEvent"),
    "bpmn:IntermediateThrowEvent": as("bpmn:IntermediateEvent"),
    "bpmn:Lane": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      return renderLane(parentGfx, element, {
        ...attrs,
        fillOpacity: LOW_OPACITY
      });
    },
    "bpmn:ManualTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("TASK_TYPE_MANUAL", {
        abspos: {
          x: 17,
          y: 15
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      return task;
    },
    "bpmn:MessageFlow": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element), di = getDi(element);
      var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);
      var path = drawConnectionSegments(parentGfx, element.waypoints, {
        markerEnd: marker(parentGfx, "messageflow-end", fill, stroke),
        markerStart: marker(parentGfx, "messageflow-start", fill, stroke),
        stroke,
        strokeDasharray: "10, 11",
        strokeWidth: 1.5
      });
      if (semantic.get("messageRef")) {
        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        var markerPathData = pathMap.getScaledPath("MESSAGE_FLOW_MARKER", {
          abspos: {
            x: midPoint.x,
            y: midPoint.y
          }
        });
        var messageAttrs = {
          strokeWidth: 1
        };
        if (di.get("messageVisibleKind") === "initiating") {
          messageAttrs.fill = fill;
          messageAttrs.stroke = stroke;
        } else {
          messageAttrs.fill = stroke;
          messageAttrs.stroke = fill;
        }
        var message = drawPath2(parentGfx, markerPathData, messageAttrs);
        var messageRef = semantic.get("messageRef"), name2 = messageRef.get("name");
        var label = renderLabel(parentGfx, name2, {
          align: "center-top",
          fitBox: true,
          style: {
            fill: stroke
          }
        });
        var messageBounds = message.getBBox(), labelBounds = label.getBBox();
        var translateX = midPoint.x - labelBounds.width / 2, translateY = midPoint.y + messageBounds.height / 2 + ELEMENT_LABEL_DISTANCE;
        transform2(label, translateX, translateY, 0);
      }
      return path;
    },
    "bpmn:ParallelGateway": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var diamond = renderGateway(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
        xScaleFactor: 0.6,
        yScaleFactor: 0.6,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.2
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return diamond;
    },
    "bpmn:Participant": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      var participant = renderLane(parentGfx, element, attrs);
      var expandedParticipant = isExpanded(element);
      var horizontalParticipant = isHorizontal(element);
      var semantic = getBusinessObject(element), name2 = semantic.get("name");
      if (expandedParticipant) {
        var waypoints = horizontalParticipant ? [
          {
            x: 30,
            y: 0
          },
          {
            x: 30,
            y: getHeight(element, attrs)
          }
        ] : [
          {
            x: 0,
            y: 30
          },
          {
            x: getWidth(element, attrs),
            y: 30
          }
        ];
        drawLine(parentGfx, waypoints, {
          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: PARTICIPANT_STROKE_WIDTH
        });
        renderLaneLabel(parentGfx, name2, element, attrs);
      } else {
        var bounds = getBounds(element, attrs);
        if (!horizontalParticipant) {
          bounds.height = getWidth(element, attrs);
          bounds.width = getHeight(element, attrs);
        }
        var textBox = renderLabel(parentGfx, name2, {
          box: bounds,
          align: "center-middle",
          style: {
            fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
          }
        });
        if (!horizontalParticipant) {
          var top = -1 * getHeight(element, attrs);
          transform2(textBox, 0, -top, 270);
        }
      }
      if (semantic.get("participantMultiplicity")) {
        renderTaskMarker("ParticipantMultiplicityMarker", parentGfx, element, attrs);
      }
      return participant;
    },
    "bpmn:ReceiveTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element);
      var task = renderTask(parentGfx, element, attrs);
      var pathData;
      if (semantic.get("instantiate")) {
        drawCircle(parentGfx, 28, 28, 20 * 0.22, {
          fill: getFillColor(element, defaultFillColor, attrs.fill),
          stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
          strokeWidth: 1
        });
        pathData = pathMap.getScaledPath("TASK_TYPE_INSTANTIATING_SEND", {
          abspos: {
            x: 7.77,
            y: 9.52
          }
        });
      } else {
        pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.3,
            my: 0.4
          }
        });
      }
      drawPath2(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:ScriptTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SCRIPT", {
        abspos: {
          x: 15,
          y: 20
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:SendTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: 21,
        containerHeight: 14,
        position: {
          mx: 0.285,
          my: 0.357
        }
      });
      drawPath2(parentGfx, pathData, {
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getFillColor(element, defaultFillColor, attrs.fill),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:SequenceFlow": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var fill = getFillColor(element, defaultFillColor, attrs.fill), stroke = getStrokeColor(element, defaultStrokeColor, attrs.stroke);
      var connection = drawConnectionSegments(parentGfx, element.waypoints, {
        markerEnd: marker(parentGfx, "sequenceflow-end", fill, stroke),
        stroke
      });
      var semantic = getBusinessObject(element);
      var { source } = element;
      if (source) {
        var sourceSemantic = getBusinessObject(source);
        if (semantic.get("conditionExpression") && is(sourceSemantic, "bpmn:Activity")) {
          attr(connection, {
            markerStart: marker(parentGfx, "conditional-flow-marker", fill, stroke)
          });
        }
        if (sourceSemantic.get("default") && (is(sourceSemantic, "bpmn:Gateway") || is(sourceSemantic, "bpmn:Activity")) && sourceSemantic.get("default") === semantic) {
          attr(connection, {
            markerStart: marker(parentGfx, "conditional-default-flow-marker", fill, stroke)
          });
        }
      }
      return connection;
    },
    "bpmn:ServiceTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      drawCircle(parentGfx, 10, 10, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: "none",
        transform: "translate(6, 6)"
      });
      var pathDataService1 = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 12,
          y: 18
        }
      });
      drawPath2(parentGfx, pathDataService1, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      drawCircle(parentGfx, 10, 10, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: "none",
        transform: "translate(11, 10)"
      });
      var pathDataService2 = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 17,
          y: 22
        }
      });
      drawPath2(parentGfx, pathDataService2, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1
      });
      return task;
    },
    "bpmn:StartEvent": function(parentGfx, element, attrs = {}) {
      var { renderIcon = true } = attrs;
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var semantic = getBusinessObject(element);
      if (!semantic.get("isInterrupting")) {
        attrs = {
          ...attrs,
          strokeDasharray: "6"
        };
      }
      var event2 = renderEvent(parentGfx, element, attrs);
      if (renderIcon) {
        renderEventIcon(element, parentGfx, attrs);
      }
      return event2;
    },
    "bpmn:SubProcess": function(parentGfx, element, attrs = {}) {
      if (isExpanded(element)) {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke",
          "width",
          "height"
        ]);
      } else {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke"
        ]);
      }
      return renderSubProcess(parentGfx, element, attrs);
    },
    "bpmn:Task": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      return renderTask(parentGfx, element, attrs);
    },
    "bpmn:TextAnnotation": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke",
        "width",
        "height"
      ]);
      var {
        width,
        height
      } = getBounds(element, attrs);
      var textElement = drawRect(parentGfx, width, height, 0, 0, {
        fill: "none",
        stroke: "none"
      });
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: width,
        containerHeight: height,
        position: {
          mx: 0,
          my: 0
        }
      });
      drawPath2(parentGfx, textPathData, {
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke)
      });
      var semantic = getBusinessObject(element), text = semantic.get("text") || "";
      renderLabel(parentGfx, text, {
        align: "left-top",
        box: getBounds(element, attrs),
        padding: 7,
        style: {
          fill: getLabelColor(element, defaultLabelColor, defaultStrokeColor, attrs.stroke)
        }
      });
      return textElement;
    },
    "bpmn:Transaction": function(parentGfx, element, attrs = {}) {
      if (isExpanded(element)) {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke",
          "width",
          "height"
        ]);
      } else {
        attrs = pickAttrs(attrs, [
          "fill",
          "stroke"
        ]);
      }
      var outer = renderSubProcess(parentGfx, element, {
        strokeWidth: 1.5,
        ...attrs
      });
      var innerAttrs = styles.style(["no-fill", "no-events"], {
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 1.5
      });
      var expanded = isExpanded(element);
      if (!expanded) {
        attrs = {};
      }
      drawRect(
        parentGfx,
        getWidth(element, attrs),
        getHeight(element, attrs),
        TASK_BORDER_RADIUS - INNER_OUTER_DIST,
        INNER_OUTER_DIST,
        innerAttrs
      );
      return outer;
    },
    "bpmn:UserTask": function(parentGfx, element, attrs = {}) {
      attrs = pickAttrs(attrs, [
        "fill",
        "stroke"
      ]);
      var task = renderTask(parentGfx, element, attrs);
      var x6 = 15;
      var y5 = 12;
      var pathDataUser1 = pathMap.getScaledPath("TASK_TYPE_USER_1", {
        abspos: {
          x: x6,
          y: y5
        }
      });
      drawPath2(parentGfx, pathDataUser1, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      var pathDataUser2 = pathMap.getScaledPath("TASK_TYPE_USER_2", {
        abspos: {
          x: x6,
          y: y5
        }
      });
      drawPath2(parentGfx, pathDataUser2, {
        fill: getFillColor(element, defaultFillColor, attrs.fill),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      var pathDataUser3 = pathMap.getScaledPath("TASK_TYPE_USER_3", {
        abspos: {
          x: x6,
          y: y5
        }
      });
      drawPath2(parentGfx, pathDataUser3, {
        fill: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        stroke: getStrokeColor(element, defaultStrokeColor, attrs.stroke),
        strokeWidth: 0.5
      });
      return task;
    },
    "label": function(parentGfx, element, attrs = {}) {
      return renderExternalLabel(parentGfx, element, attrs);
    }
  };
  this._drawPath = drawPath2;
  this._renderer = renderer;
}
e(BpmnRenderer, BaseRenderer);
BpmnRenderer.$inject = [
  "config.bpmnRenderer",
  "eventBus",
  "styles",
  "pathMap",
  "canvas",
  "textRenderer"
];
BpmnRenderer.prototype.canRender = function(element) {
  return is(element, "bpmn:BaseElement");
};
BpmnRenderer.prototype.drawShape = function(parentGfx, shape, attrs = {}) {
  var { type } = shape;
  var handler = this._renderer(type);
  return handler(parentGfx, shape, attrs);
};
BpmnRenderer.prototype.drawConnection = function(parentGfx, connection, attrs = {}) {
  var { type } = connection;
  var handler = this._renderer(type);
  return handler(parentGfx, connection, attrs);
};
BpmnRenderer.prototype.getShapePath = function(shape) {
  if (is(shape, "bpmn:Event")) {
    return getCirclePath(shape);
  }
  if (is(shape, "bpmn:Activity")) {
    return getRoundRectPath(shape, TASK_BORDER_RADIUS);
  }
  if (is(shape, "bpmn:Gateway")) {
    return getDiamondPath(shape);
  }
  return getRectPath(shape);
};
function pickAttrs(attrs, keys2 = []) {
  return keys2.reduce((pickedAttrs, key) => {
    if (attrs[key]) {
      pickedAttrs[key] = attrs[key];
    }
    return pickedAttrs;
  }, {});
}

// node_modules/diagram-js/lib/util/Text.js
var DEFAULT_BOX_PADDING = 0;
var DEFAULT_LABEL_SIZE2 = {
  width: 150,
  height: 50
};
function parseAlign(align) {
  var parts = align.split("-");
  return {
    horizontal: parts[0] || "center",
    vertical: parts[1] || "top"
  };
}
function parsePadding(padding) {
  if (isObject(padding)) {
    return assign({ top: 0, left: 0, right: 0, bottom: 0 }, padding);
  } else {
    return {
      top: padding,
      left: padding,
      right: padding,
      bottom: padding
    };
  }
}
function getTextBBox(text, fakeText) {
  fakeText.textContent = text;
  var textBBox;
  try {
    var bbox, emptyLine = text === "";
    fakeText.textContent = emptyLine ? "dummy" : text;
    textBBox = fakeText.getBBox();
    bbox = {
      width: textBBox.width + textBBox.x * 2,
      height: textBBox.height
    };
    if (emptyLine) {
      bbox.width = 0;
    }
    return bbox;
  } catch (e8) {
    console.log(e8);
    return { width: 0, height: 0 };
  }
}
function layoutNext(lines, maxWidth, fakeText) {
  var originalLine = lines.shift(), fitLine = originalLine;
  var textBBox;
  for (; ; ) {
    textBBox = getTextBBox(fitLine, fakeText);
    textBBox.width = fitLine ? textBBox.width : 0;
    if (fitLine === " " || fitLine === "" || textBBox.width < Math.round(maxWidth) || fitLine.length < 2) {
      return fit(lines, fitLine, originalLine, textBBox);
    }
    fitLine = shortenLine(fitLine, textBBox.width, maxWidth);
  }
}
function fit(lines, fitLine, originalLine, textBBox) {
  if (fitLine.length < originalLine.length) {
    var remainder = originalLine.slice(fitLine.length).trim();
    lines.unshift(remainder);
  }
  return {
    width: textBBox.width,
    height: textBBox.height,
    text: fitLine
  };
}
var SOFT_BREAK = "\xAD";
function semanticShorten(line2, maxLength) {
  var parts = line2.split(/(\s|-|\u00AD)/g), part, shortenedParts = [], length2 = 0;
  if (parts.length > 1) {
    while (part = parts.shift()) {
      if (part.length + length2 < maxLength) {
        shortenedParts.push(part);
        length2 += part.length;
      } else {
        if (part === "-" || part === SOFT_BREAK) {
          shortenedParts.pop();
        }
        break;
      }
    }
  }
  var last4 = shortenedParts[shortenedParts.length - 1];
  if (last4 && last4 === SOFT_BREAK) {
    shortenedParts[shortenedParts.length - 1] = "-";
  }
  return shortenedParts.join("");
}
function shortenLine(line2, width, maxWidth) {
  var length2 = Math.max(line2.length * (maxWidth / width), 1);
  var shortenedLine = semanticShorten(line2, length2);
  if (!shortenedLine) {
    shortenedLine = line2.slice(0, Math.max(Math.round(length2 - 1), 1));
  }
  return shortenedLine;
}
function getHelperSvg() {
  var helperSvg = document.getElementById("helper-svg");
  if (!helperSvg) {
    helperSvg = create("svg");
    attr(helperSvg, {
      id: "helper-svg"
    });
    assign2(helperSvg, {
      visibility: "hidden",
      position: "fixed",
      width: 0,
      height: 0
    });
    document.body.appendChild(helperSvg);
  }
  return helperSvg;
}
function Text(config) {
  this._config = assign({}, {
    size: DEFAULT_LABEL_SIZE2,
    padding: DEFAULT_BOX_PADDING,
    style: {},
    align: "center-top"
  }, config || {});
}
Text.prototype.createText = function(text, options) {
  return this.layoutText(text, options).element;
};
Text.prototype.getDimensions = function(text, options) {
  return this.layoutText(text, options).dimensions;
};
Text.prototype.layoutText = function(text, options) {
  var box = assign({}, this._config.size, options.box), style = assign({}, this._config.style, options.style), align = parseAlign(options.align || this._config.align), padding = parsePadding(options.padding !== void 0 ? options.padding : this._config.padding), fitBox = options.fitBox || false;
  var lineHeight = getLineHeight(style);
  var lines = text.split(/\u00AD?\r?\n/), layouted = [];
  var maxWidth = box.width - padding.left - padding.right;
  var helperText = create("text");
  attr(helperText, { x: 0, y: 0 });
  attr(helperText, style);
  var helperSvg = getHelperSvg();
  append(helperSvg, helperText);
  while (lines.length) {
    layouted.push(layoutNext(lines, maxWidth, helperText));
  }
  if (align.vertical === "middle") {
    padding.top = padding.bottom = 0;
  }
  var totalHeight = reduce(layouted, function(sum, line2, idx) {
    return sum + (lineHeight || line2.height);
  }, 0) + padding.top + padding.bottom;
  var maxLineWidth = reduce(layouted, function(sum, line2, idx) {
    return line2.width > sum ? line2.width : sum;
  }, 0);
  var y5 = padding.top;
  if (align.vertical === "middle") {
    y5 += (box.height - totalHeight) / 2;
  }
  y5 -= (lineHeight || layouted[0].height) / 4;
  var textElement = create("text");
  attr(textElement, style);
  forEach(layouted, function(line2) {
    var x6;
    y5 += lineHeight || line2.height;
    switch (align.horizontal) {
      case "left":
        x6 = padding.left;
        break;
      case "right":
        x6 = (fitBox ? maxLineWidth : maxWidth) - padding.right - line2.width;
        break;
      default:
        x6 = Math.max(((fitBox ? maxLineWidth : maxWidth) - line2.width) / 2 + padding.left, 0);
    }
    var tspan = create("tspan");
    attr(tspan, { x: x6, y: y5 });
    tspan.textContent = line2.text;
    append(textElement, tspan);
  });
  remove(helperText);
  var dimensions = {
    width: maxLineWidth,
    height: totalHeight
  };
  return {
    dimensions,
    element: textElement
  };
};
function getLineHeight(style) {
  if ("fontSize" in style && "lineHeight" in style) {
    return style.lineHeight * parseInt(style.fontSize, 10);
  }
}

// node_modules/bpmn-js/lib/draw/TextRenderer.js
var DEFAULT_FONT_SIZE = 12;
var LINE_HEIGHT_RATIO = 1.2;
var MIN_TEXT_ANNOTATION_HEIGHT = 30;
function TextRenderer(config) {
  var defaultStyle = assign({
    fontFamily: "Arial, sans-serif",
    fontSize: DEFAULT_FONT_SIZE,
    fontWeight: "normal",
    lineHeight: LINE_HEIGHT_RATIO
  }, config && config.defaultStyle || {});
  var fontSize = parseInt(defaultStyle.fontSize, 10) - 1;
  var externalStyle = assign({}, defaultStyle, {
    fontSize
  }, config && config.externalStyle || {});
  var textUtil = new Text({
    style: defaultStyle
  });
  this.getExternalLabelBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: {
        width: 90,
        height: 30
      },
      style: externalStyle
    });
    return {
      x: Math.round(bounds.x + bounds.width / 2 - layoutedDimensions.width / 2),
      y: Math.round(bounds.y),
      width: Math.ceil(layoutedDimensions.width),
      height: Math.ceil(layoutedDimensions.height)
    };
  };
  this.getTextAnnotationBounds = function(bounds, text) {
    var layoutedDimensions = textUtil.getDimensions(text, {
      box: bounds,
      style: defaultStyle,
      align: "left-top",
      padding: 5
    });
    return {
      x: bounds.x,
      y: bounds.y,
      width: bounds.width,
      height: Math.max(MIN_TEXT_ANNOTATION_HEIGHT, Math.round(layoutedDimensions.height))
    };
  };
  this.createText = function(text, options) {
    return textUtil.createText(text, options || {});
  };
  this.getDefaultStyle = function() {
    return defaultStyle;
  };
  this.getExternalStyle = function() {
    return externalStyle;
  };
}
TextRenderer.$inject = [
  "config.textRenderer"
];

// node_modules/bpmn-js/lib/draw/PathMap.js
function PathMap() {
  this.pathMap = {
    "EVENT_MESSAGE": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 36,
      width: 36,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "EVENT_SIGNAL": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x1},0 Z",
      height: 36,
      width: 36,
      heightElements: [18],
      widthElements: [10, 20]
    },
    "EVENT_ESCALATION": {
      d: "M {mx},{my} l {e.x0},{e.y0} l -{e.x0},-{e.y1} l -{e.x0},{e.y1} Z",
      height: 36,
      width: 36,
      heightElements: [20, 7],
      widthElements: [8]
    },
    "EVENT_CONDITIONAL": {
      d: "M {e.x0},{e.y0} l {e.x1},0 l 0,{e.y2} l -{e.x1},0 Z M {e.x2},{e.y3} l {e.x0},0 M {e.x2},{e.y4} l {e.x0},0 M {e.x2},{e.y5} l {e.x0},0 M {e.x2},{e.y6} l {e.x0},0 M {e.x2},{e.y7} l {e.x0},0 M {e.x2},{e.y8} l {e.x0},0 ",
      height: 36,
      width: 36,
      heightElements: [8.5, 14.5, 18, 11.5, 14.5, 17.5, 20.5, 23.5, 26.5],
      widthElements: [10.5, 14.5, 12.5]
    },
    "EVENT_LINK": {
      d: "m {mx},{my} 0,{e.y0} -{e.x1},0 0,{e.y1} {e.x1},0 0,{e.y0} {e.x0},-{e.y2} -{e.x0},-{e.y2} z",
      height: 36,
      width: 36,
      heightElements: [4.4375, 6.75, 7.8125],
      widthElements: [9.84375, 13.5]
    },
    "EVENT_ERROR": {
      d: "m {mx},{my} {e.x0},-{e.y0} {e.x1},-{e.y1} {e.x2},{e.y2} {e.x3},-{e.y3} -{e.x4},{e.y4} -{e.x5},-{e.y5} z",
      height: 36,
      width: 36,
      heightElements: [0.023, 8.737, 8.151, 16.564, 10.591, 8.714],
      widthElements: [0.085, 6.672, 6.97, 4.273, 5.337, 6.636]
    },
    "EVENT_CANCEL_45": {
      d: "m {mx},{my} -{e.x1},0 0,{e.x0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 36,
      width: 36,
      heightElements: [4.75, 8.5],
      widthElements: [4.75, 8.5]
    },
    "EVENT_COMPENSATION": {
      d: "m {mx},{my} {e.x0},-{e.y0} 0,{e.y1} z m {e.x1},-{e.y2} {e.x2},-{e.y3} 0,{e.y1} -{e.x2},-{e.y3} z",
      height: 36,
      width: 36,
      heightElements: [6.5, 13, 0.4, 6.1],
      widthElements: [9, 9.3, 8.7]
    },
    "EVENT_TIMER_WH": {
      d: "M {mx},{my} l {e.x0},-{e.y0} m -{e.x0},{e.y0} l {e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 2],
      widthElements: [3, 7]
    },
    "EVENT_TIMER_LINE": {
      d: "M {mx},{my} m {e.x0},{e.y0} l -{e.x1},{e.y1} ",
      height: 36,
      width: 36,
      heightElements: [10, 3],
      widthElements: [0, 0]
    },
    "EVENT_MULTIPLE": {
      d: "m {mx},{my} {e.x1},-{e.y0} {e.x1},{e.y0} -{e.x0},{e.y1} -{e.x2},0 z",
      height: 36,
      width: 36,
      heightElements: [6.28099, 12.56199],
      widthElements: [3.1405, 9.42149, 12.56198]
    },
    "EVENT_PARALLEL_MULTIPLE": {
      d: "m {mx},{my} {e.x0},0 0,{e.y1} {e.x1},0 0,{e.y0} -{e.x1},0 0,{e.y1} -{e.x0},0 0,-{e.y1} -{e.x1},0 0,-{e.y0} {e.x1},0 z",
      height: 36,
      width: 36,
      heightElements: [2.56228, 7.68683],
      widthElements: [2.56228, 7.68683]
    },
    "GATEWAY_EXCLUSIVE": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x1},{e.y0} {e.x2},0 {e.x4},{e.y2} {e.x4},{e.y1} {e.x2},0 {e.x1},{e.y3} {e.x0},{e.y3} {e.x3},0 {e.x5},{e.y1} {e.x5},{e.y2} {e.x3},0 z",
      height: 17.5,
      width: 17.5,
      heightElements: [8.5, 6.5312, -6.5312, -8.5],
      widthElements: [6.5, -6.5, 3, -3, 5, -5]
    },
    "GATEWAY_PARALLEL": {
      d: "m {mx},{my} 0,{e.y1} -{e.x1},0 0,{e.y0} {e.x1},0 0,{e.y1} {e.x0},0 0,-{e.y1} {e.x1},0 0,-{e.y0} -{e.x1},0 0,-{e.y1} -{e.x0},0 z",
      height: 30,
      width: 30,
      heightElements: [5, 12.5],
      widthElements: [5, 12.5]
    },
    "GATEWAY_EVENT_BASED": {
      d: "m {mx},{my} {e.x0},{e.y0} {e.x0},{e.y1} {e.x1},{e.y2} {e.x2},0 z",
      height: 11,
      width: 11,
      heightElements: [-6, 6, 12, -12],
      widthElements: [9, -3, -12]
    },
    "GATEWAY_COMPLEX": {
      d: "m {mx},{my} 0,{e.y0} -{e.x0},-{e.y1} -{e.x1},{e.y2} {e.x0},{e.y1} -{e.x2},0 0,{e.y3} {e.x2},0  -{e.x0},{e.y1} l {e.x1},{e.y2} {e.x0},-{e.y1} 0,{e.y0} {e.x3},0 0,-{e.y0} {e.x0},{e.y1} {e.x1},-{e.y2} -{e.x0},-{e.y1} {e.x2},0 0,-{e.y3} -{e.x2},0 {e.x0},-{e.y1} -{e.x1},-{e.y2} -{e.x0},{e.y1} 0,-{e.y0} -{e.x3},0 z",
      height: 17.125,
      width: 17.125,
      heightElements: [4.875, 3.4375, 2.125, 3],
      widthElements: [3.4375, 2.125, 4.875, 3]
    },
    "DATA_OBJECT_PATH": {
      d: "m 0,0 {e.x1},0 {e.x0},{e.y0} 0,{e.y1} -{e.x2},0 0,-{e.y2} {e.x1},0 0,{e.y0} {e.x0},0",
      height: 61,
      width: 51,
      heightElements: [10, 50, 60],
      widthElements: [10, 40, 50, 60]
    },
    "DATA_OBJECT_COLLECTION_PATH": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "DATA_ARROW": {
      d: "m 5,9 9,0 0,-3 5,5 -5,5 0,-3 -9,0 z",
      height: 61,
      width: 51,
      heightElements: [],
      widthElements: []
    },
    "DATA_STORE": {
      d: "m  {mx},{my} l  0,{e.y2} c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 l  0,-{e.y2} c -{e.x0},-{e.y1} -{e.x1},-{e.y1} -{e.x2},0c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0 m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1} {e.x2},0m  -{e.x2},{e.y0}c  {e.x0},{e.y1} {e.x1},{e.y1}  {e.x2},0",
      height: 61,
      width: 61,
      heightElements: [7, 10, 45],
      widthElements: [2, 58, 60]
    },
    "TEXT_ANNOTATION": {
      d: "m {mx}, {my} m 10,0 l -10,0 l 0,{e.y0} l 10,0",
      height: 30,
      width: 10,
      heightElements: [30],
      widthElements: [10]
    },
    "MARKER_SUB_PROCESS": {
      d: "m{mx},{my} m 7,2 l 0,10 m -5,-5 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_PARALLEL": {
      d: "m{mx},{my} m 3,2 l 0,10 m 3,-10 l 0,10 m 3,-10 l 0,10",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_SEQUENTIAL": {
      d: "m{mx},{my} m 0,3 l 10,0 m -10,3 l 10,0 m -10,3 l 10,0",
      height: 10,
      width: 10,
      heightElements: [],
      widthElements: []
    },
    "MARKER_COMPENSATION": {
      d: "m {mx},{my} 7,-5 0,10 z m 7.1,-0.3 6.9,-4.7 0,10 -6.9,-4.7 z",
      height: 10,
      width: 21,
      heightElements: [],
      widthElements: []
    },
    "MARKER_LOOP": {
      d: "m {mx},{my} c 3.526979,0 6.386161,-2.829858 6.386161,-6.320661 0,-3.490806 -2.859182,-6.320661 -6.386161,-6.320661 -3.526978,0 -6.38616,2.829855 -6.38616,6.320661 0,1.745402 0.714797,3.325567 1.870463,4.469381 0.577834,0.571908 1.265885,1.034728 2.029916,1.35457 l -0.718163,-3.909793 m 0.718163,3.909793 -3.885211,0.802902",
      height: 13.9,
      width: 13.7,
      heightElements: [],
      widthElements: []
    },
    "MARKER_ADHOC": {
      d: "m {mx},{my} m 0.84461,2.64411 c 1.05533,-1.23780996 2.64337,-2.07882 4.29653,-1.97997996 2.05163,0.0805 3.85579,1.15803 5.76082,1.79107 1.06385,0.34139996 2.24454,0.1438 3.18759,-0.43767 0.61743,-0.33642 1.2775,-0.64078 1.7542,-1.17511 0,0.56023 0,1.12046 0,1.6807 -0.98706,0.96237996 -2.29792,1.62393996 -3.6918,1.66181996 -1.24459,0.0927 -2.46671,-0.2491 -3.59505,-0.74812 -1.35789,-0.55965 -2.75133,-1.33436996 -4.27027,-1.18121996 -1.37741,0.14601 -2.41842,1.13685996 -3.44288,1.96782996 z",
      height: 4,
      width: 15,
      heightElements: [],
      widthElements: []
    },
    "TASK_TYPE_SEND": {
      d: "m {mx},{my} l 0,{e.y1} l {e.x1},0 l 0,-{e.y1} z l {e.x0},{e.y0} l {e.x0},-{e.y0}",
      height: 14,
      width: 21,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_SCRIPT": {
      d: "m {mx},{my} c 9.966553,-6.27276 -8.000926,-7.91932 2.968968,-14.938 l -8.802728,0 c -10.969894,7.01868 6.997585,8.66524 -2.968967,14.938 z m -7,-12 l 5,0 m -4.5,3 l 4.5,0 m -3,3 l 5,0m -4,3 l 5,0",
      height: 15,
      width: 12.6,
      heightElements: [6, 14],
      widthElements: [10.5, 21]
    },
    "TASK_TYPE_USER_1": {
      d: "m {mx},{my} c 0.909,-0.845 1.594,-2.049 1.594,-3.385 0,-2.554 -1.805,-4.62199999 -4.357,-4.62199999 -2.55199998,0 -4.28799998,2.06799999 -4.28799998,4.62199999 0,1.348 0.974,2.562 1.89599998,3.405 -0.52899998,0.187 -5.669,2.097 -5.794,4.7560005 v 6.718 h 17 v -6.718 c 0,-2.2980005 -5.5279996,-4.5950005 -6.0509996,-4.7760005 zm -8,6 l 0,5.5 m 11,0 l 0,-5"
    },
    "TASK_TYPE_USER_2": {
      d: "m {mx},{my} m 2.162,1.009 c 0,2.4470005 -2.158,4.4310005 -4.821,4.4310005 -2.66499998,0 -4.822,-1.981 -4.822,-4.4310005 "
    },
    "TASK_TYPE_USER_3": {
      d: "m {mx},{my} m -6.9,-3.80 c 0,0 2.25099998,-2.358 4.27399998,-1.177 2.024,1.181 4.221,1.537 4.124,0.965 -0.098,-0.57 -0.117,-3.79099999 -4.191,-4.13599999 -3.57499998,0.001 -4.20799998,3.36699999 -4.20699998,4.34799999 z"
    },
    "TASK_TYPE_MANUAL": {
      d: "m {mx},{my} c 0.234,-0.01 5.604,0.008 8.029,0.004 0.808,0 1.271,-0.172 1.417,-0.752 0.227,-0.898 -0.334,-1.314 -1.338,-1.316 -2.467,-0.01 -7.886,-0.004 -8.108,-0.004 -0.014,-0.079 0.016,-0.533 0,-0.61 0.195,-0.042 8.507,0.006 9.616,0.002 0.877,-0.007 1.35,-0.438 1.353,-1.208 0.003,-0.768 -0.479,-1.09 -1.35,-1.091 -2.968,-0.002 -9.619,-0.013 -9.619,-0.013 v -0.591 c 0,0 5.052,-0.016 7.225,-0.016 0.888,-0.002 1.354,-0.416 1.351,-1.193 -0.006,-0.761 -0.492,-1.196 -1.361,-1.196 -3.473,-0.005 -10.86,-0.003 -11.0829995,-0.003 -0.022,-0.047 -0.045,-0.094 -0.069,-0.139 0.3939995,-0.319 2.0409995,-1.626 2.4149995,-2.017 0.469,-0.4870005 0.519,-1.1650005 0.162,-1.6040005 -0.414,-0.511 -0.973,-0.5 -1.48,-0.236 -1.4609995,0.764 -6.5999995,3.6430005 -7.7329995,4.2710005 -0.9,0.499 -1.516,1.253 -1.882,2.19 -0.37000002,0.95 -0.17,2.01 -0.166,2.979 0.004,0.718 -0.27300002,1.345 -0.055,2.063 0.629,2.087 2.425,3.312 4.859,3.318 4.6179995,0.014 9.2379995,-0.139 13.8569995,-0.158 0.755,-0.004 1.171,-0.301 1.182,-1.033 0.012,-0.754 -0.423,-0.969 -1.183,-0.973 -1.778,-0.01 -5.824,-0.004 -6.04,-0.004 10e-4,-0.084 0.003,-0.586 10e-4,-0.67 z"
    },
    "TASK_TYPE_INSTANTIATING_SEND": {
      d: "m {mx},{my} l 0,8.4 l 12.6,0 l 0,-8.4 z l 6.3,3.6 l 6.3,-3.6"
    },
    "TASK_TYPE_SERVICE": {
      d: "m {mx},{my} v -1.71335 c 0.352326,-0.0705 0.703932,-0.17838 1.047628,-0.32133 0.344416,-0.14465 0.665822,-0.32133 0.966377,-0.52145 l 1.19431,1.18005 1.567487,-1.57688 -1.195028,-1.18014 c 0.403376,-0.61394 0.683079,-1.29908 0.825447,-2.01824 l 1.622133,-0.01 v -2.2196 l -1.636514,0.01 c -0.07333,-0.35153 -0.178319,-0.70024 -0.323564,-1.04372 -0.145244,-0.34406 -0.321407,-0.6644 -0.522735,-0.96217 l 1.131035,-1.13631 -1.583305,-1.56293 -1.129598,1.13589 c -0.614052,-0.40108 -1.302883,-0.68093 -2.022633,-0.82247 l 0.0093,-1.61852 h -2.241173 l 0.0042,1.63124 c -0.353763,0.0736 -0.705369,0.17977 -1.049785,0.32371 -0.344415,0.14437 -0.665102,0.32092 -0.9635006,0.52046 l -1.1698628,-1.15823 -1.5667691,1.5792 1.1684265,1.15669 c -0.4026573,0.61283 -0.68308,1.29797 -0.8247287,2.01713 l -1.6588041,0.003 v 2.22174 l 1.6724648,-0.006 c 0.073327,0.35077 0.1797598,0.70243 0.3242851,1.04472 0.1452428,0.34448 0.3214064,0.6644 0.5227339,0.96066 l -1.1993431,1.19723 1.5840256,1.56011 1.1964668,-1.19348 c 0.6140517,0.40346 1.3028827,0.68232 2.0233517,0.82331 l 7.19e-4,1.69892 h 2.226848 z m 0.221462,-3.9957 c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_SERVICE_FILL": {
      d: "m {mx},{my} c -1.788948,0.7502 -3.8576,-0.0928 -4.6097055,-1.87438 -0.7521065,-1.78321 0.090598,-3.84627 1.8802645,-4.59604 1.78823,-0.74936 3.856881,0.0929 4.608987,1.87437 0.752106,1.78165 -0.0906,3.84612 -1.879546,4.59605 z"
    },
    "TASK_TYPE_BUSINESS_RULE_HEADER": {
      d: "m {mx},{my} 0,4 20,0 0,-4 z"
    },
    "TASK_TYPE_BUSINESS_RULE_MAIN": {
      d: "m {mx},{my} 0,12 20,0 0,-12 zm 0,8 l 20,0 m -13,-4 l 0,8"
    },
    "MESSAGE_FLOW_MARKER": {
      d: "m {mx},{my} m -10.5 ,-7 l 0,14 l 21,0 l 0,-14 z l 10.5,6 l 10.5,-6"
    }
  };
  this.getRawPath = function getRawPath(pathId) {
    return this.pathMap[pathId].d;
  };
  this.getScaledPath = function getScaledPath(pathId, param) {
    var rawPath = this.pathMap[pathId];
    var mx, my;
    if (param.abspos) {
      mx = param.abspos.x;
      my = param.abspos.y;
    } else {
      mx = param.containerWidth * param.position.mx;
      my = param.containerHeight * param.position.my;
    }
    var coordinates = {};
    if (param.position) {
      var heightRatio = param.containerHeight / rawPath.height * param.yScaleFactor;
      var widthRatio = param.containerWidth / rawPath.width * param.xScaleFactor;
      for (var heightIndex = 0; heightIndex < rawPath.heightElements.length; heightIndex++) {
        coordinates["y" + heightIndex] = rawPath.heightElements[heightIndex] * heightRatio;
      }
      for (var widthIndex = 0; widthIndex < rawPath.widthElements.length; widthIndex++) {
        coordinates["x" + widthIndex] = rawPath.widthElements[widthIndex] * widthRatio;
      }
    }
    var path = format(
      rawPath.d,
      {
        mx,
        my,
        e: coordinates
      }
    );
    return path;
  };
}
var tokenRegex = /\{([^{}]+)\}/g;
var objNotationRegex = /(?:(?:^|\.)(.+?)(?=\[|\.|$|\()|\[('|")(.+?)\2\])(\(\))?/g;
function replacer(all2, key, obj) {
  var res = obj;
  key.replace(objNotationRegex, function(all3, name2, quote, quotedName, isFunc) {
    name2 = name2 || quotedName;
    if (res) {
      if (name2 in res) {
        res = res[name2];
      }
      typeof res == "function" && isFunc && (res = res());
    }
  });
  res = (res == null || res == obj ? all2 : res) + "";
  return res;
}
function format(str, obj) {
  return String(str).replace(tokenRegex, function(all2, key) {
    return replacer(all2, key, obj);
  });
}

// node_modules/bpmn-js/lib/draw/index.js
var draw_default = {
  __init__: ["bpmnRenderer"],
  bpmnRenderer: ["type", BpmnRenderer],
  textRenderer: ["type", TextRenderer],
  pathMap: ["type", PathMap]
};

// node_modules/diagram-js/lib/i18n/translate/translate.js
function translate2(template, replacements) {
  replacements = replacements || {};
  return template.replace(/{([^}]+)}/g, function(_5, key) {
    return replacements[key] || "{" + key + "}";
  });
}

// node_modules/diagram-js/lib/i18n/translate/index.js
var translate_default = {
  translate: ["value", translate2]
};

// node_modules/diagram-js/lib/util/Geometry.js
function pointDistance(a6, b4) {
  if (!a6 || !b4) {
    return -1;
  }
  return Math.sqrt(
    Math.pow(a6.x - b4.x, 2) + Math.pow(a6.y - b4.y, 2)
  );
}
function pointsOnLine(p5, q6, r7, accuracy) {
  if (typeof accuracy === "undefined") {
    accuracy = 5;
  }
  if (!p5 || !q6 || !r7) {
    return false;
  }
  var val = (q6.x - p5.x) * (r7.y - p5.y) - (q6.y - p5.y) * (r7.x - p5.x), dist = pointDistance(p5, q6);
  return Math.abs(val / dist) <= accuracy;
}
var ALIGNED_THRESHOLD = 2;
function pointsAligned(a6, b4) {
  var points = Array.from(arguments).flat();
  const axisMap = {
    "x": "v",
    "y": "h"
  };
  for (const [axis, orientation] of Object.entries(axisMap)) {
    if (pointsAlignedOnAxis(axis, points)) {
      return orientation;
    }
  }
  return false;
}
function pointsAlignedOnAxis(axis, points) {
  const referencePoint = points[0];
  return every(points, function(point) {
    return Math.abs(referencePoint[axis] - point[axis]) <= ALIGNED_THRESHOLD;
  });
}
function pointInRect(p5, rect, tolerance) {
  tolerance = tolerance || 0;
  return p5.x > rect.x - tolerance && p5.y > rect.y - tolerance && p5.x < rect.x + rect.width + tolerance && p5.y < rect.y + rect.height + tolerance;
}
function getMidPoint(p5, q6) {
  return {
    x: Math.round(p5.x + (q6.x - p5.x) / 2),
    y: Math.round(p5.y + (q6.y - p5.y) / 2)
  };
}

// node_modules/path-intersection/intersect.js
var p2s = /,?([a-z]),?/gi;
var toFloat = parseFloat;
var math = Math;
var PI = math.PI;
var mmin = math.min;
var mmax = math.max;
var pow = math.pow;
var abs = math.abs;
var pathCommand = /([a-z])[\s,]*((-?\d*\.?\d*(?:e[-+]?\d+)?[\s]*,?[\s]*)+)/ig;
var pathValues = /(-?\d*\.?\d*(?:e[-+]?\d+)?)[\s]*,?[\s]*/ig;
var isArray3 = Array.isArray || function(o5) {
  return o5 instanceof Array;
};
function hasProperty(obj, property) {
  return Object.prototype.hasOwnProperty.call(obj, property);
}
function clone2(obj) {
  if (typeof obj == "function" || Object(obj) !== obj) {
    return obj;
  }
  var res = new obj.constructor();
  for (var key in obj) {
    if (hasProperty(obj, key)) {
      res[key] = clone2(obj[key]);
    }
  }
  return res;
}
function repush(array, item) {
  for (var i7 = 0, ii = array.length; i7 < ii; i7++) if (array[i7] === item) {
    return array.push(array.splice(i7, 1)[0]);
  }
}
function cacher(f6) {
  function newf() {
    var arg = Array.prototype.slice.call(arguments, 0), args = arg.join("\u2400"), cache = newf.cache = newf.cache || {}, count = newf.count = newf.count || [];
    if (hasProperty(cache, args)) {
      repush(count, args);
      return cache[args];
    }
    count.length >= 1e3 && delete cache[count.shift()];
    count.push(args);
    cache[args] = f6(...arguments);
    return cache[args];
  }
  return newf;
}
function parsePathString(pathString) {
  if (!pathString) {
    return null;
  }
  var pth = paths(pathString);
  if (pth.arr) {
    return clone2(pth.arr);
  }
  var paramCounts = { a: 7, c: 6, h: 1, l: 2, m: 2, q: 4, s: 4, t: 2, v: 1, z: 0 }, data = [];
  if (isArray3(pathString) && isArray3(pathString[0])) {
    data = clone2(pathString);
  }
  if (!data.length) {
    String(pathString).replace(pathCommand, function(a6, b4, c5) {
      var params = [], name2 = b4.toLowerCase();
      c5.replace(pathValues, function(a7, b5) {
        b5 && params.push(+b5);
      });
      if (name2 == "m" && params.length > 2) {
        data.push([b4, ...params.splice(0, 2)]);
        name2 = "l";
        b4 = b4 == "m" ? "l" : "L";
      }
      while (params.length >= paramCounts[name2]) {
        data.push([b4, ...params.splice(0, paramCounts[name2])]);
        if (!paramCounts[name2]) {
          break;
        }
      }
    });
  }
  data.toString = paths.toString;
  pth.arr = clone2(data);
  return data;
}
function paths(ps) {
  var p5 = paths.ps = paths.ps || {};
  if (p5[ps]) {
    p5[ps].sleep = 100;
  } else {
    p5[ps] = {
      sleep: 100
    };
  }
  setTimeout(function() {
    for (var key in p5) {
      if (hasProperty(p5, key) && key != ps) {
        p5[key].sleep--;
        !p5[key].sleep && delete p5[key];
      }
    }
  });
  return p5[ps];
}
function rectBBox(x6, y5, width, height) {
  if (arguments.length === 1) {
    y5 = x6.y;
    width = x6.width;
    height = x6.height;
    x6 = x6.x;
  }
  return {
    x: x6,
    y: y5,
    width,
    height,
    x2: x6 + width,
    y2: y5 + height
  };
}
function pathToString() {
  return this.join(",").replace(p2s, "$1");
}
function pathClone(pathArray) {
  var res = clone2(pathArray);
  res.toString = pathToString;
  return res;
}
function findDotsAtSegment(p1x, p1y, c1x, c1y, c2x, c2y, p2x, p2y, t7) {
  var t1 = 1 - t7, t13 = pow(t1, 3), t12 = pow(t1, 2), t22 = t7 * t7, t32 = t22 * t7, x6 = t13 * p1x + t12 * 3 * t7 * c1x + t1 * 3 * t7 * t7 * c2x + t32 * p2x, y5 = t13 * p1y + t12 * 3 * t7 * c1y + t1 * 3 * t7 * t7 * c2y + t32 * p2y;
  return {
    x: fixError(x6),
    y: fixError(y5)
  };
}
function bezierBBox(points) {
  var bbox = curveBBox(...points);
  return rectBBox(
    bbox.x0,
    bbox.y0,
    bbox.x1 - bbox.x0,
    bbox.y1 - bbox.y0
  );
}
function isPointInsideBBox(bbox, x6, y5) {
  return x6 >= bbox.x && x6 <= bbox.x + bbox.width && y5 >= bbox.y && y5 <= bbox.y + bbox.height;
}
function isBBoxIntersect(bbox1, bbox2) {
  bbox1 = rectBBox(bbox1);
  bbox2 = rectBBox(bbox2);
  return isPointInsideBBox(bbox2, bbox1.x, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y) || isPointInsideBBox(bbox2, bbox1.x, bbox1.y2) || isPointInsideBBox(bbox2, bbox1.x2, bbox1.y2) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y) || isPointInsideBBox(bbox1, bbox2.x, bbox2.y2) || isPointInsideBBox(bbox1, bbox2.x2, bbox2.y2) || (bbox1.x < bbox2.x2 && bbox1.x > bbox2.x || bbox2.x < bbox1.x2 && bbox2.x > bbox1.x) && (bbox1.y < bbox2.y2 && bbox1.y > bbox2.y || bbox2.y < bbox1.y2 && bbox2.y > bbox1.y);
}
function base3(t7, p1, p22, p32, p42) {
  var t1 = -3 * p1 + 9 * p22 - 9 * p32 + 3 * p42, t22 = t7 * t1 + 6 * p1 - 12 * p22 + 6 * p32;
  return t7 * t22 - 3 * p1 + 3 * p22;
}
function bezlen(x1, y1, x22, y22, x32, y32, x42, y42, z6) {
  if (z6 == null) {
    z6 = 1;
  }
  z6 = z6 > 1 ? 1 : z6 < 0 ? 0 : z6;
  var z22 = z6 / 2, n4 = 12, Tvalues = [-0.1252, 0.1252, -0.3678, 0.3678, -0.5873, 0.5873, -0.7699, 0.7699, -0.9041, 0.9041, -0.9816, 0.9816], Cvalues = [0.2491, 0.2491, 0.2335, 0.2335, 0.2032, 0.2032, 0.1601, 0.1601, 0.1069, 0.1069, 0.0472, 0.0472], sum = 0;
  for (var i7 = 0; i7 < n4; i7++) {
    var ct = z22 * Tvalues[i7] + z22, xbase = base3(ct, x1, x22, x32, x42), ybase = base3(ct, y1, y22, y32, y42), comb = xbase * xbase + ybase * ybase;
    sum += Cvalues[i7] * math.sqrt(comb);
  }
  return z22 * sum;
}
function intersectLines(x1, y1, x22, y22, x32, y32, x42, y42) {
  if (mmax(x1, x22) < mmin(x32, x42) || mmin(x1, x22) > mmax(x32, x42) || mmax(y1, y22) < mmin(y32, y42) || mmin(y1, y22) > mmax(y32, y42)) {
    return;
  }
  var nx = (x1 * y22 - y1 * x22) * (x32 - x42) - (x1 - x22) * (x32 * y42 - y32 * x42), ny = (x1 * y22 - y1 * x22) * (y32 - y42) - (y1 - y22) * (x32 * y42 - y32 * x42), denominator = (x1 - x22) * (y32 - y42) - (y1 - y22) * (x32 - x42);
  if (!denominator) {
    return;
  }
  var px = fixError(nx / denominator), py = fixError(ny / denominator), px2 = +px.toFixed(2), py2 = +py.toFixed(2);
  if (px2 < +mmin(x1, x22).toFixed(2) || px2 > +mmax(x1, x22).toFixed(2) || px2 < +mmin(x32, x42).toFixed(2) || px2 > +mmax(x32, x42).toFixed(2) || py2 < +mmin(y1, y22).toFixed(2) || py2 > +mmax(y1, y22).toFixed(2) || py2 < +mmin(y32, y42).toFixed(2) || py2 > +mmax(y32, y42).toFixed(2)) {
    return;
  }
  return { x: px, y: py };
}
function fixError(number) {
  return Math.round(number * 1e11) / 1e11;
}
function findBezierIntersections(bez1, bez2, justCount) {
  var bbox1 = bezierBBox(bez1), bbox2 = bezierBBox(bez2);
  if (!isBBoxIntersect(bbox1, bbox2)) {
    return justCount ? 0 : [];
  }
  var l1 = bezlen(...bez1), l22 = bezlen(...bez2), n1 = isLine(bez1) ? 1 : ~~(l1 / 5) || 1, n22 = isLine(bez2) ? 1 : ~~(l22 / 5) || 1, dots1 = [], dots2 = [], xy = {}, res = justCount ? 0 : [];
  for (var i7 = 0; i7 < n1 + 1; i7++) {
    var p5 = findDotsAtSegment(...bez1, i7 / n1);
    dots1.push({ x: p5.x, y: p5.y, t: i7 / n1 });
  }
  for (i7 = 0; i7 < n22 + 1; i7++) {
    p5 = findDotsAtSegment(...bez2, i7 / n22);
    dots2.push({ x: p5.x, y: p5.y, t: i7 / n22 });
  }
  for (i7 = 0; i7 < n1; i7++) {
    for (var j6 = 0; j6 < n22; j6++) {
      var di = dots1[i7], di1 = dots1[i7 + 1], dj = dots2[j6], dj1 = dots2[j6 + 1], ci = abs(di1.x - di.x) < 0.01 ? "y" : "x", cj = abs(dj1.x - dj.x) < 0.01 ? "y" : "x", is7 = intersectLines(di.x, di.y, di1.x, di1.y, dj.x, dj.y, dj1.x, dj1.y), key;
      if (is7) {
        key = is7.x.toFixed(9) + "#" + is7.y.toFixed(9);
        if (xy[key]) {
          continue;
        }
        xy[key] = true;
        var t1 = di.t + abs((is7[ci] - di[ci]) / (di1[ci] - di[ci])) * (di1.t - di.t), t22 = dj.t + abs((is7[cj] - dj[cj]) / (dj1[cj] - dj[cj])) * (dj1.t - dj.t);
        if (t1 >= 0 && t1 <= 1 && t22 >= 0 && t22 <= 1) {
          if (justCount) {
            res++;
          } else {
            res.push({
              x: is7.x,
              y: is7.y,
              t1,
              t2: t22
            });
          }
        }
      }
    }
  }
  return res;
}
function findPathIntersections(path1, path2, justCount) {
  path1 = pathToCurve(path1);
  path2 = pathToCurve(path2);
  var x1, y1, x22, y22, x1m, y1m, x2m, y2m, bez1, bez2, res = justCount ? 0 : [];
  for (var i7 = 0, ii = path1.length; i7 < ii; i7++) {
    var pi = path1[i7];
    if (pi[0] == "M") {
      x1 = x1m = pi[1];
      y1 = y1m = pi[2];
    } else {
      if (pi[0] == "C") {
        bez1 = [x1, y1, ...pi.slice(1)];
        x1 = bez1[6];
        y1 = bez1[7];
      } else {
        bez1 = [x1, y1, x1, y1, x1m, y1m, x1m, y1m];
        x1 = x1m;
        y1 = y1m;
      }
      for (var j6 = 0, jj = path2.length; j6 < jj; j6++) {
        var pj = path2[j6];
        if (pj[0] == "M") {
          x22 = x2m = pj[1];
          y22 = y2m = pj[2];
        } else {
          if (pj[0] == "C") {
            bez2 = [x22, y22, ...pj.slice(1)];
            x22 = bez2[6];
            y22 = bez2[7];
          } else {
            bez2 = [x22, y22, x22, y22, x2m, y2m, x2m, y2m];
            x22 = x2m;
            y22 = y2m;
          }
          var intr = findBezierIntersections(bez1, bez2, justCount);
          if (justCount) {
            res += intr;
          } else {
            for (var k6 = 0, kk = intr.length; k6 < kk; k6++) {
              intr[k6].segment1 = i7;
              intr[k6].segment2 = j6;
              intr[k6].bez1 = bez1;
              intr[k6].bez2 = bez2;
            }
            res = res.concat(intr);
          }
        }
      }
    }
  }
  return res;
}
function pathToAbsolute(pathArray) {
  var pth = paths(pathArray);
  if (pth.abs) {
    return pathClone(pth.abs);
  }
  if (!isArray3(pathArray) || !isArray3(pathArray && pathArray[0])) {
    pathArray = parsePathString(pathArray);
  }
  if (!pathArray || !pathArray.length) {
    return [["M", 0, 0]];
  }
  var res = [], x6 = 0, y5 = 0, mx = 0, my = 0, start = 0, pa0;
  if (pathArray[0][0] == "M") {
    x6 = +pathArray[0][1];
    y5 = +pathArray[0][2];
    mx = x6;
    my = y5;
    start++;
    res[0] = ["M", x6, y5];
  }
  for (var r7, pa, i7 = start, ii = pathArray.length; i7 < ii; i7++) {
    res.push(r7 = []);
    pa = pathArray[i7];
    pa0 = pa[0];
    if (pa0 != pa0.toUpperCase()) {
      r7[0] = pa0.toUpperCase();
      switch (r7[0]) {
        case "A":
          r7[1] = pa[1];
          r7[2] = pa[2];
          r7[3] = pa[3];
          r7[4] = pa[4];
          r7[5] = pa[5];
          r7[6] = +pa[6] + x6;
          r7[7] = +pa[7] + y5;
          break;
        case "V":
          r7[1] = +pa[1] + y5;
          break;
        case "H":
          r7[1] = +pa[1] + x6;
          break;
        case "M":
          mx = +pa[1] + x6;
          my = +pa[2] + y5;
        default:
          for (var j6 = 1, jj = pa.length; j6 < jj; j6++) {
            r7[j6] = +pa[j6] + (j6 % 2 ? x6 : y5);
          }
      }
    } else {
      for (var k6 = 0, kk = pa.length; k6 < kk; k6++) {
        r7[k6] = pa[k6];
      }
    }
    pa0 = pa0.toUpperCase();
    switch (r7[0]) {
      case "Z":
        x6 = +mx;
        y5 = +my;
        break;
      case "H":
        x6 = r7[1];
        break;
      case "V":
        y5 = r7[1];
        break;
      case "M":
        mx = r7[r7.length - 2];
        my = r7[r7.length - 1];
      default:
        x6 = r7[r7.length - 2];
        y5 = r7[r7.length - 1];
    }
  }
  res.toString = pathToString;
  pth.abs = pathClone(res);
  return res;
}
function isLine(bez) {
  return bez[0] === bez[2] && bez[1] === bez[3] && bez[4] === bez[6] && bez[5] === bez[7];
}
function lineToCurve(x1, y1, x22, y22) {
  return [
    x1,
    y1,
    x22,
    y22,
    x22,
    y22
  ];
}
function qubicToCurve(x1, y1, ax, ay, x22, y22) {
  var _13 = 1 / 3, _23 = 2 / 3;
  return [
    _13 * x1 + _23 * ax,
    _13 * y1 + _23 * ay,
    _13 * x22 + _23 * ax,
    _13 * y22 + _23 * ay,
    x22,
    y22
  ];
}
function arcToCurve(x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x22, y22, recursive) {
  var _120 = PI * 120 / 180, rad = PI / 180 * (+angle || 0), res = [], xy, rotate3 = cacher(function(x7, y6, rad2) {
    var X2 = x7 * math.cos(rad2) - y6 * math.sin(rad2), Y2 = x7 * math.sin(rad2) + y6 * math.cos(rad2);
    return { x: X2, y: Y2 };
  });
  if (!recursive) {
    xy = rotate3(x1, y1, -rad);
    x1 = xy.x;
    y1 = xy.y;
    xy = rotate3(x22, y22, -rad);
    x22 = xy.x;
    y22 = xy.y;
    var x6 = (x1 - x22) / 2, y5 = (y1 - y22) / 2;
    var h5 = x6 * x6 / (rx * rx) + y5 * y5 / (ry * ry);
    if (h5 > 1) {
      h5 = math.sqrt(h5);
      rx = h5 * rx;
      ry = h5 * ry;
    }
    var rx2 = rx * rx, ry2 = ry * ry, k6 = (large_arc_flag == sweep_flag ? -1 : 1) * math.sqrt(abs((rx2 * ry2 - rx2 * y5 * y5 - ry2 * x6 * x6) / (rx2 * y5 * y5 + ry2 * x6 * x6))), cx = k6 * rx * y5 / ry + (x1 + x22) / 2, cy = k6 * -ry * x6 / rx + (y1 + y22) / 2, f1 = math.asin(((y1 - cy) / ry).toFixed(9)), f22 = math.asin(((y22 - cy) / ry).toFixed(9));
    f1 = x1 < cx ? PI - f1 : f1;
    f22 = x22 < cx ? PI - f22 : f22;
    f1 < 0 && (f1 = PI * 2 + f1);
    f22 < 0 && (f22 = PI * 2 + f22);
    if (sweep_flag && f1 > f22) {
      f1 = f1 - PI * 2;
    }
    if (!sweep_flag && f22 > f1) {
      f22 = f22 - PI * 2;
    }
  } else {
    f1 = recursive[0];
    f22 = recursive[1];
    cx = recursive[2];
    cy = recursive[3];
  }
  var df = f22 - f1;
  if (abs(df) > _120) {
    var f2old = f22, x2old = x22, y2old = y22;
    f22 = f1 + _120 * (sweep_flag && f22 > f1 ? 1 : -1);
    x22 = cx + rx * math.cos(f22);
    y22 = cy + ry * math.sin(f22);
    res = arcToCurve(x22, y22, rx, ry, angle, 0, sweep_flag, x2old, y2old, [f22, f2old, cx, cy]);
  }
  df = f22 - f1;
  var c1 = math.cos(f1), s1 = math.sin(f1), c22 = math.cos(f22), s22 = math.sin(f22), t7 = math.tan(df / 4), hx = 4 / 3 * rx * t7, hy = 4 / 3 * ry * t7, m1 = [x1, y1], m22 = [x1 + hx * s1, y1 - hy * c1], m32 = [x22 + hx * s22, y22 - hy * c22], m42 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return [m22, m32, m42].concat(res);
  } else {
    res = [m22, m32, m42].concat(res).join().split(",");
    var newres = [];
    for (var i7 = 0, ii = res.length; i7 < ii; i7++) {
      newres[i7] = i7 % 2 ? rotate3(res[i7 - 1], res[i7], rad).y : rotate3(res[i7], res[i7 + 1], rad).x;
    }
    return newres;
  }
}
function curveBBox(x0, y0, x1, y1, x22, y22, x32, y32) {
  var tvalues = [], bounds = [[], []], a6, b4, c5, t7, t1, t22, b2ac, sqrtb2ac;
  for (var i7 = 0; i7 < 2; ++i7) {
    if (i7 == 0) {
      b4 = 6 * x0 - 12 * x1 + 6 * x22;
      a6 = -3 * x0 + 9 * x1 - 9 * x22 + 3 * x32;
      c5 = 3 * x1 - 3 * x0;
    } else {
      b4 = 6 * y0 - 12 * y1 + 6 * y22;
      a6 = -3 * y0 + 9 * y1 - 9 * y22 + 3 * y32;
      c5 = 3 * y1 - 3 * y0;
    }
    if (abs(a6) < 1e-12) {
      if (abs(b4) < 1e-12) {
        continue;
      }
      t7 = -c5 / b4;
      if (0 < t7 && t7 < 1) {
        tvalues.push(t7);
      }
      continue;
    }
    b2ac = b4 * b4 - 4 * c5 * a6;
    sqrtb2ac = math.sqrt(b2ac);
    if (b2ac < 0) {
      continue;
    }
    t1 = (-b4 + sqrtb2ac) / (2 * a6);
    if (0 < t1 && t1 < 1) {
      tvalues.push(t1);
    }
    t22 = (-b4 - sqrtb2ac) / (2 * a6);
    if (0 < t22 && t22 < 1) {
      tvalues.push(t22);
    }
  }
  var j6 = tvalues.length, jlen = j6, mt;
  while (j6--) {
    t7 = tvalues[j6];
    mt = 1 - t7;
    bounds[0][j6] = mt * mt * mt * x0 + 3 * mt * mt * t7 * x1 + 3 * mt * t7 * t7 * x22 + t7 * t7 * t7 * x32;
    bounds[1][j6] = mt * mt * mt * y0 + 3 * mt * mt * t7 * y1 + 3 * mt * t7 * t7 * y22 + t7 * t7 * t7 * y32;
  }
  bounds[0][jlen] = x0;
  bounds[1][jlen] = y0;
  bounds[0][jlen + 1] = x32;
  bounds[1][jlen + 1] = y32;
  bounds[0].length = bounds[1].length = jlen + 2;
  return {
    x0: mmin(...bounds[0]),
    y0: mmin(...bounds[1]),
    x1: mmax(...bounds[0]),
    y1: mmax(...bounds[1])
  };
}
function pathToCurve(path) {
  var pth = paths(path);
  if (pth.curve) {
    return pathClone(pth.curve);
  }
  var curvedPath = pathToAbsolute(path), attrs = { x: 0, y: 0, bx: 0, by: 0, X: 0, Y: 0, qx: null, qy: null }, processPath = function(path2, d5, pathCommand3) {
    var nx, ny;
    if (!path2) {
      return ["C", d5.x, d5.y, d5.x, d5.y, d5.x, d5.y];
    }
    !(path2[0] in { T: 1, Q: 1 }) && (d5.qx = d5.qy = null);
    switch (path2[0]) {
      case "M":
        d5.X = path2[1];
        d5.Y = path2[2];
        break;
      case "A":
        path2 = ["C", ...arcToCurve(d5.x, d5.y, ...path2.slice(1))];
        break;
      case "S":
        if (pathCommand3 == "C" || pathCommand3 == "S") {
          nx = d5.x * 2 - d5.bx;
          ny = d5.y * 2 - d5.by;
        } else {
          nx = d5.x;
          ny = d5.y;
        }
        path2 = ["C", nx, ny, ...path2.slice(1)];
        break;
      case "T":
        if (pathCommand3 == "Q" || pathCommand3 == "T") {
          d5.qx = d5.x * 2 - d5.qx;
          d5.qy = d5.y * 2 - d5.qy;
        } else {
          d5.qx = d5.x;
          d5.qy = d5.y;
        }
        path2 = ["C", ...qubicToCurve(d5.x, d5.y, d5.qx, d5.qy, path2[1], path2[2])];
        break;
      case "Q":
        d5.qx = path2[1];
        d5.qy = path2[2];
        path2 = ["C", ...qubicToCurve(d5.x, d5.y, path2[1], path2[2], path2[3], path2[4])];
        break;
      case "L":
        path2 = ["C", ...lineToCurve(d5.x, d5.y, path2[1], path2[2])];
        break;
      case "H":
        path2 = ["C", ...lineToCurve(d5.x, d5.y, path2[1], d5.y)];
        break;
      case "V":
        path2 = ["C", ...lineToCurve(d5.x, d5.y, d5.x, path2[1])];
        break;
      case "Z":
        path2 = ["C", ...lineToCurve(d5.x, d5.y, d5.X, d5.Y)];
        break;
    }
    return path2;
  }, fixArc = function(pp, i8) {
    if (pp[i8].length > 7) {
      pp[i8].shift();
      var pi = pp[i8];
      while (pi.length) {
        pathCommands[i8] = "A";
        pp.splice(i8++, 0, ["C", ...pi.splice(0, 6)]);
      }
      pp.splice(i8, 1);
      ii = curvedPath.length;
    }
  }, pathCommands = [], pfirst = "", pathCommand2 = "";
  for (var i7 = 0, ii = curvedPath.length; i7 < ii; i7++) {
    curvedPath[i7] && (pfirst = curvedPath[i7][0]);
    if (pfirst != "C") {
      pathCommands[i7] = pfirst;
      i7 && (pathCommand2 = pathCommands[i7 - 1]);
    }
    curvedPath[i7] = processPath(curvedPath[i7], attrs, pathCommand2);
    if (pathCommands[i7] != "A" && pfirst == "C") pathCommands[i7] = "C";
    fixArc(curvedPath, i7);
    var seg = curvedPath[i7], seglen = seg.length;
    attrs.x = seg[seglen - 2];
    attrs.y = seg[seglen - 1];
    attrs.bx = toFloat(seg[seglen - 4]) || attrs.x;
    attrs.by = toFloat(seg[seglen - 3]) || attrs.y;
  }
  pth.curve = pathClone(curvedPath);
  return curvedPath;
}

// node_modules/diagram-js/lib/layout/LayoutUtil.js
function roundBounds(bounds) {
  return {
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  };
}
function roundPoint(point) {
  return {
    x: Math.round(point.x),
    y: Math.round(point.y)
  };
}
function asTRBL(bounds) {
  return {
    top: bounds.y,
    right: bounds.x + (bounds.width || 0),
    bottom: bounds.y + (bounds.height || 0),
    left: bounds.x
  };
}
function asBounds(trbl) {
  return {
    x: trbl.left,
    y: trbl.top,
    width: trbl.right - trbl.left,
    height: trbl.bottom - trbl.top
  };
}
function getBoundsMid(bounds) {
  return roundPoint({
    x: bounds.x + (bounds.width || 0) / 2,
    y: bounds.y + (bounds.height || 0) / 2
  });
}
function getConnectionMid(connection) {
  var waypoints = connection.waypoints;
  var parts = waypoints.reduce(function(parts2, point, index5) {
    var lastPoint = waypoints[index5 - 1];
    if (lastPoint) {
      var lastPart = parts2[parts2.length - 1];
      var startLength = lastPart && lastPart.endLength || 0;
      var length2 = distance(lastPoint, point);
      parts2.push({
        start: lastPoint,
        end: point,
        startLength,
        endLength: startLength + length2,
        length: length2
      });
    }
    return parts2;
  }, []);
  var totalLength = parts.reduce(function(length2, part) {
    return length2 + part.length;
  }, 0);
  var midLength = totalLength / 2;
  var i7 = 0;
  var midSegment = parts[i7];
  while (midSegment.endLength < midLength) {
    midSegment = parts[++i7];
  }
  var segmentProgress = (midLength - midSegment.startLength) / midSegment.length;
  var midPoint = {
    x: midSegment.start.x + (midSegment.end.x - midSegment.start.x) * segmentProgress,
    y: midSegment.start.y + (midSegment.end.y - midSegment.start.y) * segmentProgress
  };
  return midPoint;
}
function getMid(element) {
  if (isConnection(element)) {
    return getConnectionMid(element);
  }
  return getBoundsMid(element);
}
function getOrientation(rect, reference, padding) {
  padding = padding || 0;
  if (!isObject(padding)) {
    padding = { x: padding, y: padding };
  }
  var rectOrientation = asTRBL(rect), referenceOrientation = asTRBL(reference);
  var top = rectOrientation.bottom + padding.y <= referenceOrientation.top, right = rectOrientation.left - padding.x >= referenceOrientation.right, bottom = rectOrientation.top - padding.y >= referenceOrientation.bottom, left = rectOrientation.right + padding.x <= referenceOrientation.left;
  var vertical = top ? "top" : bottom ? "bottom" : null, horizontal = left ? "left" : right ? "right" : null;
  if (horizontal && vertical) {
    return vertical + "-" + horizontal;
  } else {
    return horizontal || vertical || "intersect";
  }
}
function getElementLineIntersection(elementPath, linePath2, cropStart) {
  var intersections = getIntersections(elementPath, linePath2);
  if (intersections.length === 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length === 2 && pointDistance(intersections[0], intersections[1]) < 1) {
    return roundPoint(intersections[0]);
  } else if (intersections.length > 1) {
    intersections = sortBy(intersections, function(i7) {
      var distance4 = Math.floor(i7.t2 * 100) || 1;
      distance4 = 100 - distance4;
      distance4 = (distance4 < 10 ? "0" : "") + distance4;
      return i7.segment2 + "#" + distance4;
    });
    return roundPoint(intersections[cropStart ? 0 : intersections.length - 1]);
  }
  return null;
}
function getIntersections(a6, b4) {
  return findPathIntersections(a6, b4);
}
function filterRedundantWaypoints(waypoints) {
  waypoints = waypoints.slice();
  var idx = 0, point, previousPoint, nextPoint;
  while (waypoints[idx]) {
    point = waypoints[idx];
    previousPoint = waypoints[idx - 1];
    nextPoint = waypoints[idx + 1];
    if (pointDistance(point, nextPoint) === 0 || pointsOnLine(previousPoint, nextPoint, point)) {
      waypoints.splice(idx, 1);
    } else {
      idx++;
    }
  }
  return waypoints;
}
function distance(a6, b4) {
  return Math.sqrt(Math.pow(a6.x - b4.x, 2) + Math.pow(a6.y - b4.y, 2));
}

// node_modules/bpmn-js/lib/import/Util.js
function elementToString(e8) {
  if (!e8) {
    return "<null>";
  }
  return "<" + e8.$type + (e8.id ? ' id="' + e8.id : "") + '" />';
}

// node_modules/bpmn-js/lib/import/BpmnImporter.js
function elementData(semantic, di, attrs) {
  return assign({
    id: semantic.id,
    type: semantic.$type,
    businessObject: semantic,
    di
  }, attrs);
}
function getWaypoints(di, source, target) {
  var waypoints = di.waypoint;
  if (!waypoints || waypoints.length < 2) {
    return [getMid(source), getMid(target)];
  }
  return waypoints.map(function(p5) {
    return { x: p5.x, y: p5.y };
  });
}
function notYetDrawn(semantic, refSemantic, property) {
  return new Error(
    `element ${elementToString(refSemantic)} referenced by ${elementToString(semantic)}#${property} not yet drawn`
  );
}
function BpmnImporter(eventBus, canvas, elementFactory, elementRegistry, textRenderer) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementFactory = elementFactory;
  this._elementRegistry = elementRegistry;
  this._textRenderer = textRenderer;
}
BpmnImporter.$inject = [
  "eventBus",
  "canvas",
  "elementFactory",
  "elementRegistry",
  "textRenderer"
];
BpmnImporter.prototype.add = function(semantic, di, parentElement) {
  var element, hidden;
  var parentIndex;
  if (is(di, "bpmndi:BPMNPlane")) {
    var attrs = is(semantic, "bpmn:SubProcess") ? { id: semantic.id + "_plane" } : {};
    element = this._elementFactory.createRoot(elementData(semantic, di, attrs));
    this._canvas.addRootElement(element);
  } else if (is(di, "bpmndi:BPMNShape")) {
    var collapsed = !isExpanded(semantic, di), isFrame = isFrameElement(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    var bounds = di.bounds;
    element = this._elementFactory.createShape(elementData(semantic, di, {
      collapsed,
      hidden,
      x: Math.round(bounds.x),
      y: Math.round(bounds.y),
      width: Math.round(bounds.width),
      height: Math.round(bounds.height),
      isFrame
    }));
    if (is(semantic, "bpmn:BoundaryEvent")) {
      this._attachBoundary(semantic, element);
    }
    if (is(semantic, "bpmn:Lane")) {
      parentIndex = 0;
    }
    if (is(semantic, "bpmn:DataStoreReference")) {
      if (!isPointInsideBBox2(parentElement, getMid(bounds))) {
        parentElement = this._canvas.findRoot(parentElement);
      }
    }
    this._canvas.addShape(element, parentElement, parentIndex);
  } else if (is(di, "bpmndi:BPMNEdge")) {
    var source = this._getSource(semantic), target = this._getTarget(semantic);
    hidden = parentElement && (parentElement.hidden || parentElement.collapsed);
    element = this._elementFactory.createConnection(elementData(semantic, di, {
      hidden,
      source,
      target,
      waypoints: getWaypoints(di, source, target)
    }));
    if (is(semantic, "bpmn:DataAssociation")) {
      parentElement = this._canvas.findRoot(parentElement);
    }
    this._canvas.addConnection(element, parentElement, parentIndex);
  } else {
    throw new Error(
      `unknown di ${elementToString(di)} for element ${elementToString(semantic)}`
    );
  }
  if (isLabelExternal(semantic) && getLabel(element)) {
    this.addLabel(semantic, di, element);
  }
  this._eventBus.fire("bpmnElement.added", { element });
  return element;
};
BpmnImporter.prototype._attachBoundary = function(boundarySemantic, boundaryElement) {
  var hostSemantic = boundarySemantic.attachedToRef;
  if (!hostSemantic) {
    throw new Error(
      `missing ${elementToString(boundarySemantic)}#attachedToRef`
    );
  }
  var host = this._elementRegistry.get(hostSemantic.id), attachers = host && host.attachers;
  if (!host) {
    throw notYetDrawn(boundarySemantic, hostSemantic, "attachedToRef");
  }
  boundaryElement.host = host;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  if (attachers.indexOf(boundaryElement) === -1) {
    attachers.push(boundaryElement);
  }
};
BpmnImporter.prototype.addLabel = function(semantic, di, element) {
  var bounds, text, label;
  bounds = getExternalLabelBounds(di, element);
  text = getLabel(element);
  if (text) {
    bounds = this._textRenderer.getExternalLabelBounds(bounds, text);
  }
  label = this._elementFactory.createLabel(elementData(semantic, di, {
    id: semantic.id + "_label",
    labelTarget: element,
    type: "label",
    hidden: element.hidden || !getLabel(element),
    x: Math.round(bounds.x),
    y: Math.round(bounds.y),
    width: Math.round(bounds.width),
    height: Math.round(bounds.height)
  }));
  return this._canvas.addShape(label, element.parent);
};
BpmnImporter.prototype._getConnectedElement = function(semantic, side) {
  var element, refSemantic, type = semantic.$type;
  refSemantic = semantic[side + "Ref"];
  if (side === "source" && type === "bpmn:DataInputAssociation") {
    refSemantic = refSemantic && refSemantic[0];
  }
  if (side === "source" && type === "bpmn:DataOutputAssociation" || side === "target" && type === "bpmn:DataInputAssociation") {
    refSemantic = semantic.$parent;
  }
  element = refSemantic && this._getElement(refSemantic);
  if (element) {
    return element;
  }
  if (refSemantic) {
    throw notYetDrawn(semantic, refSemantic, side + "Ref");
  } else {
    throw new Error(
      `${elementToString(semantic)}#${side} Ref not specified`
    );
  }
};
BpmnImporter.prototype._getSource = function(semantic) {
  return this._getConnectedElement(semantic, "source");
};
BpmnImporter.prototype._getTarget = function(semantic) {
  return this._getConnectedElement(semantic, "target");
};
BpmnImporter.prototype._getElement = function(semantic) {
  return this._elementRegistry.get(semantic.id);
};
function isPointInsideBBox2(bbox, point) {
  var x6 = point.x, y5 = point.y;
  return x6 >= bbox.x && x6 <= bbox.x + bbox.width && y5 >= bbox.y && y5 <= bbox.y + bbox.height;
}
function isFrameElement(semantic) {
  return is(semantic, "bpmn:Group");
}

// node_modules/bpmn-js/lib/import/index.js
var import_default = {
  __depends__: [
    translate_default
  ],
  bpmnImporter: ["type", BpmnImporter]
};

// node_modules/bpmn-js/lib/core/index.js
var core_default = {
  __depends__: [
    draw_default,
    import_default
  ]
};

// node_modules/diagram-js/lib/util/Elements.js
function getParents(elements) {
  return filter(elements, function(element) {
    return !find(elements, function(e8) {
      return e8 !== element && getParent(element, e8);
    });
  });
}
function getParent(element, parent) {
  if (!parent) {
    return;
  }
  if (element === parent) {
    return parent;
  }
  if (!element.parent) {
    return;
  }
  return getParent(element.parent, parent);
}
function add(elements, element, unique) {
  var canAdd = !unique || elements.indexOf(element) === -1;
  if (canAdd) {
    elements.push(element);
  }
  return canAdd;
}
function eachElement(elements, fn2, depth) {
  depth = depth || 0;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(s5, i7) {
    var filter2 = fn2(s5, i7, depth);
    if (isArray(filter2) && filter2.length) {
      eachElement(filter2, fn2, depth + 1);
    }
  });
}
function selfAndChildren(elements, unique, maxDepth) {
  var result = [], processedChildren = [];
  eachElement(elements, function(element, i7, depth) {
    add(result, element, unique);
    var children = element.children;
    if (maxDepth === -1 || depth < maxDepth) {
      if (children && add(processedChildren, children, unique)) {
        return children;
      }
    }
  });
  return result;
}
function selfAndAllChildren(elements, allowDuplicates) {
  return selfAndChildren(elements, !allowDuplicates, -1);
}
function getClosure(elements, isTopLevel, closure) {
  if (isUndefined(isTopLevel)) {
    isTopLevel = true;
  }
  if (isObject(isTopLevel)) {
    closure = isTopLevel;
    isTopLevel = true;
  }
  closure = closure || {};
  var allShapes = copyObject(closure.allShapes), allConnections = copyObject(closure.allConnections), enclosedElements = copyObject(closure.enclosedElements), enclosedConnections = copyObject(closure.enclosedConnections);
  var topLevel = copyObject(
    closure.topLevel,
    isTopLevel && groupBy(elements, function(e8) {
      return e8.id;
    })
  );
  function handleConnection(c5) {
    if (topLevel[c5.source.id] && topLevel[c5.target.id]) {
      topLevel[c5.id] = [c5];
    }
    if (allShapes[c5.source.id] && allShapes[c5.target.id]) {
      enclosedConnections[c5.id] = enclosedElements[c5.id] = c5;
    }
    allConnections[c5.id] = c5;
  }
  function handleElement(element) {
    enclosedElements[element.id] = element;
    if (element.waypoints) {
      enclosedConnections[element.id] = allConnections[element.id] = element;
    } else {
      allShapes[element.id] = element;
      forEach(element.incoming, handleConnection);
      forEach(element.outgoing, handleConnection);
      return element.children;
    }
  }
  eachElement(elements, handleElement);
  return {
    allShapes,
    allConnections,
    topLevel,
    enclosedConnections,
    enclosedElements
  };
}
function getBBox(elements, stopRecursion) {
  stopRecursion = !!stopRecursion;
  if (!isArray(elements)) {
    elements = [elements];
  }
  var minX, minY, maxX, maxY;
  forEach(elements, function(element) {
    var bbox = element;
    if (element.waypoints && !stopRecursion) {
      bbox = getBBox(element.waypoints, true);
    }
    var x6 = bbox.x, y5 = bbox.y, height = bbox.height || 0, width = bbox.width || 0;
    if (x6 < minX || minX === void 0) {
      minX = x6;
    }
    if (y5 < minY || minY === void 0) {
      minY = y5;
    }
    if (x6 + width > maxX || maxX === void 0) {
      maxX = x6 + width;
    }
    if (y5 + height > maxY || maxY === void 0) {
      maxY = y5 + height;
    }
  });
  return {
    x: minX,
    y: minY,
    height: maxY - minY,
    width: maxX - minX
  };
}
function getEnclosedElements(elements, bbox) {
  var filteredElements = {};
  forEach(elements, function(element) {
    var e8 = element;
    if (e8.waypoints) {
      e8 = getBBox(e8);
    }
    if (!isNumber(bbox.y) && e8.x > bbox.x) {
      filteredElements[element.id] = element;
    }
    if (!isNumber(bbox.x) && e8.y > bbox.y) {
      filteredElements[element.id] = element;
    }
    if (e8.x > bbox.x && e8.y > bbox.y) {
      if (isNumber(bbox.width) && isNumber(bbox.height) && e8.width + e8.x < bbox.width + bbox.x && e8.height + e8.y < bbox.height + bbox.y) {
        filteredElements[element.id] = element;
      } else if (!isNumber(bbox.width) || !isNumber(bbox.height)) {
        filteredElements[element.id] = element;
      }
    }
  });
  return filteredElements;
}
function getType(element) {
  if ("waypoints" in element) {
    return "connection";
  }
  if ("x" in element) {
    return "shape";
  }
  return "root";
}
function isFrameElement2(element) {
  return !!(element && element.isFrame);
}
function copyObject(src1, src2) {
  return assign({}, src1 || {}, src2 || {});
}

// node_modules/diagram-js/lib/util/IdGenerator.js
function IdGenerator(prefix3) {
  this._counter = 0;
  this._prefix = (prefix3 ? prefix3 + "-" : "") + Math.floor(Math.random() * 1e9) + "-";
}
IdGenerator.prototype.next = function() {
  return this._prefix + ++this._counter;
};

// node_modules/diagram-js/lib/features/overlays/Overlays.js
var ids = new IdGenerator("ov");
var LOW_PRIORITY = 500;
function Overlays(config, eventBus, canvas, elementRegistry) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._ids = ids;
  this._overlayDefaults = assign({
    // no show constraints
    show: null,
    // always scale
    scale: true
  }, config && config.defaults);
  this._overlays = {};
  this._overlayContainers = [];
  this._overlayRoot = createRoot(canvas.getContainer());
  this._init();
}
Overlays.$inject = [
  "config.overlays",
  "eventBus",
  "canvas",
  "elementRegistry"
];
Overlays.prototype.get = function(search2) {
  if (isString(search2)) {
    search2 = { id: search2 };
  }
  if (isString(search2.element)) {
    search2.element = this._elementRegistry.get(search2.element);
  }
  if (search2.element) {
    var container = this._getOverlayContainer(search2.element, true);
    if (container) {
      return search2.type ? filter(container.overlays, matchPattern({ type: search2.type })) : container.overlays.slice();
    } else {
      return [];
    }
  } else if (search2.type) {
    return filter(this._overlays, matchPattern({ type: search2.type }));
  } else {
    return search2.id ? this._overlays[search2.id] : null;
  }
};
Overlays.prototype.add = function(element, type, overlay) {
  if (isObject(type)) {
    overlay = type;
    type = null;
  }
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  if (!overlay.position) {
    throw new Error("must specifiy overlay position");
  }
  if (!overlay.html) {
    throw new Error("must specifiy overlay html");
  }
  if (!element) {
    throw new Error("invalid element specified");
  }
  var id = this._ids.next();
  overlay = assign({}, this._overlayDefaults, overlay, {
    id,
    type,
    element,
    html: overlay.html
  });
  this._addOverlay(overlay);
  return id;
};
Overlays.prototype.remove = function(filter2) {
  var overlays = this.get(filter2) || [];
  if (!isArray(overlays)) {
    overlays = [overlays];
  }
  var self2 = this;
  forEach(overlays, function(overlay) {
    var container = self2._getOverlayContainer(overlay.element, true);
    if (overlay) {
      remove2(overlay.html);
      remove2(overlay.htmlContainer);
      delete overlay.htmlContainer;
      delete overlay.element;
      delete self2._overlays[overlay.id];
    }
    if (container) {
      var idx = container.overlays.indexOf(overlay);
      if (idx !== -1) {
        container.overlays.splice(idx, 1);
      }
    }
  });
};
Overlays.prototype.isShown = function() {
  return this._overlayRoot.style.display !== "none";
};
Overlays.prototype.show = function() {
  setVisible(this._overlayRoot);
};
Overlays.prototype.hide = function() {
  setVisible(this._overlayRoot, false);
};
Overlays.prototype.clear = function() {
  this._overlays = {};
  this._overlayContainers = [];
  clear2(this._overlayRoot);
};
Overlays.prototype._updateOverlayContainer = function(container) {
  var element = container.element, html = container.html;
  var x6 = element.x, y5 = element.y;
  if (element.waypoints) {
    var bbox = getBBox(element);
    x6 = bbox.x;
    y5 = bbox.y;
  }
  setPosition(html, x6, y5);
  attr2(container.html, "data-container-id", element.id);
};
Overlays.prototype._updateOverlay = function(overlay) {
  var position = overlay.position, htmlContainer = overlay.htmlContainer, element = overlay.element;
  var left = position.left, top = position.top;
  if (position.right !== void 0) {
    var width;
    if (element.waypoints) {
      width = getBBox(element).width;
    } else {
      width = element.width;
    }
    left = position.right * -1 + width;
  }
  if (position.bottom !== void 0) {
    var height;
    if (element.waypoints) {
      height = getBBox(element).height;
    } else {
      height = element.height;
    }
    top = position.bottom * -1 + height;
  }
  setPosition(htmlContainer, left || 0, top || 0);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._createOverlayContainer = function(element) {
  var html = domify$1('<div class="djs-overlays" />');
  assign2(html, { position: "absolute" });
  this._overlayRoot.appendChild(html);
  var container = {
    html,
    element,
    overlays: []
  };
  this._updateOverlayContainer(container);
  this._overlayContainers.push(container);
  return container;
};
Overlays.prototype._updateRoot = function(viewbox) {
  var scale = viewbox.scale || 1;
  var matrix = "matrix(" + [
    scale,
    0,
    0,
    scale,
    -1 * viewbox.x * scale,
    -1 * viewbox.y * scale
  ].join(",") + ")";
  setTransform(this._overlayRoot, matrix);
};
Overlays.prototype._getOverlayContainer = function(element, raw) {
  var container = find(this._overlayContainers, function(c5) {
    return c5.element === element;
  });
  if (!container && !raw) {
    return this._createOverlayContainer(element);
  }
  return container;
};
Overlays.prototype._addOverlay = function(overlay) {
  var id = overlay.id, element = overlay.element, html = overlay.html, htmlContainer, overlayContainer;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString(html)) {
    html = domify$1(html);
  }
  overlayContainer = this._getOverlayContainer(element);
  htmlContainer = domify$1('<div class="djs-overlay" data-overlay-id="' + id + '">');
  assign2(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (overlay.type) {
    classes2(htmlContainer).add("djs-overlay-" + overlay.type);
  }
  var elementRoot = this._canvas.findRoot(element);
  var activeRoot = this._canvas.getRootElement();
  setVisible(htmlContainer, elementRoot === activeRoot);
  overlay.htmlContainer = htmlContainer;
  overlayContainer.overlays.push(overlay);
  overlayContainer.html.appendChild(htmlContainer);
  this._overlays[id] = overlay;
  this._updateOverlay(overlay);
  this._updateOverlayVisibilty(overlay, this._canvas.viewbox());
};
Overlays.prototype._updateOverlayVisibilty = function(overlay, viewbox) {
  var show = overlay.show, rootElement = this._canvas.findRoot(overlay.element), minZoom = show && show.minZoom, maxZoom = show && show.maxZoom, htmlContainer = overlay.htmlContainer, activeRootElement = this._canvas.getRootElement(), visible = true;
  if (rootElement !== activeRootElement) {
    visible = false;
  } else if (show) {
    if (isDefined(minZoom) && minZoom > viewbox.scale || isDefined(maxZoom) && maxZoom < viewbox.scale) {
      visible = false;
    }
  }
  setVisible(htmlContainer, visible);
  this._updateOverlayScale(overlay, viewbox);
};
Overlays.prototype._updateOverlayScale = function(overlay, viewbox) {
  var shouldScale = overlay.scale, minScale, maxScale, htmlContainer = overlay.htmlContainer;
  var scale, transform4 = "";
  if (shouldScale !== true) {
    if (shouldScale === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = shouldScale.min;
      maxScale = shouldScale.max;
    }
    if (isDefined(minScale) && viewbox.scale < minScale) {
      scale = (1 / viewbox.scale || 1) * minScale;
    }
    if (isDefined(maxScale) && viewbox.scale > maxScale) {
      scale = (1 / viewbox.scale || 1) * maxScale;
    }
  }
  if (isDefined(scale)) {
    transform4 = "scale(" + scale + "," + scale + ")";
  }
  setTransform(htmlContainer, transform4);
};
Overlays.prototype._updateOverlaysVisibilty = function(viewbox) {
  var self2 = this;
  forEach(this._overlays, function(overlay) {
    self2._updateOverlayVisibilty(overlay, viewbox);
  });
};
Overlays.prototype._init = function() {
  var eventBus = this._eventBus;
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateOverlaysVisibilty(viewbox);
    self2.show();
  }
  eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
  eventBus.on(["shape.remove", "connection.remove"], function(e8) {
    var element = e8.element;
    var overlays = self2.get({ element });
    forEach(overlays, function(o5) {
      self2.remove(o5.id);
    });
    var container = self2._getOverlayContainer(element);
    if (container) {
      remove2(container.html);
      var i7 = self2._overlayContainers.indexOf(container);
      if (i7 !== -1) {
        self2._overlayContainers.splice(i7, 1);
      }
    }
  });
  eventBus.on("element.changed", LOW_PRIORITY, function(e8) {
    var element = e8.element;
    var container = self2._getOverlayContainer(element, true);
    if (container) {
      forEach(container.overlays, function(overlay) {
        self2._updateOverlay(overlay);
      });
      self2._updateOverlayContainer(container);
    }
  });
  eventBus.on("element.marker.update", function(e8) {
    var container = self2._getOverlayContainer(e8.element, true);
    if (container) {
      classes2(container.html)[e8.add ? "add" : "remove"](e8.marker);
    }
  });
  eventBus.on("root.set", function() {
    self2._updateOverlaysVisibilty(self2._canvas.viewbox());
  });
  eventBus.on("diagram.clear", this.clear, this);
};
function createRoot(parentNode) {
  var root = domify$1(
    '<div class="djs-overlay-container" />'
  );
  assign2(root, {
    position: "absolute",
    width: 0,
    height: 0
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition(el, x6, y5) {
  assign2(el, { left: x6 + "px", top: y5 + "px" });
}
function setVisible(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
function setTransform(el, transform4) {
  el.style["transform-origin"] = "top left";
  ["", "-ms-", "-webkit-"].forEach(function(prefix3) {
    el.style[prefix3 + "transform"] = transform4;
  });
}

// node_modules/diagram-js/lib/features/overlays/index.js
var overlays_default = {
  __init__: ["overlays"],
  overlays: ["type", Overlays]
};

// node_modules/diagram-js/lib/features/change-support/ChangeSupport.js
function ChangeSupport(eventBus, canvas, elementRegistry, graphicsFactory) {
  eventBus.on("element.changed", function(event2) {
    var element = event2.element;
    if (element.parent || element === canvas.getRootElement()) {
      event2.gfx = elementRegistry.getGraphics(element);
    }
    if (!event2.gfx) {
      return;
    }
    eventBus.fire(getType(element) + ".changed", event2);
  });
  eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements;
    elements.forEach(function(e8) {
      eventBus.fire("element.changed", { element: e8 });
    });
    graphicsFactory.updateContainments(elements);
  });
  eventBus.on("shape.changed", function(event2) {
    graphicsFactory.update("shape", event2.element, event2.gfx);
  });
  eventBus.on("connection.changed", function(event2) {
    graphicsFactory.update("connection", event2.element, event2.gfx);
  });
}
ChangeSupport.$inject = [
  "eventBus",
  "canvas",
  "elementRegistry",
  "graphicsFactory"
];

// node_modules/diagram-js/lib/features/change-support/index.js
var change_support_default = {
  __init__: ["changeSupport"],
  changeSupport: ["type", ChangeSupport]
};

// node_modules/diagram-js/lib/command/CommandInterceptor.js
var DEFAULT_PRIORITY = 1e3;
function CommandInterceptor(eventBus) {
  this._eventBus = eventBus;
}
CommandInterceptor.$inject = ["eventBus"];
function unwrapEvent(fn2, that) {
  return function(event2) {
    return fn2.call(that || null, event2.context, event2.command, event2);
  };
}
CommandInterceptor.prototype.on = function(events, hook, priority, handlerFn, unwrap, that) {
  if (isFunction(hook) || isNumber(hook)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = hook;
    hook = null;
  }
  if (isFunction(priority)) {
    that = unwrap;
    unwrap = handlerFn;
    handlerFn = priority;
    priority = DEFAULT_PRIORITY;
  }
  if (isObject(unwrap)) {
    that = unwrap;
    unwrap = false;
  }
  if (!isFunction(handlerFn)) {
    throw new Error("handlerFn must be a function");
  }
  if (!isArray(events)) {
    events = [events];
  }
  var eventBus = this._eventBus;
  forEach(events, function(event2) {
    var fullEvent = ["commandStack", event2, hook].filter(function(e8) {
      return e8;
    }).join(".");
    eventBus.on(fullEvent, priority, unwrap ? unwrapEvent(handlerFn, that) : handlerFn, that);
  });
};
CommandInterceptor.prototype.canExecute = createHook("canExecute");
CommandInterceptor.prototype.preExecute = createHook("preExecute");
CommandInterceptor.prototype.preExecuted = createHook("preExecuted");
CommandInterceptor.prototype.execute = createHook("execute");
CommandInterceptor.prototype.executed = createHook("executed");
CommandInterceptor.prototype.postExecute = createHook("postExecute");
CommandInterceptor.prototype.postExecuted = createHook("postExecuted");
CommandInterceptor.prototype.revert = createHook("revert");
CommandInterceptor.prototype.reverted = createHook("reverted");
function createHook(hook) {
  const hookFn = function(events, priority, handlerFn, unwrap, that) {
    if (isFunction(events) || isNumber(events)) {
      that = unwrap;
      unwrap = handlerFn;
      handlerFn = priority;
      priority = events;
      events = null;
    }
    this.on(events, hook, priority, handlerFn, unwrap, that);
  };
  return hookFn;
}

// node_modules/diagram-js/lib/features/root-elements/RootElementsBehavior.js
function RootElementsBehavior(canvas, injector) {
  injector.invoke(CommandInterceptor, this);
  this.executed(function(event2) {
    var context = event2.context;
    if (context.rootElement) {
      canvas.setRootElement(context.rootElement);
    } else {
      context.rootElement = canvas.getRootElement();
    }
  });
  this.revert(function(event2) {
    var context = event2.context;
    if (context.rootElement) {
      canvas.setRootElement(context.rootElement);
    }
  });
}
e(RootElementsBehavior, CommandInterceptor);
RootElementsBehavior.$inject = ["canvas", "injector"];

// node_modules/diagram-js/lib/features/root-elements/index.js
var root_elements_default = {
  __init__: ["rootElementsBehavior"],
  rootElementsBehavior: ["type", RootElementsBehavior]
};

// node_modules/diagram-js/lib/util/EscapeUtil.js
function escapeCSS(str) {
  return CSS.escape(str);
}
var HTML_ESCAPE_MAP = {
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  '"': "&quot;",
  "'": "&#39;"
};
function escapeHTML(str) {
  str = "" + str;
  return str && str.replace(/[&<>"']/g, function(match) {
    return HTML_ESCAPE_MAP[match];
  });
}

// node_modules/bpmn-js/lib/util/DrilldownUtil.js
var planeSuffix = "_plane";
function getShapeIdFromPlane(element) {
  var id = element.id;
  return removePlaneSuffix(id);
}
function getPlaneIdFromShape(element) {
  var id = element.id;
  if (is(element, "bpmn:SubProcess")) {
    return addPlaneSuffix(id);
  }
  return id;
}
function toPlaneId(id) {
  return addPlaneSuffix(id);
}
function isPlane(element) {
  var di = getDi(element);
  return is(di, "bpmndi:BPMNPlane");
}
function addPlaneSuffix(id) {
  return id + planeSuffix;
}
function removePlaneSuffix(id) {
  return id.replace(new RegExp(planeSuffix + "$"), "");
}

// node_modules/bpmn-js/lib/features/drilldown/DrilldownBreadcrumbs.js
var OPEN_CLASS = "bjs-breadcrumbs-shown";
function DrilldownBreadcrumbs(eventBus, elementRegistry, canvas) {
  var breadcrumbs = domify$1('<ul class="bjs-breadcrumbs"></ul>');
  var container = canvas.getContainer();
  var containerClasses = classes2(container);
  container.appendChild(breadcrumbs);
  var businessObjectParents = [];
  eventBus.on("element.changed", function(event2) {
    var shape = event2.element, businessObject = getBusinessObject(shape);
    var isPresent = find(businessObjectParents, function(element) {
      return element === businessObject;
    });
    if (!isPresent) {
      return;
    }
    updateBreadcrumbs();
  });
  function updateBreadcrumbs(element) {
    if (element) {
      businessObjectParents = getBusinessObjectParentChain(element);
    }
    var path = businessObjectParents.flatMap(function(parent) {
      var parentPlane = canvas.findRoot(getPlaneIdFromShape(parent)) || canvas.findRoot(parent.id);
      if (!parentPlane && is(parent, "bpmn:Process")) {
        var participant = elementRegistry.find(function(element2) {
          var businessObject = getBusinessObject(element2);
          return businessObject && businessObject.get("processRef") === parent;
        });
        parentPlane = participant && canvas.findRoot(participant.id);
      }
      if (!parentPlane) {
        return [];
      }
      var title = escapeHTML(parent.name || parent.id);
      var link = domify$1('<li><span class="bjs-crumb"><a title="' + title + '">' + title + "</a></span></li>");
      link.addEventListener("click", function() {
        canvas.setRootElement(parentPlane);
      });
      return link;
    });
    breadcrumbs.innerHTML = "";
    var visible = path.length > 1;
    containerClasses.toggle(OPEN_CLASS, visible);
    path.forEach(function(element2) {
      breadcrumbs.appendChild(element2);
    });
  }
  eventBus.on("root.set", function(event2) {
    updateBreadcrumbs(event2.element);
  });
}
DrilldownBreadcrumbs.$inject = ["eventBus", "elementRegistry", "canvas"];
function getBusinessObjectParentChain(child) {
  var businessObject = getBusinessObject(child);
  var parents = [];
  for (var element = businessObject; element; element = element.$parent) {
    if (is(element, "bpmn:SubProcess") || is(element, "bpmn:Process")) {
      parents.push(element);
    }
  }
  return parents.reverse();
}

// node_modules/bpmn-js/lib/features/drilldown/DrilldownCentering.js
function DrilldownCentering(eventBus, canvas) {
  var currentRoot = null;
  var positionMap = new Map2();
  eventBus.on("root.set", function(event2) {
    var newRoot = event2.element;
    var currentViewbox = canvas.viewbox();
    var storedViewbox = positionMap.get(newRoot);
    positionMap.set(currentRoot, {
      x: currentViewbox.x,
      y: currentViewbox.y,
      zoom: currentViewbox.scale
    });
    currentRoot = newRoot;
    if (!is(newRoot, "bpmn:SubProcess") && !storedViewbox) {
      return;
    }
    storedViewbox = storedViewbox || { x: 0, y: 0, zoom: 1 };
    var dx = (currentViewbox.x - storedViewbox.x) * currentViewbox.scale, dy = (currentViewbox.y - storedViewbox.y) * currentViewbox.scale;
    if (dx !== 0 || dy !== 0) {
      canvas.scroll({
        dx,
        dy
      });
    }
    if (storedViewbox.zoom !== currentViewbox.scale) {
      canvas.zoom(storedViewbox.zoom, { x: 0, y: 0 });
    }
  });
  eventBus.on("diagram.clear", function() {
    positionMap.clear();
    currentRoot = null;
  });
}
DrilldownCentering.$inject = ["eventBus", "canvas"];
function Map2() {
  this._entries = [];
  this.set = function(key, value) {
    var found = false;
    for (var k6 in this._entries) {
      if (this._entries[k6][0] === key) {
        this._entries[k6][1] = value;
        found = true;
        break;
      }
    }
    if (!found) {
      this._entries.push([key, value]);
    }
  };
  this.get = function(key) {
    for (var k6 in this._entries) {
      if (this._entries[k6][0] === key) {
        return this._entries[k6][1];
      }
    }
    return null;
  };
  this.clear = function() {
    this._entries.length = 0;
  };
  this.remove = function(key) {
    var idx = -1;
    for (var k6 in this._entries) {
      if (this._entries[k6][0] === key) {
        idx = k6;
        break;
      }
    }
    if (idx !== -1) {
      this._entries.splice(idx, 1);
    }
  };
}

// node_modules/bpmn-js/lib/features/drilldown/SubprocessCompatibility.js
var DEFAULT_POSITION = {
  x: 180,
  y: 160
};
function SubprocessCompatibility(eventBus, moddle) {
  this._eventBus = eventBus;
  this._moddle = moddle;
  var self2 = this;
  eventBus.on("import.render.start", 1500, function(e8, context) {
    self2._handleImport(context.definitions);
  });
}
SubprocessCompatibility.prototype._handleImport = function(definitions) {
  if (!definitions.diagrams) {
    return;
  }
  var self2 = this;
  this._definitions = definitions;
  this._processToDiagramMap = {};
  definitions.diagrams.forEach(function(diagram) {
    if (!diagram.plane || !diagram.plane.bpmnElement) {
      return;
    }
    self2._processToDiagramMap[diagram.plane.bpmnElement.id] = diagram;
  });
  var newDiagrams = definitions.diagrams.filter((diagram) => diagram.plane).flatMap((diagram) => self2._createNewDiagrams(diagram.plane));
  newDiagrams.forEach(function(diagram) {
    self2._movePlaneElementsToOrigin(diagram.plane);
  });
};
SubprocessCompatibility.prototype._createNewDiagrams = function(plane) {
  var self2 = this;
  var collapsedElements = [];
  var elementsToMove = [];
  plane.get("planeElement").forEach(function(diElement) {
    var businessObject = diElement.bpmnElement;
    if (!businessObject) {
      return;
    }
    var parent = businessObject.$parent;
    if (is(businessObject, "bpmn:SubProcess") && !diElement.isExpanded) {
      collapsedElements.push(businessObject);
    }
    if (shouldMoveToPlane(businessObject, plane)) {
      elementsToMove.push({ diElement, parent });
    }
  });
  var newDiagrams = [];
  collapsedElements.forEach(function(element) {
    if (!self2._processToDiagramMap[element.id]) {
      var diagram = self2._createDiagram(element);
      self2._processToDiagramMap[element.id] = diagram;
      newDiagrams.push(diagram);
    }
  });
  elementsToMove.forEach(function(element) {
    var diElement = element.diElement;
    var parent = element.parent;
    while (parent && collapsedElements.indexOf(parent) === -1) {
      parent = parent.$parent;
    }
    if (!parent) {
      return;
    }
    var diagram = self2._processToDiagramMap[parent.id];
    self2._moveToDiPlane(diElement, diagram.plane);
  });
  return newDiagrams;
};
SubprocessCompatibility.prototype._movePlaneElementsToOrigin = function(plane) {
  var elements = plane.get("planeElement");
  var planeBounds = getPlaneBounds(plane);
  var offset = {
    x: planeBounds.x - DEFAULT_POSITION.x,
    y: planeBounds.y - DEFAULT_POSITION.y
  };
  elements.forEach(function(diElement) {
    if (diElement.waypoint) {
      diElement.waypoint.forEach(function(waypoint) {
        waypoint.x = waypoint.x - offset.x;
        waypoint.y = waypoint.y - offset.y;
      });
    } else if (diElement.bounds) {
      diElement.bounds.x = diElement.bounds.x - offset.x;
      diElement.bounds.y = diElement.bounds.y - offset.y;
    }
  });
};
SubprocessCompatibility.prototype._moveToDiPlane = function(diElement, newPlane) {
  var containingDiagram = findRootDiagram(diElement);
  var parentPlaneElement = containingDiagram.plane.get("planeElement");
  parentPlaneElement.splice(parentPlaneElement.indexOf(diElement), 1);
  newPlane.get("planeElement").push(diElement);
};
SubprocessCompatibility.prototype._createDiagram = function(businessObject) {
  var plane = this._moddle.create("bpmndi:BPMNPlane", {
    bpmnElement: businessObject
  });
  var diagram = this._moddle.create("bpmndi:BPMNDiagram", {
    plane
  });
  plane.$parent = diagram;
  plane.bpmnElement = businessObject;
  diagram.$parent = this._definitions;
  this._definitions.diagrams.push(diagram);
  return diagram;
};
SubprocessCompatibility.$inject = ["eventBus", "moddle"];
function findRootDiagram(element) {
  if (is(element, "bpmndi:BPMNDiagram")) {
    return element;
  } else {
    return findRootDiagram(element.$parent);
  }
}
function getPlaneBounds(plane) {
  var planeTrbl = {
    top: Infinity,
    right: -Infinity,
    bottom: -Infinity,
    left: Infinity
  };
  plane.planeElement.forEach(function(element) {
    if (!element.bounds) {
      return;
    }
    var trbl = asTRBL(element.bounds);
    planeTrbl.top = Math.min(trbl.top, planeTrbl.top);
    planeTrbl.left = Math.min(trbl.left, planeTrbl.left);
  });
  return asBounds(planeTrbl);
}
function shouldMoveToPlane(businessObject, plane) {
  var parent = businessObject.$parent;
  if (!is(parent, "bpmn:SubProcess") || parent === plane.bpmnElement) {
    return false;
  }
  if (isAny(businessObject, ["bpmn:DataInputAssociation", "bpmn:DataOutputAssociation"])) {
    return false;
  }
  return true;
}

// node_modules/bpmn-js/lib/features/drilldown/DrilldownOverlayBehavior.js
var LOW_PRIORITY2 = 250;
var ARROW_DOWN_SVG = '<svg xmlns="http://www.w3.org/2000/svg" width="20" height="20" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M4.81801948,3.50735931 L10.4996894,9.1896894 L10.5,4 L12,4 L12,12 L4,12 L4,10.5 L9.6896894,10.4996894 L3.75735931,4.56801948 C3.46446609,4.27512627 3.46446609,3.80025253 3.75735931,3.50735931 C4.05025253,3.21446609 4.52512627,3.21446609 4.81801948,3.50735931 Z"/></svg>';
var EMPTY_MARKER = "bjs-drilldown-empty";
function DrilldownOverlayBehavior(canvas, eventBus, elementRegistry, overlays, translate4) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._overlays = overlays;
  this._translate = translate4;
  var self2 = this;
  this.executed("shape.toggleCollapse", LOW_PRIORITY2, function(context) {
    var shape = context.shape;
    if (self2._canDrillDown(shape)) {
      self2._addOverlay(shape);
    } else {
      self2._removeOverlay(shape);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY2, function(context) {
    var shape = context.shape;
    if (self2._canDrillDown(shape)) {
      self2._addOverlay(shape);
    } else {
      self2._removeOverlay(shape);
    }
  }, true);
  this.executed(
    ["shape.create", "shape.move", "shape.delete"],
    LOW_PRIORITY2,
    function(context) {
      var oldParent = context.oldParent, newParent = context.newParent || context.parent, shape = context.shape;
      if (self2._canDrillDown(shape)) {
        self2._addOverlay(shape);
      }
      self2._updateDrilldownOverlay(oldParent);
      self2._updateDrilldownOverlay(newParent);
      self2._updateDrilldownOverlay(shape);
    },
    true
  );
  this.reverted(
    ["shape.create", "shape.move", "shape.delete"],
    LOW_PRIORITY2,
    function(context) {
      var oldParent = context.oldParent, newParent = context.newParent || context.parent, shape = context.shape;
      if (self2._canDrillDown(shape)) {
        self2._addOverlay(shape);
      }
      self2._updateDrilldownOverlay(oldParent);
      self2._updateDrilldownOverlay(newParent);
      self2._updateDrilldownOverlay(shape);
    },
    true
  );
  eventBus.on("import.render.complete", function() {
    elementRegistry.filter(function(e8) {
      return self2._canDrillDown(e8);
    }).map(function(el) {
      self2._addOverlay(el);
    });
  });
}
e(DrilldownOverlayBehavior, CommandInterceptor);
DrilldownOverlayBehavior.prototype._updateDrilldownOverlay = function(shape) {
  var canvas = this._canvas;
  if (!shape) {
    return;
  }
  var root = canvas.findRoot(shape);
  if (root) {
    this._updateOverlayVisibility(root);
  }
};
DrilldownOverlayBehavior.prototype._canDrillDown = function(element) {
  var canvas = this._canvas;
  return is(element, "bpmn:SubProcess") && canvas.findRoot(getPlaneIdFromShape(element));
};
DrilldownOverlayBehavior.prototype._updateOverlayVisibility = function(element) {
  var overlays = this._overlays;
  var businessObject = getBusinessObject(element);
  var overlay = overlays.get({ element: businessObject.id, type: "drilldown" })[0];
  if (!overlay) {
    return;
  }
  var hasFlowElements = businessObject && businessObject.get("flowElements") && businessObject.get("flowElements").length;
  classes2(overlay.html).toggle(EMPTY_MARKER, !hasFlowElements);
};
DrilldownOverlayBehavior.prototype._addOverlay = function(element) {
  var canvas = this._canvas, overlays = this._overlays, bo = getBusinessObject(element);
  var existingOverlays = overlays.get({ element, type: "drilldown" });
  if (existingOverlays.length) {
    this._removeOverlay(element);
  }
  var button = domify$1('<button type="button" class="bjs-drilldown">' + ARROW_DOWN_SVG + "</button>"), elementName = bo.get("name") || bo.get("id"), title = this._translate("Open {element}", { element: elementName });
  button.setAttribute("title", title);
  button.addEventListener("click", function() {
    canvas.setRootElement(canvas.findRoot(getPlaneIdFromShape(element)));
  });
  overlays.add(element, "drilldown", {
    position: {
      bottom: -7,
      right: -8
    },
    html: button
  });
  this._updateOverlayVisibility(element);
};
DrilldownOverlayBehavior.prototype._removeOverlay = function(element) {
  var overlays = this._overlays;
  overlays.remove({
    element,
    type: "drilldown"
  });
};
DrilldownOverlayBehavior.$inject = [
  "canvas",
  "eventBus",
  "elementRegistry",
  "overlays",
  "translate"
];

// node_modules/bpmn-js/lib/features/drilldown/index.js
var drilldown_default = {
  __depends__: [overlays_default, change_support_default, root_elements_default],
  __init__: ["drilldownBreadcrumbs", "drilldownOverlayBehavior", "drilldownCentering", "subprocessCompatibility"],
  drilldownBreadcrumbs: ["type", DrilldownBreadcrumbs],
  drilldownCentering: ["type", DrilldownCentering],
  drilldownOverlayBehavior: ["type", DrilldownOverlayBehavior],
  subprocessCompatibility: ["type", SubprocessCompatibility]
};

// node_modules/diagram-js/lib/util/Event.js
function __stopPropagation(event2) {
  if (!event2 || typeof event2.stopPropagation !== "function") {
    return;
  }
  event2.stopPropagation();
}
function getOriginal(event2) {
  return event2.originalEvent || event2.srcEvent;
}
function stopPropagation(event2) {
  __stopPropagation(event2);
  __stopPropagation(getOriginal(event2));
}
function toPoint(event2) {
  if (event2.pointers && event2.pointers.length) {
    event2 = event2.pointers[0];
  }
  if (event2.touches && event2.touches.length) {
    event2 = event2.touches[0];
  }
  return event2 ? {
    x: event2.clientX,
    y: event2.clientY
  } : null;
}

// node_modules/diagram-js/lib/util/Platform.js
function isMac() {
  return /mac/i.test(navigator.platform);
}

// node_modules/diagram-js/lib/util/Mouse.js
function isButton(event2, button) {
  return (getOriginal(event2) || event2).button === button;
}
function isPrimaryButton(event2) {
  return isButton(event2, 0);
}
function isAuxiliaryButton(event2) {
  return isButton(event2, 1);
}
function hasPrimaryModifier(event2) {
  var originalEvent = getOriginal(event2) || event2;
  if (!isPrimaryButton(event2)) {
    return false;
  }
  if (isMac()) {
    return originalEvent.metaKey;
  } else {
    return originalEvent.ctrlKey;
  }
}
function hasSecondaryModifier(event2) {
  var originalEvent = getOriginal(event2) || event2;
  return isPrimaryButton(event2) && originalEvent.shiftKey;
}

// node_modules/diagram-js/lib/features/interaction-events/InteractionEvents.js
function allowAll(event2) {
  return true;
}
function allowPrimaryAndAuxiliary(event2) {
  return isPrimaryButton(event2) || isAuxiliaryButton(event2);
}
var LOW_PRIORITY3 = 500;
function InteractionEvents(eventBus, elementRegistry, styles) {
  var self2 = this;
  function fire(type, event2, element) {
    if (isIgnored(type, event2)) {
      return;
    }
    var target, gfx, returnValue;
    if (!element) {
      target = event2.delegateTarget || event2.target;
      if (target) {
        gfx = target;
        element = elementRegistry.get(gfx);
      }
    } else {
      gfx = elementRegistry.getGraphics(element);
    }
    if (!gfx || !element) {
      return;
    }
    returnValue = eventBus.fire(type, {
      element,
      gfx,
      originalEvent: event2
    });
    if (returnValue === false) {
      event2.stopPropagation();
      event2.preventDefault();
    }
  }
  var handlers = {};
  function mouseHandler(localEventName) {
    return handlers[localEventName];
  }
  function isIgnored(localEventName, event2) {
    var filter2 = ignoredFilters[localEventName] || isPrimaryButton;
    return !filter2(event2);
  }
  var bindings = {
    click: "element.click",
    contextmenu: "element.contextmenu",
    dblclick: "element.dblclick",
    mousedown: "element.mousedown",
    mousemove: "element.mousemove",
    mouseover: "element.hover",
    mouseout: "element.out",
    mouseup: "element.mouseup"
  };
  var ignoredFilters = {
    "element.contextmenu": allowAll,
    "element.mousedown": allowPrimaryAndAuxiliary,
    "element.mouseup": allowPrimaryAndAuxiliary,
    "element.click": allowPrimaryAndAuxiliary,
    "element.dblclick": allowPrimaryAndAuxiliary
  };
  function triggerMouseEvent(eventName, event2, targetElement) {
    var localEventName = bindings[eventName];
    if (!localEventName) {
      throw new Error("unmapped DOM event name <" + eventName + ">");
    }
    return fire(localEventName, event2, targetElement);
  }
  var ELEMENT_SELECTOR2 = "svg, .djs-element";
  function registerEvent(node2, event2, localEvent, ignoredFilter) {
    var handler = handlers[localEvent] = function(event3) {
      fire(localEvent, event3);
    };
    if (ignoredFilter) {
      ignoredFilters[localEvent] = ignoredFilter;
    }
    handler.$delegate = delegate.bind(node2, ELEMENT_SELECTOR2, event2, handler);
  }
  function unregisterEvent(node2, event2, localEvent) {
    var handler = mouseHandler(localEvent);
    if (!handler) {
      return;
    }
    delegate.unbind(node2, event2, handler.$delegate);
  }
  function registerEvents(svg) {
    forEach(bindings, function(val, key) {
      registerEvent(svg, key, val);
    });
  }
  function unregisterEvents(svg) {
    forEach(bindings, function(val, key) {
      unregisterEvent(svg, key, val);
    });
  }
  eventBus.on("canvas.destroy", function(event2) {
    unregisterEvents(event2.svg);
  });
  eventBus.on("canvas.init", function(event2) {
    registerEvents(event2.svg);
  });
  eventBus.on(["shape.added", "connection.added"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    eventBus.fire("interactionEvents.createHit", { element, gfx });
  });
  eventBus.on([
    "shape.changed",
    "connection.changed"
  ], LOW_PRIORITY3, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    eventBus.fire("interactionEvents.updateHit", { element, gfx });
  });
  eventBus.on("interactionEvents.createHit", LOW_PRIORITY3, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    self2.createDefaultHit(element, gfx);
  });
  eventBus.on("interactionEvents.updateHit", function(event2) {
    var element = event2.element, gfx = event2.gfx;
    self2.updateDefaultHit(element, gfx);
  });
  var STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-stroke");
  var CLICK_STROKE_HIT_STYLE = createHitStyle("djs-hit djs-hit-click-stroke");
  var ALL_HIT_STYLE = createHitStyle("djs-hit djs-hit-all");
  var NO_MOVE_HIT_STYLE = createHitStyle("djs-hit djs-hit-no-move");
  var HIT_TYPES = {
    "all": ALL_HIT_STYLE,
    "click-stroke": CLICK_STROKE_HIT_STYLE,
    "stroke": STROKE_HIT_STYLE,
    "no-move": NO_MOVE_HIT_STYLE
  };
  function createHitStyle(classNames, attrs) {
    attrs = assign({
      stroke: "white",
      strokeWidth: 15
    }, attrs || {});
    return styles.cls(classNames, ["no-fill", "no-border"], attrs);
  }
  function applyStyle(hit, type) {
    var attrs = HIT_TYPES[type];
    if (!attrs) {
      throw new Error("invalid hit type <" + type + ">");
    }
    attr(hit, attrs);
    return hit;
  }
  function appendHit(gfx, hit) {
    append(gfx, hit);
  }
  this.removeHits = function(gfx) {
    var hits = all(".djs-hit", gfx);
    forEach(hits, remove);
  };
  this.createDefaultHit = function(element, gfx) {
    var waypoints = element.waypoints, isFrame = element.isFrame, boxType;
    if (waypoints) {
      return this.createWaypointsHit(gfx, waypoints);
    } else {
      boxType = isFrame ? "stroke" : "all";
      return this.createBoxHit(gfx, boxType, {
        width: element.width,
        height: element.height
      });
    }
  };
  this.createWaypointsHit = function(gfx, waypoints) {
    var hit = createLine(waypoints);
    applyStyle(hit, "stroke");
    appendHit(gfx, hit);
    return hit;
  };
  this.createBoxHit = function(gfx, type, attrs) {
    attrs = assign({
      x: 0,
      y: 0
    }, attrs);
    var hit = create("rect");
    applyStyle(hit, type);
    attr(hit, attrs);
    appendHit(gfx, hit);
    return hit;
  };
  this.updateDefaultHit = function(element, gfx) {
    var hit = query(".djs-hit", gfx);
    if (!hit) {
      return;
    }
    if (element.waypoints) {
      updateLine(hit, element.waypoints);
    } else {
      attr(hit, {
        width: element.width,
        height: element.height
      });
    }
    return hit;
  };
  this.fire = fire;
  this.triggerMouseEvent = triggerMouseEvent;
  this.mouseHandler = mouseHandler;
  this.registerEvent = registerEvent;
  this.unregisterEvent = unregisterEvent;
}
InteractionEvents.$inject = [
  "eventBus",
  "elementRegistry",
  "styles"
];

// node_modules/diagram-js/lib/features/interaction-events/index.js
var interaction_events_default = {
  __init__: ["interactionEvents"],
  interactionEvents: ["type", InteractionEvents]
};

// node_modules/diagram-js/lib/features/selection/Selection.js
function Selection(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._selectedElements = [];
  var self2 = this;
  eventBus.on(["shape.remove", "connection.remove"], function(e8) {
    var element = e8.element;
    self2.deselect(element);
  });
  eventBus.on(["diagram.clear", "root.set"], function(e8) {
    self2.select(null);
  });
}
Selection.$inject = ["eventBus", "canvas"];
Selection.prototype.deselect = function(element) {
  var selectedElements = this._selectedElements;
  var idx = selectedElements.indexOf(element);
  if (idx !== -1) {
    var oldSelection = selectedElements.slice();
    selectedElements.splice(idx, 1);
    this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
  }
};
Selection.prototype.get = function() {
  return this._selectedElements;
};
Selection.prototype.isSelected = function(element) {
  return this._selectedElements.indexOf(element) !== -1;
};
Selection.prototype.select = function(elements, add5) {
  var selectedElements = this._selectedElements, oldSelection = selectedElements.slice();
  if (!isArray(elements)) {
    elements = elements ? [elements] : [];
  }
  var canvas = this._canvas;
  var rootElement = canvas.getRootElement();
  elements = elements.filter(function(element) {
    var elementRoot = canvas.findRoot(element);
    return rootElement === elementRoot;
  });
  if (add5) {
    forEach(elements, function(element) {
      if (selectedElements.indexOf(element) !== -1) {
        return;
      } else {
        selectedElements.push(element);
      }
    });
  } else {
    this._selectedElements = selectedElements = elements.slice();
  }
  this._eventBus.fire("selection.changed", { oldSelection, newSelection: selectedElements });
};

// node_modules/diagram-js/lib/features/selection/SelectionVisuals.js
var MARKER_HOVER = "hover";
var MARKER_SELECTED = "selected";
function SelectionVisuals(canvas, eventBus) {
  this._canvas = canvas;
  function addMarker(e8, cls) {
    canvas.addMarker(e8, cls);
  }
  function removeMarker(e8, cls) {
    canvas.removeMarker(e8, cls);
  }
  eventBus.on("element.hover", function(event2) {
    addMarker(event2.element, MARKER_HOVER);
  });
  eventBus.on("element.out", function(event2) {
    removeMarker(event2.element, MARKER_HOVER);
  });
  eventBus.on("selection.changed", function(event2) {
    function deselect(s5) {
      removeMarker(s5, MARKER_SELECTED);
    }
    function select(s5) {
      addMarker(s5, MARKER_SELECTED);
    }
    var oldSelection = event2.oldSelection, newSelection = event2.newSelection;
    forEach(oldSelection, function(e8) {
      if (newSelection.indexOf(e8) === -1) {
        deselect(e8);
      }
    });
    forEach(newSelection, function(e8) {
      if (oldSelection.indexOf(e8) === -1) {
        select(e8);
      }
    });
  });
}
SelectionVisuals.$inject = [
  "canvas",
  "eventBus"
];

// node_modules/diagram-js/lib/features/selection/SelectionBehavior.js
function SelectionBehavior(eventBus, selection2, canvas, elementRegistry) {
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, canExecute = context.canExecute, elements = context.elements, hints = context.hints || {}, autoSelect = hints.autoSelect;
    if (canExecute) {
      if (autoSelect === false) {
        return;
      }
      if (isArray(autoSelect)) {
        selection2.select(autoSelect);
      } else {
        selection2.select(elements.filter(isShown));
      }
    }
  });
  eventBus.on("connect.end", 500, function(event2) {
    var context = event2.context, connection = context.connection;
    if (connection) {
      selection2.select(connection);
    }
  });
  eventBus.on("shape.move.end", 500, function(event2) {
    var previousSelection = event2.previousSelection || [];
    var shape = elementRegistry.get(event2.context.shape.id);
    var isSelected = find(previousSelection, function(selectedShape) {
      return shape.id === selectedShape.id;
    });
    if (!isSelected) {
      selection2.select(shape);
    }
  });
  eventBus.on("element.click", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var element = event2.element;
    if (element === canvas.getRootElement()) {
      element = null;
    }
    var isSelected = selection2.isSelected(element), isMultiSelect = selection2.get().length > 1;
    var add5 = hasSecondaryModifier(event2);
    if (isSelected && isMultiSelect) {
      if (add5) {
        return selection2.deselect(element);
      } else {
        return selection2.select(element);
      }
    } else if (!isSelected) {
      selection2.select(element, add5);
    } else {
      selection2.deselect(element);
    }
  });
}
SelectionBehavior.$inject = [
  "eventBus",
  "selection",
  "canvas",
  "elementRegistry"
];
function isShown(element) {
  return !element.hidden;
}

// node_modules/diagram-js/lib/features/selection/index.js
var selection_default = {
  __init__: ["selectionVisuals", "selectionBehavior"],
  __depends__: [
    interaction_events_default
  ],
  selection: ["type", Selection],
  selectionVisuals: ["type", SelectionVisuals],
  selectionBehavior: ["type", SelectionBehavior]
};

// node_modules/didi/dist/index.js
var CLASS_PATTERN = /^class[ {]/;
function isClass(fn2) {
  return CLASS_PATTERN.test(fn2.toString());
}
function isArray4(obj) {
  return Array.isArray(obj);
}
function hasOwnProp(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}
function annotate(...args) {
  if (args.length === 1 && isArray4(args[0])) {
    args = args[0];
  }
  args = [...args];
  const fn2 = args.pop();
  fn2.$inject = args;
  return fn2;
}
var CONSTRUCTOR_ARGS = /constructor\s*[^(]*\(\s*([^)]*)\)/m;
var FN_ARGS = /^(?:async\s+)?(?:function\s*[^(]*)?(?:\(\s*([^)]*)\)|(\w+))/m;
var FN_ARG = /\/\*([^*]*)\*\//m;
function parseAnnotations(fn2) {
  if (typeof fn2 !== "function") {
    throw new Error(`Cannot annotate "${fn2}". Expected a function!`);
  }
  const match = fn2.toString().match(isClass(fn2) ? CONSTRUCTOR_ARGS : FN_ARGS);
  if (!match) {
    return [];
  }
  const args = match[1] || match[2];
  return args && args.split(",").map((arg) => {
    const argMatch = arg.match(FN_ARG);
    return (argMatch && argMatch[1] || arg).trim();
  }) || [];
}
function Injector(modules, _parent) {
  const parent = _parent || /** @type InjectorContext */
  {
    get: function(name2, strict) {
      currentlyResolving.push(name2);
      if (strict === false) {
        return null;
      } else {
        throw error4(`No provider for "${name2}"!`);
      }
    }
  };
  const currentlyResolving = [];
  const providers = this._providers = Object.create(parent._providers || null);
  const instances = this._instances = /* @__PURE__ */ Object.create(null);
  const self2 = instances.injector = this;
  const error4 = function(msg) {
    const stack = currentlyResolving.join(" -> ");
    currentlyResolving.length = 0;
    return new Error(stack ? `${msg} (Resolving: ${stack})` : msg);
  };
  function get4(name2, strict) {
    if (!providers[name2] && name2.includes(".")) {
      const parts = name2.split(".");
      let pivot = get4(
        /** @type { string } */
        parts.shift()
      );
      while (parts.length) {
        pivot = pivot[
          /** @type { string } */
          parts.shift()
        ];
      }
      return pivot;
    }
    if (hasOwnProp(instances, name2)) {
      return instances[name2];
    }
    if (hasOwnProp(providers, name2)) {
      if (currentlyResolving.indexOf(name2) !== -1) {
        currentlyResolving.push(name2);
        throw error4("Cannot resolve circular dependency!");
      }
      currentlyResolving.push(name2);
      instances[name2] = providers[name2][0](providers[name2][1]);
      currentlyResolving.pop();
      return instances[name2];
    }
    return parent.get(name2, strict);
  }
  function fnDef(fn2, locals) {
    if (typeof locals === "undefined") {
      locals = {};
    }
    if (typeof fn2 !== "function") {
      if (isArray4(fn2)) {
        fn2 = annotate(fn2.slice());
      } else {
        throw error4(`Cannot invoke "${fn2}". Expected a function!`);
      }
    }
    const inject = fn2.$inject || parseAnnotations(fn2);
    const dependencies = inject.map((dep) => {
      if (hasOwnProp(locals, dep)) {
        return locals[dep];
      } else {
        return get4(dep);
      }
    });
    return {
      fn: fn2,
      dependencies
    };
  }
  function instantiate(type) {
    const {
      fn: fn2,
      dependencies
    } = fnDef(type);
    const Constructor = Function.prototype.bind.call(fn2, null, ...dependencies);
    return new Constructor();
  }
  function invoke(func, context, locals) {
    const {
      fn: fn2,
      dependencies
    } = fnDef(func, locals);
    return fn2.apply(context, dependencies);
  }
  function createPrivateInjectorFactory(childInjector) {
    return annotate((key) => childInjector.get(key));
  }
  function createChild(modules2, forceNewInstances) {
    if (forceNewInstances && forceNewInstances.length) {
      const fromParentModule = /* @__PURE__ */ Object.create(null);
      const matchedScopes = /* @__PURE__ */ Object.create(null);
      const privateInjectorsCache = [];
      const privateChildInjectors = [];
      const privateChildFactories = [];
      let provider;
      let cacheIdx;
      let privateChildInjector;
      let privateChildInjectorFactory;
      for (let name2 in providers) {
        provider = providers[name2];
        if (forceNewInstances.indexOf(name2) !== -1) {
          if (provider[2] === "private") {
            cacheIdx = privateInjectorsCache.indexOf(provider[3]);
            if (cacheIdx === -1) {
              privateChildInjector = provider[3].createChild([], forceNewInstances);
              privateChildInjectorFactory = createPrivateInjectorFactory(privateChildInjector);
              privateInjectorsCache.push(provider[3]);
              privateChildInjectors.push(privateChildInjector);
              privateChildFactories.push(privateChildInjectorFactory);
              fromParentModule[name2] = [privateChildInjectorFactory, name2, "private", privateChildInjector];
            } else {
              fromParentModule[name2] = [privateChildFactories[cacheIdx], name2, "private", privateChildInjectors[cacheIdx]];
            }
          } else {
            fromParentModule[name2] = [provider[2], provider[1]];
          }
          matchedScopes[name2] = true;
        }
        if ((provider[2] === "factory" || provider[2] === "type") && provider[1].$scope) {
          forceNewInstances.forEach((scope) => {
            if (provider[1].$scope.indexOf(scope) !== -1) {
              fromParentModule[name2] = [provider[2], provider[1]];
              matchedScopes[scope] = true;
            }
          });
        }
      }
      forceNewInstances.forEach((scope) => {
        if (!matchedScopes[scope]) {
          throw new Error('No provider for "' + scope + '". Cannot use provider from the parent!');
        }
      });
      modules2.unshift(fromParentModule);
    }
    return new Injector(modules2, self2);
  }
  const factoryMap = {
    factory: invoke,
    type: instantiate,
    value: function(value) {
      return value;
    }
  };
  function createInitializer(moduleDefinition, injector) {
    const initializers = moduleDefinition.__init__ || [];
    return function() {
      initializers.forEach((initializer) => {
        if (typeof initializer === "string") {
          injector.get(initializer);
        } else {
          injector.invoke(initializer);
        }
      });
    };
  }
  function loadModule(moduleDefinition) {
    const moduleExports = moduleDefinition.__exports__;
    if (moduleExports) {
      const nestedModules = moduleDefinition.__modules__;
      const clonedModule = Object.keys(moduleDefinition).reduce((clonedModule2, key) => {
        if (key !== "__exports__" && key !== "__modules__" && key !== "__init__" && key !== "__depends__") {
          clonedModule2[key] = moduleDefinition[key];
        }
        return clonedModule2;
      }, /* @__PURE__ */ Object.create(null));
      const childModules = (nestedModules || []).concat(clonedModule);
      const privateInjector = createChild(childModules);
      const getFromPrivateInjector = annotate(function(key) {
        return privateInjector.get(key);
      });
      moduleExports.forEach(function(key) {
        providers[key] = [getFromPrivateInjector, key, "private", privateInjector];
      });
      const initializers = (moduleDefinition.__init__ || []).slice();
      initializers.unshift(function() {
        privateInjector.init();
      });
      moduleDefinition = Object.assign({}, moduleDefinition, {
        __init__: initializers
      });
      return createInitializer(moduleDefinition, privateInjector);
    }
    Object.keys(moduleDefinition).forEach(function(key) {
      if (key === "__init__" || key === "__depends__") {
        return;
      }
      const typeDeclaration = (
        /** @type { TypedDeclaration } */
        moduleDefinition[key]
      );
      if (typeDeclaration[2] === "private") {
        providers[key] = typeDeclaration;
        return;
      }
      const type = typeDeclaration[0];
      const value = typeDeclaration[1];
      providers[key] = [factoryMap[type], arrayUnwrap(type, value), type];
    });
    return createInitializer(moduleDefinition, self2);
  }
  function resolveDependencies(moduleDefinitions, moduleDefinition) {
    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
      return moduleDefinitions;
    }
    moduleDefinitions = (moduleDefinition.__depends__ || []).reduce(resolveDependencies, moduleDefinitions);
    if (moduleDefinitions.indexOf(moduleDefinition) !== -1) {
      return moduleDefinitions;
    }
    return moduleDefinitions.concat(moduleDefinition);
  }
  function bootstrap2(moduleDefinitions) {
    const initializers = moduleDefinitions.reduce(resolveDependencies, []).map(loadModule);
    let initialized = false;
    return function() {
      if (initialized) {
        return;
      }
      initialized = true;
      initializers.forEach((initializer) => initializer());
    };
  }
  this.get = get4;
  this.invoke = invoke;
  this.instantiate = instantiate;
  this.createChild = createChild;
  this.init = bootstrap2(modules);
}
function arrayUnwrap(type, value) {
  if (type !== "value" && isArray4(value)) {
    value = annotate(value.slice());
  }
  return value;
}

// node_modules/diagram-js/lib/draw/DefaultRenderer.js
var DEFAULT_RENDER_PRIORITY2 = 1;
function DefaultRenderer(eventBus, styles) {
  BaseRenderer.call(this, eventBus, DEFAULT_RENDER_PRIORITY2);
  this.CONNECTION_STYLE = styles.style(["no-fill"], { strokeWidth: 5, stroke: "fuchsia" });
  this.SHAPE_STYLE = styles.style({ fill: "white", stroke: "fuchsia", strokeWidth: 2 });
  this.FRAME_STYLE = styles.style(["no-fill"], { stroke: "fuchsia", strokeDasharray: 4, strokeWidth: 2 });
}
e(DefaultRenderer, BaseRenderer);
DefaultRenderer.prototype.canRender = function() {
  return true;
};
DefaultRenderer.prototype.drawShape = function drawShape(visuals, element, attrs) {
  var rect = create("rect");
  attr(rect, {
    x: 0,
    y: 0,
    width: element.width || 0,
    height: element.height || 0
  });
  if (isFrameElement2(element)) {
    attr(rect, assign({}, this.FRAME_STYLE, attrs || {}));
  } else {
    attr(rect, assign({}, this.SHAPE_STYLE, attrs || {}));
  }
  append(visuals, rect);
  return rect;
};
DefaultRenderer.prototype.drawConnection = function drawConnection(visuals, connection, attrs) {
  var line2 = createLine(connection.waypoints, assign({}, this.CONNECTION_STYLE, attrs || {}));
  append(visuals, line2);
  return line2;
};
DefaultRenderer.prototype.getShapePath = function getShapePath(shape) {
  var x6 = shape.x, y5 = shape.y, width = shape.width, height = shape.height;
  var shapePath = [
    ["M", x6, y5],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath(shapePath);
};
DefaultRenderer.prototype.getConnectionPath = function getConnectionPath(connection) {
  var waypoints = connection.waypoints;
  var idx, point, connectionPath = [];
  for (idx = 0; point = waypoints[idx]; idx++) {
    point = point.original || point;
    connectionPath.push([idx === 0 ? "M" : "L", point.x, point.y]);
  }
  return componentsToPath(connectionPath);
};
DefaultRenderer.$inject = ["eventBus", "styles"];

// node_modules/diagram-js/lib/draw/Styles.js
function Styles() {
  var defaultTraits = {
    "no-fill": {
      fill: "none"
    },
    "no-border": {
      strokeOpacity: 0
    },
    "no-events": {
      pointerEvents: "none"
    }
  };
  var self2 = this;
  this.cls = function(className, traits, additionalAttrs) {
    var attrs = this.style(traits, additionalAttrs);
    return assign(attrs, { "class": className });
  };
  this.style = function(traits, additionalAttrs) {
    if (!isArray(traits) && !additionalAttrs) {
      additionalAttrs = traits;
      traits = [];
    }
    var attrs = reduce(traits, function(attrs2, t7) {
      return assign(attrs2, defaultTraits[t7] || {});
    }, {});
    return additionalAttrs ? assign(attrs, additionalAttrs) : attrs;
  };
  this.computeStyle = function(custom, traits, defaultStyles) {
    if (!isArray(traits)) {
      defaultStyles = traits;
      traits = [];
    }
    return self2.style(traits || [], assign({}, defaultStyles, custom || {}));
  };
}

// node_modules/diagram-js/lib/draw/index.js
var draw_default2 = {
  __init__: ["defaultRenderer"],
  defaultRenderer: ["type", DefaultRenderer],
  styles: ["type", Styles]
};

// node_modules/diagram-js/lib/util/Collections.js
function remove3(collection, element) {
  if (!collection || !element) {
    return -1;
  }
  var idx = collection.indexOf(element);
  if (idx !== -1) {
    collection.splice(idx, 1);
  }
  return idx;
}
function add2(collection, element, idx) {
  if (!collection || !element) {
    return;
  }
  if (typeof idx !== "number") {
    idx = -1;
  }
  var currentIdx = collection.indexOf(element);
  if (currentIdx !== -1) {
    if (currentIdx === idx) {
      return;
    } else {
      if (idx !== -1) {
        collection.splice(currentIdx, 1);
      } else {
        return;
      }
    }
  }
  if (idx !== -1) {
    collection.splice(idx, 0, element);
  } else {
    collection.push(element);
  }
}
function indexOf(collection, element) {
  if (!collection || !element) {
    return -1;
  }
  return collection.indexOf(element);
}

// node_modules/diagram-js/lib/core/Canvas.js
function round(number, resolution) {
  return Math.round(number * resolution) / resolution;
}
function ensurePx(number) {
  return isNumber(number) ? number + "px" : number;
}
function findRoot(element) {
  while (element.parent) {
    element = element.parent;
  }
  return element;
}
function createContainer(options) {
  options = assign({}, { width: "100%", height: "100%" }, options);
  const container = options.container || document.body;
  const parent = document.createElement("div");
  parent.setAttribute("class", "djs-container djs-parent");
  assign2(parent, {
    position: "relative",
    overflow: "hidden",
    width: ensurePx(options.width),
    height: ensurePx(options.height)
  });
  container.appendChild(parent);
  return parent;
}
function createGroup(parent, cls, childIndex) {
  const group = create("g");
  classes(group).add(cls);
  const index5 = childIndex !== void 0 ? childIndex : parent.childNodes.length - 1;
  parent.insertBefore(group, parent.childNodes[index5] || null);
  return group;
}
var BASE_LAYER = "base";
var PLANE_LAYER_INDEX = 0;
var UTILITY_LAYER_INDEX = 1;
var REQUIRED_MODEL_ATTRS = {
  shape: ["x", "y", "width", "height"],
  connection: ["waypoints"]
};
function Canvas(config, eventBus, graphicsFactory, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
  this._rootsIdx = 0;
  this._layers = {};
  this._planes = [];
  this._rootElement = null;
  this._focused = false;
  this._init(config || {});
}
Canvas.$inject = [
  "config.canvas",
  "eventBus",
  "graphicsFactory",
  "elementRegistry"
];
Canvas.prototype._init = function(config) {
  const eventBus = this._eventBus;
  const container = this._container = createContainer(config);
  const svg = this._svg = create("svg");
  attr(svg, {
    width: "100%",
    height: "100%"
  });
  attr2(svg, "tabindex", 0);
  config.autoFocus && eventBus.on("element.hover", () => {
    this.restoreFocus();
  });
  eventBus.on("element.mousedown", 500, (event2) => {
    this.focus();
  });
  svg.addEventListener("focusin", () => {
    this._setFocused(true);
  });
  svg.addEventListener("focusout", () => {
    this._setFocused(false);
  });
  append(container, svg);
  const viewport = this._viewport = createGroup(svg, "viewport");
  if (config.deferUpdate) {
    this._viewboxChanged = debounce(bind(this._viewboxChanged, this), 300);
  }
  eventBus.on("diagram.init", () => {
    eventBus.fire("canvas.init", {
      svg,
      viewport
    });
  });
  eventBus.on([
    "shape.added",
    "connection.added",
    "shape.removed",
    "connection.removed",
    "elements.changed",
    "root.set"
  ], () => {
    delete this._cachedViewbox;
  });
  eventBus.on("diagram.destroy", 500, this._destroy, this);
  eventBus.on("diagram.clear", 500, this._clear, this);
};
Canvas.prototype._destroy = function() {
  this._eventBus.fire("canvas.destroy", {
    svg: this._svg,
    viewport: this._viewport
  });
  const parent = this._container.parentNode;
  if (parent) {
    parent.removeChild(this._container);
  }
  delete this._svg;
  delete this._container;
  delete this._layers;
  delete this._planes;
  delete this._rootElement;
  delete this._viewport;
};
Canvas.prototype._setFocused = function(focused) {
  if (focused == this._focused) {
    return;
  }
  this._focused = focused;
  this._eventBus.fire("canvas.focus.changed", { focused });
};
Canvas.prototype._clear = function() {
  const allElements = this._elementRegistry.getAll();
  allElements.forEach((element) => {
    const type = getType(element);
    if (type === "root") {
      this.removeRootElement(element);
    } else {
      this._removeElement(element, type);
    }
  });
  this._planes = [];
  this._rootElement = null;
  delete this._cachedViewbox;
};
Canvas.prototype.focus = function() {
  this._svg.focus({ preventScroll: true });
  this._setFocused(true);
};
Canvas.prototype.restoreFocus = function() {
  if (document.activeElement === document.body) {
    this.focus();
  }
};
Canvas.prototype.isFocused = function() {
  return this._focused;
};
Canvas.prototype.getDefaultLayer = function() {
  return this.getLayer(BASE_LAYER, PLANE_LAYER_INDEX);
};
Canvas.prototype.getLayer = function(name2, index5) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  let layer = this._layers[name2];
  if (!layer) {
    layer = this._layers[name2] = this._createLayer(name2, index5);
  }
  if (typeof index5 !== "undefined" && layer.index !== index5) {
    throw new Error("layer <" + name2 + "> already created at index <" + index5 + ">");
  }
  return layer.group;
};
Canvas.prototype._getChildIndex = function(index5) {
  return reduce(this._layers, function(childIndex, layer) {
    if (layer.visible && index5 >= layer.index) {
      childIndex++;
    }
    return childIndex;
  }, 0);
};
Canvas.prototype._createLayer = function(name2, index5) {
  if (typeof index5 === "undefined") {
    index5 = UTILITY_LAYER_INDEX;
  }
  const childIndex = this._getChildIndex(index5);
  return {
    group: createGroup(this._viewport, "layer-" + name2, childIndex),
    index: index5,
    visible: true
  };
};
Canvas.prototype.showLayer = function(name2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  const layer = this._layers[name2];
  if (!layer) {
    throw new Error("layer <" + name2 + "> does not exist");
  }
  const viewport = this._viewport;
  const group = layer.group;
  const index5 = layer.index;
  if (layer.visible) {
    return group;
  }
  const childIndex = this._getChildIndex(index5);
  viewport.insertBefore(group, viewport.childNodes[childIndex] || null);
  layer.visible = true;
  return group;
};
Canvas.prototype.hideLayer = function(name2) {
  if (!name2) {
    throw new Error("must specify a name");
  }
  const layer = this._layers[name2];
  if (!layer) {
    throw new Error("layer <" + name2 + "> does not exist");
  }
  const group = layer.group;
  if (!layer.visible) {
    return group;
  }
  remove(group);
  layer.visible = false;
  return group;
};
Canvas.prototype._removeLayer = function(name2) {
  const layer = this._layers[name2];
  if (layer) {
    delete this._layers[name2];
    remove(layer.group);
  }
};
Canvas.prototype.getActiveLayer = function() {
  const plane = this._findPlaneForRoot(this.getRootElement());
  if (!plane) {
    return null;
  }
  return plane.layer;
};
Canvas.prototype.findRoot = function(element) {
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  if (!element) {
    return;
  }
  const plane = this._findPlaneForRoot(
    findRoot(element)
  ) || {};
  return plane.rootElement;
};
Canvas.prototype.getRootElements = function() {
  return this._planes.map(function(plane) {
    return plane.rootElement;
  });
};
Canvas.prototype._findPlaneForRoot = function(rootElement) {
  return find(this._planes, function(plane) {
    return plane.rootElement === rootElement;
  });
};
Canvas.prototype.getContainer = function() {
  return this._container;
};
Canvas.prototype._updateMarker = function(element, marker, add5) {
  let container;
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  element.markers = element.markers || /* @__PURE__ */ new Set();
  container = this._elementRegistry._elements[element.id];
  if (!container) {
    return;
  }
  forEach([container.gfx, container.secondaryGfx], function(gfx) {
    if (gfx) {
      if (add5) {
        element.markers.add(marker);
        classes(gfx).add(marker);
      } else {
        element.markers.delete(marker);
        classes(gfx).remove(marker);
      }
    }
  });
  this._eventBus.fire("element.marker.update", { element, gfx: container.gfx, marker, add: !!add5 });
};
Canvas.prototype.addMarker = function(element, marker) {
  this._updateMarker(element, marker, true);
};
Canvas.prototype.removeMarker = function(element, marker) {
  this._updateMarker(element, marker, false);
};
Canvas.prototype.hasMarker = function(element, marker) {
  if (!element.id) {
    element = this._elementRegistry.get(element);
  }
  if (!element.markers) {
    return false;
  }
  return element.markers.has(marker);
};
Canvas.prototype.toggleMarker = function(element, marker) {
  if (this.hasMarker(element, marker)) {
    this.removeMarker(element, marker);
  } else {
    this.addMarker(element, marker);
  }
};
Canvas.prototype.getRootElement = function() {
  const rootElement = this._rootElement;
  if (rootElement || this._planes.length) {
    return rootElement;
  }
  return this.setRootElement(this.addRootElement(null));
};
Canvas.prototype.addRootElement = function(rootElement) {
  const idx = this._rootsIdx++;
  if (!rootElement) {
    rootElement = {
      id: "__implicitroot_" + idx,
      children: [],
      isImplicit: true
    };
  }
  const layerName = rootElement.layer = "root-" + idx;
  this._ensureValid("root", rootElement);
  const layer = this.getLayer(layerName, PLANE_LAYER_INDEX);
  this.hideLayer(layerName);
  this._addRoot(rootElement, layer);
  this._planes.push({
    rootElement,
    layer
  });
  return rootElement;
};
Canvas.prototype.removeRootElement = function(rootElement) {
  if (typeof rootElement === "string") {
    rootElement = this._elementRegistry.get(rootElement);
  }
  const plane = this._findPlaneForRoot(rootElement);
  if (!plane) {
    return;
  }
  this._removeRoot(rootElement);
  this._removeLayer(rootElement.layer);
  this._planes = this._planes.filter(function(plane2) {
    return plane2.rootElement !== rootElement;
  });
  if (this._rootElement === rootElement) {
    this._rootElement = null;
  }
  return rootElement;
};
Canvas.prototype.setRootElement = function(rootElement) {
  if (rootElement === this._rootElement) {
    return rootElement;
  }
  let plane;
  if (!rootElement) {
    throw new Error("rootElement required");
  }
  plane = this._findPlaneForRoot(rootElement);
  if (!plane) {
    rootElement = this.addRootElement(rootElement);
  }
  this._setRoot(rootElement);
  return rootElement;
};
Canvas.prototype._removeRoot = function(element) {
  const elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  eventBus.fire("root.remove", { element });
  eventBus.fire("root.removed", { element });
  elementRegistry.remove(element);
};
Canvas.prototype._addRoot = function(element, gfx) {
  const elementRegistry = this._elementRegistry, eventBus = this._eventBus;
  eventBus.fire("root.add", { element });
  elementRegistry.add(element, gfx);
  eventBus.fire("root.added", { element, gfx });
};
Canvas.prototype._setRoot = function(rootElement, layer) {
  const currentRoot = this._rootElement;
  if (currentRoot) {
    this._elementRegistry.updateGraphics(currentRoot, null, true);
    this.hideLayer(currentRoot.layer);
  }
  if (rootElement) {
    if (!layer) {
      layer = this._findPlaneForRoot(rootElement).layer;
    }
    this._elementRegistry.updateGraphics(rootElement, this._svg, true);
    this.showLayer(rootElement.layer);
  }
  this._rootElement = rootElement;
  this._eventBus.fire("root.set", { element: rootElement });
};
Canvas.prototype._ensureValid = function(type, element) {
  if (!element.id) {
    throw new Error("element must have an id");
  }
  if (this._elementRegistry.get(element.id)) {
    throw new Error("element <" + element.id + "> already exists");
  }
  const requiredAttrs = REQUIRED_MODEL_ATTRS[type];
  const valid = every(requiredAttrs, function(attr3) {
    return typeof element[attr3] !== "undefined";
  });
  if (!valid) {
    throw new Error(
      "must supply { " + requiredAttrs.join(", ") + " } with " + type
    );
  }
};
Canvas.prototype._setParent = function(element, parent, parentIndex) {
  add2(parent.children, element, parentIndex);
  element.parent = parent;
};
Canvas.prototype._addElement = function(type, element, parent, parentIndex) {
  parent = parent || this.getRootElement();
  const eventBus = this._eventBus, graphicsFactory = this._graphicsFactory;
  this._ensureValid(type, element);
  eventBus.fire(type + ".add", { element, parent });
  this._setParent(element, parent, parentIndex);
  const gfx = graphicsFactory.create(type, element, parentIndex);
  this._elementRegistry.add(element, gfx);
  graphicsFactory.update(type, element, gfx);
  eventBus.fire(type + ".added", { element, gfx });
  return element;
};
Canvas.prototype.addShape = function(shape, parent, parentIndex) {
  return this._addElement("shape", shape, parent, parentIndex);
};
Canvas.prototype.addConnection = function(connection, parent, parentIndex) {
  return this._addElement("connection", connection, parent, parentIndex);
};
Canvas.prototype._removeElement = function(element, type) {
  const elementRegistry = this._elementRegistry, graphicsFactory = this._graphicsFactory, eventBus = this._eventBus;
  element = elementRegistry.get(element.id || element);
  if (!element) {
    return;
  }
  eventBus.fire(type + ".remove", { element });
  graphicsFactory.remove(element);
  remove3(element.parent && element.parent.children, element);
  element.parent = null;
  eventBus.fire(type + ".removed", { element });
  elementRegistry.remove(element);
  return element;
};
Canvas.prototype.removeShape = function(shape) {
  return this._removeElement(shape, "shape");
};
Canvas.prototype.removeConnection = function(connection) {
  return this._removeElement(connection, "connection");
};
Canvas.prototype.getGraphics = function(element, secondary) {
  return this._elementRegistry.getGraphics(element, secondary);
};
Canvas.prototype._changeViewbox = function(changeFn) {
  this._eventBus.fire("canvas.viewbox.changing");
  changeFn.apply(this);
  this._cachedViewbox = null;
  this._viewboxChanged();
};
Canvas.prototype._viewboxChanged = function() {
  this._eventBus.fire("canvas.viewbox.changed", { viewbox: this.viewbox() });
};
Canvas.prototype.viewbox = function(box) {
  if (box === void 0 && this._cachedViewbox) {
    return structuredClone(this._cachedViewbox);
  }
  const viewport = this._viewport, outerBox = this.getSize();
  let innerBox, matrix, activeLayer, transform4, scale, x6, y5;
  if (!box) {
    activeLayer = this._rootElement ? this.getActiveLayer() : null;
    innerBox = activeLayer && activeLayer.getBBox() || {};
    transform4 = transform(viewport);
    matrix = transform4 ? transform4.matrix : createMatrix();
    scale = round(matrix.a, 1e3);
    x6 = round(-matrix.e || 0, 1e3);
    y5 = round(-matrix.f || 0, 1e3);
    box = this._cachedViewbox = {
      x: x6 ? x6 / scale : 0,
      y: y5 ? y5 / scale : 0,
      width: outerBox.width / scale,
      height: outerBox.height / scale,
      scale,
      inner: {
        width: innerBox.width || 0,
        height: innerBox.height || 0,
        x: innerBox.x || 0,
        y: innerBox.y || 0
      },
      outer: outerBox
    };
    return box;
  } else {
    this._changeViewbox(function() {
      scale = Math.min(outerBox.width / box.width, outerBox.height / box.height);
      const matrix2 = this._svg.createSVGMatrix().scale(scale).translate(-box.x, -box.y);
      transform(viewport, matrix2);
    });
  }
  return box;
};
Canvas.prototype.scroll = function(delta2) {
  const node2 = this._viewport;
  let matrix = node2.getCTM();
  if (delta2) {
    this._changeViewbox(function() {
      delta2 = assign({ dx: 0, dy: 0 }, delta2 || {});
      matrix = this._svg.createSVGMatrix().translate(delta2.dx, delta2.dy).multiply(matrix);
      setCTM(node2, matrix);
    });
  }
  return { x: matrix.e, y: matrix.f };
};
Canvas.prototype.scrollToElement = function(element, padding) {
  let defaultPadding = 100;
  if (typeof element === "string") {
    element = this._elementRegistry.get(element);
  }
  const rootElement = this.findRoot(element);
  if (rootElement !== this.getRootElement()) {
    this.setRootElement(rootElement);
  }
  if (rootElement === element) {
    return;
  }
  if (!padding) {
    padding = {};
  }
  if (typeof padding === "number") {
    defaultPadding = padding;
  }
  padding = {
    top: padding.top || defaultPadding,
    right: padding.right || defaultPadding,
    bottom: padding.bottom || defaultPadding,
    left: padding.left || defaultPadding
  };
  const elementBounds = getBBox(element), elementTrbl = asTRBL(elementBounds), viewboxBounds = this.viewbox(), zoom2 = this.zoom();
  let dx, dy;
  viewboxBounds.y += padding.top / zoom2;
  viewboxBounds.x += padding.left / zoom2;
  viewboxBounds.width -= (padding.right + padding.left) / zoom2;
  viewboxBounds.height -= (padding.bottom + padding.top) / zoom2;
  const viewboxTrbl = asTRBL(viewboxBounds);
  const canFit = elementBounds.width < viewboxBounds.width && elementBounds.height < viewboxBounds.height;
  if (!canFit) {
    dx = elementBounds.x - viewboxBounds.x;
    dy = elementBounds.y - viewboxBounds.y;
  } else {
    const dRight = Math.max(0, elementTrbl.right - viewboxTrbl.right), dLeft = Math.min(0, elementTrbl.left - viewboxTrbl.left), dBottom = Math.max(0, elementTrbl.bottom - viewboxTrbl.bottom), dTop = Math.min(0, elementTrbl.top - viewboxTrbl.top);
    dx = dRight || dLeft;
    dy = dBottom || dTop;
  }
  this.scroll({ dx: -dx * zoom2, dy: -dy * zoom2 });
};
Canvas.prototype.zoom = function(newScale, center2) {
  if (!newScale) {
    return this.viewbox(newScale).scale;
  }
  if (newScale === "fit-viewport") {
    return this._fitViewport(center2);
  }
  let outer, matrix;
  this._changeViewbox(function() {
    if (typeof center2 !== "object") {
      outer = this.viewbox().outer;
      center2 = {
        x: outer.width / 2,
        y: outer.height / 2
      };
    }
    matrix = this._setZoom(newScale, center2);
  });
  return round(matrix.a, 1e3);
};
function setCTM(node2, m6) {
  const mstr = "matrix(" + m6.a + "," + m6.b + "," + m6.c + "," + m6.d + "," + m6.e + "," + m6.f + ")";
  node2.setAttribute("transform", mstr);
}
Canvas.prototype._fitViewport = function(center2) {
  const vbox = this.viewbox(), outer = vbox.outer, inner = vbox.inner;
  let newScale, newViewbox;
  if (inner.x >= 0 && inner.y >= 0 && inner.x + inner.width <= outer.width && inner.y + inner.height <= outer.height && !center2) {
    newViewbox = {
      x: 0,
      y: 0,
      width: Math.max(inner.width + inner.x, outer.width),
      height: Math.max(inner.height + inner.y, outer.height)
    };
  } else {
    newScale = Math.min(1, outer.width / inner.width, outer.height / inner.height);
    newViewbox = {
      x: inner.x + (center2 ? inner.width / 2 - outer.width / newScale / 2 : 0),
      y: inner.y + (center2 ? inner.height / 2 - outer.height / newScale / 2 : 0),
      width: outer.width / newScale,
      height: outer.height / newScale
    };
  }
  this.viewbox(newViewbox);
  return this.viewbox(false).scale;
};
Canvas.prototype._setZoom = function(scale, center2) {
  const svg = this._svg, viewport = this._viewport;
  const matrix = svg.createSVGMatrix();
  const point = svg.createSVGPoint();
  let centerPoint, originalPoint, currentMatrix, scaleMatrix, newMatrix;
  currentMatrix = viewport.getCTM();
  const currentScale = currentMatrix.a;
  if (center2) {
    centerPoint = assign(point, center2);
    originalPoint = centerPoint.matrixTransform(currentMatrix.inverse());
    scaleMatrix = matrix.translate(originalPoint.x, originalPoint.y).scale(1 / currentScale * scale).translate(-originalPoint.x, -originalPoint.y);
    newMatrix = currentMatrix.multiply(scaleMatrix);
  } else {
    newMatrix = matrix.scale(scale);
  }
  setCTM(this._viewport, newMatrix);
  return newMatrix;
};
Canvas.prototype.getSize = function() {
  return {
    width: this._container.clientWidth,
    height: this._container.clientHeight
  };
};
Canvas.prototype.getAbsoluteBBox = function(element) {
  const vbox = this.viewbox();
  let bbox;
  if (element.waypoints) {
    const gfx = this.getGraphics(element);
    bbox = gfx.getBBox();
  } else {
    bbox = element;
  }
  const x6 = bbox.x * vbox.scale - vbox.x * vbox.scale;
  const y5 = bbox.y * vbox.scale - vbox.y * vbox.scale;
  const width = bbox.width * vbox.scale;
  const height = bbox.height * vbox.scale;
  return {
    x: x6,
    y: y5,
    width,
    height
  };
};
Canvas.prototype.resized = function() {
  delete this._cachedViewbox;
  this._eventBus.fire("canvas.resized");
};

// node_modules/diagram-js/lib/core/ElementRegistry.js
var ELEMENT_ID = "data-element-id";
function ElementRegistry(eventBus) {
  this._elements = {};
  this._eventBus = eventBus;
}
ElementRegistry.$inject = ["eventBus"];
ElementRegistry.prototype.add = function(element, gfx, secondaryGfx) {
  var id = element.id;
  this._validateId(id);
  attr(gfx, ELEMENT_ID, id);
  if (secondaryGfx) {
    attr(secondaryGfx, ELEMENT_ID, id);
  }
  this._elements[id] = { element, gfx, secondaryGfx };
};
ElementRegistry.prototype.remove = function(element) {
  var elements = this._elements, id = element.id || element, container = id && elements[id];
  if (container) {
    attr(container.gfx, ELEMENT_ID, "");
    if (container.secondaryGfx) {
      attr(container.secondaryGfx, ELEMENT_ID, "");
    }
    delete elements[id];
  }
};
ElementRegistry.prototype.updateId = function(element, newId) {
  this._validateId(newId);
  if (typeof element === "string") {
    element = this.get(element);
  }
  this._eventBus.fire("element.updateId", {
    element,
    newId
  });
  var gfx = this.getGraphics(element), secondaryGfx = this.getGraphics(element, true);
  this.remove(element);
  element.id = newId;
  this.add(element, gfx, secondaryGfx);
};
ElementRegistry.prototype.updateGraphics = function(filter2, gfx, secondary) {
  var id = filter2.id || filter2;
  var container = this._elements[id];
  if (secondary) {
    container.secondaryGfx = gfx;
  } else {
    container.gfx = gfx;
  }
  if (gfx) {
    attr(gfx, ELEMENT_ID, id);
  }
  return gfx;
};
ElementRegistry.prototype.get = function(filter2) {
  var id;
  if (typeof filter2 === "string") {
    id = filter2;
  } else {
    id = filter2 && attr(filter2, ELEMENT_ID);
  }
  var container = this._elements[id];
  return container && container.element;
};
ElementRegistry.prototype.filter = function(fn2) {
  var filtered = [];
  this.forEach(function(element, gfx) {
    if (fn2(element, gfx)) {
      filtered.push(element);
    }
  });
  return filtered;
};
ElementRegistry.prototype.find = function(fn2) {
  var map4 = this._elements, keys2 = Object.keys(map4);
  for (var i7 = 0; i7 < keys2.length; i7++) {
    var id = keys2[i7], container = map4[id], element = container.element, gfx = container.gfx;
    if (fn2(element, gfx)) {
      return element;
    }
  }
};
ElementRegistry.prototype.getAll = function() {
  return this.filter(function(e8) {
    return e8;
  });
};
ElementRegistry.prototype.forEach = function(fn2) {
  var map4 = this._elements;
  Object.keys(map4).forEach(function(id) {
    var container = map4[id], element = container.element, gfx = container.gfx;
    return fn2(element, gfx);
  });
};
ElementRegistry.prototype.getGraphics = function(filter2, secondary) {
  var id = filter2.id || filter2;
  var container = this._elements[id];
  return container && (secondary ? container.secondaryGfx : container.gfx);
};
ElementRegistry.prototype._validateId = function(id) {
  if (!id) {
    throw new Error("element must have an id");
  }
  if (this._elements[id]) {
    throw new Error("element with id " + id + " already added");
  }
};

// node_modules/object-refs/dist/index.js
function extend2(collection, refs, property, target) {
  var inverseProperty = property.inverse;
  Object.defineProperty(collection, "remove", {
    value: function(element) {
      var idx = this.indexOf(element);
      if (idx !== -1) {
        this.splice(idx, 1);
        refs.unset(element, inverseProperty, target);
      }
      return element;
    }
  });
  Object.defineProperty(collection, "contains", {
    value: function(element) {
      return this.indexOf(element) !== -1;
    }
  });
  Object.defineProperty(collection, "add", {
    value: function(element, idx) {
      var currentIdx = this.indexOf(element);
      if (typeof idx === "undefined") {
        if (currentIdx !== -1) {
          return;
        }
        idx = this.length;
      }
      if (currentIdx !== -1) {
        this.splice(currentIdx, 1);
      }
      this.splice(idx, 0, element);
      if (currentIdx === -1) {
        refs.set(element, inverseProperty, target);
      }
    }
  });
  Object.defineProperty(collection, "__refs_collection", {
    value: true
  });
  return collection;
}
function isExtended(collection) {
  return collection.__refs_collection === true;
}
function hasOwnProperty(e8, property) {
  return Object.prototype.hasOwnProperty.call(e8, property.name || property);
}
function defineCollectionProperty(ref, property, target) {
  var collection = extend2(target[property.name] || [], ref, property, target);
  Object.defineProperty(target, property.name, {
    enumerable: property.enumerable,
    value: collection
  });
  if (collection.length) {
    collection.forEach(function(o5) {
      ref.set(o5, property.inverse, target);
    });
  }
}
function defineProperty(ref, property, target) {
  var inverseProperty = property.inverse;
  var _value = target[property.name];
  Object.defineProperty(target, property.name, {
    configurable: property.configurable,
    enumerable: property.enumerable,
    get: function() {
      return _value;
    },
    set: function(value) {
      if (value === _value) {
        return;
      }
      var old = _value;
      _value = null;
      if (old) {
        ref.unset(old, inverseProperty, target);
      }
      _value = value;
      ref.set(_value, inverseProperty, target);
    }
  });
}
function Refs(a6, b4) {
  if (!(this instanceof Refs)) {
    return new Refs(a6, b4);
  }
  a6.inverse = b4;
  b4.inverse = a6;
  this.props = {};
  this.props[a6.name] = a6;
  this.props[b4.name] = b4;
}
Refs.prototype.bind = function(target, property) {
  if (typeof property === "string") {
    if (!this.props[property]) {
      throw new Error("no property <" + property + "> in ref");
    }
    property = this.props[property];
  }
  if (property.collection) {
    defineCollectionProperty(this, property, target);
  } else {
    defineProperty(this, property, target);
  }
};
Refs.prototype.ensureRefsCollection = function(target, property) {
  var collection = target[property.name];
  if (!isExtended(collection)) {
    defineCollectionProperty(this, property, target);
  }
  return collection;
};
Refs.prototype.ensureBound = function(target, property) {
  if (!hasOwnProperty(target, property)) {
    this.bind(target, property);
  }
};
Refs.prototype.unset = function(target, property, value) {
  if (target) {
    this.ensureBound(target, property);
    if (property.collection) {
      this.ensureRefsCollection(target, property).remove(value);
    } else {
      target[property.name] = void 0;
    }
  }
};
Refs.prototype.set = function(target, property, value) {
  if (target) {
    this.ensureBound(target, property);
    if (property.collection) {
      this.ensureRefsCollection(target, property).add(value);
    } else {
      target[property.name] = value;
    }
  }
};

// node_modules/diagram-js/lib/model/index.js
var parentRefs = new Refs({ name: "children", enumerable: true, collection: true }, { name: "parent" });
var labelRefs = new Refs({ name: "labels", enumerable: true, collection: true }, { name: "labelTarget" });
var attacherRefs = new Refs({ name: "attachers", collection: true }, { name: "host" });
var outgoingRefs = new Refs({ name: "outgoing", collection: true }, { name: "source" });
var incomingRefs = new Refs({ name: "incoming", collection: true }, { name: "target" });
function ElementImpl() {
  Object.defineProperty(this, "businessObject", {
    writable: true
  });
  Object.defineProperty(this, "label", {
    get: function() {
      return this.labels[0];
    },
    set: function(newLabel) {
      var label = this.label, labels = this.labels;
      if (!newLabel && label) {
        labels.remove(label);
      } else {
        labels.add(newLabel, 0);
      }
    }
  });
  parentRefs.bind(this, "parent");
  labelRefs.bind(this, "labels");
  outgoingRefs.bind(this, "outgoing");
  incomingRefs.bind(this, "incoming");
}
function ShapeImpl() {
  ElementImpl.call(this);
  parentRefs.bind(this, "children");
  attacherRefs.bind(this, "host");
  attacherRefs.bind(this, "attachers");
}
e(ShapeImpl, ElementImpl);
function RootImpl() {
  ElementImpl.call(this);
  parentRefs.bind(this, "children");
}
e(RootImpl, ShapeImpl);
function LabelImpl() {
  ShapeImpl.call(this);
  labelRefs.bind(this, "labelTarget");
}
e(LabelImpl, ShapeImpl);
function ConnectionImpl() {
  ElementImpl.call(this);
  outgoingRefs.bind(this, "source");
  incomingRefs.bind(this, "target");
}
e(ConnectionImpl, ElementImpl);
var types = {
  connection: ConnectionImpl,
  shape: ShapeImpl,
  label: LabelImpl,
  root: RootImpl
};
function create2(type, attrs) {
  var Type3 = types[type];
  if (!Type3) {
    throw new Error("unknown type: <" + type + ">");
  }
  return assign(new Type3(), attrs);
}
function isModelElement(obj) {
  return obj instanceof ElementImpl;
}

// node_modules/diagram-js/lib/core/ElementFactory.js
function ElementFactory() {
  this._uid = 12;
}
ElementFactory.prototype.createRoot = function(attrs) {
  return this.create("root", attrs);
};
ElementFactory.prototype.createLabel = function(attrs) {
  return this.create("label", attrs);
};
ElementFactory.prototype.createShape = function(attrs) {
  return this.create("shape", attrs);
};
ElementFactory.prototype.createConnection = function(attrs) {
  return this.create("connection", attrs);
};
ElementFactory.prototype.create = function(type, attrs) {
  attrs = assign({}, attrs || {});
  if (!attrs.id) {
    attrs.id = type + "_" + this._uid++;
  }
  return create2(type, attrs);
};

// node_modules/diagram-js/lib/core/EventBus.js
var FN_REF = "__fn";
var DEFAULT_PRIORITY2 = 1e3;
var slice2 = Array.prototype.slice;
function EventBus() {
  this._listeners = {};
  this.on("diagram.destroy", 1, this._destroy, this);
}
EventBus.prototype.on = function(events, priority, callback, that) {
  events = isArray(events) ? events : [events];
  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY2;
  }
  if (!isNumber(priority)) {
    throw new Error("priority must be a number");
  }
  var actualCallback = callback;
  if (that) {
    actualCallback = bind(callback, that);
    actualCallback[FN_REF] = callback[FN_REF] || callback;
  }
  var self2 = this;
  events.forEach(function(e8) {
    self2._addListener(e8, {
      priority,
      callback: actualCallback,
      next: null
    });
  });
};
EventBus.prototype.once = function(events, priority, callback, that) {
  var self2 = this;
  if (isFunction(priority)) {
    that = callback;
    callback = priority;
    priority = DEFAULT_PRIORITY2;
  }
  if (!isNumber(priority)) {
    throw new Error("priority must be a number");
  }
  function wrappedCallback() {
    wrappedCallback.__isTomb = true;
    var result = callback.apply(that, arguments);
    self2.off(events, wrappedCallback);
    return result;
  }
  wrappedCallback[FN_REF] = callback;
  this.on(events, priority, wrappedCallback);
};
EventBus.prototype.off = function(events, callback) {
  events = isArray(events) ? events : [events];
  var self2 = this;
  events.forEach(function(event2) {
    self2._removeListener(event2, callback);
  });
};
EventBus.prototype.createEvent = function(data) {
  var event2 = new InternalEvent();
  event2.init(data);
  return event2;
};
EventBus.prototype.fire = function(type, data) {
  var event2, firstListener, returnValue, args;
  args = slice2.call(arguments);
  if (typeof type === "object") {
    data = type;
    type = data.type;
  }
  if (!type) {
    throw new Error("no event type specified");
  }
  firstListener = this._listeners[type];
  if (!firstListener) {
    return;
  }
  if (data instanceof InternalEvent) {
    event2 = data;
  } else {
    event2 = this.createEvent(data);
  }
  args[0] = event2;
  var originalType = event2.type;
  if (type !== originalType) {
    event2.type = type;
  }
  try {
    returnValue = this._invokeListeners(event2, args, firstListener);
  } finally {
    if (type !== originalType) {
      event2.type = originalType;
    }
  }
  if (returnValue === void 0 && event2.defaultPrevented) {
    returnValue = false;
  }
  return returnValue;
};
EventBus.prototype.handleError = function(error4) {
  return this.fire("error", { error: error4 }) === false;
};
EventBus.prototype._destroy = function() {
  this._listeners = {};
};
EventBus.prototype._invokeListeners = function(event2, args, listener) {
  var returnValue;
  while (listener) {
    if (event2.cancelBubble) {
      break;
    }
    returnValue = this._invokeListener(event2, args, listener);
    listener = listener.next;
  }
  return returnValue;
};
EventBus.prototype._invokeListener = function(event2, args, listener) {
  var returnValue;
  if (listener.callback.__isTomb) {
    return returnValue;
  }
  try {
    returnValue = invokeFunction(listener.callback, args);
    if (returnValue !== void 0) {
      event2.returnValue = returnValue;
      event2.stopPropagation();
    }
    if (returnValue === false) {
      event2.preventDefault();
    }
  } catch (error4) {
    if (!this.handleError(error4)) {
      console.error("unhandled error in event listener", error4);
      throw error4;
    }
  }
  return returnValue;
};
EventBus.prototype._addListener = function(event2, newListener) {
  var listener = this._getListeners(event2), previousListener;
  if (!listener) {
    this._setListeners(event2, newListener);
    return;
  }
  while (listener) {
    if (listener.priority < newListener.priority) {
      newListener.next = listener;
      if (previousListener) {
        previousListener.next = newListener;
      } else {
        this._setListeners(event2, newListener);
      }
      return;
    }
    previousListener = listener;
    listener = listener.next;
  }
  previousListener.next = newListener;
};
EventBus.prototype._getListeners = function(name2) {
  return this._listeners[name2];
};
EventBus.prototype._setListeners = function(name2, listener) {
  this._listeners[name2] = listener;
};
EventBus.prototype._removeListener = function(event2, callback) {
  var listener = this._getListeners(event2), nextListener, previousListener, listenerCallback;
  if (!callback) {
    this._setListeners(event2, null);
    return;
  }
  while (listener) {
    nextListener = listener.next;
    listenerCallback = listener.callback;
    if (listenerCallback === callback || listenerCallback[FN_REF] === callback) {
      if (previousListener) {
        previousListener.next = nextListener;
      } else {
        this._setListeners(event2, nextListener);
      }
    }
    previousListener = listener;
    listener = nextListener;
  }
};
function InternalEvent() {
}
InternalEvent.prototype.stopPropagation = function() {
  this.cancelBubble = true;
};
InternalEvent.prototype.preventDefault = function() {
  this.defaultPrevented = true;
};
InternalEvent.prototype.init = function(data) {
  assign(this, data || {});
};
function invokeFunction(fn2, args) {
  return fn2.apply(null, args);
}

// node_modules/diagram-js/lib/util/GraphicsUtil.js
function getVisual(gfx) {
  return gfx.childNodes[0];
}
function getChildren(gfx) {
  return gfx.parentNode.childNodes[1];
}

// node_modules/diagram-js/lib/core/GraphicsFactory.js
function GraphicsFactory(eventBus, elementRegistry) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
}
GraphicsFactory.$inject = ["eventBus", "elementRegistry"];
GraphicsFactory.prototype._getChildrenContainer = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  var childrenGfx;
  if (!element.parent) {
    childrenGfx = gfx;
  } else {
    childrenGfx = getChildren(gfx);
    if (!childrenGfx) {
      childrenGfx = create("g");
      classes(childrenGfx).add("djs-children");
      append(gfx.parentNode, childrenGfx);
    }
  }
  return childrenGfx;
};
GraphicsFactory.prototype._clear = function(gfx) {
  var visual = getVisual(gfx);
  clear2(visual);
  return visual;
};
GraphicsFactory.prototype._createContainer = function(type, childrenGfx, parentIndex, isFrame) {
  var outerGfx = create("g");
  classes(outerGfx).add("djs-group");
  if (typeof parentIndex !== "undefined") {
    prependTo(outerGfx, childrenGfx, childrenGfx.childNodes[parentIndex]);
  } else {
    append(childrenGfx, outerGfx);
  }
  var gfx = create("g");
  classes(gfx).add("djs-element");
  classes(gfx).add("djs-" + type);
  if (isFrame) {
    classes(gfx).add("djs-frame");
  }
  append(outerGfx, gfx);
  var visual = create("g");
  classes(visual).add("djs-visual");
  append(gfx, visual);
  return gfx;
};
GraphicsFactory.prototype.create = function(type, element, parentIndex) {
  var childrenGfx = this._getChildrenContainer(element.parent);
  return this._createContainer(type, childrenGfx, parentIndex, isFrameElement2(element));
};
GraphicsFactory.prototype.updateContainments = function(elements) {
  var self2 = this, elementRegistry = this._elementRegistry, parents;
  parents = reduce(elements, function(map4, e8) {
    if (e8.parent) {
      map4[e8.parent.id] = e8.parent;
    }
    return map4;
  }, {});
  forEach(parents, function(parent) {
    var children = parent.children;
    if (!children) {
      return;
    }
    var childrenGfx = self2._getChildrenContainer(parent);
    forEach(children.slice().reverse(), function(child) {
      var childGfx = elementRegistry.getGraphics(child);
      prependTo(childGfx.parentNode, childrenGfx);
    });
  });
};
GraphicsFactory.prototype.drawShape = function(visual, element, attrs = {}) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.shape", { gfx: visual, element, attrs });
};
GraphicsFactory.prototype.getShapePath = function(element) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getShapePath", element);
};
GraphicsFactory.prototype.drawConnection = function(visual, element, attrs = {}) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.connection", { gfx: visual, element, attrs });
};
GraphicsFactory.prototype.getConnectionPath = function(connection) {
  var eventBus = this._eventBus;
  return eventBus.fire("render.getConnectionPath", connection);
};
GraphicsFactory.prototype.update = function(type, element, gfx) {
  if (!element.parent) {
    return;
  }
  var visual = this._clear(gfx);
  if (type === "shape") {
    this.drawShape(visual, element);
    translate(gfx, element.x, element.y);
  } else if (type === "connection") {
    this.drawConnection(visual, element);
  } else {
    throw new Error("unknown type: " + type);
  }
  if (element.hidden) {
    attr(gfx, "display", "none");
  } else {
    attr(gfx, "display", "block");
  }
};
GraphicsFactory.prototype.remove = function(element) {
  var gfx = this._elementRegistry.getGraphics(element);
  remove(gfx.parentNode);
};
function prependTo(newNode, parentNode, siblingNode) {
  var node2 = siblingNode || parentNode.firstChild;
  if (newNode === node2) {
    return;
  }
  parentNode.insertBefore(newNode, node2);
}

// node_modules/diagram-js/lib/core/index.js
var core_default2 = {
  __depends__: [draw_default2],
  __init__: ["canvas"],
  canvas: ["type", Canvas],
  elementRegistry: ["type", ElementRegistry],
  elementFactory: ["type", ElementFactory],
  eventBus: ["type", EventBus],
  graphicsFactory: ["type", GraphicsFactory]
};

// node_modules/diagram-js/lib/Diagram.js
function bootstrap(modules) {
  var injector = new Injector(modules);
  injector.init();
  return injector;
}
function createInjector(options) {
  options = options || {};
  var configModule = {
    "config": ["value", options]
  };
  var modules = [configModule, core_default2].concat(options.modules || []);
  return bootstrap(modules);
}
function Diagram(options, injector) {
  this._injector = injector || createInjector(options);
  this.get("eventBus").fire("diagram.init");
}
Diagram.prototype.get = function(name2, strict) {
  return this._injector.get(name2, strict);
};
Diagram.prototype.invoke = function(func, context, locals) {
  return this._injector.invoke(func, context, locals);
};
Diagram.prototype.destroy = function() {
  this.get("eventBus").fire("diagram.destroy");
};
Diagram.prototype.clear = function() {
  this.get("eventBus").fire("diagram.clear");
};

// node_modules/moddle/dist/index.js
function Base() {
}
Base.prototype.get = function(name2) {
  return this.$model.properties.get(this, name2);
};
Base.prototype.set = function(name2, value) {
  this.$model.properties.set(this, name2, value);
};
function Factory(model, properties) {
  this.model = model;
  this.properties = properties;
}
Factory.prototype.createType = function(descriptor) {
  var model = this.model;
  var props = this.properties, prototype = Object.create(Base.prototype);
  forEach(descriptor.properties, function(p5) {
    if (!p5.isMany && p5.default !== void 0) {
      prototype[p5.name] = p5.default;
    }
  });
  props.defineModel(prototype, model);
  props.defineDescriptor(prototype, descriptor);
  var name2 = descriptor.ns.name;
  function ModdleElement(attrs) {
    props.define(this, "$type", { value: name2, enumerable: true });
    props.define(this, "$attrs", { value: {} });
    props.define(this, "$parent", { writable: true });
    forEach(attrs, bind(function(val, key) {
      this.set(key, val);
    }, this));
  }
  ModdleElement.prototype = prototype;
  ModdleElement.hasType = prototype.$instanceOf = this.model.hasType;
  props.defineModel(ModdleElement, model);
  props.defineDescriptor(ModdleElement, descriptor);
  return ModdleElement;
};
var BUILTINS = {
  String: true,
  Boolean: true,
  Integer: true,
  Real: true,
  Element: true
};
var TYPE_CONVERTERS = {
  String: function(s5) {
    return s5;
  },
  Boolean: function(s5) {
    return s5 === "true";
  },
  Integer: function(s5) {
    return parseInt(s5, 10);
  },
  Real: function(s5) {
    return parseFloat(s5);
  }
};
function coerceType(type, value) {
  var converter = TYPE_CONVERTERS[type];
  if (converter) {
    return converter(value);
  } else {
    return value;
  }
}
function isBuiltIn(type) {
  return !!BUILTINS[type];
}
function isSimple(type) {
  return !!TYPE_CONVERTERS[type];
}
function parseName(name2, defaultPrefix) {
  var parts = name2.split(/:/), localName, prefix3;
  if (parts.length === 1) {
    localName = name2;
    prefix3 = defaultPrefix;
  } else if (parts.length === 2) {
    localName = parts[1];
    prefix3 = parts[0];
  } else {
    throw new Error("expected <prefix:localName> or <localName>, got " + name2);
  }
  name2 = (prefix3 ? prefix3 + ":" : "") + localName;
  return {
    name: name2,
    prefix: prefix3,
    localName
  };
}
function DescriptorBuilder(nameNs) {
  this.ns = nameNs;
  this.name = nameNs.name;
  this.allTypes = [];
  this.allTypesByName = {};
  this.properties = [];
  this.propertiesByName = {};
}
DescriptorBuilder.prototype.build = function() {
  return pick(this, [
    "ns",
    "name",
    "allTypes",
    "allTypesByName",
    "properties",
    "propertiesByName",
    "bodyProperty",
    "idProperty"
  ]);
};
DescriptorBuilder.prototype.addProperty = function(p5, idx, validate) {
  if (typeof idx === "boolean") {
    validate = idx;
    idx = void 0;
  }
  this.addNamedProperty(p5, validate !== false);
  var properties = this.properties;
  if (idx !== void 0) {
    properties.splice(idx, 0, p5);
  } else {
    properties.push(p5);
  }
};
DescriptorBuilder.prototype.replaceProperty = function(oldProperty, newProperty, replace) {
  var oldNameNs = oldProperty.ns;
  var props = this.properties, propertiesByName = this.propertiesByName, rename = oldProperty.name !== newProperty.name;
  if (oldProperty.isId) {
    if (!newProperty.isId) {
      throw new Error(
        "property <" + newProperty.ns.name + "> must be id property to refine <" + oldProperty.ns.name + ">"
      );
    }
    this.setIdProperty(newProperty, false);
  }
  if (oldProperty.isBody) {
    if (!newProperty.isBody) {
      throw new Error(
        "property <" + newProperty.ns.name + "> must be body property to refine <" + oldProperty.ns.name + ">"
      );
    }
    this.setBodyProperty(newProperty, false);
  }
  var idx = props.indexOf(oldProperty);
  if (idx === -1) {
    throw new Error("property <" + oldNameNs.name + "> not found in property list");
  }
  props.splice(idx, 1);
  this.addProperty(newProperty, replace ? void 0 : idx, rename);
  propertiesByName[oldNameNs.name] = propertiesByName[oldNameNs.localName] = newProperty;
};
DescriptorBuilder.prototype.redefineProperty = function(p5, targetPropertyName, replace) {
  var nsPrefix = p5.ns.prefix;
  var parts = targetPropertyName.split("#");
  var name2 = parseName(parts[0], nsPrefix);
  var attrName = parseName(parts[1], name2.prefix).name;
  var redefinedProperty = this.propertiesByName[attrName];
  if (!redefinedProperty) {
    throw new Error("refined property <" + attrName + "> not found");
  } else {
    this.replaceProperty(redefinedProperty, p5, replace);
  }
  delete p5.redefines;
};
DescriptorBuilder.prototype.addNamedProperty = function(p5, validate) {
  var ns2 = p5.ns, propsByName = this.propertiesByName;
  if (validate) {
    this.assertNotDefined(p5, ns2.name);
    this.assertNotDefined(p5, ns2.localName);
  }
  propsByName[ns2.name] = propsByName[ns2.localName] = p5;
};
DescriptorBuilder.prototype.removeNamedProperty = function(p5) {
  var ns2 = p5.ns, propsByName = this.propertiesByName;
  delete propsByName[ns2.name];
  delete propsByName[ns2.localName];
};
DescriptorBuilder.prototype.setBodyProperty = function(p5, validate) {
  if (validate && this.bodyProperty) {
    throw new Error(
      "body property defined multiple times (<" + this.bodyProperty.ns.name + ">, <" + p5.ns.name + ">)"
    );
  }
  this.bodyProperty = p5;
};
DescriptorBuilder.prototype.setIdProperty = function(p5, validate) {
  if (validate && this.idProperty) {
    throw new Error(
      "id property defined multiple times (<" + this.idProperty.ns.name + ">, <" + p5.ns.name + ">)"
    );
  }
  this.idProperty = p5;
};
DescriptorBuilder.prototype.assertNotTrait = function(typeDescriptor) {
  const _extends3 = typeDescriptor.extends || [];
  if (_extends3.length) {
    throw new Error(
      `cannot create <${typeDescriptor.name}> extending <${typeDescriptor.extends}>`
    );
  }
};
DescriptorBuilder.prototype.assertNotDefined = function(p5, name2) {
  var propertyName = p5.name, definedProperty = this.propertiesByName[propertyName];
  if (definedProperty) {
    throw new Error(
      "property <" + propertyName + "> already defined; override of <" + definedProperty.definedBy.ns.name + "#" + definedProperty.ns.name + "> by <" + p5.definedBy.ns.name + "#" + p5.ns.name + "> not allowed without redefines"
    );
  }
};
DescriptorBuilder.prototype.hasProperty = function(name2) {
  return this.propertiesByName[name2];
};
DescriptorBuilder.prototype.addTrait = function(t7, inherited) {
  if (inherited) {
    this.assertNotTrait(t7);
  }
  var typesByName = this.allTypesByName, types3 = this.allTypes;
  var typeName = t7.name;
  if (typeName in typesByName) {
    return;
  }
  forEach(t7.properties, bind(function(p5) {
    p5 = assign({}, p5, {
      name: p5.ns.localName,
      inherited
    });
    Object.defineProperty(p5, "definedBy", {
      value: t7
    });
    var replaces = p5.replaces, redefines = p5.redefines;
    if (replaces || redefines) {
      this.redefineProperty(p5, replaces || redefines, replaces);
    } else {
      if (p5.isBody) {
        this.setBodyProperty(p5);
      }
      if (p5.isId) {
        this.setIdProperty(p5);
      }
      this.addProperty(p5);
    }
  }, this));
  types3.push(t7);
  typesByName[typeName] = t7;
};
function Registry(packages2, properties) {
  this.packageMap = {};
  this.typeMap = {};
  this.packages = [];
  this.properties = properties;
  forEach(packages2, bind(this.registerPackage, this));
}
Registry.prototype.getPackage = function(uriOrPrefix) {
  return this.packageMap[uriOrPrefix];
};
Registry.prototype.getPackages = function() {
  return this.packages;
};
Registry.prototype.registerPackage = function(pkg) {
  pkg = assign({}, pkg);
  var pkgMap = this.packageMap;
  ensureAvailable(pkgMap, pkg, "prefix");
  ensureAvailable(pkgMap, pkg, "uri");
  forEach(pkg.types, bind(function(descriptor) {
    this.registerType(descriptor, pkg);
  }, this));
  pkgMap[pkg.uri] = pkgMap[pkg.prefix] = pkg;
  this.packages.push(pkg);
};
Registry.prototype.registerType = function(type, pkg) {
  type = assign({}, type, {
    superClass: (type.superClass || []).slice(),
    extends: (type.extends || []).slice(),
    properties: (type.properties || []).slice(),
    meta: assign(type.meta || {})
  });
  var ns2 = parseName(type.name, pkg.prefix), name2 = ns2.name, propertiesByName = {};
  forEach(type.properties, bind(function(p5) {
    var propertyNs = parseName(p5.name, ns2.prefix), propertyName = propertyNs.name;
    if (!isBuiltIn(p5.type)) {
      p5.type = parseName(p5.type, propertyNs.prefix).name;
    }
    assign(p5, {
      ns: propertyNs,
      name: propertyName
    });
    propertiesByName[propertyName] = p5;
  }, this));
  assign(type, {
    ns: ns2,
    name: name2,
    propertiesByName
  });
  forEach(type.extends, bind(function(extendsName) {
    var extendsNameNs = parseName(extendsName, ns2.prefix);
    var extended = this.typeMap[extendsNameNs.name];
    extended.traits = extended.traits || [];
    extended.traits.push(name2);
  }, this));
  this.definePackage(type, pkg);
  this.typeMap[name2] = type;
};
Registry.prototype.mapTypes = function(nsName2, iterator, trait) {
  var type = isBuiltIn(nsName2.name) ? { name: nsName2.name } : this.typeMap[nsName2.name];
  var self2 = this;
  function traverse(cls, trait2) {
    var parentNs = parseName(cls, isBuiltIn(cls) ? "" : nsName2.prefix);
    self2.mapTypes(parentNs, iterator, trait2);
  }
  function traverseTrait(cls) {
    return traverse(cls, true);
  }
  function traverseSuper(cls) {
    return traverse(cls, false);
  }
  if (!type) {
    throw new Error("unknown type <" + nsName2.name + ">");
  }
  forEach(type.superClass, trait ? traverseTrait : traverseSuper);
  iterator(type, !trait);
  forEach(type.traits, traverseTrait);
};
Registry.prototype.getEffectiveDescriptor = function(name2) {
  var nsName2 = parseName(name2);
  var builder = new DescriptorBuilder(nsName2);
  this.mapTypes(nsName2, function(type, inherited) {
    builder.addTrait(type, inherited);
  });
  var descriptor = builder.build();
  this.definePackage(descriptor, descriptor.allTypes[descriptor.allTypes.length - 1].$pkg);
  return descriptor;
};
Registry.prototype.definePackage = function(target, pkg) {
  this.properties.define(target, "$pkg", { value: pkg });
};
function ensureAvailable(packageMap, pkg, identifierKey) {
  var value = pkg[identifierKey];
  if (value in packageMap) {
    throw new Error("package with " + identifierKey + " <" + value + "> already defined");
  }
}
function Properties(model) {
  this.model = model;
}
Properties.prototype.set = function(target, name2, value) {
  if (!isString(name2) || !name2.length) {
    throw new TypeError("property name must be a non-empty string");
  }
  var property = this.getProperty(target, name2);
  var propertyName = property && property.name;
  if (isUndefined3(value)) {
    if (property) {
      delete target[propertyName];
    } else {
      delete target.$attrs[stripGlobal(name2)];
    }
  } else {
    if (property) {
      if (propertyName in target) {
        target[propertyName] = value;
      } else {
        defineProperty2(target, property, value);
      }
    } else {
      target.$attrs[stripGlobal(name2)] = value;
    }
  }
};
Properties.prototype.get = function(target, name2) {
  var property = this.getProperty(target, name2);
  if (!property) {
    return target.$attrs[stripGlobal(name2)];
  }
  var propertyName = property.name;
  if (!target[propertyName] && property.isMany) {
    defineProperty2(target, property, []);
  }
  return target[propertyName];
};
Properties.prototype.define = function(target, name2, options) {
  if (!options.writable) {
    var value = options.value;
    options = assign({}, options, {
      get: function() {
        return value;
      }
    });
    delete options.value;
  }
  Object.defineProperty(target, name2, options);
};
Properties.prototype.defineDescriptor = function(target, descriptor) {
  this.define(target, "$descriptor", { value: descriptor });
};
Properties.prototype.defineModel = function(target, model) {
  this.define(target, "$model", { value: model });
};
Properties.prototype.getProperty = function(target, name2) {
  var model = this.model;
  var property = model.getPropertyDescriptor(target, name2);
  if (property) {
    return property;
  }
  if (name2.includes(":")) {
    return null;
  }
  const strict = model.config.strict;
  if (typeof strict !== "undefined") {
    const error4 = new TypeError(`unknown property <${name2}> on <${target.$type}>`);
    if (strict) {
      throw error4;
    } else {
      typeof console !== "undefined" && console.warn(error4);
    }
  }
  return null;
};
function isUndefined3(val) {
  return typeof val === "undefined";
}
function defineProperty2(target, property, value) {
  Object.defineProperty(target, property.name, {
    enumerable: !property.isReference,
    writable: true,
    value,
    configurable: true
  });
}
function stripGlobal(name2) {
  return name2.replace(/^:/, "");
}
function Moddle(packages2, config = {}) {
  this.properties = new Properties(this);
  this.factory = new Factory(this, this.properties);
  this.registry = new Registry(packages2, this.properties);
  this.typeCache = {};
  this.config = config;
}
Moddle.prototype.create = function(descriptor, attrs) {
  var Type3 = this.getType(descriptor);
  if (!Type3) {
    throw new Error("unknown type <" + descriptor + ">");
  }
  return new Type3(attrs);
};
Moddle.prototype.getType = function(descriptor) {
  var cache = this.typeCache;
  var name2 = isString(descriptor) ? descriptor : descriptor.ns.name;
  var type = cache[name2];
  if (!type) {
    descriptor = this.registry.getEffectiveDescriptor(name2);
    type = cache[name2] = this.factory.createType(descriptor);
  }
  return type;
};
Moddle.prototype.createAny = function(name2, nsUri, properties) {
  var nameNs = parseName(name2);
  var element = {
    $type: name2,
    $instanceOf: function(type) {
      return type === this.$type;
    },
    get: function(key) {
      return this[key];
    },
    set: function(key, value) {
      set(this, [key], value);
    }
  };
  var descriptor = {
    name: name2,
    isGeneric: true,
    ns: {
      prefix: nameNs.prefix,
      localName: nameNs.localName,
      uri: nsUri
    }
  };
  this.properties.defineDescriptor(element, descriptor);
  this.properties.defineModel(element, this);
  this.properties.define(element, "get", { enumerable: false, writable: true });
  this.properties.define(element, "set", { enumerable: false, writable: true });
  this.properties.define(element, "$parent", { enumerable: false, writable: true });
  this.properties.define(element, "$instanceOf", { enumerable: false, writable: true });
  forEach(properties, function(a6, key) {
    if (isObject(a6) && a6.value !== void 0) {
      element[a6.name] = a6.value;
    } else {
      element[key] = a6;
    }
  });
  return element;
};
Moddle.prototype.getPackage = function(uriOrPrefix) {
  return this.registry.getPackage(uriOrPrefix);
};
Moddle.prototype.getPackages = function() {
  return this.registry.getPackages();
};
Moddle.prototype.getElementDescriptor = function(element) {
  return element.$descriptor;
};
Moddle.prototype.hasType = function(element, type) {
  if (type === void 0) {
    type = element;
    element = this;
  }
  var descriptor = element.$model.getElementDescriptor(element);
  return type in descriptor.allTypesByName;
};
Moddle.prototype.getPropertyDescriptor = function(element, property) {
  return this.getElementDescriptor(element).propertiesByName[property];
};
Moddle.prototype.getTypeDescriptor = function(type) {
  return this.registry.typeMap[type];
};

// node_modules/saxen/dist/index.js
var fromCharCode = String.fromCharCode;
var hasOwnProperty2 = Object.prototype.hasOwnProperty;
var ENTITY_PATTERN = /&#(\d+);|&#x([0-9a-f]+);|&(\w+);/ig;
var ENTITY_MAPPING = {
  "amp": "&",
  "apos": "'",
  "gt": ">",
  "lt": "<",
  "quot": '"'
};
Object.keys(ENTITY_MAPPING).forEach(function(k6) {
  ENTITY_MAPPING[k6.toUpperCase()] = ENTITY_MAPPING[k6];
});
function replaceEntities(_5, d5, x6, z6) {
  if (z6) {
    if (hasOwnProperty2.call(ENTITY_MAPPING, z6)) {
      return ENTITY_MAPPING[z6];
    } else {
      return "&" + z6 + ";";
    }
  }
  if (d5) {
    return fromCharCode(d5);
  }
  return fromCharCode(parseInt(x6, 16));
}
function decodeEntities(s5) {
  if (s5.length > 3 && s5.indexOf("&") !== -1) {
    return s5.replace(ENTITY_PATTERN, replaceEntities);
  }
  return s5;
}
var NON_WHITESPACE_OUTSIDE_ROOT_NODE = "non-whitespace outside of root node";
function error(msg) {
  return new Error(msg);
}
function missingNamespaceForPrefix(prefix3) {
  return "missing namespace for prefix <" + prefix3 + ">";
}
function getter(getFn) {
  return {
    "get": getFn,
    "enumerable": true
  };
}
function cloneNsMatrix(nsMatrix) {
  var clone4 = {}, key;
  for (key in nsMatrix) {
    clone4[key] = nsMatrix[key];
  }
  return clone4;
}
function uriPrefix(prefix3) {
  return prefix3 + "$uri";
}
function buildNsMatrix(nsUriToPrefix) {
  var nsMatrix = {}, uri2, prefix3;
  for (uri2 in nsUriToPrefix) {
    prefix3 = nsUriToPrefix[uri2];
    nsMatrix[prefix3] = prefix3;
    nsMatrix[uriPrefix(prefix3)] = uri2;
  }
  return nsMatrix;
}
function noopGetContext() {
  return { line: 0, column: 0 };
}
function throwFunc(err) {
  throw err;
}
function Parser(options) {
  if (!this) {
    return new Parser(options);
  }
  var proxy = options && options["proxy"];
  var onText, onOpenTag, onCloseTag, onCDATA, onError = throwFunc, onWarning, onComment, onQuestion, onAttention;
  var getContext = noopGetContext;
  var maybeNS = false;
  var isNamespace = false;
  var returnError = null;
  var parseStop = false;
  var nsUriToPrefix;
  function handleError(err) {
    if (!(err instanceof Error)) {
      err = error(err);
    }
    returnError = err;
    onError(err, getContext);
  }
  function handleWarning(err) {
    if (!onWarning) {
      return;
    }
    if (!(err instanceof Error)) {
      err = error(err);
    }
    onWarning(err, getContext);
  }
  this["on"] = function(name2, cb) {
    if (typeof cb !== "function") {
      throw error("required args <name, cb>");
    }
    switch (name2) {
      case "openTag":
        onOpenTag = cb;
        break;
      case "text":
        onText = cb;
        break;
      case "closeTag":
        onCloseTag = cb;
        break;
      case "error":
        onError = cb;
        break;
      case "warn":
        onWarning = cb;
        break;
      case "cdata":
        onCDATA = cb;
        break;
      case "attention":
        onAttention = cb;
        break;
      // <!XXXXX zzzz="eeee">
      case "question":
        onQuestion = cb;
        break;
      // <? ....  ?>
      case "comment":
        onComment = cb;
        break;
      default:
        throw error("unsupported event: " + name2);
    }
    return this;
  };
  this["ns"] = function(nsMap) {
    if (typeof nsMap === "undefined") {
      nsMap = {};
    }
    if (typeof nsMap !== "object") {
      throw error("required args <nsMap={}>");
    }
    var _nsUriToPrefix = {}, k6;
    for (k6 in nsMap) {
      _nsUriToPrefix[k6] = nsMap[k6];
    }
    isNamespace = true;
    nsUriToPrefix = _nsUriToPrefix;
    return this;
  };
  this["parse"] = function(xml2) {
    if (typeof xml2 !== "string") {
      throw error("required args <xml=string>");
    }
    returnError = null;
    parse3(xml2);
    getContext = noopGetContext;
    parseStop = false;
    return returnError;
  };
  this["stop"] = function() {
    parseStop = true;
  };
  function parse3(xml2) {
    var nsMatrixStack = isNamespace ? [] : null, nsMatrix = isNamespace ? buildNsMatrix(nsUriToPrefix) : null, _nsMatrix, nodeStack = [], anonymousNsCount = 0, tagStart = false, tagEnd = false, i7 = 0, j6 = 0, x6, y5, q6, w6, v5, xmlns, elementName, _elementName, elementProxy;
    var attrsString = "", attrsStart = 0, cachedAttrs;
    function getAttrs() {
      if (cachedAttrs !== null) {
        return cachedAttrs;
      }
      var nsUri, nsUriPrefix, nsName2, defaultAlias = isNamespace && nsMatrix["xmlns"], attrList = isNamespace && maybeNS ? [] : null, i8 = attrsStart, s5 = attrsString, l5 = s5.length, hasNewMatrix, newalias, value, alias, name2, attrs = {}, seenAttrs = {}, skipAttr, w7, j7;
      parseAttr:
        for (; i8 < l5; i8++) {
          skipAttr = false;
          w7 = s5.charCodeAt(i8);
          if (w7 === 32 || w7 < 14 && w7 > 8) {
            continue;
          }
          if (w7 < 65 || w7 > 122 || w7 > 90 && w7 < 97) {
            if (w7 !== 95 && w7 !== 58) {
              handleWarning("illegal first char attribute name");
              skipAttr = true;
            }
          }
          for (j7 = i8 + 1; j7 < l5; j7++) {
            w7 = s5.charCodeAt(j7);
            if (w7 > 96 && w7 < 123 || w7 > 64 && w7 < 91 || w7 > 47 && w7 < 59 || w7 === 46 || // '.'
            w7 === 45 || // '-'
            w7 === 95) {
              continue;
            }
            if (w7 === 32 || w7 < 14 && w7 > 8) {
              handleWarning("missing attribute value");
              i8 = j7;
              continue parseAttr;
            }
            if (w7 === 61) {
              break;
            }
            handleWarning("illegal attribute name char");
            skipAttr = true;
          }
          name2 = s5.substring(i8, j7);
          if (name2 === "xmlns:xmlns") {
            handleWarning("illegal declaration of xmlns");
            skipAttr = true;
          }
          w7 = s5.charCodeAt(j7 + 1);
          if (w7 === 34) {
            j7 = s5.indexOf('"', i8 = j7 + 2);
            if (j7 === -1) {
              j7 = s5.indexOf("'", i8);
              if (j7 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else if (w7 === 39) {
            j7 = s5.indexOf("'", i8 = j7 + 2);
            if (j7 === -1) {
              j7 = s5.indexOf('"', i8);
              if (j7 !== -1) {
                handleWarning("attribute value quote missmatch");
                skipAttr = true;
              }
            }
          } else {
            handleWarning("missing attribute value quotes");
            skipAttr = true;
            for (j7 = j7 + 1; j7 < l5; j7++) {
              w7 = s5.charCodeAt(j7 + 1);
              if (w7 === 32 || w7 < 14 && w7 > 8) {
                break;
              }
            }
          }
          if (j7 === -1) {
            handleWarning("missing closing quotes");
            j7 = l5;
            skipAttr = true;
          }
          if (!skipAttr) {
            value = s5.substring(i8, j7);
          }
          i8 = j7;
          for (; j7 + 1 < l5; j7++) {
            w7 = s5.charCodeAt(j7 + 1);
            if (w7 === 32 || w7 < 14 && w7 > 8) {
              break;
            }
            if (i8 === j7) {
              handleWarning("illegal character after attribute end");
              skipAttr = true;
            }
          }
          i8 = j7 + 1;
          if (skipAttr) {
            continue parseAttr;
          }
          if (name2 in seenAttrs) {
            handleWarning("attribute <" + name2 + "> already defined");
            continue;
          }
          seenAttrs[name2] = true;
          if (!isNamespace) {
            attrs[name2] = value;
            continue;
          }
          if (maybeNS) {
            newalias = name2 === "xmlns" ? "xmlns" : name2.charCodeAt(0) === 120 && name2.substr(0, 6) === "xmlns:" ? name2.substr(6) : null;
            if (newalias !== null) {
              nsUri = decodeEntities(value);
              nsUriPrefix = uriPrefix(newalias);
              alias = nsUriToPrefix[nsUri];
              if (!alias) {
                if (newalias === "xmlns" || nsUriPrefix in nsMatrix && nsMatrix[nsUriPrefix] !== nsUri) {
                  do {
                    alias = "ns" + anonymousNsCount++;
                  } while (typeof nsMatrix[alias] !== "undefined");
                } else {
                  alias = newalias;
                }
                nsUriToPrefix[nsUri] = alias;
              }
              if (nsMatrix[newalias] !== alias) {
                if (!hasNewMatrix) {
                  nsMatrix = cloneNsMatrix(nsMatrix);
                  hasNewMatrix = true;
                }
                nsMatrix[newalias] = alias;
                if (newalias === "xmlns") {
                  nsMatrix[uriPrefix(alias)] = nsUri;
                  defaultAlias = alias;
                }
                nsMatrix[nsUriPrefix] = nsUri;
              }
              attrs[name2] = value;
              continue;
            }
            attrList.push(name2, value);
            continue;
          }
          w7 = name2.indexOf(":");
          if (w7 === -1) {
            attrs[name2] = value;
            continue;
          }
          if (!(nsName2 = nsMatrix[name2.substring(0, w7)])) {
            handleWarning(missingNamespaceForPrefix(name2.substring(0, w7)));
            continue;
          }
          name2 = defaultAlias === nsName2 ? name2.substr(w7 + 1) : nsName2 + name2.substr(w7);
          attrs[name2] = value;
        }
      if (maybeNS) {
        for (i8 = 0, l5 = attrList.length; i8 < l5; i8++) {
          name2 = attrList[i8++];
          value = attrList[i8];
          w7 = name2.indexOf(":");
          if (w7 !== -1) {
            if (!(nsName2 = nsMatrix[name2.substring(0, w7)])) {
              handleWarning(missingNamespaceForPrefix(name2.substring(0, w7)));
              continue;
            }
            name2 = defaultAlias === nsName2 ? name2.substr(w7 + 1) : nsName2 + name2.substr(w7);
          }
          attrs[name2] = value;
        }
      }
      return cachedAttrs = attrs;
    }
    function getParseContext() {
      var splitsRe = /(\r\n|\r|\n)/g;
      var line2 = 0;
      var column = 0;
      var startOfLine = 0;
      var endOfLine = j6;
      var match;
      var data;
      while (i7 >= startOfLine) {
        match = splitsRe.exec(xml2);
        if (!match) {
          break;
        }
        endOfLine = match[0].length + match.index;
        if (endOfLine > i7) {
          break;
        }
        line2 += 1;
        startOfLine = endOfLine;
      }
      if (i7 == -1) {
        column = endOfLine;
        data = xml2.substring(j6);
      } else if (j6 === 0) {
        data = xml2.substring(j6, i7);
      } else {
        column = i7 - startOfLine;
        data = j6 == -1 ? xml2.substring(i7) : xml2.substring(i7, j6 + 1);
      }
      return {
        "data": data,
        "line": line2,
        "column": column
      };
    }
    getContext = getParseContext;
    if (proxy) {
      elementProxy = Object.create({}, {
        "name": getter(function() {
          return elementName;
        }),
        "originalName": getter(function() {
          return _elementName;
        }),
        "attrs": getter(getAttrs),
        "ns": getter(function() {
          return nsMatrix;
        })
      });
    }
    while (j6 !== -1) {
      if (xml2.charCodeAt(j6) === 60) {
        i7 = j6;
      } else {
        i7 = xml2.indexOf("<", j6);
      }
      if (i7 === -1) {
        if (nodeStack.length) {
          return handleError("unexpected end of file");
        }
        if (j6 === 0) {
          return handleError("missing start tag");
        }
        if (j6 < xml2.length) {
          if (xml2.substring(j6).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
          }
        }
        return;
      }
      if (j6 !== i7) {
        if (nodeStack.length) {
          if (onText) {
            onText(xml2.substring(j6, i7), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
        } else {
          if (xml2.substring(j6, i7).trim()) {
            handleWarning(NON_WHITESPACE_OUTSIDE_ROOT_NODE);
            if (parseStop) {
              return;
            }
          }
        }
      }
      w6 = xml2.charCodeAt(i7 + 1);
      if (w6 === 33) {
        q6 = xml2.charCodeAt(i7 + 2);
        if (q6 === 91 && xml2.substr(i7 + 3, 6) === "CDATA[") {
          j6 = xml2.indexOf("]]>", i7);
          if (j6 === -1) {
            return handleError("unclosed cdata");
          }
          if (onCDATA) {
            onCDATA(xml2.substring(i7 + 9, j6), getContext);
            if (parseStop) {
              return;
            }
          }
          j6 += 3;
          continue;
        }
        if (q6 === 45 && xml2.charCodeAt(i7 + 3) === 45) {
          j6 = xml2.indexOf("-->", i7);
          if (j6 === -1) {
            return handleError("unclosed comment");
          }
          if (onComment) {
            onComment(xml2.substring(i7 + 4, j6), decodeEntities, getContext);
            if (parseStop) {
              return;
            }
          }
          j6 += 3;
          continue;
        }
      }
      if (w6 === 63) {
        j6 = xml2.indexOf("?>", i7);
        if (j6 === -1) {
          return handleError("unclosed question");
        }
        if (onQuestion) {
          onQuestion(xml2.substring(i7, j6 + 2), getContext);
          if (parseStop) {
            return;
          }
        }
        j6 += 2;
        continue;
      }
      for (x6 = i7 + 1; ; x6++) {
        v5 = xml2.charCodeAt(x6);
        if (isNaN(v5)) {
          j6 = -1;
          return handleError("unclosed tag");
        }
        if (v5 === 34) {
          q6 = xml2.indexOf('"', x6 + 1);
          x6 = q6 !== -1 ? q6 : x6;
        } else if (v5 === 39) {
          q6 = xml2.indexOf("'", x6 + 1);
          x6 = q6 !== -1 ? q6 : x6;
        } else if (v5 === 62) {
          j6 = x6;
          break;
        }
      }
      if (w6 === 33) {
        if (onAttention) {
          onAttention(xml2.substring(i7, j6 + 1), decodeEntities, getContext);
          if (parseStop) {
            return;
          }
        }
        j6 += 1;
        continue;
      }
      cachedAttrs = {};
      if (w6 === 47) {
        tagStart = false;
        tagEnd = true;
        if (!nodeStack.length) {
          return handleError("missing open tag");
        }
        x6 = elementName = nodeStack.pop();
        q6 = i7 + 2 + x6.length;
        if (xml2.substring(i7 + 2, q6) !== x6) {
          return handleError("closing tag mismatch");
        }
        for (; q6 < j6; q6++) {
          w6 = xml2.charCodeAt(q6);
          if (w6 === 32 || w6 > 8 && w6 < 14) {
            continue;
          }
          return handleError("close tag");
        }
      } else {
        if (xml2.charCodeAt(j6 - 1) === 47) {
          x6 = elementName = xml2.substring(i7 + 1, j6 - 1);
          tagStart = true;
          tagEnd = true;
        } else {
          x6 = elementName = xml2.substring(i7 + 1, j6);
          tagStart = true;
          tagEnd = false;
        }
        if (!(w6 > 96 && w6 < 123 || w6 > 64 && w6 < 91 || w6 === 95 || w6 === 58)) {
          return handleError("illegal first char nodeName");
        }
        for (q6 = 1, y5 = x6.length; q6 < y5; q6++) {
          w6 = x6.charCodeAt(q6);
          if (w6 > 96 && w6 < 123 || w6 > 64 && w6 < 91 || w6 > 47 && w6 < 59 || w6 === 45 || w6 === 95 || w6 == 46) {
            continue;
          }
          if (w6 === 32 || w6 < 14 && w6 > 8) {
            elementName = x6.substring(0, q6);
            cachedAttrs = null;
            break;
          }
          return handleError("invalid nodeName");
        }
        if (!tagEnd) {
          nodeStack.push(elementName);
        }
      }
      if (isNamespace) {
        _nsMatrix = nsMatrix;
        if (tagStart) {
          if (!tagEnd) {
            nsMatrixStack.push(_nsMatrix);
          }
          if (cachedAttrs === null) {
            if (maybeNS = x6.indexOf("xmlns", q6) !== -1) {
              attrsStart = q6;
              attrsString = x6;
              getAttrs();
              maybeNS = false;
            }
          }
        }
        _elementName = elementName;
        w6 = elementName.indexOf(":");
        if (w6 !== -1) {
          xmlns = nsMatrix[elementName.substring(0, w6)];
          if (!xmlns) {
            return handleError("missing namespace on <" + _elementName + ">");
          }
          elementName = elementName.substr(w6 + 1);
        } else {
          xmlns = nsMatrix["xmlns"];
        }
        if (xmlns) {
          elementName = xmlns + ":" + elementName;
        }
      }
      if (tagStart) {
        attrsStart = q6;
        attrsString = x6;
        if (onOpenTag) {
          if (proxy) {
            onOpenTag(elementProxy, decodeEntities, tagEnd, getContext);
          } else {
            onOpenTag(elementName, getAttrs, decodeEntities, tagEnd, getContext);
          }
          if (parseStop) {
            return;
          }
        }
      }
      if (tagEnd) {
        if (onCloseTag) {
          onCloseTag(proxy ? elementProxy : elementName, decodeEntities, tagStart, getContext);
          if (parseStop) {
            return;
          }
        }
        if (isNamespace) {
          if (!tagStart) {
            nsMatrix = nsMatrixStack.pop();
          } else {
            nsMatrix = _nsMatrix;
          }
        }
      }
      j6 += 1;
    }
  }
}

// node_modules/moddle-xml/dist/index.js
function hasLowerCaseAlias(pkg) {
  return pkg.xml && pkg.xml.tagAlias === "lowerCase";
}
var DEFAULT_NS_MAP = {
  "xsi": "http://www.w3.org/2001/XMLSchema-instance",
  "xml": "http://www.w3.org/XML/1998/namespace"
};
var SERIALIZE_PROPERTY = "property";
function getSerialization(element) {
  return element.xml && element.xml.serialize;
}
function getSerializationType(element) {
  const type = getSerialization(element);
  return type !== SERIALIZE_PROPERTY && (type || null);
}
function capitalize(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}
function aliasToName(aliasNs, pkg) {
  if (!hasLowerCaseAlias(pkg)) {
    return aliasNs.name;
  }
  return aliasNs.prefix + ":" + capitalize(aliasNs.localName);
}
function prefixedToName(nameNs, pkg) {
  var name2 = nameNs.name, localName = nameNs.localName;
  var typePrefix = pkg && pkg.xml && pkg.xml.typePrefix;
  if (typePrefix && localName.indexOf(typePrefix) === 0) {
    return nameNs.prefix + ":" + localName.slice(typePrefix.length);
  } else {
    return name2;
  }
}
function normalizeTypeName(name2, nsMap, model) {
  const nameNs = parseName(name2, nsMap.xmlns);
  const normalizedName = `${nsMap[nameNs.prefix] || nameNs.prefix}:${nameNs.localName}`;
  const normalizedNameNs = parseName(normalizedName);
  var pkg = model.getPackage(normalizedNameNs.prefix);
  return prefixedToName(normalizedNameNs, pkg);
}
function error2(message) {
  return new Error(message);
}
function getModdleDescriptor(element) {
  return element.$descriptor;
}
function Context(options) {
  assign(this, options);
  this.elementsById = {};
  this.references = [];
  this.warnings = [];
  this.addReference = function(reference) {
    this.references.push(reference);
  };
  this.addElement = function(element) {
    if (!element) {
      throw error2("expected element");
    }
    var elementsById = this.elementsById;
    var descriptor = getModdleDescriptor(element);
    var idProperty = descriptor.idProperty, id;
    if (idProperty) {
      id = element.get(idProperty.name);
      if (id) {
        if (!/^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i.test(id)) {
          throw new Error("illegal ID <" + id + ">");
        }
        if (elementsById[id]) {
          throw error2("duplicate ID <" + id + ">");
        }
        elementsById[id] = element;
      }
    }
  };
  this.addWarning = function(warning) {
    this.warnings.push(warning);
  };
}
function BaseHandler() {
}
BaseHandler.prototype.handleEnd = function() {
};
BaseHandler.prototype.handleText = function() {
};
BaseHandler.prototype.handleNode = function() {
};
function NoopHandler() {
}
NoopHandler.prototype = Object.create(BaseHandler.prototype);
NoopHandler.prototype.handleNode = function() {
  return this;
};
function BodyHandler() {
}
BodyHandler.prototype = Object.create(BaseHandler.prototype);
BodyHandler.prototype.handleText = function(text) {
  this.body = (this.body || "") + text;
};
function ReferenceHandler(property, context) {
  this.property = property;
  this.context = context;
}
ReferenceHandler.prototype = Object.create(BodyHandler.prototype);
ReferenceHandler.prototype.handleNode = function(node2) {
  if (this.element) {
    throw error2("expected no sub nodes");
  } else {
    this.element = this.createReference(node2);
  }
  return this;
};
ReferenceHandler.prototype.handleEnd = function() {
  this.element.id = this.body;
};
ReferenceHandler.prototype.createReference = function(node2) {
  return {
    property: this.property.ns.name,
    id: ""
  };
};
function ValueHandler(propertyDesc, element) {
  this.element = element;
  this.propertyDesc = propertyDesc;
}
ValueHandler.prototype = Object.create(BodyHandler.prototype);
ValueHandler.prototype.handleEnd = function() {
  var value = this.body || "", element = this.element, propertyDesc = this.propertyDesc;
  value = coerceType(propertyDesc.type, value);
  if (propertyDesc.isMany) {
    element.get(propertyDesc.name).push(value);
  } else {
    element.set(propertyDesc.name, value);
  }
};
function BaseElementHandler() {
}
BaseElementHandler.prototype = Object.create(BodyHandler.prototype);
BaseElementHandler.prototype.handleNode = function(node2) {
  var parser4 = this, element = this.element;
  if (!element) {
    element = this.element = this.createElement(node2);
    this.context.addElement(element);
  } else {
    parser4 = this.handleChild(node2);
  }
  return parser4;
};
function ElementHandler(model, typeName, context) {
  this.model = model;
  this.type = model.getType(typeName);
  this.context = context;
}
ElementHandler.prototype = Object.create(BaseElementHandler.prototype);
ElementHandler.prototype.addReference = function(reference) {
  this.context.addReference(reference);
};
ElementHandler.prototype.handleText = function(text) {
  var element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (!bodyProperty) {
    throw error2("unexpected body text <" + text + ">");
  }
  BodyHandler.prototype.handleText.call(this, text);
};
ElementHandler.prototype.handleEnd = function() {
  var value = this.body, element = this.element, descriptor = getModdleDescriptor(element), bodyProperty = descriptor.bodyProperty;
  if (bodyProperty && value !== void 0) {
    value = coerceType(bodyProperty.type, value);
    element.set(bodyProperty.name, value);
  }
};
ElementHandler.prototype.createElement = function(node2) {
  var attributes = node2.attributes, Type3 = this.type, descriptor = getModdleDescriptor(Type3), context = this.context, instance = new Type3({}), model = this.model, propNameNs;
  forEach(attributes, function(value, name2) {
    var prop = descriptor.propertiesByName[name2], values2;
    if (prop && prop.isReference) {
      if (!prop.isMany) {
        context.addReference({
          element: instance,
          property: prop.ns.name,
          id: value
        });
      } else {
        values2 = value.split(" ");
        forEach(values2, function(v5) {
          context.addReference({
            element: instance,
            property: prop.ns.name,
            id: v5
          });
        });
      }
    } else {
      if (prop) {
        value = coerceType(prop.type, value);
      } else if (name2 === "xmlns") {
        name2 = ":" + name2;
      } else {
        propNameNs = parseName(name2, descriptor.ns.prefix);
        if (model.getPackage(propNameNs.prefix)) {
          context.addWarning({
            message: "unknown attribute <" + name2 + ">",
            element: instance,
            property: name2,
            value
          });
        }
      }
      instance.set(name2, value);
    }
  });
  return instance;
};
ElementHandler.prototype.getPropertyForNode = function(node2) {
  var name2 = node2.name;
  var nameNs = parseName(name2);
  var type = this.type, model = this.model, descriptor = getModdleDescriptor(type);
  var propertyName = nameNs.name, property = descriptor.propertiesByName[propertyName];
  if (property && !property.isAttr) {
    const serializationType = getSerializationType(property);
    if (serializationType) {
      const elementTypeName = node2.attributes[serializationType];
      if (elementTypeName) {
        const normalizedTypeName = normalizeTypeName(elementTypeName, node2.ns, model);
        const elementType = model.getType(normalizedTypeName);
        return assign({}, property, {
          effectiveType: getModdleDescriptor(elementType).name
        });
      }
    }
    return property;
  }
  var pkg = model.getPackage(nameNs.prefix);
  if (pkg) {
    const elementTypeName = aliasToName(nameNs, pkg);
    const elementType = model.getType(elementTypeName);
    property = find(descriptor.properties, function(p5) {
      return !p5.isVirtual && !p5.isReference && !p5.isAttribute && elementType.hasType(p5.type);
    });
    if (property) {
      return assign({}, property, {
        effectiveType: getModdleDescriptor(elementType).name
      });
    }
  } else {
    property = find(descriptor.properties, function(p5) {
      return !p5.isReference && !p5.isAttribute && p5.type === "Element";
    });
    if (property) {
      return property;
    }
  }
  throw error2("unrecognized element <" + nameNs.name + ">");
};
ElementHandler.prototype.toString = function() {
  return "ElementDescriptor[" + getModdleDescriptor(this.type).name + "]";
};
ElementHandler.prototype.valueHandler = function(propertyDesc, element) {
  return new ValueHandler(propertyDesc, element);
};
ElementHandler.prototype.referenceHandler = function(propertyDesc) {
  return new ReferenceHandler(propertyDesc, this.context);
};
ElementHandler.prototype.handler = function(type) {
  if (type === "Element") {
    return new GenericElementHandler(this.model, type, this.context);
  } else {
    return new ElementHandler(this.model, type, this.context);
  }
};
ElementHandler.prototype.handleChild = function(node2) {
  var propertyDesc, type, element, childHandler;
  propertyDesc = this.getPropertyForNode(node2);
  element = this.element;
  type = propertyDesc.effectiveType || propertyDesc.type;
  if (isSimple(type)) {
    return this.valueHandler(propertyDesc, element);
  }
  if (propertyDesc.isReference) {
    childHandler = this.referenceHandler(propertyDesc).handleNode(node2);
  } else {
    childHandler = this.handler(type).handleNode(node2);
  }
  var newElement = childHandler.element;
  if (newElement !== void 0) {
    if (propertyDesc.isMany) {
      element.get(propertyDesc.name).push(newElement);
    } else {
      element.set(propertyDesc.name, newElement);
    }
    if (propertyDesc.isReference) {
      assign(newElement, {
        element
      });
      this.context.addReference(newElement);
    } else {
      newElement.$parent = element;
    }
  }
  return childHandler;
};
function RootElementHandler(model, typeName, context) {
  ElementHandler.call(this, model, typeName, context);
}
RootElementHandler.prototype = Object.create(ElementHandler.prototype);
RootElementHandler.prototype.createElement = function(node2) {
  var name2 = node2.name, nameNs = parseName(name2), model = this.model, type = this.type, pkg = model.getPackage(nameNs.prefix), typeName = pkg && aliasToName(nameNs, pkg) || name2;
  if (!type.hasType(typeName)) {
    throw error2("unexpected element <" + node2.originalName + ">");
  }
  return ElementHandler.prototype.createElement.call(this, node2);
};
function GenericElementHandler(model, typeName, context) {
  this.model = model;
  this.context = context;
}
GenericElementHandler.prototype = Object.create(BaseElementHandler.prototype);
GenericElementHandler.prototype.createElement = function(node2) {
  var name2 = node2.name, ns2 = parseName(name2), prefix3 = ns2.prefix, uri2 = node2.ns[prefix3 + "$uri"], attributes = node2.attributes;
  return this.model.createAny(name2, uri2, attributes);
};
GenericElementHandler.prototype.handleChild = function(node2) {
  var handler = new GenericElementHandler(this.model, "Element", this.context).handleNode(node2), element = this.element;
  var newElement = handler.element, children;
  if (newElement !== void 0) {
    children = element.$children = element.$children || [];
    children.push(newElement);
    newElement.$parent = element;
  }
  return handler;
};
GenericElementHandler.prototype.handleEnd = function() {
  if (this.body) {
    this.element.$body = this.body;
  }
};
function Reader(options) {
  if (options instanceof Moddle) {
    options = {
      model: options
    };
  }
  assign(this, { lax: false }, options);
}
Reader.prototype.fromXML = function(xml2, options, done) {
  var rootHandler = options.rootHandler;
  if (options instanceof ElementHandler) {
    rootHandler = options;
    options = {};
  } else {
    if (typeof options === "string") {
      rootHandler = this.handler(options);
      options = {};
    } else if (typeof rootHandler === "string") {
      rootHandler = this.handler(rootHandler);
    }
  }
  var model = this.model, lax = this.lax;
  var context = new Context(assign({}, options, { rootHandler })), parser4 = new Parser({ proxy: true }), stack = createStack();
  rootHandler.context = context;
  stack.push(rootHandler);
  function handleError(err, getContext, lax2) {
    var ctx = getContext();
    var line2 = ctx.line, column = ctx.column, data = ctx.data;
    if (data.charAt(0) === "<" && data.indexOf(" ") !== -1) {
      data = data.slice(0, data.indexOf(" ")) + ">";
    }
    var message = "unparsable content " + (data ? data + " " : "") + "detected\n	line: " + line2 + "\n	column: " + column + "\n	nested error: " + err.message;
    if (lax2) {
      context.addWarning({
        message,
        error: err
      });
      return true;
    } else {
      throw error2(message);
    }
  }
  function handleWarning(err, getContext) {
    return handleError(err, getContext, true);
  }
  function resolveReferences() {
    var elementsById = context.elementsById;
    var references = context.references;
    var i7, r7;
    for (i7 = 0; r7 = references[i7]; i7++) {
      var element = r7.element;
      var reference = elementsById[r7.id];
      var property = getModdleDescriptor(element).propertiesByName[r7.property];
      if (!reference) {
        context.addWarning({
          message: "unresolved reference <" + r7.id + ">",
          element: r7.element,
          property: r7.property,
          value: r7.id
        });
      }
      if (property.isMany) {
        var collection = element.get(property.name), idx = collection.indexOf(r7);
        if (idx === -1) {
          idx = collection.length;
        }
        if (!reference) {
          collection.splice(idx, 1);
        } else {
          collection[idx] = reference;
        }
      } else {
        element.set(property.name, reference);
      }
    }
  }
  function handleClose() {
    stack.pop().handleEnd();
  }
  var PREAMBLE_START_PATTERN = /^<\?xml /i;
  var ENCODING_PATTERN = / encoding="([^"]+)"/i;
  var UTF_8_PATTERN = /^utf-8$/i;
  function handleQuestion(question) {
    if (!PREAMBLE_START_PATTERN.test(question)) {
      return;
    }
    var match = ENCODING_PATTERN.exec(question);
    var encoding = match && match[1];
    if (!encoding || UTF_8_PATTERN.test(encoding)) {
      return;
    }
    context.addWarning({
      message: "unsupported document encoding <" + encoding + ">, falling back to UTF-8"
    });
  }
  function handleOpen(node2, getContext) {
    var handler = stack.peek();
    try {
      stack.push(handler.handleNode(node2));
    } catch (err) {
      if (handleError(err, getContext, lax)) {
        stack.push(new NoopHandler());
      }
    }
  }
  function handleCData(text, getContext) {
    try {
      stack.peek().handleText(text);
    } catch (err) {
      handleWarning(err, getContext);
    }
  }
  function handleText(text, getContext) {
    if (!text.trim()) {
      return;
    }
    handleCData(text, getContext);
  }
  var uriMap = model.getPackages().reduce(function(uriMap2, p5) {
    uriMap2[p5.uri] = p5.prefix;
    return uriMap2;
  }, Object.entries(DEFAULT_NS_MAP).reduce(function(map4, [prefix3, url]) {
    map4[url] = prefix3;
    return map4;
  }, model.config && model.config.nsMap || {}));
  parser4.ns(uriMap).on("openTag", function(obj, decodeStr, selfClosing, getContext) {
    var attrs = obj.attrs || {};
    var decodedAttrs = Object.keys(attrs).reduce(function(d5, key) {
      var value = decodeStr(attrs[key]);
      d5[key] = value;
      return d5;
    }, {});
    var node2 = {
      name: obj.name,
      originalName: obj.originalName,
      attributes: decodedAttrs,
      ns: obj.ns
    };
    handleOpen(node2, getContext);
  }).on("question", handleQuestion).on("closeTag", handleClose).on("cdata", handleCData).on("text", function(text, decodeEntities2, getContext) {
    handleText(decodeEntities2(text), getContext);
  }).on("error", handleError).on("warn", handleWarning);
  return new Promise(function(resolve, reject) {
    var err;
    try {
      parser4.parse(xml2);
      resolveReferences();
    } catch (e8) {
      err = e8;
    }
    var rootElement = rootHandler.element;
    if (!err && !rootElement) {
      err = error2("failed to parse document as <" + rootHandler.type.$descriptor.name + ">");
    }
    var warnings = context.warnings;
    var references = context.references;
    var elementsById = context.elementsById;
    if (err) {
      err.warnings = warnings;
      return reject(err);
    } else {
      return resolve({
        rootElement,
        elementsById,
        references,
        warnings
      });
    }
  });
};
Reader.prototype.handler = function(name2) {
  return new RootElementHandler(this.model, name2);
};
function createStack() {
  var stack = [];
  Object.defineProperty(stack, "peek", {
    value: function() {
      return this[this.length - 1];
    }
  });
  return stack;
}
var XML_PREAMBLE = '<?xml version="1.0" encoding="UTF-8"?>\n';
var ESCAPE_ATTR_CHARS = /<|>|'|"|&|\n\r|\n/g;
var ESCAPE_CHARS = /<|>|&/g;
function Namespaces(parent) {
  this.prefixMap = {};
  this.uriMap = {};
  this.used = {};
  this.wellknown = [];
  this.custom = [];
  this.parent = parent;
  this.defaultPrefixMap = parent && parent.defaultPrefixMap || {};
}
Namespaces.prototype.mapDefaultPrefixes = function(defaultPrefixMap) {
  this.defaultPrefixMap = defaultPrefixMap;
};
Namespaces.prototype.defaultUriByPrefix = function(prefix3) {
  return this.defaultPrefixMap[prefix3];
};
Namespaces.prototype.byUri = function(uri2) {
  return this.uriMap[uri2] || this.parent && this.parent.byUri(uri2);
};
Namespaces.prototype.add = function(ns2, isWellknown) {
  this.uriMap[ns2.uri] = ns2;
  if (isWellknown) {
    this.wellknown.push(ns2);
  } else {
    this.custom.push(ns2);
  }
  this.mapPrefix(ns2.prefix, ns2.uri);
};
Namespaces.prototype.uriByPrefix = function(prefix3) {
  return this.prefixMap[prefix3 || "xmlns"] || this.parent && this.parent.uriByPrefix(prefix3);
};
Namespaces.prototype.mapPrefix = function(prefix3, uri2) {
  this.prefixMap[prefix3 || "xmlns"] = uri2;
};
Namespaces.prototype.getNSKey = function(ns2) {
  return ns2.prefix !== void 0 ? ns2.uri + "|" + ns2.prefix : ns2.uri;
};
Namespaces.prototype.logUsed = function(ns2) {
  var uri2 = ns2.uri;
  var nsKey = this.getNSKey(ns2);
  this.used[nsKey] = this.byUri(uri2);
  if (this.parent) {
    this.parent.logUsed(ns2);
  }
};
Namespaces.prototype.getUsed = function(ns2) {
  var allNs = [].concat(this.wellknown, this.custom);
  return allNs.filter((ns3) => {
    var nsKey = this.getNSKey(ns3);
    return this.used[nsKey];
  });
};
function lower(string) {
  return string.charAt(0).toLowerCase() + string.slice(1);
}
function nameToAlias(name2, pkg) {
  if (hasLowerCaseAlias(pkg)) {
    return lower(name2);
  } else {
    return name2;
  }
}
function inherits(ctor, superCtor) {
  ctor.super_ = superCtor;
  ctor.prototype = Object.create(superCtor.prototype, {
    constructor: {
      value: ctor,
      enumerable: false,
      writable: true,
      configurable: true
    }
  });
}
function nsName(ns2) {
  if (isString(ns2)) {
    return ns2;
  } else {
    return (ns2.prefix ? ns2.prefix + ":" : "") + ns2.localName;
  }
}
function getNsAttrs(namespaces) {
  return namespaces.getUsed().filter(function(ns2) {
    return ns2.prefix !== "xml";
  }).map(function(ns2) {
    var name2 = "xmlns" + (ns2.prefix ? ":" + ns2.prefix : "");
    return { name: name2, value: ns2.uri };
  });
}
function getElementNs(ns2, descriptor) {
  if (descriptor.isGeneric) {
    return assign({ localName: descriptor.ns.localName }, ns2);
  } else {
    return assign({ localName: nameToAlias(descriptor.ns.localName, descriptor.$pkg) }, ns2);
  }
}
function getPropertyNs(ns2, descriptor) {
  return assign({ localName: descriptor.ns.localName }, ns2);
}
function getSerializableProperties(element) {
  var descriptor = element.$descriptor;
  return filter(descriptor.properties, function(p5) {
    var name2 = p5.name;
    if (p5.isVirtual) {
      return false;
    }
    if (!has(element, name2)) {
      return false;
    }
    var value = element[name2];
    if (value === p5.default) {
      return false;
    }
    if (value === null) {
      return false;
    }
    return p5.isMany ? value.length : true;
  });
}
var ESCAPE_ATTR_MAP = {
  "\n": "#10",
  "\n\r": "#10",
  '"': "#34",
  "'": "#39",
  "<": "#60",
  ">": "#62",
  "&": "#38"
};
var ESCAPE_MAP = {
  "<": "lt",
  ">": "gt",
  "&": "amp"
};
function escape2(str, charPattern, replaceMap) {
  str = isString(str) ? str : "" + str;
  return str.replace(charPattern, function(s5) {
    return "&" + replaceMap[s5] + ";";
  });
}
function escapeAttr(str) {
  return escape2(str, ESCAPE_ATTR_CHARS, ESCAPE_ATTR_MAP);
}
function escapeBody(str) {
  return escape2(str, ESCAPE_CHARS, ESCAPE_MAP);
}
function filterAttributes(props) {
  return filter(props, function(p5) {
    return p5.isAttr;
  });
}
function filterContained(props) {
  return filter(props, function(p5) {
    return !p5.isAttr;
  });
}
function ReferenceSerializer(tagName) {
  this.tagName = tagName;
}
ReferenceSerializer.prototype.build = function(element) {
  this.element = element;
  return this;
};
ReferenceSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">" + this.element.id + "</" + this.tagName + ">").appendNewLine();
};
function BodySerializer() {
}
BodySerializer.prototype.serializeValue = BodySerializer.prototype.serializeTo = function(writer) {
  writer.append(
    this.escape ? escapeBody(this.value) : this.value
  );
};
BodySerializer.prototype.build = function(prop, value) {
  this.value = value;
  if (prop.type === "String" && value.search(ESCAPE_CHARS) !== -1) {
    this.escape = true;
  }
  return this;
};
function ValueSerializer(tagName) {
  this.tagName = tagName;
}
inherits(ValueSerializer, BodySerializer);
ValueSerializer.prototype.serializeTo = function(writer) {
  writer.appendIndent().append("<" + this.tagName + ">");
  this.serializeValue(writer);
  writer.append("</" + this.tagName + ">").appendNewLine();
};
function ElementSerializer(parent, propertyDescriptor) {
  this.body = [];
  this.attrs = [];
  this.parent = parent;
  this.propertyDescriptor = propertyDescriptor;
}
ElementSerializer.prototype.build = function(element) {
  this.element = element;
  var elementDescriptor = element.$descriptor, propertyDescriptor = this.propertyDescriptor;
  var otherAttrs, properties;
  var isGeneric = elementDescriptor.isGeneric;
  if (isGeneric) {
    otherAttrs = this.parseGenericNsAttributes(element);
  } else {
    otherAttrs = this.parseNsAttributes(element);
  }
  if (propertyDescriptor) {
    this.ns = this.nsPropertyTagName(propertyDescriptor);
  } else {
    this.ns = this.nsTagName(elementDescriptor);
  }
  this.tagName = this.addTagName(this.ns);
  if (isGeneric) {
    this.parseGenericContainments(element);
  } else {
    properties = getSerializableProperties(element);
    this.parseAttributes(filterAttributes(properties));
    this.parseContainments(filterContained(properties));
  }
  this.parseGenericAttributes(element, otherAttrs);
  return this;
};
ElementSerializer.prototype.nsTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getElementNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.nsPropertyTagName = function(descriptor) {
  var effectiveNs = this.logNamespaceUsed(descriptor.ns);
  return getPropertyNs(effectiveNs, descriptor);
};
ElementSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === this.ns.uri;
};
ElementSerializer.prototype.nsAttributeName = function(element) {
  var ns2;
  if (isString(element)) {
    ns2 = parseName(element);
  } else {
    ns2 = element.ns;
  }
  if (element.inherited) {
    return { localName: ns2.localName };
  }
  var effectiveNs = this.logNamespaceUsed(ns2);
  this.getNamespaces().logUsed(effectiveNs);
  if (this.isLocalNs(effectiveNs)) {
    return { localName: ns2.localName };
  } else {
    return assign({ localName: ns2.localName }, effectiveNs);
  }
};
ElementSerializer.prototype.parseGenericNsAttributes = function(element) {
  return Object.entries(element).filter(
    ([key, value]) => !key.startsWith("$") && this.parseNsAttribute(element, key, value)
  ).map(
    ([key, value]) => ({ name: key, value })
  );
};
ElementSerializer.prototype.parseGenericContainments = function(element) {
  var body = element.$body;
  if (body) {
    this.body.push(new BodySerializer().build({ type: "String" }, body));
  }
  var children = element.$children;
  if (children) {
    forEach(children, (child) => {
      this.body.push(new ElementSerializer(this).build(child));
    });
  }
};
ElementSerializer.prototype.parseNsAttribute = function(element, name2, value) {
  var model = element.$model;
  var nameNs = parseName(name2);
  var ns2;
  if (nameNs.prefix === "xmlns") {
    ns2 = { prefix: nameNs.localName, uri: value };
  }
  if (!nameNs.prefix && nameNs.localName === "xmlns") {
    ns2 = { uri: value };
  }
  if (!ns2) {
    return {
      name: name2,
      value
    };
  }
  if (model && model.getPackage(value)) {
    this.logNamespace(ns2, true, true);
  } else {
    var actualNs = this.logNamespaceUsed(ns2, true);
    this.getNamespaces().logUsed(actualNs);
  }
};
ElementSerializer.prototype.parseNsAttributes = function(element) {
  var self2 = this;
  var genericAttrs = element.$attrs;
  var attributes = [];
  forEach(genericAttrs, function(value, name2) {
    var nonNsAttr = self2.parseNsAttribute(element, name2, value);
    if (nonNsAttr) {
      attributes.push(nonNsAttr);
    }
  });
  return attributes;
};
ElementSerializer.prototype.parseGenericAttributes = function(element, attributes) {
  var self2 = this;
  forEach(attributes, function(attr3) {
    try {
      self2.addAttribute(self2.nsAttributeName(attr3.name), attr3.value);
    } catch (e8) {
      typeof console !== "undefined" && console.warn(
        `missing namespace information for <${attr3.name}=${attr3.value}> on`,
        element,
        e8
      );
    }
  });
};
ElementSerializer.prototype.parseContainments = function(properties) {
  var self2 = this, body = this.body, element = this.element;
  forEach(properties, function(p5) {
    var value = element.get(p5.name), isReference = p5.isReference, isMany = p5.isMany;
    if (!isMany) {
      value = [value];
    }
    if (p5.isBody) {
      body.push(new BodySerializer().build(p5, value[0]));
    } else if (isSimple(p5.type)) {
      forEach(value, function(v5) {
        body.push(new ValueSerializer(self2.addTagName(self2.nsPropertyTagName(p5))).build(p5, v5));
      });
    } else if (isReference) {
      forEach(value, function(v5) {
        body.push(new ReferenceSerializer(self2.addTagName(self2.nsPropertyTagName(p5))).build(v5));
      });
    } else {
      var serialization = getSerialization(p5);
      forEach(value, function(v5) {
        var serializer;
        if (serialization) {
          if (serialization === SERIALIZE_PROPERTY) {
            serializer = new ElementSerializer(self2, p5);
          } else {
            serializer = new TypeSerializer(self2, p5, serialization);
          }
        } else {
          serializer = new ElementSerializer(self2);
        }
        body.push(serializer.build(v5));
      });
    }
  });
};
ElementSerializer.prototype.getNamespaces = function(local) {
  var namespaces = this.namespaces, parent = this.parent, parentNamespaces;
  if (!namespaces) {
    parentNamespaces = parent && parent.getNamespaces();
    if (local || !parentNamespaces) {
      this.namespaces = namespaces = new Namespaces(parentNamespaces);
    } else {
      namespaces = parentNamespaces;
    }
  }
  return namespaces;
};
ElementSerializer.prototype.logNamespace = function(ns2, wellknown, local) {
  var namespaces = this.getNamespaces(local);
  var nsUri = ns2.uri, nsPrefix = ns2.prefix;
  var existing = namespaces.byUri(nsUri);
  if (!existing || local) {
    namespaces.add(ns2, wellknown);
  }
  namespaces.mapPrefix(nsPrefix, nsUri);
  return ns2;
};
ElementSerializer.prototype.logNamespaceUsed = function(ns2, local) {
  var namespaces = this.getNamespaces(local);
  var prefix3 = ns2.prefix, uri2 = ns2.uri, newPrefix, idx, wellknownUri;
  if (!prefix3 && !uri2) {
    return { localName: ns2.localName };
  }
  wellknownUri = namespaces.defaultUriByPrefix(prefix3);
  uri2 = uri2 || wellknownUri || namespaces.uriByPrefix(prefix3);
  if (!uri2) {
    throw new Error("no namespace uri given for prefix <" + prefix3 + ">");
  }
  ns2 = namespaces.byUri(uri2);
  if (!ns2 && !prefix3) {
    ns2 = this.logNamespace({ uri: uri2 }, wellknownUri === uri2, true);
  }
  if (!ns2) {
    newPrefix = prefix3;
    idx = 1;
    while (namespaces.uriByPrefix(newPrefix)) {
      newPrefix = prefix3 + "_" + idx++;
    }
    ns2 = this.logNamespace({ prefix: newPrefix, uri: uri2 }, wellknownUri === uri2);
  }
  if (prefix3) {
    namespaces.mapPrefix(prefix3, uri2);
  }
  return ns2;
};
ElementSerializer.prototype.parseAttributes = function(properties) {
  var self2 = this, element = this.element;
  forEach(properties, function(p5) {
    var value = element.get(p5.name);
    if (p5.isReference) {
      if (!p5.isMany) {
        value = value.id;
      } else {
        var values2 = [];
        forEach(value, function(v5) {
          values2.push(v5.id);
        });
        value = values2.join(" ");
      }
    }
    self2.addAttribute(self2.nsAttributeName(p5), value);
  });
};
ElementSerializer.prototype.addTagName = function(nsTagName) {
  var actualNs = this.logNamespaceUsed(nsTagName);
  this.getNamespaces().logUsed(actualNs);
  return nsName(nsTagName);
};
ElementSerializer.prototype.addAttribute = function(name2, value) {
  var attrs = this.attrs;
  if (isString(value)) {
    value = escapeAttr(value);
  }
  var idx = findIndex(attrs, function(element) {
    return element.name.localName === name2.localName && element.name.uri === name2.uri && element.name.prefix === name2.prefix;
  });
  var attr3 = { name: name2, value };
  if (idx !== -1) {
    attrs.splice(idx, 1, attr3);
  } else {
    attrs.push(attr3);
  }
};
ElementSerializer.prototype.serializeAttributes = function(writer) {
  var attrs = this.attrs, namespaces = this.namespaces;
  if (namespaces) {
    attrs = getNsAttrs(namespaces).concat(attrs);
  }
  forEach(attrs, function(a6) {
    writer.append(" ").append(nsName(a6.name)).append('="').append(a6.value).append('"');
  });
};
ElementSerializer.prototype.serializeTo = function(writer) {
  var firstBody = this.body[0], indent2 = firstBody && firstBody.constructor !== BodySerializer;
  writer.appendIndent().append("<" + this.tagName);
  this.serializeAttributes(writer);
  writer.append(firstBody ? ">" : " />");
  if (firstBody) {
    if (indent2) {
      writer.appendNewLine().indent();
    }
    forEach(this.body, function(b4) {
      b4.serializeTo(writer);
    });
    if (indent2) {
      writer.unindent().appendIndent();
    }
    writer.append("</" + this.tagName + ">");
  }
  writer.appendNewLine();
};
function TypeSerializer(parent, propertyDescriptor, serialization) {
  ElementSerializer.call(this, parent, propertyDescriptor);
  this.serialization = serialization;
}
inherits(TypeSerializer, ElementSerializer);
TypeSerializer.prototype.parseNsAttributes = function(element) {
  var attributes = ElementSerializer.prototype.parseNsAttributes.call(this, element).filter(
    (attr3) => attr3.name !== this.serialization
  );
  var descriptor = element.$descriptor;
  if (descriptor.name === this.propertyDescriptor.type) {
    return attributes;
  }
  var typeNs = this.typeNs = this.nsTagName(descriptor);
  this.getNamespaces().logUsed(this.typeNs);
  var pkg = element.$model.getPackage(typeNs.uri), typePrefix = pkg.xml && pkg.xml.typePrefix || "";
  this.addAttribute(
    this.nsAttributeName(this.serialization),
    (typeNs.prefix ? typeNs.prefix + ":" : "") + typePrefix + descriptor.ns.localName
  );
  return attributes;
};
TypeSerializer.prototype.isLocalNs = function(ns2) {
  return ns2.uri === (this.typeNs || this.ns).uri;
};
function SavingWriter() {
  this.value = "";
  this.write = function(str) {
    this.value += str;
  };
}
function FormatingWriter(out, format2) {
  var indent2 = [""];
  this.append = function(str) {
    out.write(str);
    return this;
  };
  this.appendNewLine = function() {
    if (format2) {
      out.write("\n");
    }
    return this;
  };
  this.appendIndent = function() {
    if (format2) {
      out.write(indent2.join("  "));
    }
    return this;
  };
  this.indent = function() {
    indent2.push("");
    return this;
  };
  this.unindent = function() {
    indent2.pop();
    return this;
  };
}
function Writer(options) {
  options = assign({ format: false, preamble: true }, options || {});
  function toXML(tree, writer) {
    var internalWriter = writer || new SavingWriter();
    var formatingWriter = new FormatingWriter(internalWriter, options.format);
    if (options.preamble) {
      formatingWriter.append(XML_PREAMBLE);
    }
    var serializer = new ElementSerializer();
    var model = tree.$model;
    serializer.getNamespaces().mapDefaultPrefixes(getDefaultPrefixMappings(model));
    serializer.build(tree).serializeTo(formatingWriter);
    if (!writer) {
      return internalWriter.value;
    }
  }
  return {
    toXML
  };
}
function getDefaultPrefixMappings(model) {
  const nsMap = model.config && model.config.nsMap || {};
  const prefixMap = {};
  for (const prefix3 in DEFAULT_NS_MAP) {
    prefixMap[prefix3] = DEFAULT_NS_MAP[prefix3];
  }
  for (const uri2 in nsMap) {
    const prefix3 = nsMap[uri2];
    prefixMap[prefix3] = uri2;
  }
  for (const pkg of model.getPackages()) {
    prefixMap[pkg.prefix] = pkg.uri;
  }
  return prefixMap;
}

// node_modules/bpmn-moddle/dist/index.js
function BpmnModdle(packages2, options) {
  Moddle.call(this, packages2, options);
}
BpmnModdle.prototype = Object.create(Moddle.prototype);
BpmnModdle.prototype.fromXML = function(xmlStr, typeName, options) {
  if (!isString(typeName)) {
    options = typeName;
    typeName = "bpmn:Definitions";
  }
  var reader = new Reader(assign({ model: this, lax: true }, options));
  var rootHandler = reader.handler(typeName);
  return reader.fromXML(xmlStr, rootHandler);
};
BpmnModdle.prototype.toXML = function(element, options) {
  var writer = new Writer(options);
  return new Promise(function(resolve, reject) {
    try {
      var result = writer.toXML(element);
      return resolve({
        xml: result
      });
    } catch (err) {
      return reject(err);
    }
  });
};
var name$5 = "BPMN20";
var uri$5 = "http://www.omg.org/spec/BPMN/20100524/MODEL";
var prefix$5 = "bpmn";
var associations$5 = [];
var types$5 = [
  {
    name: "Interface",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "operations",
        type: "Operation",
        isMany: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Operation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "outMessageRef",
        type: "Message",
        isReference: true
      },
      {
        name: "errorRef",
        type: "Error",
        isMany: true,
        isReference: true
      },
      {
        name: "implementationRef",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "EndPoint",
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "Auditing",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "GlobalTask",
    superClass: [
      "CallableElement"
    ],
    properties: [
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      }
    ]
  },
  {
    name: "Monitoring",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Performer",
    superClass: [
      "ResourceRole"
    ]
  },
  {
    name: "Process",
    superClass: [
      "FlowElementsContainer",
      "CallableElement"
    ],
    properties: [
      {
        name: "processType",
        type: "ProcessType",
        isAttr: true
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "laneSets",
        isMany: true,
        replaces: "FlowElementsContainer#laneSets",
        type: "LaneSet"
      },
      {
        name: "flowElements",
        isMany: true,
        replaces: "FlowElementsContainer#flowElements",
        type: "FlowElement"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "correlationSubscriptions",
        type: "CorrelationSubscription",
        isMany: true
      },
      {
        name: "supports",
        type: "Process",
        isMany: true,
        isReference: true
      },
      {
        name: "definitionalCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "isExecutable",
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "LaneSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "lanes",
        type: "Lane",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Lane",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "partitionElementRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "partitionElement",
        type: "BaseElement"
      },
      {
        name: "flowNodeRef",
        type: "FlowNode",
        isMany: true,
        isReference: true
      },
      {
        name: "childLaneSet",
        type: "LaneSet",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "GlobalManualTask",
    superClass: [
      "GlobalTask"
    ]
  },
  {
    name: "ManualTask",
    superClass: [
      "Task"
    ]
  },
  {
    name: "UserTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      },
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Rendering",
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "HumanPerformer",
    superClass: [
      "Performer"
    ]
  },
  {
    name: "PotentialOwner",
    superClass: [
      "HumanPerformer"
    ]
  },
  {
    name: "GlobalUserTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "renderings",
        type: "Rendering",
        isMany: true
      }
    ]
  },
  {
    name: "Gateway",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "gatewayDirection",
        type: "GatewayDirection",
        "default": "Unspecified",
        isAttr: true
      }
    ]
  },
  {
    name: "EventBasedGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "eventGatewayType",
        type: "EventBasedGatewayType",
        isAttr: true,
        "default": "Exclusive"
      }
    ]
  },
  {
    name: "ComplexGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "activationCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InclusiveGateway",
    superClass: [
      "Gateway"
    ],
    properties: [
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParallelGateway",
    superClass: [
      "Gateway"
    ]
  },
  {
    name: "RootElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Relationship",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "direction",
        type: "RelationshipDirection",
        isAttr: true
      },
      {
        name: "source",
        isMany: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "target",
        isMany: true,
        isReference: true,
        type: "Element"
      }
    ]
  },
  {
    name: "BaseElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        type: "String",
        isId: true
      },
      {
        name: "documentation",
        type: "Documentation",
        isMany: true
      },
      {
        name: "extensionDefinitions",
        type: "ExtensionDefinition",
        isMany: true,
        isReference: true
      },
      {
        name: "extensionElements",
        type: "ExtensionElements"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "mustUnderstand",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "definition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "extensionAttributeDefinitions",
        type: "ExtensionAttributeDefinition",
        isMany: true
      }
    ]
  },
  {
    name: "ExtensionAttributeDefinition",
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        isAttr: true,
        type: "String"
      },
      {
        name: "isReference",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "extensionDefinition",
        type: "ExtensionDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ExtensionElements",
    properties: [
      {
        name: "valueRef",
        isAttr: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "values",
        type: "Element",
        isMany: true
      },
      {
        name: "extensionAttributeDefinition",
        type: "ExtensionAttributeDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Documentation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "text",
        type: "String",
        isBody: true
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Event",
    isAbstract: true,
    superClass: [
      "FlowNode",
      "InteractionNode"
    ],
    properties: [
      {
        name: "properties",
        type: "Property",
        isMany: true
      }
    ]
  },
  {
    name: "IntermediateCatchEvent",
    superClass: [
      "CatchEvent"
    ]
  },
  {
    name: "IntermediateThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "EndEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "StartEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "isInterrupting",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "ThrowEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "inputSet",
        type: "InputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CatchEvent",
    isAbstract: true,
    superClass: [
      "Event"
    ],
    properties: [
      {
        name: "parallelMultiple",
        isAttr: true,
        type: "Boolean",
        "default": false
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "outputSet",
        type: "OutputSet"
      },
      {
        name: "eventDefinitions",
        type: "EventDefinition",
        isMany: true
      },
      {
        name: "eventDefinitionRef",
        type: "EventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "BoundaryEvent",
    superClass: [
      "CatchEvent"
    ],
    properties: [
      {
        name: "cancelActivity",
        "default": true,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "attachedToRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "EventDefinition",
    isAbstract: true,
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CancelEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "ErrorEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "errorRef",
        type: "Error",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TerminateEventDefinition",
    superClass: [
      "EventDefinition"
    ]
  },
  {
    name: "EscalationEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "escalationRef",
        type: "Escalation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Escalation",
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "escalationCode",
        isAttr: true,
        type: "String"
      }
    ],
    superClass: [
      "RootElement"
    ]
  },
  {
    name: "CompensateEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "waitForCompletion",
        isAttr: true,
        type: "Boolean",
        "default": true
      },
      {
        name: "activityRef",
        type: "Activity",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TimerEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "timeDate",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeCycle",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "timeDuration",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "LinkEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "target",
        type: "LinkEventDefinition",
        isReference: true
      },
      {
        name: "source",
        type: "LinkEventDefinition",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConditionalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "condition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "SignalEventDefinition",
    superClass: [
      "EventDefinition"
    ],
    properties: [
      {
        name: "signalRef",
        type: "Signal",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Signal",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ImplicitThrowEvent",
    superClass: [
      "ThrowEvent"
    ]
  },
  {
    name: "DataState",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ItemAwareElement",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "itemSubjectRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "dataState",
        type: "DataState"
      }
    ]
  },
  {
    name: "DataAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "ItemAwareElement",
        isMany: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "transformation",
        type: "FormalExpression",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "assignment",
        type: "Assignment",
        isMany: true
      }
    ]
  },
  {
    name: "DataInput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "inputSetRef",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithOptional",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "inputSetWithWhileExecuting",
        type: "InputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataOutput",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "outputSetRef",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithOptional",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outputSetWithWhileExecuting",
        type: "OutputSet",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "InputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "dataInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingInputRefs",
        type: "DataInput",
        isMany: true,
        isReference: true
      },
      {
        name: "outputSetRefs",
        type: "OutputSet",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "OutputSet",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "inputSetRefs",
        type: "InputSet",
        isMany: true,
        isReference: true
      },
      {
        name: "optionalOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      },
      {
        name: "whileExecutingOutputRefs",
        type: "DataOutput",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Property",
    superClass: [
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "DataInputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "DataOutputAssociation",
    superClass: [
      "DataAssociation"
    ]
  },
  {
    name: "InputOutputSpecification",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataInputs",
        type: "DataInput",
        isMany: true
      },
      {
        name: "dataOutputs",
        type: "DataOutput",
        isMany: true
      },
      {
        name: "inputSets",
        type: "InputSet",
        isMany: true
      },
      {
        name: "outputSets",
        type: "OutputSet",
        isMany: true
      }
    ]
  },
  {
    name: "DataObject",
    superClass: [
      "FlowElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "InputOutputBinding",
    properties: [
      {
        name: "inputDataRef",
        type: "InputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "outputDataRef",
        type: "OutputSet",
        isAttr: true,
        isReference: true
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Assignment",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "from",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "to",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "DataStore",
    superClass: [
      "RootElement",
      "ItemAwareElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "capacity",
        isAttr: true,
        type: "Integer"
      },
      {
        name: "isUnlimited",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "DataStoreReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataStoreRef",
        type: "DataStore",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "DataObjectReference",
    superClass: [
      "ItemAwareElement",
      "FlowElement"
    ],
    properties: [
      {
        name: "dataObjectRef",
        type: "DataObject",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ConversationLink",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ConversationAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerConversationNodeRef",
        type: "ConversationNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CallConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "calledCollaborationRef",
        type: "Collaboration",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "Conversation",
    superClass: [
      "ConversationNode"
    ]
  },
  {
    name: "SubConversation",
    superClass: [
      "ConversationNode"
    ],
    properties: [
      {
        name: "conversationNodes",
        type: "ConversationNode",
        isMany: true
      }
    ]
  },
  {
    name: "ConversationNode",
    isAbstract: true,
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "messageFlowRefs",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      }
    ]
  },
  {
    name: "GlobalConversation",
    superClass: [
      "Collaboration"
    ]
  },
  {
    name: "PartnerEntity",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "PartnerRole",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationProperty",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "correlationPropertyRetrievalExpression",
        type: "CorrelationPropertyRetrievalExpression",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Error",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "structureRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "errorCode",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "CorrelationKey",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isMany: true,
        isReference: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Expression",
    superClass: [
      "BaseElement"
    ],
    isAbstract: false,
    properties: [
      {
        name: "body",
        isBody: true,
        type: "String"
      }
    ]
  },
  {
    name: "FormalExpression",
    superClass: [
      "Expression"
    ],
    properties: [
      {
        name: "language",
        isAttr: true,
        type: "String"
      },
      {
        name: "evaluatesToTypeRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Message",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "itemRef",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ItemDefinition",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "itemKind",
        type: "ItemKind",
        isAttr: true
      },
      {
        name: "structureRef",
        isAttr: true,
        type: "String"
      },
      {
        name: "isCollection",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "import",
        type: "Import",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElement",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "auditing",
        type: "Auditing"
      },
      {
        name: "monitoring",
        type: "Monitoring"
      },
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "SequenceFlow",
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "isImmediate",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "conditionExpression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "sourceRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "FlowNode",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "FlowElementsContainer",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "laneSets",
        type: "LaneSet",
        isMany: true
      },
      {
        name: "flowElements",
        type: "FlowElement",
        isMany: true
      }
    ]
  },
  {
    name: "CallableElement",
    isAbstract: true,
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "supportedInterfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "ioBinding",
        type: "InputOutputBinding",
        isMany: true,
        xml: {
          serialize: "property"
        }
      }
    ]
  },
  {
    name: "FlowNode",
    isAbstract: true,
    superClass: [
      "FlowElement"
    ],
    properties: [
      {
        name: "incoming",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "outgoing",
        type: "SequenceFlow",
        isMany: true,
        isReference: true
      },
      {
        name: "lanes",
        type: "Lane",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyRetrievalExpression",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "messagePath",
        type: "FormalExpression"
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationPropertyBinding",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "dataPath",
        type: "FormalExpression"
      },
      {
        name: "correlationPropertyRef",
        type: "CorrelationProperty",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Resource",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "resourceParameters",
        type: "ResourceParameter",
        isMany: true
      }
    ]
  },
  {
    name: "ResourceParameter",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isRequired",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "type",
        type: "ItemDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "CorrelationSubscription",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "correlationKeyRef",
        type: "CorrelationKey",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationPropertyBinding",
        type: "CorrelationPropertyBinding",
        isMany: true
      }
    ]
  },
  {
    name: "MessageFlow",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "sourceRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "InteractionNode",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "MessageFlowAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerMessageFlowRef",
        type: "MessageFlow",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "InteractionNode",
    isAbstract: true,
    properties: [
      {
        name: "incomingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "outgoingConversationLinks",
        type: "ConversationLink",
        isMany: true,
        isVirtual: true,
        isReference: true
      }
    ]
  },
  {
    name: "Participant",
    superClass: [
      "InteractionNode",
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "interfaceRef",
        type: "Interface",
        isMany: true,
        isReference: true
      },
      {
        name: "participantMultiplicity",
        type: "ParticipantMultiplicity"
      },
      {
        name: "endPointRefs",
        type: "EndPoint",
        isMany: true,
        isReference: true
      },
      {
        name: "processRef",
        type: "Process",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantAssociation",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "innerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "outerParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ParticipantMultiplicity",
    properties: [
      {
        name: "minimum",
        "default": 0,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "maximum",
        "default": 1,
        isAttr: true,
        type: "Integer"
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Collaboration",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "isClosed",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participants",
        type: "Participant",
        isMany: true
      },
      {
        name: "messageFlows",
        type: "MessageFlow",
        isMany: true
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      },
      {
        name: "conversations",
        type: "ConversationNode",
        isMany: true
      },
      {
        name: "conversationAssociations",
        type: "ConversationAssociation"
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      },
      {
        name: "messageFlowAssociations",
        type: "MessageFlowAssociation",
        isMany: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "choreographyRef",
        type: "Choreography",
        isMany: true,
        isReference: true
      },
      {
        name: "conversationLinks",
        type: "ConversationLink",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyActivity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "participantRef",
        type: "Participant",
        isMany: true,
        isReference: true
      },
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      },
      {
        name: "correlationKeys",
        type: "CorrelationKey",
        isMany: true
      },
      {
        name: "loopType",
        type: "ChoreographyLoopType",
        "default": "None",
        isAttr: true
      }
    ]
  },
  {
    name: "CallChoreography",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "calledChoreographyRef",
        type: "Choreography",
        isAttr: true,
        isReference: true
      },
      {
        name: "participantAssociations",
        type: "ParticipantAssociation",
        isMany: true
      }
    ]
  },
  {
    name: "SubChoreography",
    superClass: [
      "ChoreographyActivity",
      "FlowElementsContainer"
    ],
    properties: [
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "ChoreographyTask",
    superClass: [
      "ChoreographyActivity"
    ],
    properties: [
      {
        name: "messageFlowRef",
        type: "MessageFlow",
        isMany: true,
        isReference: true
      }
    ]
  },
  {
    name: "Choreography",
    superClass: [
      "Collaboration",
      "FlowElementsContainer"
    ]
  },
  {
    name: "GlobalChoreographyTask",
    superClass: [
      "Choreography"
    ],
    properties: [
      {
        name: "initiatingParticipantRef",
        type: "Participant",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "TextAnnotation",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "text",
        type: "String"
      },
      {
        name: "textFormat",
        "default": "text/plain",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Group",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "categoryValueRef",
        type: "CategoryValue",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Association",
    superClass: [
      "Artifact"
    ],
    properties: [
      {
        name: "associationDirection",
        type: "AssociationDirection",
        isAttr: true
      },
      {
        name: "sourceRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      },
      {
        name: "targetRef",
        type: "BaseElement",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "Category",
    superClass: [
      "RootElement"
    ],
    properties: [
      {
        name: "categoryValue",
        type: "CategoryValue",
        isMany: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Artifact",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "CategoryValue",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "categorizedFlowElements",
        type: "FlowElement",
        isMany: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "value",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Activity",
    isAbstract: true,
    superClass: [
      "FlowNode"
    ],
    properties: [
      {
        name: "isForCompensation",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "default",
        type: "SequenceFlow",
        isAttr: true,
        isReference: true
      },
      {
        name: "ioSpecification",
        type: "InputOutputSpecification",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "boundaryEventRefs",
        type: "BoundaryEvent",
        isMany: true,
        isReference: true
      },
      {
        name: "properties",
        type: "Property",
        isMany: true
      },
      {
        name: "dataInputAssociations",
        type: "DataInputAssociation",
        isMany: true
      },
      {
        name: "dataOutputAssociations",
        type: "DataOutputAssociation",
        isMany: true
      },
      {
        name: "startQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "resources",
        type: "ResourceRole",
        isMany: true
      },
      {
        name: "completionQuantity",
        "default": 1,
        isAttr: true,
        type: "Integer"
      },
      {
        name: "loopCharacteristics",
        type: "LoopCharacteristics"
      }
    ]
  },
  {
    name: "ServiceTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "SubProcess",
    superClass: [
      "Activity",
      "FlowElementsContainer",
      "InteractionNode"
    ],
    properties: [
      {
        name: "triggeredByEvent",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "artifacts",
        type: "Artifact",
        isMany: true
      }
    ]
  },
  {
    name: "LoopCharacteristics",
    isAbstract: true,
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "MultiInstanceLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "isSequential",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "behavior",
        type: "MultiInstanceBehavior",
        "default": "All",
        isAttr: true
      },
      {
        name: "loopCardinality",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopDataInputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "loopDataOutputRef",
        type: "ItemAwareElement",
        isReference: true
      },
      {
        name: "inputDataItem",
        type: "DataInput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "outputDataItem",
        type: "DataOutput",
        xml: {
          serialize: "property"
        }
      },
      {
        name: "complexBehaviorDefinition",
        type: "ComplexBehaviorDefinition",
        isMany: true
      },
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "oneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      },
      {
        name: "noneBehaviorEventRef",
        type: "EventDefinition",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "StandardLoopCharacteristics",
    superClass: [
      "LoopCharacteristics"
    ],
    properties: [
      {
        name: "testBefore",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "loopCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "loopMaximum",
        type: "Integer",
        isAttr: true
      }
    ]
  },
  {
    name: "CallActivity",
    superClass: [
      "Activity",
      "InteractionNode"
    ],
    properties: [
      {
        name: "calledElement",
        type: "String",
        isAttr: true
      }
    ]
  },
  {
    name: "Task",
    superClass: [
      "Activity",
      "InteractionNode"
    ]
  },
  {
    name: "SendTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ReceiveTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      },
      {
        name: "instantiate",
        "default": false,
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "operationRef",
        type: "Operation",
        isAttr: true,
        isReference: true
      },
      {
        name: "messageRef",
        type: "Message",
        isAttr: true,
        isReference: true
      }
    ]
  },
  {
    name: "ScriptTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "scriptFormat",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        type: "String"
      }
    ]
  },
  {
    name: "BusinessRuleTask",
    superClass: [
      "Task"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "AdHocSubProcess",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "completionCondition",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "ordering",
        type: "AdHocOrdering",
        isAttr: true
      },
      {
        name: "cancelRemainingInstances",
        "default": true,
        isAttr: true,
        type: "Boolean"
      }
    ]
  },
  {
    name: "Transaction",
    superClass: [
      "SubProcess"
    ],
    properties: [
      {
        name: "protocol",
        isAttr: true,
        type: "String"
      },
      {
        name: "method",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalScriptTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "scriptLanguage",
        isAttr: true,
        type: "String"
      },
      {
        name: "script",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "GlobalBusinessRuleTask",
    superClass: [
      "GlobalTask"
    ],
    properties: [
      {
        name: "implementation",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ComplexBehaviorDefinition",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "condition",
        type: "FormalExpression"
      },
      {
        name: "event",
        type: "ImplicitThrowEvent"
      }
    ]
  },
  {
    name: "ResourceRole",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "resourceRef",
        type: "Resource",
        isReference: true
      },
      {
        name: "resourceParameterBindings",
        type: "ResourceParameterBinding",
        isMany: true
      },
      {
        name: "resourceAssignmentExpression",
        type: "ResourceAssignmentExpression"
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ResourceParameterBinding",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      },
      {
        name: "parameterRef",
        type: "ResourceParameter",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "ResourceAssignmentExpression",
    properties: [
      {
        name: "expression",
        type: "Expression",
        xml: {
          serialize: "xsi:type"
        }
      }
    ],
    superClass: [
      "BaseElement"
    ]
  },
  {
    name: "Import",
    properties: [
      {
        name: "importType",
        isAttr: true,
        type: "String"
      },
      {
        name: "location",
        isAttr: true,
        type: "String"
      },
      {
        name: "namespace",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "Definitions",
    superClass: [
      "BaseElement"
    ],
    properties: [
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "targetNamespace",
        isAttr: true,
        type: "String"
      },
      {
        name: "expressionLanguage",
        "default": "http://www.w3.org/1999/XPath",
        isAttr: true,
        type: "String"
      },
      {
        name: "typeLanguage",
        "default": "http://www.w3.org/2001/XMLSchema",
        isAttr: true,
        type: "String"
      },
      {
        name: "imports",
        type: "Import",
        isMany: true
      },
      {
        name: "extensions",
        type: "Extension",
        isMany: true
      },
      {
        name: "rootElements",
        type: "RootElement",
        isMany: true
      },
      {
        name: "diagrams",
        isMany: true,
        type: "bpmndi:BPMNDiagram"
      },
      {
        name: "exporter",
        isAttr: true,
        type: "String"
      },
      {
        name: "relationships",
        type: "Relationship",
        isMany: true
      },
      {
        name: "exporterVersion",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$3 = [
  {
    name: "ProcessType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Public"
      },
      {
        name: "Private"
      }
    ]
  },
  {
    name: "GatewayDirection",
    literalValues: [
      {
        name: "Unspecified"
      },
      {
        name: "Converging"
      },
      {
        name: "Diverging"
      },
      {
        name: "Mixed"
      }
    ]
  },
  {
    name: "EventBasedGatewayType",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Exclusive"
      }
    ]
  },
  {
    name: "RelationshipDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Forward"
      },
      {
        name: "Backward"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "ItemKind",
    literalValues: [
      {
        name: "Physical"
      },
      {
        name: "Information"
      }
    ]
  },
  {
    name: "ChoreographyLoopType",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "Standard"
      },
      {
        name: "MultiInstanceSequential"
      },
      {
        name: "MultiInstanceParallel"
      }
    ]
  },
  {
    name: "AssociationDirection",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "Both"
      }
    ]
  },
  {
    name: "MultiInstanceBehavior",
    literalValues: [
      {
        name: "None"
      },
      {
        name: "One"
      },
      {
        name: "All"
      },
      {
        name: "Complex"
      }
    ]
  },
  {
    name: "AdHocOrdering",
    literalValues: [
      {
        name: "Parallel"
      },
      {
        name: "Sequential"
      }
    ]
  }
];
var xml$1 = {
  tagAlias: "lowerCase",
  typePrefix: "t"
};
var BpmnPackage = {
  name: name$5,
  uri: uri$5,
  prefix: prefix$5,
  associations: associations$5,
  types: types$5,
  enumerations: enumerations$3,
  xml: xml$1
};
var name$4 = "BPMNDI";
var uri$4 = "http://www.omg.org/spec/BPMN/20100524/DI";
var prefix$4 = "bpmndi";
var types$4 = [
  {
    name: "BPMNDiagram",
    properties: [
      {
        name: "plane",
        type: "BPMNPlane",
        redefines: "di:Diagram#rootElement"
      },
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isMany: true
      }
    ],
    superClass: [
      "di:Diagram"
    ]
  },
  {
    name: "BPMNPlane",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      }
    ],
    superClass: [
      "di:Plane"
    ]
  },
  {
    name: "BPMNShape",
    properties: [
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "isHorizontal",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isExpanded",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "isMarkerVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "isMessageVisible",
        isAttr: true,
        type: "Boolean"
      },
      {
        name: "participantBandKind",
        type: "ParticipantBandKind",
        isAttr: true
      },
      {
        name: "choreographyActivityShape",
        type: "BPMNShape",
        isAttr: true,
        isReference: true
      }
    ],
    superClass: [
      "di:LabeledShape"
    ]
  },
  {
    name: "BPMNEdge",
    properties: [
      {
        name: "label",
        type: "BPMNLabel"
      },
      {
        name: "bpmnElement",
        isAttr: true,
        isReference: true,
        type: "bpmn:BaseElement",
        redefines: "di:DiagramElement#modelElement"
      },
      {
        name: "sourceElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#source"
      },
      {
        name: "targetElement",
        isAttr: true,
        isReference: true,
        type: "di:DiagramElement",
        redefines: "di:Edge#target"
      },
      {
        name: "messageVisibleKind",
        type: "MessageVisibleKind",
        isAttr: true,
        "default": "initiating"
      }
    ],
    superClass: [
      "di:LabeledEdge"
    ]
  },
  {
    name: "BPMNLabel",
    properties: [
      {
        name: "labelStyle",
        type: "BPMNLabelStyle",
        isAttr: true,
        isReference: true,
        redefines: "di:DiagramElement#style"
      }
    ],
    superClass: [
      "di:Label"
    ]
  },
  {
    name: "BPMNLabelStyle",
    properties: [
      {
        name: "font",
        type: "dc:Font"
      }
    ],
    superClass: [
      "di:Style"
    ]
  }
];
var enumerations$2 = [
  {
    name: "ParticipantBandKind",
    literalValues: [
      {
        name: "top_initiating"
      },
      {
        name: "middle_initiating"
      },
      {
        name: "bottom_initiating"
      },
      {
        name: "top_non_initiating"
      },
      {
        name: "middle_non_initiating"
      },
      {
        name: "bottom_non_initiating"
      }
    ]
  },
  {
    name: "MessageVisibleKind",
    literalValues: [
      {
        name: "initiating"
      },
      {
        name: "non_initiating"
      }
    ]
  }
];
var associations$4 = [];
var BpmnDiPackage = {
  name: name$4,
  uri: uri$4,
  prefix: prefix$4,
  types: types$4,
  enumerations: enumerations$2,
  associations: associations$4
};
var name$3 = "DC";
var uri$3 = "http://www.omg.org/spec/DD/20100524/DC";
var prefix$3 = "dc";
var types$3 = [
  {
    name: "Boolean"
  },
  {
    name: "Integer"
  },
  {
    name: "Real"
  },
  {
    name: "String"
  },
  {
    name: "Font",
    properties: [
      {
        name: "name",
        type: "String",
        isAttr: true
      },
      {
        name: "size",
        type: "Real",
        isAttr: true
      },
      {
        name: "isBold",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isItalic",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isUnderline",
        type: "Boolean",
        isAttr: true
      },
      {
        name: "isStrikeThrough",
        type: "Boolean",
        isAttr: true
      }
    ]
  },
  {
    name: "Point",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      }
    ]
  },
  {
    name: "Bounds",
    properties: [
      {
        name: "x",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "y",
        type: "Real",
        "default": "0",
        isAttr: true
      },
      {
        name: "width",
        type: "Real",
        isAttr: true
      },
      {
        name: "height",
        type: "Real",
        isAttr: true
      }
    ]
  }
];
var associations$3 = [];
var DcPackage = {
  name: name$3,
  uri: uri$3,
  prefix: prefix$3,
  types: types$3,
  associations: associations$3
};
var name$2 = "DI";
var uri$2 = "http://www.omg.org/spec/DD/20100524/DI";
var prefix$2 = "di";
var types$2 = [
  {
    name: "DiagramElement",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "extension",
        type: "Extension"
      },
      {
        name: "owningDiagram",
        type: "Diagram",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "owningElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "modelElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true,
        type: "Element"
      },
      {
        name: "style",
        type: "Style",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "ownedElement",
        type: "DiagramElement",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Node",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ]
  },
  {
    name: "Edge",
    isAbstract: true,
    superClass: [
      "DiagramElement"
    ],
    properties: [
      {
        name: "source",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "target",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true,
        isReference: true
      },
      {
        name: "waypoint",
        isUnique: false,
        isMany: true,
        type: "dc:Point",
        xml: {
          serialize: "xsi:type"
        }
      }
    ]
  },
  {
    name: "Diagram",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      },
      {
        name: "rootElement",
        type: "DiagramElement",
        isReadOnly: true,
        isVirtual: true
      },
      {
        name: "name",
        isAttr: true,
        type: "String"
      },
      {
        name: "documentation",
        isAttr: true,
        type: "String"
      },
      {
        name: "resolution",
        isAttr: true,
        type: "Real"
      },
      {
        name: "ownedStyle",
        type: "Style",
        isReadOnly: true,
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Shape",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Plane",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "planeElement",
        type: "DiagramElement",
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true
      }
    ]
  },
  {
    name: "LabeledEdge",
    isAbstract: true,
    superClass: [
      "Edge"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "LabeledShape",
    isAbstract: true,
    superClass: [
      "Shape"
    ],
    properties: [
      {
        name: "ownedLabel",
        type: "Label",
        isReadOnly: true,
        subsettedProperty: "DiagramElement-ownedElement",
        isMany: true,
        isVirtual: true
      }
    ]
  },
  {
    name: "Label",
    isAbstract: true,
    superClass: [
      "Node"
    ],
    properties: [
      {
        name: "bounds",
        type: "dc:Bounds"
      }
    ]
  },
  {
    name: "Style",
    isAbstract: true,
    properties: [
      {
        name: "id",
        isAttr: true,
        isId: true,
        type: "String"
      }
    ]
  },
  {
    name: "Extension",
    properties: [
      {
        name: "values",
        isMany: true,
        type: "Element"
      }
    ]
  }
];
var associations$2 = [];
var xml = {
  tagAlias: "lowerCase"
};
var DiPackage = {
  name: name$2,
  uri: uri$2,
  prefix: prefix$2,
  types: types$2,
  associations: associations$2,
  xml
};
var name$1 = "bpmn.io colors for BPMN";
var uri$1 = "http://bpmn.io/schema/bpmn/biocolor/1.0";
var prefix$1 = "bioc";
var types$1 = [
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "stroke",
        isAttr: true,
        type: "String"
      },
      {
        name: "fill",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations$1 = [];
var associations$1 = [];
var BiocPackage = {
  name: name$1,
  uri: uri$1,
  prefix: prefix$1,
  types: types$1,
  enumerations: enumerations$1,
  associations: associations$1
};
var name = "BPMN in Color";
var uri = "http://www.omg.org/spec/BPMN/non-normative/color/1.0";
var prefix2 = "color";
var types2 = [
  {
    name: "ColoredLabel",
    "extends": [
      "bpmndi:BPMNLabel"
    ],
    properties: [
      {
        name: "color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredShape",
    "extends": [
      "bpmndi:BPMNShape"
    ],
    properties: [
      {
        name: "background-color",
        isAttr: true,
        type: "String"
      },
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  },
  {
    name: "ColoredEdge",
    "extends": [
      "bpmndi:BPMNEdge"
    ],
    properties: [
      {
        name: "border-color",
        isAttr: true,
        type: "String"
      }
    ]
  }
];
var enumerations = [];
var associations = [];
var BpmnInColorPackage = {
  name,
  uri,
  prefix: prefix2,
  types: types2,
  enumerations,
  associations
};
var packages = {
  bpmn: BpmnPackage,
  bpmndi: BpmnDiPackage,
  dc: DcPackage,
  di: DiPackage,
  bioc: BiocPackage,
  color: BpmnInColorPackage
};
function SimpleBpmnModdle(additionalPackages, options) {
  const pks = assign({}, packages, additionalPackages);
  return new BpmnModdle(pks, options);
}

// node_modules/bpmn-js/lib/util/CompatibilityUtil.js
var DI_ERROR_MESSAGE = "Tried to access di from the businessObject. The di is available through the diagram element only. For more information, see https://github.com/bpmn-io/bpmn-js/issues/1472";
function ensureCompatDiRef(businessObject) {
  if (!has(businessObject, "di")) {
    Object.defineProperty(businessObject, "di", {
      enumerable: false,
      get: function() {
        throw new Error(DI_ERROR_MESSAGE);
      }
    });
  }
}

// node_modules/bpmn-js/lib/import/BpmnTreeWalker.js
function is2(element, type) {
  return element.$instanceOf(type);
}
function findDisplayCandidate(definitions) {
  return find(definitions.rootElements, function(e8) {
    return is2(e8, "bpmn:Process") || is2(e8, "bpmn:Collaboration");
  });
}
function BpmnTreeWalker(handler) {
  var handledElements = {};
  var deferred = [];
  var diMap = {};
  function contextual(fn2, ctx) {
    return function(e8) {
      fn2(e8, ctx);
    };
  }
  function handled(element) {
    handledElements[element.id] = element;
  }
  function isHandled(element) {
    return handledElements[element.id];
  }
  function visit(element, ctx) {
    var gfx = element.gfx;
    if (gfx) {
      throw new Error(
        `already rendered ${elementToString(element)}`
      );
    }
    return handler.element(element, diMap[element.id], ctx);
  }
  function visitRoot(element, diagram) {
    return handler.root(element, diMap[element.id], diagram);
  }
  function visitIfDi(element, ctx) {
    try {
      var gfx = diMap[element.id] && visit(element, ctx);
      handled(element);
      return gfx;
    } catch (error4) {
      logError(error4.message, { element, error: error4 });
      console.error(`failed to import ${elementToString(element)}`, error4);
    }
  }
  function logError(message, context) {
    handler.error(message, context);
  }
  var registerDi = this.registerDi = function registerDi2(di) {
    var bpmnElement = di.bpmnElement;
    if (bpmnElement) {
      if (diMap[bpmnElement.id]) {
        logError(
          `multiple DI elements defined for ${elementToString(bpmnElement)}`,
          { element: bpmnElement }
        );
      } else {
        diMap[bpmnElement.id] = di;
        ensureCompatDiRef(bpmnElement);
      }
    } else {
      logError(
        `no bpmnElement referenced in ${elementToString(di)}`,
        { element: di }
      );
    }
  };
  function handleDiagram(diagram) {
    handlePlane(diagram.plane);
  }
  function handlePlane(plane) {
    registerDi(plane);
    forEach(plane.planeElement, handlePlaneElement);
  }
  function handlePlaneElement(planeElement) {
    registerDi(planeElement);
  }
  this.handleDefinitions = function handleDefinitions(definitions, diagram) {
    var diagrams = definitions.diagrams;
    if (diagram && diagrams.indexOf(diagram) === -1) {
      throw new Error("diagram not part of <bpmn:Definitions />");
    }
    if (!diagram && diagrams && diagrams.length) {
      diagram = diagrams[0];
    }
    if (!diagram) {
      throw new Error("no diagram to display");
    }
    diMap = {};
    handleDiagram(diagram);
    var plane = diagram.plane;
    if (!plane) {
      throw new Error(
        `no plane for ${elementToString(diagram)}`
      );
    }
    var rootElement = plane.bpmnElement;
    if (!rootElement) {
      rootElement = findDisplayCandidate(definitions);
      if (!rootElement) {
        throw new Error("no process or collaboration to display");
      } else {
        logError(
          `correcting missing bpmnElement on ${elementToString(plane)} to ${elementToString(rootElement)}`
        );
        plane.bpmnElement = rootElement;
        registerDi(plane);
      }
    }
    var ctx = visitRoot(rootElement, plane);
    if (is2(rootElement, "bpmn:Process") || is2(rootElement, "bpmn:SubProcess")) {
      handleProcess(rootElement, ctx);
    } else if (is2(rootElement, "bpmn:Collaboration")) {
      handleCollaboration(rootElement, ctx);
      handleUnhandledProcesses(definitions.rootElements, ctx);
    } else {
      throw new Error(
        `unsupported bpmnElement for ${elementToString(plane)}: ${elementToString(rootElement)}`
      );
    }
    handleDeferred(deferred);
  };
  var handleDeferred = this.handleDeferred = function handleDeferred2() {
    var fn2;
    while (deferred.length) {
      fn2 = deferred.shift();
      fn2();
    }
  };
  function handleProcess(process2, context) {
    handleFlowElementsContainer(process2, context);
    handleIoSpecification(process2.ioSpecification, context);
    handleArtifacts(process2.artifacts, context);
    handled(process2);
  }
  function handleUnhandledProcesses(rootElements, ctx) {
    var processes = filter(rootElements, function(e8) {
      return !isHandled(e8) && is2(e8, "bpmn:Process") && e8.laneSets;
    });
    processes.forEach(contextual(handleProcess, ctx));
  }
  function handleMessageFlow(messageFlow, context) {
    visitIfDi(messageFlow, context);
  }
  function handleMessageFlows(messageFlows, context) {
    forEach(messageFlows, contextual(handleMessageFlow, context));
  }
  function handleDataAssociation(association, context) {
    visitIfDi(association, context);
  }
  function handleDataInput(dataInput, context) {
    visitIfDi(dataInput, context);
  }
  function handleDataOutput(dataOutput, context) {
    visitIfDi(dataOutput, context);
  }
  function handleArtifact(artifact, context) {
    visitIfDi(artifact, context);
  }
  function handleArtifacts(artifacts, context) {
    forEach(artifacts, function(e8) {
      if (is2(e8, "bpmn:Association")) {
        deferred.push(function() {
          handleArtifact(e8, context);
        });
      } else {
        handleArtifact(e8, context);
      }
    });
  }
  function handleIoSpecification(ioSpecification, context) {
    if (!ioSpecification) {
      return;
    }
    forEach(ioSpecification.dataInputs, contextual(handleDataInput, context));
    forEach(ioSpecification.dataOutputs, contextual(handleDataOutput, context));
  }
  var handleSubProcess = this.handleSubProcess = function handleSubProcess2(subProcess, context) {
    handleFlowElementsContainer(subProcess, context);
    handleArtifacts(subProcess.artifacts, context);
  };
  function handleFlowNode(flowNode, context) {
    var childCtx = visitIfDi(flowNode, context);
    if (is2(flowNode, "bpmn:SubProcess")) {
      handleSubProcess(flowNode, childCtx || context);
    }
    if (is2(flowNode, "bpmn:Activity")) {
      handleIoSpecification(flowNode.ioSpecification, context);
    }
    deferred.push(function() {
      forEach(flowNode.dataInputAssociations, contextual(handleDataAssociation, context));
      forEach(flowNode.dataOutputAssociations, contextual(handleDataAssociation, context));
    });
  }
  function handleSequenceFlow(sequenceFlow, context) {
    visitIfDi(sequenceFlow, context);
  }
  function handleDataElement(dataObject, context) {
    visitIfDi(dataObject, context);
  }
  function handleLane(lane, context) {
    deferred.push(function() {
      var newContext = visitIfDi(lane, context);
      if (lane.childLaneSet) {
        handleLaneSet(lane.childLaneSet, newContext || context);
      }
      wireFlowNodeRefs(lane);
    });
  }
  function handleLaneSet(laneSet, context) {
    forEach(laneSet.lanes, contextual(handleLane, context));
  }
  function handleLaneSets(laneSets, context) {
    forEach(laneSets, contextual(handleLaneSet, context));
  }
  function handleFlowElementsContainer(container, context) {
    handleFlowElements(container.flowElements, context);
    if (container.laneSets) {
      handleLaneSets(container.laneSets, context);
    }
  }
  function handleFlowElements(flowElements, context) {
    forEach(flowElements, function(flowElement) {
      if (is2(flowElement, "bpmn:SequenceFlow")) {
        deferred.push(function() {
          handleSequenceFlow(flowElement, context);
        });
      } else if (is2(flowElement, "bpmn:BoundaryEvent")) {
        deferred.unshift(function() {
          handleFlowNode(flowElement, context);
        });
      } else if (is2(flowElement, "bpmn:FlowNode")) {
        handleFlowNode(flowElement, context);
      } else if (is2(flowElement, "bpmn:DataObject")) {
      } else if (is2(flowElement, "bpmn:DataStoreReference")) {
        handleDataElement(flowElement, context);
      } else if (is2(flowElement, "bpmn:DataObjectReference")) {
        handleDataElement(flowElement, context);
      } else {
        logError(
          `unrecognized flowElement ${elementToString(flowElement)} in context ${elementToString(context && context.businessObject)}`,
          {
            element: flowElement,
            context
          }
        );
      }
    });
  }
  function handleParticipant(participant, context) {
    var newCtx = visitIfDi(participant, context);
    var process2 = participant.processRef;
    if (process2) {
      handleProcess(process2, newCtx || context);
    }
  }
  function handleCollaboration(collaboration, context) {
    forEach(collaboration.participants, contextual(handleParticipant, context));
    handleArtifacts(collaboration.artifacts, context);
    deferred.push(function() {
      handleMessageFlows(collaboration.messageFlows, context);
    });
  }
  function wireFlowNodeRefs(lane) {
    forEach(lane.flowNodeRef, function(flowNode) {
      var lanes = flowNode.get("lanes");
      if (lanes) {
        lanes.push(lane);
      }
    });
  }
}

// node_modules/bpmn-js/lib/import/Importer.js
function importBpmnDiagram(diagram, definitions, bpmnDiagram) {
  var importer, eventBus, canvas;
  var error4, warnings = [];
  function render(definitions2, bpmnDiagram2) {
    var visitor = {
      root: function(element, di) {
        return importer.add(element, di);
      },
      element: function(element, di, parentShape) {
        return importer.add(element, di, parentShape);
      },
      error: function(message, context) {
        warnings.push({ message, context });
      }
    };
    var walker = new BpmnTreeWalker(visitor);
    bpmnDiagram2 = bpmnDiagram2 || definitions2.diagrams && definitions2.diagrams[0];
    var diagramsToImport = getDiagramsToImport(definitions2, bpmnDiagram2);
    if (!diagramsToImport) {
      throw new Error("no diagram to display");
    }
    forEach(diagramsToImport, function(diagram2) {
      walker.handleDefinitions(definitions2, diagram2);
    });
    var rootId = bpmnDiagram2.plane.bpmnElement.id;
    canvas.setRootElement(
      canvas.findRoot(rootId + "_plane") || canvas.findRoot(rootId)
    );
  }
  return new Promise(function(resolve, reject) {
    try {
      importer = diagram.get("bpmnImporter");
      eventBus = diagram.get("eventBus");
      canvas = diagram.get("canvas");
      eventBus.fire("import.render.start", { definitions });
      render(definitions, bpmnDiagram);
      eventBus.fire("import.render.complete", {
        error: error4,
        warnings
      });
      return resolve({ warnings });
    } catch (e8) {
      e8.warnings = warnings;
      return reject(e8);
    }
  });
}
function getDiagramsToImport(definitions, bpmnDiagram) {
  if (!bpmnDiagram || !bpmnDiagram.plane) {
    return;
  }
  var bpmnElement = bpmnDiagram.plane.bpmnElement, rootElement = bpmnElement;
  if (!is(bpmnElement, "bpmn:Process") && !is(bpmnElement, "bpmn:Collaboration")) {
    rootElement = findRootProcess(bpmnElement);
  }
  var collaboration;
  if (is(rootElement, "bpmn:Collaboration")) {
    collaboration = rootElement;
  } else {
    collaboration = find(definitions.rootElements, function(element) {
      if (!is(element, "bpmn:Collaboration")) {
        return;
      }
      return find(element.participants, function(participant) {
        return participant.processRef === rootElement;
      });
    });
  }
  var rootElements = [rootElement];
  if (collaboration) {
    rootElements = map(collaboration.participants, function(participant) {
      return participant.processRef;
    });
    rootElements.push(collaboration);
  }
  var allChildren = selfAndAllFlowElements(rootElements);
  var diagramsToImport = [bpmnDiagram];
  var handledElements = [bpmnElement];
  forEach(definitions.diagrams, function(diagram) {
    if (!diagram.plane) {
      return;
    }
    var businessObject = diagram.plane.bpmnElement;
    if (allChildren.indexOf(businessObject) !== -1 && handledElements.indexOf(businessObject) === -1) {
      diagramsToImport.push(diagram);
      handledElements.push(businessObject);
    }
  });
  return diagramsToImport;
}
function selfAndAllFlowElements(elements) {
  var result = [];
  forEach(elements, function(element) {
    if (!element) {
      return;
    }
    result.push(element);
    result = result.concat(selfAndAllFlowElements(element.flowElements));
  });
  return result;
}
function findRootProcess(element) {
  var parent = element;
  while (parent) {
    if (is(parent, "bpmn:Process")) {
      return parent;
    }
    parent = parent.$parent;
  }
}

// node_modules/bpmn-js/lib/util/PoweredByUtil.js
var BPMNIO_LOGO_SVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 14.02 5.57" width="53" height="21"><path fill="currentColor" d="M1.88.92v.14c0 .41-.13.68-.4.8.33.14.46.44.46.86v.33c0 .61-.33.95-.95.95H0V0h.95c.65 0 .93.3.93.92zM.63.57v1.06h.24c.24 0 .38-.1.38-.43V.98c0-.28-.1-.4-.32-.4zm0 1.63v1.22h.36c.2 0 .32-.1.32-.39v-.35c0-.37-.12-.48-.4-.48H.63zM4.18.99v.52c0 .64-.31.98-.94.98h-.3V4h-.62V0h.92c.63 0 .94.35.94.99zM2.94.57v1.35h.3c.2 0 .3-.09.3-.37v-.6c0-.29-.1-.38-.3-.38h-.3zm2.89 2.27L6.25 0h.88v4h-.6V1.12L6.1 3.99h-.6l-.46-2.82v2.82h-.55V0h.87zM8.14 1.1V4h-.56V0h.79L9 2.4V0h.56v4h-.64zm2.49 2.29v.6h-.6v-.6zM12.12 1c0-.63.33-1 .95-1 .61 0 .95.37.95 1v2.04c0 .64-.34 1-.95 1-.62 0-.95-.37-.95-1zm.62 2.08c0 .28.13.39.33.39s.32-.1.32-.4V.98c0-.29-.12-.4-.32-.4s-.33.11-.33.4z"/><path fill="currentColor" d="M0 4.53h14.02v1.04H0zM11.08 0h.63v.62h-.63zm.63 4V1h-.63v2.98z"/></svg>';
var BPMNIO_IMG = BPMNIO_LOGO_SVG;
var LOGO_STYLES = {
  verticalAlign: "middle"
};
var LINK_STYLES = {
  "color": "#404040"
};
var LIGHTBOX_STYLES = {
  "zIndex": "1001",
  "position": "fixed",
  "top": "0",
  "left": "0",
  "right": "0",
  "bottom": "0"
};
var BACKDROP_STYLES = {
  "width": "100%",
  "height": "100%",
  "background": "rgba(40,40,40,0.2)"
};
var NOTICE_STYLES = {
  "position": "absolute",
  "left": "50%",
  "top": "40%",
  "transform": "translate(-50%)",
  "width": "260px",
  "padding": "10px",
  "background": "white",
  "boxShadow": "0 1px 4px rgba(0,0,0,0.3)",
  "fontFamily": "Helvetica, Arial, sans-serif",
  "fontSize": "14px",
  "display": "flex",
  "lineHeight": "1.3"
};
var LIGHTBOX_MARKUP = '<div class="bjs-powered-by-lightbox"><div class="backdrop"></div><div class="notice"><a href="https://bpmn.io" target="_blank" rel="noopener" class="link">' + BPMNIO_IMG + '</a><span>Web-based tooling for BPMN, DMN and forms powered by <a href="https://bpmn.io" target="_blank" rel="noopener">bpmn.io</a>.</span></div></div>';
var lightbox;
function createLightbox() {
  lightbox = domify$1(LIGHTBOX_MARKUP);
  assign2(lightbox, LIGHTBOX_STYLES);
  assign2(query("svg", lightbox), LOGO_STYLES);
  assign2(query(".backdrop", lightbox), BACKDROP_STYLES);
  assign2(query(".notice", lightbox), NOTICE_STYLES);
  assign2(query(".link", lightbox), LINK_STYLES, {
    "margin": "15px 20px 15px 10px",
    "alignSelf": "center"
  });
}
function open() {
  if (!lightbox) {
    createLightbox();
    delegate.bind(lightbox, ".backdrop", "click", function(event2) {
      document.body.removeChild(lightbox);
    });
  }
  document.body.appendChild(lightbox);
}

// node_modules/bpmn-js/lib/BaseViewer.js
function BaseViewer(options) {
  options = assign({}, DEFAULT_OPTIONS, options);
  this._moddle = this._createModdle(options);
  this._container = this._createContainer(options);
  this._init(this._container, this._moddle, options);
  addProjectLogo(this._container);
}
e(BaseViewer, Diagram);
BaseViewer.prototype.importXML = async function importXML(xml2, bpmnDiagram) {
  const self2 = this;
  function ParseCompleteEvent(data) {
    return self2.get("eventBus").createEvent(data);
  }
  let aggregatedWarnings = [];
  try {
    xml2 = this._emit("import.parse.start", { xml: xml2 }) || xml2;
    let parseResult;
    try {
      parseResult = await this._moddle.fromXML(xml2, "bpmn:Definitions");
    } catch (error4) {
      this._emit("import.parse.complete", {
        error: error4
      });
      throw error4;
    }
    let definitions = parseResult.rootElement;
    const references = parseResult.references;
    const parseWarnings = parseResult.warnings;
    const elementsById = parseResult.elementsById;
    aggregatedWarnings = aggregatedWarnings.concat(parseWarnings);
    definitions = this._emit("import.parse.complete", ParseCompleteEvent({
      error: null,
      definitions,
      elementsById,
      references,
      warnings: aggregatedWarnings
    })) || definitions;
    const importResult = await this.importDefinitions(definitions, bpmnDiagram);
    aggregatedWarnings = aggregatedWarnings.concat(importResult.warnings);
    this._emit("import.done", { error: null, warnings: aggregatedWarnings });
    return { warnings: aggregatedWarnings };
  } catch (err) {
    let error4 = err;
    aggregatedWarnings = aggregatedWarnings.concat(error4.warnings || []);
    addWarningsToError(error4, aggregatedWarnings);
    error4 = checkValidationError(error4);
    this._emit("import.done", { error: error4, warnings: error4.warnings });
    throw error4;
  }
};
BaseViewer.prototype.importDefinitions = async function importDefinitions(definitions, bpmnDiagram) {
  this._setDefinitions(definitions);
  const result = await this.open(bpmnDiagram);
  return { warnings: result.warnings };
};
BaseViewer.prototype.open = async function open2(bpmnDiagramOrId) {
  const definitions = this._definitions;
  let bpmnDiagram = bpmnDiagramOrId;
  if (!definitions) {
    const error4 = new Error("no XML imported");
    addWarningsToError(error4, []);
    throw error4;
  }
  if (typeof bpmnDiagramOrId === "string") {
    bpmnDiagram = findBPMNDiagram(definitions, bpmnDiagramOrId);
    if (!bpmnDiagram) {
      const error4 = new Error("BPMNDiagram <" + bpmnDiagramOrId + "> not found");
      addWarningsToError(error4, []);
      throw error4;
    }
  }
  try {
    this.clear();
  } catch (error4) {
    addWarningsToError(error4, []);
    throw error4;
  }
  const { warnings } = await importBpmnDiagram(this, definitions, bpmnDiagram);
  return { warnings };
};
BaseViewer.prototype.saveXML = async function saveXML(options) {
  options = options || {};
  let definitions = this._definitions, error4, xml2;
  try {
    if (!definitions) {
      throw new Error("no definitions loaded");
    }
    definitions = this._emit("saveXML.start", {
      definitions
    }) || definitions;
    const result2 = await this._moddle.toXML(definitions, options);
    xml2 = result2.xml;
    xml2 = this._emit("saveXML.serialized", {
      xml: xml2
    }) || xml2;
  } catch (err) {
    error4 = err;
  }
  const result = error4 ? { error: error4 } : { xml: xml2 };
  this._emit("saveXML.done", result);
  if (error4) {
    throw error4;
  }
  return result;
};
BaseViewer.prototype.saveSVG = async function saveSVG() {
  this._emit("saveSVG.start");
  let svg, err;
  try {
    const canvas = this.get("canvas");
    const contentNode = canvas.getActiveLayer(), defsNode = query(":scope > defs", canvas._svg);
    const contents = innerSVG(contentNode), defs = defsNode ? "<defs>" + innerSVG(defsNode) + "</defs>" : "";
    const bbox = contentNode.getBBox();
    svg = '<?xml version="1.0" encoding="utf-8"?>\n<!-- created with bpmn-js / http://bpmn.io -->\n<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">\n<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" width="' + bbox.width + '" height="' + bbox.height + '" viewBox="' + bbox.x + " " + bbox.y + " " + bbox.width + " " + bbox.height + '" version="1.1">' + defs + contents + "</svg>";
  } catch (e8) {
    err = e8;
  }
  this._emit("saveSVG.done", {
    error: err,
    svg
  });
  if (err) {
    throw err;
  }
  return { svg };
};
BaseViewer.prototype._setDefinitions = function(definitions) {
  this._definitions = definitions;
};
BaseViewer.prototype.getModules = function() {
  return this._modules;
};
BaseViewer.prototype.clear = function() {
  if (!this.getDefinitions()) {
    return;
  }
  Diagram.prototype.clear.call(this);
};
BaseViewer.prototype.destroy = function() {
  Diagram.prototype.destroy.call(this);
  remove2(this._container);
};
BaseViewer.prototype.on = function(events, priority, callback, that) {
  return this.get("eventBus").on(events, priority, callback, that);
};
BaseViewer.prototype.off = function(events, callback) {
  this.get("eventBus").off(events, callback);
};
BaseViewer.prototype.attachTo = function(parentNode) {
  if (!parentNode) {
    throw new Error("parentNode required");
  }
  this.detach();
  if (parentNode.get && parentNode.constructor.prototype.jquery) {
    parentNode = parentNode.get(0);
  }
  if (typeof parentNode === "string") {
    parentNode = query(parentNode);
  }
  parentNode.appendChild(this._container);
  this._emit("attach", {});
  this.get("canvas").resized();
};
BaseViewer.prototype.getDefinitions = function() {
  return this._definitions;
};
BaseViewer.prototype.detach = function() {
  const container = this._container, parentNode = container.parentNode;
  if (!parentNode) {
    return;
  }
  this._emit("detach", {});
  parentNode.removeChild(container);
};
BaseViewer.prototype._init = function(container, moddle, options) {
  const baseModules = options.modules || this.getModules(options), additionalModules = options.additionalModules || [], staticModules = [
    {
      bpmnjs: ["value", this],
      moddle: ["value", moddle]
    }
  ];
  const diagramModules = [].concat(staticModules, baseModules, additionalModules);
  const diagramOptions = assign(omit(options, ["additionalModules"]), {
    canvas: assign({}, options.canvas, { container }),
    modules: diagramModules
  });
  Diagram.call(this, diagramOptions);
  if (options && options.container) {
    this.attachTo(options.container);
  }
};
BaseViewer.prototype._emit = function(type, event2) {
  return this.get("eventBus").fire(type, event2);
};
BaseViewer.prototype._createContainer = function(options) {
  const container = domify$1('<div class="bjs-container"></div>');
  assign2(container, {
    width: ensureUnit(options.width),
    height: ensureUnit(options.height),
    position: options.position
  });
  return container;
};
BaseViewer.prototype._createModdle = function(options) {
  const moddleOptions = assign({}, this._moddleExtensions, options.moddleExtensions);
  return new SimpleBpmnModdle(moddleOptions);
};
BaseViewer.prototype._modules = [];
function addWarningsToError(err, warningsAry) {
  err.warnings = warningsAry;
  return err;
}
function checkValidationError(err) {
  const pattern = /unparsable content <([^>]+)> detected([\s\S]*)$/;
  const match = pattern.exec(err.message);
  if (match) {
    err.message = "unparsable content <" + match[1] + "> detected; this may indicate an invalid BPMN 2.0 diagram file" + match[2];
  }
  return err;
}
var DEFAULT_OPTIONS = {
  width: "100%",
  height: "100%",
  position: "relative"
};
function ensureUnit(val) {
  return val + (isNumber(val) ? "px" : "");
}
function findBPMNDiagram(definitions, diagramId) {
  if (!diagramId) {
    return null;
  }
  return find(definitions.diagrams, function(element) {
    return element.id === diagramId;
  }) || null;
}
function addProjectLogo(container) {
  const img = BPMNIO_IMG;
  const linkMarkup = '<a href="http://bpmn.io" target="_blank" class="bjs-powered-by" title="Powered by bpmn.io" >' + img + "</a>";
  const linkElement = domify$1(linkMarkup);
  assign2(query("svg", linkElement), LOGO_STYLES);
  assign2(linkElement, LINK_STYLES, {
    position: "absolute",
    bottom: "15px",
    right: "15px",
    zIndex: "100"
  });
  container.appendChild(linkElement);
  event.bind(linkElement, "click", function(event2) {
    open();
    event2.preventDefault();
  });
}

// node_modules/bpmn-js/lib/Viewer.js
function Viewer(options) {
  BaseViewer.call(this, options);
}
e(Viewer, BaseViewer);
Viewer.prototype._modules = [
  core_default,
  drilldown_default,
  overlays_default,
  selection_default,
  translate_default
];
Viewer.prototype._moddleExtensions = {};

// node_modules/diagram-js/lib/features/keyboard/KeyboardUtil.js
var KEYS_COPY = ["c", "C"];
var KEYS_PASTE = ["v", "V"];
var KEYS_REDO = ["y", "Y"];
var KEYS_UNDO = ["z", "Z"];
function hasModifier(event2) {
  return event2.ctrlKey || event2.metaKey || event2.shiftKey || event2.altKey;
}
function isCmd(event2) {
  if (event2.altKey) {
    return false;
  }
  return event2.ctrlKey || event2.metaKey;
}
function isKey(keys2, event2) {
  keys2 = isArray(keys2) ? keys2 : [keys2];
  return keys2.indexOf(event2.key) !== -1 || keys2.indexOf(event2.code) !== -1;
}
function isShift(event2) {
  return event2.shiftKey;
}
function isCopy(event2) {
  return isCmd(event2) && isKey(KEYS_COPY, event2);
}
function isPaste(event2) {
  return isCmd(event2) && isKey(KEYS_PASTE, event2);
}
function isUndo(event2) {
  return isCmd(event2) && !isShift(event2) && isKey(KEYS_UNDO, event2);
}
function isRedo(event2) {
  return isCmd(event2) && (isKey(KEYS_REDO, event2) || isKey(KEYS_UNDO, event2) && isShift(event2));
}

// node_modules/diagram-js/lib/features/keyboard/Keyboard.js
var KEYDOWN_EVENT = "keyboard.keydown";
var KEYUP_EVENT = "keyboard.keyup";
var DEFAULT_PRIORITY3 = 1e3;
var compatMessage = "Keyboard binding is now implicit; explicit binding to an element got removed. For more information, see https://github.com/bpmn-io/diagram-js/issues/661";
function Keyboard(config, eventBus) {
  var self2 = this;
  this._config = config = config || {};
  this._eventBus = eventBus;
  this._keydownHandler = this._keydownHandler.bind(this);
  this._keyupHandler = this._keyupHandler.bind(this);
  eventBus.on("diagram.destroy", function() {
    self2._fire("destroy");
    self2.unbind();
  });
  if (config.bindTo) {
    console.error("unsupported configuration <keyboard.bindTo>", new Error(compatMessage));
  }
  var bind3 = config && config.bind !== false;
  eventBus.on("canvas.init", function(event2) {
    self2._target = event2.svg;
    if (bind3) {
      self2.bind();
    }
    self2._fire("init");
  });
}
Keyboard.$inject = [
  "config.keyboard",
  "eventBus"
];
Keyboard.prototype._keydownHandler = function(event2) {
  this._keyHandler(event2, KEYDOWN_EVENT);
};
Keyboard.prototype._keyupHandler = function(event2) {
  this._keyHandler(event2, KEYUP_EVENT);
};
Keyboard.prototype._keyHandler = function(event2, type) {
  var eventBusResult;
  if (this._isEventIgnored(event2)) {
    return;
  }
  var context = {
    keyEvent: event2
  };
  eventBusResult = this._eventBus.fire(type || KEYDOWN_EVENT, context);
  if (eventBusResult) {
    event2.preventDefault();
  }
};
Keyboard.prototype._isEventIgnored = function(event2) {
  return false;
};
Keyboard.prototype.bind = function(node2) {
  if (node2) {
    console.error("unsupported argument <node>", new Error(compatMessage));
  }
  this.unbind();
  node2 = this._node = this._target;
  event.bind(node2, "keydown", this._keydownHandler);
  event.bind(node2, "keyup", this._keyupHandler);
  this._fire("bind");
};
Keyboard.prototype.getBinding = function() {
  return this._node;
};
Keyboard.prototype.unbind = function() {
  var node2 = this._node;
  if (node2) {
    this._fire("unbind");
    event.unbind(node2, "keydown", this._keydownHandler);
    event.unbind(node2, "keyup", this._keyupHandler);
  }
  this._node = null;
};
Keyboard.prototype._fire = function(event2) {
  this._eventBus.fire("keyboard." + event2, { node: this._node });
};
Keyboard.prototype.addListener = function(priority, listener, type) {
  if (isFunction(priority)) {
    type = listener;
    listener = priority;
    priority = DEFAULT_PRIORITY3;
  }
  this._eventBus.on(type || KEYDOWN_EVENT, priority, listener);
};
Keyboard.prototype.removeListener = function(listener, type) {
  this._eventBus.off(type || KEYDOWN_EVENT, listener);
};
Keyboard.prototype.hasModifier = hasModifier;
Keyboard.prototype.isCmd = isCmd;
Keyboard.prototype.isShift = isShift;
Keyboard.prototype.isKey = isKey;

// node_modules/diagram-js/lib/features/keyboard/KeyboardBindings.js
var LOW_PRIORITY4 = 500;
function KeyboardBindings(eventBus, keyboard) {
  var self2 = this;
  eventBus.on("editorActions.init", LOW_PRIORITY4, function(event2) {
    var editorActions = event2.editorActions;
    self2.registerBindings(keyboard, editorActions);
  });
}
KeyboardBindings.$inject = [
  "eventBus",
  "keyboard"
];
KeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  function addListener(action, fn2) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn2);
    }
  }
  addListener("undo", function(context) {
    var event2 = context.keyEvent;
    if (isUndo(event2)) {
      editorActions.trigger("undo");
      return true;
    }
  });
  addListener("redo", function(context) {
    var event2 = context.keyEvent;
    if (isRedo(event2)) {
      editorActions.trigger("redo");
      return true;
    }
  });
  addListener("copy", function(context) {
    var event2 = context.keyEvent;
    if (isCopy(event2)) {
      editorActions.trigger("copy");
      return true;
    }
  });
  addListener("paste", function(context) {
    var event2 = context.keyEvent;
    if (isPaste(event2)) {
      editorActions.trigger("paste");
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["+", "Add", "="], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: 1 });
      return true;
    }
  });
  addListener("stepZoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["-", "Subtract"], event2) && isCmd(event2)) {
      editorActions.trigger("stepZoom", { value: -1 });
      return true;
    }
  });
  addListener("zoom", function(context) {
    var event2 = context.keyEvent;
    if (isKey("0", event2) && isCmd(event2)) {
      editorActions.trigger("zoom", { value: 1 });
      return true;
    }
  });
  addListener("removeSelection", function(context) {
    var event2 = context.keyEvent;
    if (isKey(["Backspace", "Delete", "Del"], event2)) {
      editorActions.trigger("removeSelection");
      return true;
    }
  });
};

// node_modules/diagram-js/lib/features/keyboard/index.js
var keyboard_default = {
  __init__: ["keyboard", "keyboardBindings"],
  keyboard: ["type", Keyboard],
  keyboardBindings: ["type", KeyboardBindings]
};

// node_modules/diagram-js/lib/navigation/keyboard-move/KeyboardMove.js
var DEFAULT_CONFIG = {
  moveSpeed: 50,
  moveSpeedAccelerated: 200
};
function KeyboardMove(config, keyboard, canvas) {
  var self2 = this;
  this._config = assign({}, DEFAULT_CONFIG, config || {});
  keyboard.addListener(arrowsListener);
  function arrowsListener(context) {
    var event2 = context.keyEvent, config2 = self2._config;
    if (!keyboard.isCmd(event2)) {
      return;
    }
    if (keyboard.isKey([
      "ArrowLeft",
      "Left",
      "ArrowUp",
      "Up",
      "ArrowDown",
      "Down",
      "ArrowRight",
      "Right"
    ], event2)) {
      var speed = keyboard.isShift(event2) ? config2.moveSpeedAccelerated : config2.moveSpeed;
      var direction;
      switch (event2.key) {
        case "ArrowLeft":
        case "Left":
          direction = "left";
          break;
        case "ArrowUp":
        case "Up":
          direction = "up";
          break;
        case "ArrowRight":
        case "Right":
          direction = "right";
          break;
        case "ArrowDown":
        case "Down":
          direction = "down";
          break;
      }
      self2.moveCanvas({
        speed,
        direction
      });
      return true;
    }
  }
  this.moveCanvas = function(options) {
    var dx = 0, dy = 0, speed = options.speed;
    var actualSpeed = speed / Math.min(Math.sqrt(canvas.viewbox().scale), 1);
    switch (options.direction) {
      case "left":
        dx = actualSpeed;
        break;
      case "up":
        dy = actualSpeed;
        break;
      case "right":
        dx = -actualSpeed;
        break;
      case "down":
        dy = -actualSpeed;
        break;
    }
    canvas.scroll({
      dx,
      dy
    });
  };
}
KeyboardMove.$inject = [
  "config.keyboardMove",
  "keyboard",
  "canvas"
];

// node_modules/diagram-js/lib/navigation/keyboard-move/index.js
var keyboard_move_default = {
  __depends__: [
    keyboard_default
  ],
  __init__: ["keyboardMove"],
  keyboardMove: ["type", KeyboardMove]
};

// node_modules/diagram-js/lib/util/Cursor.js
var CURSOR_CLS_PATTERN = /^djs-cursor-.*$/;
function set3(mode) {
  var classes3 = classes2(document.body);
  classes3.removeMatching(CURSOR_CLS_PATTERN);
  if (mode) {
    classes3.add("djs-cursor-" + mode);
  }
}
function unset() {
  set3(null);
}

// node_modules/diagram-js/lib/util/ClickTrap.js
var TRAP_PRIORITY = 5e3;
function install(eventBus, eventName) {
  eventName = eventName || "element.click";
  function trap() {
    return false;
  }
  eventBus.once(eventName, TRAP_PRIORITY, trap);
  return function() {
    eventBus.off(eventName, trap);
  };
}

// node_modules/diagram-js/lib/util/PositionUtil.js
function center(bounds) {
  return {
    x: bounds.x + bounds.width / 2,
    y: bounds.y + bounds.height / 2
  };
}
function delta(a6, b4) {
  return {
    x: a6.x - b4.x,
    y: a6.y - b4.y
  };
}

// node_modules/diagram-js/lib/navigation/movecanvas/MoveCanvas.js
var THRESHOLD = 15;
function MoveCanvas(eventBus, canvas) {
  var context;
  function handleMousedown(event2) {
    return handleStart(event2.originalEvent);
  }
  eventBus.on("canvas.focus.changed", function(event2) {
    if (event2.focused) {
      eventBus.on("element.mousedown", 500, handleMousedown);
    } else {
      eventBus.off("element.mousedown", handleMousedown);
    }
  });
  function handleMove(event2) {
    var start = context.start, button = context.button, position = toPoint(event2), delta2 = delta(position, start);
    if (!context.dragging && length(delta2) > THRESHOLD) {
      context.dragging = true;
      if (button === 0) {
        install(eventBus);
      }
      set3("grab");
    }
    if (context.dragging) {
      var lastPosition = context.last || context.start;
      delta2 = delta(position, lastPosition);
      canvas.scroll({
        dx: delta2.x,
        dy: delta2.y
      });
      context.last = position;
    }
    event2.preventDefault();
  }
  function handleEnd(event2) {
    event.unbind(document, "mousemove", handleMove);
    event.unbind(document, "mouseup", handleEnd);
    context = null;
    unset();
  }
  function handleStart(event2) {
    if (closest(event2.target, ".djs-draggable")) {
      return;
    }
    var button = event2.button;
    if (button >= 2 || event2.ctrlKey || event2.shiftKey || event2.altKey) {
      return;
    }
    context = {
      button,
      start: toPoint(event2)
    };
    event.bind(document, "mousemove", handleMove);
    event.bind(document, "mouseup", handleEnd);
    return true;
  }
  this.isActive = function() {
    return !!context;
  };
}
MoveCanvas.$inject = [
  "eventBus",
  "canvas"
];
function length(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}

// node_modules/diagram-js/lib/navigation/movecanvas/index.js
var movecanvas_default = {
  __init__: ["moveCanvas"],
  moveCanvas: ["type", MoveCanvas]
};

// node_modules/diagram-js/lib/util/Math.js
function log10(x6) {
  return Math.log(x6) / Math.log(10);
}

// node_modules/diagram-js/lib/navigation/zoomscroll/ZoomUtil.js
function getStepSize(range, steps) {
  var minLinearRange = log10(range.min), maxLinearRange = log10(range.max);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}

// node_modules/diagram-js/lib/navigation/zoomscroll/ZoomScroll.js
var sign = Math.sign || function(n4) {
  return n4 >= 0 ? 1 : -1;
};
var RANGE = { min: 0.2, max: 4 };
var NUM_STEPS = 10;
var DELTA_THRESHOLD = 0.1;
var DEFAULT_SCALE = 0.75;
function ZoomScroll(config, eventBus, canvas) {
  config = config || {};
  this._enabled = false;
  this._canvas = canvas;
  this._container = canvas._container;
  this._handleWheel = bind(this._handleWheel, this);
  this._totalDelta = 0;
  this._scale = config.scale || DEFAULT_SCALE;
  var self2 = this;
  eventBus.on("canvas.focus.changed", function(event2) {
    self2._init(event2.focused && config.enabled !== false);
  });
}
ZoomScroll.$inject = [
  "config.zoomScroll",
  "eventBus",
  "canvas"
];
ZoomScroll.prototype.scroll = function scroll(delta2) {
  this._canvas.scroll(delta2);
};
ZoomScroll.prototype.reset = function reset() {
  this._canvas.zoom("fit-viewport");
};
ZoomScroll.prototype.zoom = function zoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS * 2);
  this._totalDelta += delta2;
  if (Math.abs(this._totalDelta) > DELTA_THRESHOLD) {
    this._zoom(delta2, position, stepSize);
    this._totalDelta = 0;
  }
};
ZoomScroll.prototype._handleWheel = function handleWheel(event2) {
  if (!this._canvas.isFocused()) {
    return;
  }
  var element = this._container;
  event2.preventDefault();
  var isZoom = event2.ctrlKey || isMac() && event2.metaKey;
  var isHorizontalScroll = event2.shiftKey;
  var factor = -1 * this._scale, delta2;
  if (isZoom) {
    factor *= event2.deltaMode === 0 ? 0.02 : 0.32;
  } else {
    factor *= event2.deltaMode === 0 ? 1 : 16;
  }
  if (isZoom) {
    var elementRect = element.getBoundingClientRect();
    var offset = {
      x: event2.clientX - elementRect.left,
      y: event2.clientY - elementRect.top
    };
    delta2 = Math.sqrt(
      Math.pow(event2.deltaY, 2) + Math.pow(event2.deltaX, 2)
    ) * sign(event2.deltaY) * factor;
    this.zoom(delta2, offset);
  } else {
    if (isHorizontalScroll) {
      delta2 = {
        dx: factor * event2.deltaY,
        dy: 0
      };
    } else {
      delta2 = {
        dx: factor * event2.deltaX,
        dy: factor * event2.deltaY
      };
    }
    this.scroll(delta2);
  }
};
ZoomScroll.prototype.stepZoom = function stepZoom(delta2, position) {
  var stepSize = getStepSize(RANGE, NUM_STEPS);
  this._zoom(delta2, position, stepSize);
};
ZoomScroll.prototype._zoom = function(delta2, position, stepSize) {
  var canvas = this._canvas;
  var direction = delta2 > 0 ? 1 : -1;
  var currentLinearZoomLevel = log10(canvas.zoom());
  var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
  newLinearZoomLevel += stepSize * direction;
  var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
  canvas.zoom(cap(RANGE, newLogZoomLevel), position);
};
ZoomScroll.prototype.toggle = function toggle(newEnabled) {
  var element = this._container;
  var handleWheel2 = this._handleWheel;
  var oldEnabled = this._enabled;
  if (typeof newEnabled === "undefined") {
    newEnabled = !oldEnabled;
  }
  if (oldEnabled !== newEnabled) {
    event[newEnabled ? "bind" : "unbind"](element, "wheel", handleWheel2, false);
  }
  this._enabled = newEnabled;
  return newEnabled;
};
ZoomScroll.prototype._init = function(newEnabled) {
  this.toggle(newEnabled);
};

// node_modules/diagram-js/lib/navigation/zoomscroll/index.js
var zoomscroll_default = {
  __init__: ["zoomScroll"],
  zoomScroll: ["type", ZoomScroll]
};

// node_modules/bpmn-js/lib/NavigatedViewer.js
function NavigatedViewer(options) {
  Viewer.call(this, options);
}
e(NavigatedViewer, Viewer);
NavigatedViewer.prototype._navigationModules = [
  keyboard_move_default,
  movecanvas_default,
  zoomscroll_default
];
NavigatedViewer.prototype._modules = [].concat(
  Viewer.prototype._modules,
  NavigatedViewer.prototype._navigationModules
);

// node_modules/bpmn-js-sketchy/dist/index.esm.js
function e2(e8, t7) {
  t7 && (e8.super_ = t7, e8.prototype = Object.create(t7.prototype, { constructor: { value: e8, enumerable: false, writable: true, configurable: true } }));
}
function rotatePoints(points, center2, degrees) {
  if (points && points.length) {
    const [cx, cy] = center2;
    const angle = Math.PI / 180 * degrees;
    const cos = Math.cos(angle);
    const sin = Math.sin(angle);
    points.forEach((p5) => {
      const [x6, y5] = p5;
      p5[0] = (x6 - cx) * cos - (y5 - cy) * sin + cx;
      p5[1] = (x6 - cx) * sin + (y5 - cy) * cos + cy;
    });
  }
}
function rotateLines(lines, center2, degrees) {
  const points = [];
  lines.forEach((line2) => points.push(...line2));
  rotatePoints(points, center2, degrees);
}
function lineLength(line2) {
  const p1 = line2[0];
  const p22 = line2[1];
  return Math.sqrt(Math.pow(p1[0] - p22[0], 2) + Math.pow(p1[1] - p22[1], 2));
}
function polygonHachureLines(polygonList, o5) {
  const angle = o5.hachureAngle + 90;
  let gap = o5.hachureGap;
  if (gap < 0) {
    gap = o5.strokeWidth * 4;
  }
  gap = Math.max(gap, 0.1);
  const rotationCenter = [0, 0];
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, angle);
    }
  }
  const lines = straightHachureLines(polygonList, gap);
  if (angle) {
    for (const polygon2 of polygonList) {
      rotatePoints(polygon2, rotationCenter, -angle);
    }
    rotateLines(lines, rotationCenter, -angle);
  }
  return lines;
}
function straightHachureLines(polygonList, gap) {
  const vertexArray = [];
  for (const polygon2 of polygonList) {
    const vertices = [...polygon2];
    if (vertices[0].join(",") !== vertices[vertices.length - 1].join(",")) {
      vertices.push([vertices[0][0], vertices[0][1]]);
    }
    if (vertices.length > 2) {
      vertexArray.push(vertices);
    }
  }
  const lines = [];
  gap = Math.max(gap, 0.1);
  const edges = [];
  for (const vertices of vertexArray) {
    for (let i7 = 0; i7 < vertices.length - 1; i7++) {
      const p1 = vertices[i7];
      const p22 = vertices[i7 + 1];
      if (p1[1] !== p22[1]) {
        const ymin = Math.min(p1[1], p22[1]);
        edges.push({
          ymin,
          ymax: Math.max(p1[1], p22[1]),
          x: ymin === p1[1] ? p1[0] : p22[0],
          islope: (p22[0] - p1[0]) / (p22[1] - p1[1])
        });
      }
    }
  }
  edges.sort((e1, e22) => {
    if (e1.ymin < e22.ymin) {
      return -1;
    }
    if (e1.ymin > e22.ymin) {
      return 1;
    }
    if (e1.x < e22.x) {
      return -1;
    }
    if (e1.x > e22.x) {
      return 1;
    }
    if (e1.ymax === e22.ymax) {
      return 0;
    }
    return (e1.ymax - e22.ymax) / Math.abs(e1.ymax - e22.ymax);
  });
  if (!edges.length) {
    return lines;
  }
  let activeEdges = [];
  let y5 = edges[0].ymin;
  while (activeEdges.length || edges.length) {
    if (edges.length) {
      let ix = -1;
      for (let i7 = 0; i7 < edges.length; i7++) {
        if (edges[i7].ymin > y5) {
          break;
        }
        ix = i7;
      }
      const removed = edges.splice(0, ix + 1);
      removed.forEach((edge) => {
        activeEdges.push({ s: y5, edge });
      });
    }
    activeEdges = activeEdges.filter((ae) => {
      if (ae.edge.ymax <= y5) {
        return false;
      }
      return true;
    });
    activeEdges.sort((ae1, ae2) => {
      if (ae1.edge.x === ae2.edge.x) {
        return 0;
      }
      return (ae1.edge.x - ae2.edge.x) / Math.abs(ae1.edge.x - ae2.edge.x);
    });
    if (activeEdges.length > 1) {
      for (let i7 = 0; i7 < activeEdges.length; i7 = i7 + 2) {
        const nexti = i7 + 1;
        if (nexti >= activeEdges.length) {
          break;
        }
        const ce = activeEdges[i7].edge;
        const ne = activeEdges[nexti].edge;
        lines.push([
          [Math.round(ce.x), y5],
          [Math.round(ne.x), y5]
        ]);
      }
    }
    y5 += gap;
    activeEdges.forEach((ae) => {
      ae.edge.x = ae.edge.x + gap * ae.edge.islope;
    });
  }
  return lines;
}
var HachureFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o5) {
    return this._fillPolygons(polygonList, o5);
  }
  _fillPolygons(polygonList, o5) {
    const lines = polygonHachureLines(polygonList, o5);
    const ops = this.renderLines(lines, o5);
    return { type: "fillSketch", ops };
  }
  renderLines(lines, o5) {
    const ops = [];
    for (const line2 of lines) {
      ops.push(...this.helper.doubleLineOps(line2[0][0], line2[0][1], line2[1][0], line2[1][1], o5));
    }
    return ops;
  }
};
var ZigZagFiller = class extends HachureFiller {
  fillPolygons(polygonList, o5) {
    let gap = o5.hachureGap;
    if (gap < 0) {
      gap = o5.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    const o22 = Object.assign({}, o5, { hachureGap: gap });
    const lines = polygonHachureLines(polygonList, o22);
    const zigZagAngle = Math.PI / 180 * o5.hachureAngle;
    const zigzagLines = [];
    const dgx = gap * 0.5 * Math.cos(zigZagAngle);
    const dgy = gap * 0.5 * Math.sin(zigZagAngle);
    for (const [p1, p22] of lines) {
      if (lineLength([p1, p22])) {
        zigzagLines.push([
          [p1[0] - dgx, p1[1] + dgy],
          [...p22]
        ], [
          [p1[0] + dgx, p1[1] - dgy],
          [...p22]
        ]);
      }
    }
    const ops = this.renderLines(zigzagLines, o5);
    return { type: "fillSketch", ops };
  }
};
var HatchFiller = class extends HachureFiller {
  fillPolygons(polygonList, o5) {
    const set4 = this._fillPolygons(polygonList, o5);
    const o22 = Object.assign({}, o5, { hachureAngle: o5.hachureAngle + 90 });
    const set22 = this._fillPolygons(polygonList, o22);
    set4.ops = set4.ops.concat(set22.ops);
    return set4;
  }
};
var DotFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o5) {
    o5 = Object.assign({}, o5, { hachureAngle: 0 });
    const lines = polygonHachureLines(polygonList, o5);
    return this.dotsOnLines(lines, o5);
  }
  dotsOnLines(lines, o5) {
    const ops = [];
    let gap = o5.hachureGap;
    if (gap < 0) {
      gap = o5.strokeWidth * 4;
    }
    gap = Math.max(gap, 0.1);
    let fweight = o5.fillWeight;
    if (fweight < 0) {
      fweight = o5.strokeWidth / 2;
    }
    const ro = gap / 4;
    for (const line2 of lines) {
      const length2 = lineLength(line2);
      const dl = length2 / gap;
      const count = Math.ceil(dl) - 1;
      const offset = length2 - count * gap;
      const x6 = (line2[0][0] + line2[1][0]) / 2 - gap / 4;
      const minY = Math.min(line2[0][1], line2[1][1]);
      for (let i7 = 0; i7 < count; i7++) {
        const y5 = minY + offset + i7 * gap;
        const cx = x6 - ro + Math.random() * 2 * ro;
        const cy = y5 - ro + Math.random() * 2 * ro;
        const el = this.helper.ellipse(cx, cy, fweight, fweight, o5);
        ops.push(...el.ops);
      }
    }
    return { type: "fillSketch", ops };
  }
};
var DashedFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o5) {
    const lines = polygonHachureLines(polygonList, o5);
    return { type: "fillSketch", ops: this.dashedLine(lines, o5) };
  }
  dashedLine(lines, o5) {
    const offset = o5.dashOffset < 0 ? o5.hachureGap < 0 ? o5.strokeWidth * 4 : o5.hachureGap : o5.dashOffset;
    const gap = o5.dashGap < 0 ? o5.hachureGap < 0 ? o5.strokeWidth * 4 : o5.hachureGap : o5.dashGap;
    const ops = [];
    lines.forEach((line2) => {
      const length2 = lineLength(line2);
      const count = Math.floor(length2 / (offset + gap));
      const startOffset = (length2 + gap - count * (offset + gap)) / 2;
      let p1 = line2[0];
      let p22 = line2[1];
      if (p1[0] > p22[0]) {
        p1 = line2[1];
        p22 = line2[0];
      }
      const alpha = Math.atan((p22[1] - p1[1]) / (p22[0] - p1[0]));
      for (let i7 = 0; i7 < count; i7++) {
        const lstart = i7 * (offset + gap);
        const lend = lstart + offset;
        const start = [p1[0] + lstart * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        const end = [p1[0] + lend * Math.cos(alpha) + startOffset * Math.cos(alpha), p1[1] + lend * Math.sin(alpha) + startOffset * Math.sin(alpha)];
        ops.push(...this.helper.doubleLineOps(start[0], start[1], end[0], end[1], o5));
      }
    });
    return ops;
  }
};
var ZigZagLineFiller = class {
  constructor(helper2) {
    this.helper = helper2;
  }
  fillPolygons(polygonList, o5) {
    const gap = o5.hachureGap < 0 ? o5.strokeWidth * 4 : o5.hachureGap;
    const zo = o5.zigzagOffset < 0 ? gap : o5.zigzagOffset;
    o5 = Object.assign({}, o5, { hachureGap: gap + zo });
    const lines = polygonHachureLines(polygonList, o5);
    return { type: "fillSketch", ops: this.zigzagLines(lines, zo, o5) };
  }
  zigzagLines(lines, zo, o5) {
    const ops = [];
    lines.forEach((line2) => {
      const length2 = lineLength(line2);
      const count = Math.round(length2 / (2 * zo));
      let p1 = line2[0];
      let p22 = line2[1];
      if (p1[0] > p22[0]) {
        p1 = line2[1];
        p22 = line2[0];
      }
      const alpha = Math.atan((p22[1] - p1[1]) / (p22[0] - p1[0]));
      for (let i7 = 0; i7 < count; i7++) {
        const lstart = i7 * 2 * zo;
        const lend = (i7 + 1) * 2 * zo;
        const dz = Math.sqrt(2 * Math.pow(zo, 2));
        const start = [p1[0] + lstart * Math.cos(alpha), p1[1] + lstart * Math.sin(alpha)];
        const end = [p1[0] + lend * Math.cos(alpha), p1[1] + lend * Math.sin(alpha)];
        const middle = [start[0] + dz * Math.cos(alpha + Math.PI / 4), start[1] + dz * Math.sin(alpha + Math.PI / 4)];
        ops.push(...this.helper.doubleLineOps(start[0], start[1], middle[0], middle[1], o5), ...this.helper.doubleLineOps(middle[0], middle[1], end[0], end[1], o5));
      }
    });
    return ops;
  }
};
var fillers = {};
function getFiller(o5, helper2) {
  let fillerName = o5.fillStyle || "hachure";
  if (!fillers[fillerName]) {
    switch (fillerName) {
      case "zigzag":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagFiller(helper2);
        }
        break;
      case "cross-hatch":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HatchFiller(helper2);
        }
        break;
      case "dots":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DotFiller(helper2);
        }
        break;
      case "dashed":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new DashedFiller(helper2);
        }
        break;
      case "zigzag-line":
        if (!fillers[fillerName]) {
          fillers[fillerName] = new ZigZagLineFiller(helper2);
        }
        break;
      case "hachure":
      default:
        fillerName = "hachure";
        if (!fillers[fillerName]) {
          fillers[fillerName] = new HachureFiller(helper2);
        }
        break;
    }
  }
  return fillers[fillerName];
}
function randomSeed() {
  return Math.floor(Math.random() * 2 ** 31);
}
var Random = class {
  constructor(seed) {
    this.seed = seed;
  }
  next() {
    if (this.seed) {
      return (2 ** 31 - 1 & (this.seed = Math.imul(48271, this.seed))) / 2 ** 31;
    } else {
      return Math.random();
    }
  }
};
var COMMAND = 0;
var NUMBER = 1;
var EOD = 2;
var PARAMS = { A: 7, a: 7, C: 6, c: 6, H: 1, h: 1, L: 2, l: 2, M: 2, m: 2, Q: 4, q: 4, S: 4, s: 4, T: 2, t: 2, V: 1, v: 1, Z: 0, z: 0 };
function tokenize(d5) {
  const tokens = new Array();
  while (d5 !== "") {
    if (d5.match(/^([ \t\r\n,]+)/)) {
      d5 = d5.substr(RegExp.$1.length);
    } else if (d5.match(/^([aAcChHlLmMqQsStTvVzZ])/)) {
      tokens[tokens.length] = { type: COMMAND, text: RegExp.$1 };
      d5 = d5.substr(RegExp.$1.length);
    } else if (d5.match(/^(([-+]?[0-9]+(\.[0-9]*)?|[-+]?\.[0-9]+)([eE][-+]?[0-9]+)?)/)) {
      tokens[tokens.length] = { type: NUMBER, text: `${parseFloat(RegExp.$1)}` };
      d5 = d5.substr(RegExp.$1.length);
    } else {
      return [];
    }
  }
  tokens[tokens.length] = { type: EOD, text: "" };
  return tokens;
}
function isType(token, type) {
  return token.type === type;
}
function parsePath(d5) {
  const segments = [];
  const tokens = tokenize(d5);
  let mode = "BOD";
  let index5 = 0;
  let token = tokens[index5];
  while (!isType(token, EOD)) {
    let paramsCount = 0;
    const params = [];
    if (mode === "BOD") {
      if (token.text === "M" || token.text === "m") {
        index5++;
        paramsCount = PARAMS[token.text];
        mode = token.text;
      } else {
        return parsePath("M0,0" + d5);
      }
    } else if (isType(token, NUMBER)) {
      paramsCount = PARAMS[mode];
    } else {
      index5++;
      paramsCount = PARAMS[token.text];
      mode = token.text;
    }
    if (index5 + paramsCount < tokens.length) {
      for (let i7 = index5; i7 < index5 + paramsCount; i7++) {
        const numbeToken = tokens[i7];
        if (isType(numbeToken, NUMBER)) {
          params[params.length] = +numbeToken.text;
        } else {
          throw new Error("Param not a number: " + mode + "," + numbeToken.text);
        }
      }
      if (typeof PARAMS[mode] === "number") {
        const segment = { key: mode, data: params };
        segments.push(segment);
        index5 += paramsCount;
        token = tokens[index5];
        if (mode === "M")
          mode = "L";
        if (mode === "m")
          mode = "l";
      } else {
        throw new Error("Bad segment: " + mode);
      }
    } else {
      throw new Error("Path data ended short");
    }
  }
  return segments;
}
function absolutize(segments) {
  let cx = 0, cy = 0;
  let subx = 0, suby = 0;
  const out = [];
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy] = data;
        [subx, suby] = data;
        break;
      case "m":
        cx += data[0];
        cy += data[1];
        out.push({ key: "M", data: [cx, cy] });
        subx = cx;
        suby = cy;
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy] = data;
        break;
      case "l":
        cx += data[0];
        cy += data[1];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy = data[5];
        break;
      case "c": {
        const newdata = data.map((d5, i7) => i7 % 2 ? d5 + cy : d5 + cx);
        out.push({ key: "C", data: newdata });
        cx = newdata[4];
        cy = newdata[5];
        break;
      }
      case "Q":
        out.push({ key: "Q", data: [...data] });
        cx = data[2];
        cy = data[3];
        break;
      case "q": {
        const newdata = data.map((d5, i7) => i7 % 2 ? d5 + cy : d5 + cx);
        out.push({ key: "Q", data: newdata });
        cx = newdata[2];
        cy = newdata[3];
        break;
      }
      case "A":
        out.push({ key: "A", data: [...data] });
        cx = data[5];
        cy = data[6];
        break;
      case "a":
        cx += data[5];
        cy += data[6];
        out.push({ key: "A", data: [data[0], data[1], data[2], data[3], data[4], cx, cy] });
        break;
      case "H":
        out.push({ key: "H", data: [...data] });
        cx = data[0];
        break;
      case "h":
        cx += data[0];
        out.push({ key: "H", data: [cx] });
        break;
      case "V":
        out.push({ key: "V", data: [...data] });
        cy = data[0];
        break;
      case "v":
        cy += data[0];
        out.push({ key: "V", data: [cy] });
        break;
      case "S":
        out.push({ key: "S", data: [...data] });
        cx = data[2];
        cy = data[3];
        break;
      case "s": {
        const newdata = data.map((d5, i7) => i7 % 2 ? d5 + cy : d5 + cx);
        out.push({ key: "S", data: newdata });
        cx = newdata[2];
        cy = newdata[3];
        break;
      }
      case "T":
        out.push({ key: "T", data: [...data] });
        cx = data[0];
        cy = data[1];
        break;
      case "t":
        cx += data[0];
        cy += data[1];
        out.push({ key: "T", data: [cx, cy] });
        break;
      case "Z":
      case "z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy = suby;
        break;
    }
  }
  return out;
}
function normalize(segments) {
  const out = [];
  let lastType = "";
  let cx = 0, cy = 0;
  let subx = 0, suby = 0;
  let lcx = 0, lcy = 0;
  for (const { key, data } of segments) {
    switch (key) {
      case "M":
        out.push({ key: "M", data: [...data] });
        [cx, cy] = data;
        [subx, suby] = data;
        break;
      case "C":
        out.push({ key: "C", data: [...data] });
        cx = data[4];
        cy = data[5];
        lcx = data[2];
        lcy = data[3];
        break;
      case "L":
        out.push({ key: "L", data: [...data] });
        [cx, cy] = data;
        break;
      case "H":
        cx = data[0];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "V":
        cy = data[0];
        out.push({ key: "L", data: [cx, cy] });
        break;
      case "S": {
        let cx1 = 0, cy1 = 0;
        if (lastType === "C" || lastType === "S") {
          cx1 = cx + (cx - lcx);
          cy1 = cy + (cy - lcy);
        } else {
          cx1 = cx;
          cy1 = cy;
        }
        out.push({ key: "C", data: [cx1, cy1, ...data] });
        lcx = data[0];
        lcy = data[1];
        cx = data[2];
        cy = data[3];
        break;
      }
      case "T": {
        const [x6, y5] = data;
        let x1 = 0, y1 = 0;
        if (lastType === "Q" || lastType === "T") {
          x1 = cx + (cx - lcx);
          y1 = cy + (cy - lcy);
        } else {
          x1 = cx;
          y1 = cy;
        }
        const cx1 = cx + 2 * (x1 - cx) / 3;
        const cy1 = cy + 2 * (y1 - cy) / 3;
        const cx2 = x6 + 2 * (x1 - x6) / 3;
        const cy2 = y5 + 2 * (y1 - y5) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy2, x6, y5] });
        lcx = x1;
        lcy = y1;
        cx = x6;
        cy = y5;
        break;
      }
      case "Q": {
        const [x1, y1, x6, y5] = data;
        const cx1 = cx + 2 * (x1 - cx) / 3;
        const cy1 = cy + 2 * (y1 - cy) / 3;
        const cx2 = x6 + 2 * (x1 - x6) / 3;
        const cy2 = y5 + 2 * (y1 - y5) / 3;
        out.push({ key: "C", data: [cx1, cy1, cx2, cy2, x6, y5] });
        lcx = x1;
        lcy = y1;
        cx = x6;
        cy = y5;
        break;
      }
      case "A": {
        const r1 = Math.abs(data[0]);
        const r22 = Math.abs(data[1]);
        const angle = data[2];
        const largeArcFlag = data[3];
        const sweepFlag = data[4];
        const x6 = data[5];
        const y5 = data[6];
        if (r1 === 0 || r22 === 0) {
          out.push({ key: "C", data: [cx, cy, x6, y5, x6, y5] });
          cx = x6;
          cy = y5;
        } else {
          if (cx !== x6 || cy !== y5) {
            const curves = arcToCubicCurves(cx, cy, x6, y5, r1, r22, angle, largeArcFlag, sweepFlag);
            curves.forEach(function(curve2) {
              out.push({ key: "C", data: curve2 });
            });
            cx = x6;
            cy = y5;
          }
        }
        break;
      }
      case "Z":
        out.push({ key: "Z", data: [] });
        cx = subx;
        cy = suby;
        break;
    }
    lastType = key;
  }
  return out;
}
function degToRad(degrees) {
  return Math.PI * degrees / 180;
}
function rotate$1(x6, y5, angleRad) {
  const X2 = x6 * Math.cos(angleRad) - y5 * Math.sin(angleRad);
  const Y2 = x6 * Math.sin(angleRad) + y5 * Math.cos(angleRad);
  return [X2, Y2];
}
function arcToCubicCurves(x1, y1, x22, y22, r1, r22, angle, largeArcFlag, sweepFlag, recursive) {
  const angleRad = degToRad(angle);
  let params = [];
  let f1 = 0, f22 = 0, cx = 0, cy = 0;
  if (recursive) {
    [f1, f22, cx, cy] = recursive;
  } else {
    [x1, y1] = rotate$1(x1, y1, -angleRad);
    [x22, y22] = rotate$1(x22, y22, -angleRad);
    const x6 = (x1 - x22) / 2;
    const y5 = (y1 - y22) / 2;
    let h5 = x6 * x6 / (r1 * r1) + y5 * y5 / (r22 * r22);
    if (h5 > 1) {
      h5 = Math.sqrt(h5);
      r1 = h5 * r1;
      r22 = h5 * r22;
    }
    const sign3 = largeArcFlag === sweepFlag ? -1 : 1;
    const r1Pow = r1 * r1;
    const r2Pow = r22 * r22;
    const left = r1Pow * r2Pow - r1Pow * y5 * y5 - r2Pow * x6 * x6;
    const right = r1Pow * y5 * y5 + r2Pow * x6 * x6;
    const k6 = sign3 * Math.sqrt(Math.abs(left / right));
    cx = k6 * r1 * y5 / r22 + (x1 + x22) / 2;
    cy = k6 * -r22 * x6 / r1 + (y1 + y22) / 2;
    f1 = Math.asin(parseFloat(((y1 - cy) / r22).toFixed(9)));
    f22 = Math.asin(parseFloat(((y22 - cy) / r22).toFixed(9)));
    if (x1 < cx) {
      f1 = Math.PI - f1;
    }
    if (x22 < cx) {
      f22 = Math.PI - f22;
    }
    if (f1 < 0) {
      f1 = Math.PI * 2 + f1;
    }
    if (f22 < 0) {
      f22 = Math.PI * 2 + f22;
    }
    if (sweepFlag && f1 > f22) {
      f1 = f1 - Math.PI * 2;
    }
    if (!sweepFlag && f22 > f1) {
      f22 = f22 - Math.PI * 2;
    }
  }
  let df = f22 - f1;
  if (Math.abs(df) > Math.PI * 120 / 180) {
    const f2old = f22;
    const x2old = x22;
    const y2old = y22;
    if (sweepFlag && f22 > f1) {
      f22 = f1 + Math.PI * 120 / 180 * 1;
    } else {
      f22 = f1 + Math.PI * 120 / 180 * -1;
    }
    x22 = cx + r1 * Math.cos(f22);
    y22 = cy + r22 * Math.sin(f22);
    params = arcToCubicCurves(x22, y22, x2old, y2old, r1, r22, angle, 0, sweepFlag, [f22, f2old, cx, cy]);
  }
  df = f22 - f1;
  const c1 = Math.cos(f1);
  const s1 = Math.sin(f1);
  const c22 = Math.cos(f22);
  const s22 = Math.sin(f22);
  const t7 = Math.tan(df / 4);
  const hx = 4 / 3 * r1 * t7;
  const hy = 4 / 3 * r22 * t7;
  const m1 = [x1, y1];
  const m22 = [x1 + hx * s1, y1 - hy * c1];
  const m32 = [x22 + hx * s22, y22 - hy * c22];
  const m42 = [x22, y22];
  m22[0] = 2 * m1[0] - m22[0];
  m22[1] = 2 * m1[1] - m22[1];
  if (recursive) {
    return [m22, m32, m42].concat(params);
  } else {
    params = [m22, m32, m42].concat(params);
    const curves = [];
    for (let i7 = 0; i7 < params.length; i7 += 3) {
      const r12 = rotate$1(params[i7][0], params[i7][1], angleRad);
      const r23 = rotate$1(params[i7 + 1][0], params[i7 + 1][1], angleRad);
      const r32 = rotate$1(params[i7 + 2][0], params[i7 + 2][1], angleRad);
      curves.push([r12[0], r12[1], r23[0], r23[1], r32[0], r32[1]]);
    }
    return curves;
  }
}
var helper = {
  randOffset,
  randOffsetWithRange,
  ellipse,
  doubleLineOps: doubleLineFillOps
};
function line(x1, y1, x22, y22, o5) {
  return { type: "path", ops: _doubleLine(x1, y1, x22, y22, o5) };
}
function linearPath(points, close, o5) {
  const len = (points || []).length;
  if (len > 2) {
    const ops = [];
    for (let i7 = 0; i7 < len - 1; i7++) {
      ops.push(..._doubleLine(points[i7][0], points[i7][1], points[i7 + 1][0], points[i7 + 1][1], o5));
    }
    if (close) {
      ops.push(..._doubleLine(points[len - 1][0], points[len - 1][1], points[0][0], points[0][1], o5));
    }
    return { type: "path", ops };
  } else if (len === 2) {
    return line(points[0][0], points[0][1], points[1][0], points[1][1], o5);
  }
  return { type: "path", ops: [] };
}
function polygon(points, o5) {
  return linearPath(points, true, o5);
}
function rectangle(x6, y5, width, height, o5) {
  const points = [
    [x6, y5],
    [x6 + width, y5],
    [x6 + width, y5 + height],
    [x6, y5 + height]
  ];
  return polygon(points, o5);
}
function curve(points, o5) {
  let o1 = _curveWithOffset(points, 1 * (1 + o5.roughness * 0.2), o5);
  if (!o5.disableMultiStroke) {
    const o22 = _curveWithOffset(points, 1.5 * (1 + o5.roughness * 0.22), cloneOptionsAlterSeed(o5));
    o1 = o1.concat(o22);
  }
  return { type: "path", ops: o1 };
}
function ellipse(x6, y5, width, height, o5) {
  const params = generateEllipseParams(width, height, o5);
  return ellipseWithParams(x6, y5, o5, params).opset;
}
function generateEllipseParams(width, height, o5) {
  const psq = Math.sqrt(Math.PI * 2 * Math.sqrt((Math.pow(width / 2, 2) + Math.pow(height / 2, 2)) / 2));
  const stepCount = Math.ceil(Math.max(o5.curveStepCount, o5.curveStepCount / Math.sqrt(200) * psq));
  const increment = Math.PI * 2 / stepCount;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  const curveFitRandomness = 1 - o5.curveFitting;
  rx += _offsetOpt(rx * curveFitRandomness, o5);
  ry += _offsetOpt(ry * curveFitRandomness, o5);
  return { increment, rx, ry };
}
function ellipseWithParams(x6, y5, o5, ellipseParams) {
  const [ap1, cp1] = _computeEllipsePoints(ellipseParams.increment, x6, y5, ellipseParams.rx, ellipseParams.ry, 1, ellipseParams.increment * _offset(0.1, _offset(0.4, 1, o5), o5), o5);
  let o1 = _curve(ap1, null, o5);
  if (!o5.disableMultiStroke && o5.roughness !== 0) {
    const [ap2] = _computeEllipsePoints(ellipseParams.increment, x6, y5, ellipseParams.rx, ellipseParams.ry, 1.5, 0, o5);
    const o22 = _curve(ap2, null, o5);
    o1 = o1.concat(o22);
  }
  return {
    estimatedPoints: cp1,
    opset: { type: "path", ops: o1 }
  };
}
function arc(x6, y5, width, height, start, stop, closed, roughClosure, o5) {
  const cx = x6;
  const cy = y5;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o5);
  ry += _offsetOpt(ry * 0.01, o5);
  let strt = start;
  let stp = stop;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const ellipseInc = Math.PI * 2 / o5.curveStepCount;
  const arcInc = Math.min(ellipseInc / 2, (stp - strt) / 2);
  const ops = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1, o5);
  if (!o5.disableMultiStroke) {
    const o22 = _arc(arcInc, cx, cy, rx, ry, strt, stp, 1.5, o5);
    ops.push(...o22);
  }
  if (closed) {
    if (roughClosure) {
      ops.push(..._doubleLine(cx, cy, cx + rx * Math.cos(strt), cy + ry * Math.sin(strt), o5), ..._doubleLine(cx, cy, cx + rx * Math.cos(stp), cy + ry * Math.sin(stp), o5));
    } else {
      ops.push({ op: "lineTo", data: [cx, cy] }, { op: "lineTo", data: [cx + rx * Math.cos(strt), cy + ry * Math.sin(strt)] });
    }
  }
  return { type: "path", ops };
}
function svgPath(path, o5) {
  const segments = normalize(absolutize(parsePath(path)));
  const ops = [];
  let first2 = [0, 0];
  let current = [0, 0];
  for (const { key, data } of segments) {
    switch (key) {
      case "M": {
        const ro = 1 * (o5.maxRandomnessOffset || 0);
        const pv = o5.preserveVertices;
        ops.push({ op: "move", data: data.map((d5) => d5 + (pv ? 0 : _offsetOpt(ro, o5))) });
        current = [data[0], data[1]];
        first2 = [data[0], data[1]];
        break;
      }
      case "L":
        ops.push(..._doubleLine(current[0], current[1], data[0], data[1], o5));
        current = [data[0], data[1]];
        break;
      case "C": {
        const [x1, y1, x22, y22, x6, y5] = data;
        ops.push(..._bezierTo(x1, y1, x22, y22, x6, y5, current, o5));
        current = [x6, y5];
        break;
      }
      case "Z":
        ops.push(..._doubleLine(current[0], current[1], first2[0], first2[1], o5));
        current = [first2[0], first2[1]];
        break;
    }
  }
  return { type: "path", ops };
}
function solidFillPolygon(polygonList, o5) {
  const ops = [];
  for (const points of polygonList) {
    if (points.length) {
      const offset = o5.maxRandomnessOffset || 0;
      const len = points.length;
      if (len > 2) {
        ops.push({ op: "move", data: [points[0][0] + _offsetOpt(offset, o5), points[0][1] + _offsetOpt(offset, o5)] });
        for (let i7 = 1; i7 < len; i7++) {
          ops.push({ op: "lineTo", data: [points[i7][0] + _offsetOpt(offset, o5), points[i7][1] + _offsetOpt(offset, o5)] });
        }
      }
    }
  }
  return { type: "fillPath", ops };
}
function patternFillPolygons(polygonList, o5) {
  return getFiller(o5, helper).fillPolygons(polygonList, o5);
}
function patternFillArc(x6, y5, width, height, start, stop, o5) {
  const cx = x6;
  const cy = y5;
  let rx = Math.abs(width / 2);
  let ry = Math.abs(height / 2);
  rx += _offsetOpt(rx * 0.01, o5);
  ry += _offsetOpt(ry * 0.01, o5);
  let strt = start;
  let stp = stop;
  while (strt < 0) {
    strt += Math.PI * 2;
    stp += Math.PI * 2;
  }
  if (stp - strt > Math.PI * 2) {
    strt = 0;
    stp = Math.PI * 2;
  }
  const increment = (stp - strt) / o5.curveStepCount;
  const points = [];
  for (let angle = strt; angle <= stp; angle = angle + increment) {
    points.push([cx + rx * Math.cos(angle), cy + ry * Math.sin(angle)]);
  }
  points.push([cx + rx * Math.cos(stp), cy + ry * Math.sin(stp)]);
  points.push([cx, cy]);
  return patternFillPolygons([points], o5);
}
function randOffset(x6, o5) {
  return _offsetOpt(x6, o5);
}
function randOffsetWithRange(min5, max8, o5) {
  return _offset(min5, max8, o5);
}
function doubleLineFillOps(x1, y1, x22, y22, o5) {
  return _doubleLine(x1, y1, x22, y22, o5, true);
}
function cloneOptionsAlterSeed(ops) {
  const result = Object.assign({}, ops);
  result.randomizer = void 0;
  if (ops.seed) {
    result.seed = ops.seed + 1;
  }
  return result;
}
function random(ops) {
  if (!ops.randomizer) {
    ops.randomizer = new Random(ops.seed || 0);
  }
  return ops.randomizer.next();
}
function _offset(min5, max8, ops, roughnessGain = 1) {
  return ops.roughness * roughnessGain * (random(ops) * (max8 - min5) + min5);
}
function _offsetOpt(x6, ops, roughnessGain = 1) {
  return _offset(-x6, x6, ops, roughnessGain);
}
function _doubleLine(x1, y1, x22, y22, o5, filling = false) {
  const singleStroke = filling ? o5.disableMultiStrokeFill : o5.disableMultiStroke;
  const o1 = _line(x1, y1, x22, y22, o5, true, false);
  if (singleStroke) {
    return o1;
  }
  const o22 = _line(x1, y1, x22, y22, o5, true, true);
  return o1.concat(o22);
}
function _line(x1, y1, x22, y22, o5, move2, overlay) {
  const lengthSq = Math.pow(x1 - x22, 2) + Math.pow(y1 - y22, 2);
  const length2 = Math.sqrt(lengthSq);
  let roughnessGain = 1;
  if (length2 < 200) {
    roughnessGain = 1;
  } else if (length2 > 500) {
    roughnessGain = 0.4;
  } else {
    roughnessGain = -16668e-7 * length2 + 1.233334;
  }
  let offset = o5.maxRandomnessOffset || 0;
  if (offset * offset * 100 > lengthSq) {
    offset = length2 / 10;
  }
  const halfOffset = offset / 2;
  const divergePoint = 0.2 + random(o5) * 0.2;
  let midDispX = o5.bowing * o5.maxRandomnessOffset * (y22 - y1) / 200;
  let midDispY = o5.bowing * o5.maxRandomnessOffset * (x1 - x22) / 200;
  midDispX = _offsetOpt(midDispX, o5, roughnessGain);
  midDispY = _offsetOpt(midDispY, o5, roughnessGain);
  const ops = [];
  const randomHalf = () => _offsetOpt(halfOffset, o5, roughnessGain);
  const randomFull = () => _offsetOpt(offset, o5, roughnessGain);
  const preserveVertices = o5.preserveVertices;
  if (move2) {
    if (overlay) {
      ops.push({
        op: "move",
        data: [
          x1 + (preserveVertices ? 0 : randomHalf()),
          y1 + (preserveVertices ? 0 : randomHalf())
        ]
      });
    } else {
      ops.push({
        op: "move",
        data: [
          x1 + (preserveVertices ? 0 : _offsetOpt(offset, o5, roughnessGain)),
          y1 + (preserveVertices ? 0 : _offsetOpt(offset, o5, roughnessGain))
        ]
      });
    }
  }
  if (overlay) {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x1 + (x22 - x1) * divergePoint + randomHalf(),
        midDispY + y1 + (y22 - y1) * divergePoint + randomHalf(),
        midDispX + x1 + 2 * (x22 - x1) * divergePoint + randomHalf(),
        midDispY + y1 + 2 * (y22 - y1) * divergePoint + randomHalf(),
        x22 + (preserveVertices ? 0 : randomHalf()),
        y22 + (preserveVertices ? 0 : randomHalf())
      ]
    });
  } else {
    ops.push({
      op: "bcurveTo",
      data: [
        midDispX + x1 + (x22 - x1) * divergePoint + randomFull(),
        midDispY + y1 + (y22 - y1) * divergePoint + randomFull(),
        midDispX + x1 + 2 * (x22 - x1) * divergePoint + randomFull(),
        midDispY + y1 + 2 * (y22 - y1) * divergePoint + randomFull(),
        x22 + (preserveVertices ? 0 : randomFull()),
        y22 + (preserveVertices ? 0 : randomFull())
      ]
    });
  }
  return ops;
}
function _curveWithOffset(points, offset, o5) {
  const ps = [];
  ps.push([
    points[0][0] + _offsetOpt(offset, o5),
    points[0][1] + _offsetOpt(offset, o5)
  ]);
  ps.push([
    points[0][0] + _offsetOpt(offset, o5),
    points[0][1] + _offsetOpt(offset, o5)
  ]);
  for (let i7 = 1; i7 < points.length; i7++) {
    ps.push([
      points[i7][0] + _offsetOpt(offset, o5),
      points[i7][1] + _offsetOpt(offset, o5)
    ]);
    if (i7 === points.length - 1) {
      ps.push([
        points[i7][0] + _offsetOpt(offset, o5),
        points[i7][1] + _offsetOpt(offset, o5)
      ]);
    }
  }
  return _curve(ps, null, o5);
}
function _curve(points, closePoint, o5) {
  const len = points.length;
  const ops = [];
  if (len > 3) {
    const b4 = [];
    const s5 = 1 - o5.curveTightness;
    ops.push({ op: "move", data: [points[1][0], points[1][1]] });
    for (let i7 = 1; i7 + 2 < len; i7++) {
      const cachedVertArray = points[i7];
      b4[0] = [cachedVertArray[0], cachedVertArray[1]];
      b4[1] = [cachedVertArray[0] + (s5 * points[i7 + 1][0] - s5 * points[i7 - 1][0]) / 6, cachedVertArray[1] + (s5 * points[i7 + 1][1] - s5 * points[i7 - 1][1]) / 6];
      b4[2] = [points[i7 + 1][0] + (s5 * points[i7][0] - s5 * points[i7 + 2][0]) / 6, points[i7 + 1][1] + (s5 * points[i7][1] - s5 * points[i7 + 2][1]) / 6];
      b4[3] = [points[i7 + 1][0], points[i7 + 1][1]];
      ops.push({ op: "bcurveTo", data: [b4[1][0], b4[1][1], b4[2][0], b4[2][1], b4[3][0], b4[3][1]] });
    }
    if (closePoint && closePoint.length === 2) {
      const ro = o5.maxRandomnessOffset;
      ops.push({ op: "lineTo", data: [closePoint[0] + _offsetOpt(ro, o5), closePoint[1] + _offsetOpt(ro, o5)] });
    }
  } else if (len === 3) {
    ops.push({ op: "move", data: [points[1][0], points[1][1]] });
    ops.push({
      op: "bcurveTo",
      data: [
        points[1][0],
        points[1][1],
        points[2][0],
        points[2][1],
        points[2][0],
        points[2][1]
      ]
    });
  } else if (len === 2) {
    ops.push(..._doubleLine(points[0][0], points[0][1], points[1][0], points[1][1], o5));
  }
  return ops;
}
function _computeEllipsePoints(increment, cx, cy, rx, ry, offset, overlap, o5) {
  const coreOnly = o5.roughness === 0;
  const corePoints = [];
  const allPoints = [];
  if (coreOnly) {
    increment = increment / 4;
    allPoints.push([
      cx + rx * Math.cos(-increment),
      cy + ry * Math.sin(-increment)
    ]);
    for (let angle = 0; angle <= Math.PI * 2; angle = angle + increment) {
      const p5 = [
        cx + rx * Math.cos(angle),
        cy + ry * Math.sin(angle)
      ];
      corePoints.push(p5);
      allPoints.push(p5);
    }
    allPoints.push([
      cx + rx * Math.cos(0),
      cy + ry * Math.sin(0)
    ]);
    allPoints.push([
      cx + rx * Math.cos(increment),
      cy + ry * Math.sin(increment)
    ]);
  } else {
    const radOffset = _offsetOpt(0.5, o5) - Math.PI / 2;
    allPoints.push([
      _offsetOpt(offset, o5) + cx + 0.9 * rx * Math.cos(radOffset - increment),
      _offsetOpt(offset, o5) + cy + 0.9 * ry * Math.sin(radOffset - increment)
    ]);
    const endAngle = Math.PI * 2 + radOffset - 0.01;
    for (let angle = radOffset; angle < endAngle; angle = angle + increment) {
      const p5 = [
        _offsetOpt(offset, o5) + cx + rx * Math.cos(angle),
        _offsetOpt(offset, o5) + cy + ry * Math.sin(angle)
      ];
      corePoints.push(p5);
      allPoints.push(p5);
    }
    allPoints.push([
      _offsetOpt(offset, o5) + cx + rx * Math.cos(radOffset + Math.PI * 2 + overlap * 0.5),
      _offsetOpt(offset, o5) + cy + ry * Math.sin(radOffset + Math.PI * 2 + overlap * 0.5)
    ]);
    allPoints.push([
      _offsetOpt(offset, o5) + cx + 0.98 * rx * Math.cos(radOffset + overlap),
      _offsetOpt(offset, o5) + cy + 0.98 * ry * Math.sin(radOffset + overlap)
    ]);
    allPoints.push([
      _offsetOpt(offset, o5) + cx + 0.9 * rx * Math.cos(radOffset + overlap * 0.5),
      _offsetOpt(offset, o5) + cy + 0.9 * ry * Math.sin(radOffset + overlap * 0.5)
    ]);
  }
  return [allPoints, corePoints];
}
function _arc(increment, cx, cy, rx, ry, strt, stp, offset, o5) {
  const radOffset = strt + _offsetOpt(0.1, o5);
  const points = [];
  points.push([
    _offsetOpt(offset, o5) + cx + 0.9 * rx * Math.cos(radOffset - increment),
    _offsetOpt(offset, o5) + cy + 0.9 * ry * Math.sin(radOffset - increment)
  ]);
  for (let angle = radOffset; angle <= stp; angle = angle + increment) {
    points.push([
      _offsetOpt(offset, o5) + cx + rx * Math.cos(angle),
      _offsetOpt(offset, o5) + cy + ry * Math.sin(angle)
    ]);
  }
  points.push([
    cx + rx * Math.cos(stp),
    cy + ry * Math.sin(stp)
  ]);
  points.push([
    cx + rx * Math.cos(stp),
    cy + ry * Math.sin(stp)
  ]);
  return _curve(points, null, o5);
}
function _bezierTo(x1, y1, x22, y22, x6, y5, current, o5) {
  const ops = [];
  const ros = [o5.maxRandomnessOffset || 1, (o5.maxRandomnessOffset || 1) + 0.3];
  let f6 = [0, 0];
  const iterations = o5.disableMultiStroke ? 1 : 2;
  const preserveVertices = o5.preserveVertices;
  for (let i7 = 0; i7 < iterations; i7++) {
    if (i7 === 0) {
      ops.push({ op: "move", data: [current[0], current[1]] });
    } else {
      ops.push({ op: "move", data: [current[0] + (preserveVertices ? 0 : _offsetOpt(ros[0], o5)), current[1] + (preserveVertices ? 0 : _offsetOpt(ros[0], o5))] });
    }
    f6 = preserveVertices ? [x6, y5] : [x6 + _offsetOpt(ros[i7], o5), y5 + _offsetOpt(ros[i7], o5)];
    ops.push({
      op: "bcurveTo",
      data: [
        x1 + _offsetOpt(ros[i7], o5),
        y1 + _offsetOpt(ros[i7], o5),
        x22 + _offsetOpt(ros[i7], o5),
        y22 + _offsetOpt(ros[i7], o5),
        f6[0],
        f6[1]
      ]
    });
  }
  return ops;
}
function clone3(p5) {
  return [...p5];
}
function curveToBezier(pointsIn, curveTightness = 0) {
  const len = pointsIn.length;
  if (len < 3) {
    throw new Error("A curve must have at least three points.");
  }
  const out = [];
  if (len === 3) {
    out.push(clone3(pointsIn[0]), clone3(pointsIn[1]), clone3(pointsIn[2]), clone3(pointsIn[2]));
  } else {
    const points = [];
    points.push(pointsIn[0], pointsIn[0]);
    for (let i7 = 1; i7 < pointsIn.length; i7++) {
      points.push(pointsIn[i7]);
      if (i7 === pointsIn.length - 1) {
        points.push(pointsIn[i7]);
      }
    }
    const b4 = [];
    const s5 = 1 - curveTightness;
    out.push(clone3(points[0]));
    for (let i7 = 1; i7 + 2 < points.length; i7++) {
      const cachedVertArray = points[i7];
      b4[0] = [cachedVertArray[0], cachedVertArray[1]];
      b4[1] = [cachedVertArray[0] + (s5 * points[i7 + 1][0] - s5 * points[i7 - 1][0]) / 6, cachedVertArray[1] + (s5 * points[i7 + 1][1] - s5 * points[i7 - 1][1]) / 6];
      b4[2] = [points[i7 + 1][0] + (s5 * points[i7][0] - s5 * points[i7 + 2][0]) / 6, points[i7 + 1][1] + (s5 * points[i7][1] - s5 * points[i7 + 2][1]) / 6];
      b4[3] = [points[i7 + 1][0], points[i7 + 1][1]];
      out.push(b4[1], b4[2], b4[3]);
    }
  }
  return out;
}
function distance2(p1, p22) {
  return Math.sqrt(distanceSq(p1, p22));
}
function distanceSq(p1, p22) {
  return Math.pow(p1[0] - p22[0], 2) + Math.pow(p1[1] - p22[1], 2);
}
function distanceToSegmentSq(p5, v5, w6) {
  const l22 = distanceSq(v5, w6);
  if (l22 === 0) {
    return distanceSq(p5, v5);
  }
  let t7 = ((p5[0] - v5[0]) * (w6[0] - v5[0]) + (p5[1] - v5[1]) * (w6[1] - v5[1])) / l22;
  t7 = Math.max(0, Math.min(1, t7));
  return distanceSq(p5, lerp(v5, w6, t7));
}
function lerp(a6, b4, t7) {
  return [
    a6[0] + (b4[0] - a6[0]) * t7,
    a6[1] + (b4[1] - a6[1]) * t7
  ];
}
function flatness(points, offset) {
  const p1 = points[offset + 0];
  const p22 = points[offset + 1];
  const p32 = points[offset + 2];
  const p42 = points[offset + 3];
  let ux = 3 * p22[0] - 2 * p1[0] - p42[0];
  ux *= ux;
  let uy = 3 * p22[1] - 2 * p1[1] - p42[1];
  uy *= uy;
  let vx = 3 * p32[0] - 2 * p42[0] - p1[0];
  vx *= vx;
  let vy = 3 * p32[1] - 2 * p42[1] - p1[1];
  vy *= vy;
  if (ux < vx) {
    ux = vx;
  }
  if (uy < vy) {
    uy = vy;
  }
  return ux + uy;
}
function getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints) {
  const outPoints = newPoints || [];
  if (flatness(points, offset) < tolerance) {
    const p0 = points[offset + 0];
    if (outPoints.length) {
      const d5 = distance2(outPoints[outPoints.length - 1], p0);
      if (d5 > 1) {
        outPoints.push(p0);
      }
    } else {
      outPoints.push(p0);
    }
    outPoints.push(points[offset + 3]);
  } else {
    const t7 = 0.5;
    const p1 = points[offset + 0];
    const p22 = points[offset + 1];
    const p32 = points[offset + 2];
    const p42 = points[offset + 3];
    const q1 = lerp(p1, p22, t7);
    const q22 = lerp(p22, p32, t7);
    const q32 = lerp(p32, p42, t7);
    const r1 = lerp(q1, q22, t7);
    const r22 = lerp(q22, q32, t7);
    const red = lerp(r1, r22, t7);
    getPointsOnBezierCurveWithSplitting([p1, q1, r1, red], 0, tolerance, outPoints);
    getPointsOnBezierCurveWithSplitting([red, r22, q32, p42], 0, tolerance, outPoints);
  }
  return outPoints;
}
function simplify(points, distance4) {
  return simplifyPoints(points, 0, points.length, distance4);
}
function simplifyPoints(points, start, end, epsilon, newPoints) {
  const outPoints = newPoints || [];
  const s5 = points[start];
  const e8 = points[end - 1];
  let maxDistSq = 0;
  let maxNdx = 1;
  for (let i7 = start + 1; i7 < end - 1; ++i7) {
    const distSq = distanceToSegmentSq(points[i7], s5, e8);
    if (distSq > maxDistSq) {
      maxDistSq = distSq;
      maxNdx = i7;
    }
  }
  if (Math.sqrt(maxDistSq) > epsilon) {
    simplifyPoints(points, start, maxNdx + 1, epsilon, outPoints);
    simplifyPoints(points, maxNdx, end, epsilon, outPoints);
  } else {
    if (!outPoints.length) {
      outPoints.push(s5);
    }
    outPoints.push(e8);
  }
  return outPoints;
}
function pointsOnBezierCurves(points, tolerance = 0.15, distance4) {
  const newPoints = [];
  const numSegments = (points.length - 1) / 3;
  for (let i7 = 0; i7 < numSegments; i7++) {
    const offset = i7 * 3;
    getPointsOnBezierCurveWithSplitting(points, offset, tolerance, newPoints);
  }
  if (distance4 && distance4 > 0) {
    return simplifyPoints(newPoints, 0, newPoints.length, distance4);
  }
  return newPoints;
}
function pointsOnPath(path, tolerance, distance4) {
  const segments = parsePath(path);
  const normalized = normalize(absolutize(segments));
  const sets = [];
  let currentPoints = [];
  let start = [0, 0];
  let pendingCurve = [];
  const appendPendingCurve = () => {
    if (pendingCurve.length >= 4) {
      currentPoints.push(...pointsOnBezierCurves(pendingCurve, tolerance));
    }
    pendingCurve = [];
  };
  const appendPendingPoints = () => {
    appendPendingCurve();
    if (currentPoints.length) {
      sets.push(currentPoints);
      currentPoints = [];
    }
  };
  for (const { key, data } of normalized) {
    switch (key) {
      case "M":
        appendPendingPoints();
        start = [data[0], data[1]];
        currentPoints.push(start);
        break;
      case "L":
        appendPendingCurve();
        currentPoints.push([data[0], data[1]]);
        break;
      case "C":
        if (!pendingCurve.length) {
          const lastPoint = currentPoints.length ? currentPoints[currentPoints.length - 1] : start;
          pendingCurve.push([lastPoint[0], lastPoint[1]]);
        }
        pendingCurve.push([data[0], data[1]]);
        pendingCurve.push([data[2], data[3]]);
        pendingCurve.push([data[4], data[5]]);
        break;
      case "Z":
        appendPendingCurve();
        currentPoints.push([start[0], start[1]]);
        break;
    }
  }
  appendPendingPoints();
  if (!distance4) {
    return sets;
  }
  const out = [];
  for (const set4 of sets) {
    const simplifiedSet = simplify(set4, distance4);
    if (simplifiedSet.length) {
      out.push(simplifiedSet);
    }
  }
  return out;
}
var NOS = "none";
var RoughGenerator = class {
  constructor(config) {
    this.defaultOptions = {
      maxRandomnessOffset: 2,
      roughness: 1,
      bowing: 1,
      stroke: "#000",
      strokeWidth: 1,
      curveTightness: 0,
      curveFitting: 0.95,
      curveStepCount: 9,
      fillStyle: "hachure",
      fillWeight: -1,
      hachureAngle: -41,
      hachureGap: -1,
      dashOffset: -1,
      dashGap: -1,
      zigzagOffset: -1,
      seed: 0,
      disableMultiStroke: false,
      disableMultiStrokeFill: false,
      preserveVertices: false
    };
    this.config = config || {};
    if (this.config.options) {
      this.defaultOptions = this._o(this.config.options);
    }
  }
  static newSeed() {
    return randomSeed();
  }
  _o(options) {
    return options ? Object.assign({}, this.defaultOptions, options) : this.defaultOptions;
  }
  _d(shape, sets, options) {
    return { shape, sets: sets || [], options: options || this.defaultOptions };
  }
  line(x1, y1, x22, y22, options) {
    const o5 = this._o(options);
    return this._d("line", [line(x1, y1, x22, y22, o5)], o5);
  }
  rectangle(x6, y5, width, height, options) {
    const o5 = this._o(options);
    const paths2 = [];
    const outline = rectangle(x6, y5, width, height, o5);
    if (o5.fill) {
      const points = [[x6, y5], [x6 + width, y5], [x6 + width, y5 + height], [x6, y5 + height]];
      if (o5.fillStyle === "solid") {
        paths2.push(solidFillPolygon([points], o5));
      } else {
        paths2.push(patternFillPolygons([points], o5));
      }
    }
    if (o5.stroke !== NOS) {
      paths2.push(outline);
    }
    return this._d("rectangle", paths2, o5);
  }
  ellipse(x6, y5, width, height, options) {
    const o5 = this._o(options);
    const paths2 = [];
    const ellipseParams = generateEllipseParams(width, height, o5);
    const ellipseResponse = ellipseWithParams(x6, y5, o5, ellipseParams);
    if (o5.fill) {
      if (o5.fillStyle === "solid") {
        const shape = ellipseWithParams(x6, y5, o5, ellipseParams).opset;
        shape.type = "fillPath";
        paths2.push(shape);
      } else {
        paths2.push(patternFillPolygons([ellipseResponse.estimatedPoints], o5));
      }
    }
    if (o5.stroke !== NOS) {
      paths2.push(ellipseResponse.opset);
    }
    return this._d("ellipse", paths2, o5);
  }
  circle(x6, y5, diameter, options) {
    const ret = this.ellipse(x6, y5, diameter, diameter, options);
    ret.shape = "circle";
    return ret;
  }
  linearPath(points, options) {
    const o5 = this._o(options);
    return this._d("linearPath", [linearPath(points, false, o5)], o5);
  }
  arc(x6, y5, width, height, start, stop, closed = false, options) {
    const o5 = this._o(options);
    const paths2 = [];
    const outline = arc(x6, y5, width, height, start, stop, closed, true, o5);
    if (closed && o5.fill) {
      if (o5.fillStyle === "solid") {
        const fillOptions = Object.assign({}, o5);
        fillOptions.disableMultiStroke = true;
        const shape = arc(x6, y5, width, height, start, stop, true, false, fillOptions);
        shape.type = "fillPath";
        paths2.push(shape);
      } else {
        paths2.push(patternFillArc(x6, y5, width, height, start, stop, o5));
      }
    }
    if (o5.stroke !== NOS) {
      paths2.push(outline);
    }
    return this._d("arc", paths2, o5);
  }
  curve(points, options) {
    const o5 = this._o(options);
    const paths2 = [];
    const outline = curve(points, o5);
    if (o5.fill && o5.fill !== NOS && points.length >= 3) {
      const bcurve = curveToBezier(points);
      const polyPoints = pointsOnBezierCurves(bcurve, 10, (1 + o5.roughness) / 2);
      if (o5.fillStyle === "solid") {
        paths2.push(solidFillPolygon([polyPoints], o5));
      } else {
        paths2.push(patternFillPolygons([polyPoints], o5));
      }
    }
    if (o5.stroke !== NOS) {
      paths2.push(outline);
    }
    return this._d("curve", paths2, o5);
  }
  polygon(points, options) {
    const o5 = this._o(options);
    const paths2 = [];
    const outline = linearPath(points, true, o5);
    if (o5.fill) {
      if (o5.fillStyle === "solid") {
        paths2.push(solidFillPolygon([points], o5));
      } else {
        paths2.push(patternFillPolygons([points], o5));
      }
    }
    if (o5.stroke !== NOS) {
      paths2.push(outline);
    }
    return this._d("polygon", paths2, o5);
  }
  path(d5, options) {
    const o5 = this._o(options);
    const paths2 = [];
    if (!d5) {
      return this._d("path", paths2, o5);
    }
    d5 = (d5 || "").replace(/\n/g, " ").replace(/(-\s)/g, "-").replace("/(ss)/g", " ");
    const hasFill = o5.fill && o5.fill !== "transparent" && o5.fill !== NOS;
    const hasStroke = o5.stroke !== NOS;
    const simplified = !!(o5.simplification && o5.simplification < 1);
    const distance4 = simplified ? 4 - 4 * o5.simplification : (1 + o5.roughness) / 2;
    const sets = pointsOnPath(d5, 1, distance4);
    if (hasFill) {
      if (o5.fillStyle === "solid") {
        paths2.push(solidFillPolygon(sets, o5));
      } else {
        paths2.push(patternFillPolygons(sets, o5));
      }
    }
    if (hasStroke) {
      if (simplified) {
        sets.forEach((set4) => {
          paths2.push(linearPath(set4, false, o5));
        });
      } else {
        paths2.push(svgPath(d5, o5));
      }
    }
    return this._d("path", paths2, o5);
  }
  opsToPath(drawing, fixedDecimals) {
    let path = "";
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d5) => +d5.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          path += `M${data[0]} ${data[1]} `;
          break;
        case "bcurveTo":
          path += `C${data[0]} ${data[1]}, ${data[2]} ${data[3]}, ${data[4]} ${data[5]} `;
          break;
        case "lineTo":
          path += `L${data[0]} ${data[1]} `;
          break;
      }
    }
    return path.trim();
  }
  toPaths(drawable) {
    const sets = drawable.sets || [];
    const o5 = drawable.options || this.defaultOptions;
    const paths2 = [];
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path":
          path = {
            d: this.opsToPath(drawing),
            stroke: o5.stroke,
            strokeWidth: o5.strokeWidth,
            fill: NOS
          };
          break;
        case "fillPath":
          path = {
            d: this.opsToPath(drawing),
            stroke: NOS,
            strokeWidth: 0,
            fill: o5.fill || NOS
          };
          break;
        case "fillSketch":
          path = this.fillSketch(drawing, o5);
          break;
      }
      if (path) {
        paths2.push(path);
      }
    }
    return paths2;
  }
  fillSketch(drawing, o5) {
    let fweight = o5.fillWeight;
    if (fweight < 0) {
      fweight = o5.strokeWidth / 2;
    }
    return {
      d: this.opsToPath(drawing),
      stroke: o5.fill || NOS,
      strokeWidth: fweight,
      fill: NOS
    };
  }
};
var RoughCanvas = class {
  constructor(canvas, config) {
    this.canvas = canvas;
    this.ctx = this.canvas.getContext("2d");
    this.gen = new RoughGenerator(config);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o5 = drawable.options || this.getDefaultOptions();
    const ctx = this.ctx;
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      switch (drawing.type) {
        case "path":
          ctx.save();
          ctx.strokeStyle = o5.stroke === "none" ? "transparent" : o5.stroke;
          ctx.lineWidth = o5.strokeWidth;
          if (o5.strokeLineDash) {
            ctx.setLineDash(o5.strokeLineDash);
          }
          if (o5.strokeLineDashOffset) {
            ctx.lineDashOffset = o5.strokeLineDashOffset;
          }
          this._drawToContext(ctx, drawing, precision);
          ctx.restore();
          break;
        case "fillPath": {
          ctx.save();
          ctx.fillStyle = o5.fill || "";
          const fillRule = drawable.shape === "curve" || drawable.shape === "polygon" || drawable.shape === "path" ? "evenodd" : "nonzero";
          this._drawToContext(ctx, drawing, precision, fillRule);
          ctx.restore();
          break;
        }
        case "fillSketch":
          this.fillSketch(ctx, drawing, o5);
          break;
      }
    }
  }
  fillSketch(ctx, drawing, o5) {
    let fweight = o5.fillWeight;
    if (fweight < 0) {
      fweight = o5.strokeWidth / 2;
    }
    ctx.save();
    if (o5.fillLineDash) {
      ctx.setLineDash(o5.fillLineDash);
    }
    if (o5.fillLineDashOffset) {
      ctx.lineDashOffset = o5.fillLineDashOffset;
    }
    ctx.strokeStyle = o5.fill || "";
    ctx.lineWidth = fweight;
    this._drawToContext(ctx, drawing, o5.fixedDecimalPlaceDigits);
    ctx.restore();
  }
  _drawToContext(ctx, drawing, fixedDecimals, rule = "nonzero") {
    ctx.beginPath();
    for (const item of drawing.ops) {
      const data = typeof fixedDecimals === "number" && fixedDecimals >= 0 ? item.data.map((d5) => +d5.toFixed(fixedDecimals)) : item.data;
      switch (item.op) {
        case "move":
          ctx.moveTo(data[0], data[1]);
          break;
        case "bcurveTo":
          ctx.bezierCurveTo(data[0], data[1], data[2], data[3], data[4], data[5]);
          break;
        case "lineTo":
          ctx.lineTo(data[0], data[1]);
          break;
      }
    }
    if (drawing.type === "fillPath") {
      ctx.fill(rule);
    } else {
      ctx.stroke();
    }
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  line(x1, y1, x22, y22, options) {
    const d5 = this.gen.line(x1, y1, x22, y22, options);
    this.draw(d5);
    return d5;
  }
  rectangle(x6, y5, width, height, options) {
    const d5 = this.gen.rectangle(x6, y5, width, height, options);
    this.draw(d5);
    return d5;
  }
  ellipse(x6, y5, width, height, options) {
    const d5 = this.gen.ellipse(x6, y5, width, height, options);
    this.draw(d5);
    return d5;
  }
  circle(x6, y5, diameter, options) {
    const d5 = this.gen.circle(x6, y5, diameter, options);
    this.draw(d5);
    return d5;
  }
  linearPath(points, options) {
    const d5 = this.gen.linearPath(points, options);
    this.draw(d5);
    return d5;
  }
  polygon(points, options) {
    const d5 = this.gen.polygon(points, options);
    this.draw(d5);
    return d5;
  }
  arc(x6, y5, width, height, start, stop, closed = false, options) {
    const d5 = this.gen.arc(x6, y5, width, height, start, stop, closed, options);
    this.draw(d5);
    return d5;
  }
  curve(points, options) {
    const d5 = this.gen.curve(points, options);
    this.draw(d5);
    return d5;
  }
  path(d5, options) {
    const drawing = this.gen.path(d5, options);
    this.draw(drawing);
    return drawing;
  }
};
var SVGNS = "http://www.w3.org/2000/svg";
var RoughSVG = class {
  constructor(svg, config) {
    this.svg = svg;
    this.gen = new RoughGenerator(config);
  }
  draw(drawable) {
    const sets = drawable.sets || [];
    const o5 = drawable.options || this.getDefaultOptions();
    const doc = this.svg.ownerDocument || window.document;
    const g6 = doc.createElementNS(SVGNS, "g");
    const precision = drawable.options.fixedDecimalPlaceDigits;
    for (const drawing of sets) {
      let path = null;
      switch (drawing.type) {
        case "path": {
          path = doc.createElementNS(SVGNS, "path");
          path.setAttribute("d", this.opsToPath(drawing, precision));
          path.setAttribute("stroke", o5.stroke);
          path.setAttribute("stroke-width", o5.strokeWidth + "");
          path.setAttribute("fill", "none");
          if (o5.strokeLineDash) {
            path.setAttribute("stroke-dasharray", o5.strokeLineDash.join(" ").trim());
          }
          if (o5.strokeLineDashOffset) {
            path.setAttribute("stroke-dashoffset", `${o5.strokeLineDashOffset}`);
          }
          break;
        }
        case "fillPath": {
          path = doc.createElementNS(SVGNS, "path");
          path.setAttribute("d", this.opsToPath(drawing, precision));
          path.setAttribute("stroke", "none");
          path.setAttribute("stroke-width", "0");
          path.setAttribute("fill", o5.fill || "");
          if (drawable.shape === "curve" || drawable.shape === "polygon") {
            path.setAttribute("fill-rule", "evenodd");
          }
          break;
        }
        case "fillSketch": {
          path = this.fillSketch(doc, drawing, o5);
          break;
        }
      }
      if (path) {
        g6.appendChild(path);
      }
    }
    return g6;
  }
  fillSketch(doc, drawing, o5) {
    let fweight = o5.fillWeight;
    if (fweight < 0) {
      fweight = o5.strokeWidth / 2;
    }
    const path = doc.createElementNS(SVGNS, "path");
    path.setAttribute("d", this.opsToPath(drawing, o5.fixedDecimalPlaceDigits));
    path.setAttribute("stroke", o5.fill || "");
    path.setAttribute("stroke-width", fweight + "");
    path.setAttribute("fill", "none");
    if (o5.fillLineDash) {
      path.setAttribute("stroke-dasharray", o5.fillLineDash.join(" ").trim());
    }
    if (o5.fillLineDashOffset) {
      path.setAttribute("stroke-dashoffset", `${o5.fillLineDashOffset}`);
    }
    return path;
  }
  get generator() {
    return this.gen;
  }
  getDefaultOptions() {
    return this.gen.defaultOptions;
  }
  opsToPath(drawing, fixedDecimalPlaceDigits) {
    return this.gen.opsToPath(drawing, fixedDecimalPlaceDigits);
  }
  line(x1, y1, x22, y22, options) {
    const d5 = this.gen.line(x1, y1, x22, y22, options);
    return this.draw(d5);
  }
  rectangle(x6, y5, width, height, options) {
    const d5 = this.gen.rectangle(x6, y5, width, height, options);
    return this.draw(d5);
  }
  ellipse(x6, y5, width, height, options) {
    const d5 = this.gen.ellipse(x6, y5, width, height, options);
    return this.draw(d5);
  }
  circle(x6, y5, diameter, options) {
    const d5 = this.gen.circle(x6, y5, diameter, options);
    return this.draw(d5);
  }
  linearPath(points, options) {
    const d5 = this.gen.linearPath(points, options);
    return this.draw(d5);
  }
  polygon(points, options) {
    const d5 = this.gen.polygon(points, options);
    return this.draw(d5);
  }
  arc(x6, y5, width, height, start, stop, closed = false, options) {
    const d5 = this.gen.arc(x6, y5, width, height, start, stop, closed, options);
    return this.draw(d5);
  }
  curve(points, options) {
    const d5 = this.gen.curve(points, options);
    return this.draw(d5);
  }
  path(d5, options) {
    const drawing = this.gen.path(d5, options);
    return this.draw(drawing);
  }
};
var rough = {
  canvas(canvas, config) {
    return new RoughCanvas(canvas, config);
  },
  svg(svg, config) {
    return new RoughSVG(svg, config);
  },
  generator(config) {
    return new RoughGenerator(config);
  },
  newSeed() {
    return RoughGenerator.newSeed();
  }
};
var DEFAULT_RENDER_PRIORITY3 = 1e3;
function BaseRenderer2(eventBus, renderPriority) {
  var self2 = this;
  renderPriority = renderPriority || DEFAULT_RENDER_PRIORITY3;
  eventBus.on(["render.shape", "render.connection"], renderPriority, function(evt, context) {
    var type = evt.type, element = context.element, visuals = context.gfx, attrs = context.attrs;
    if (self2.canRender(element)) {
      if (type === "render.shape") {
        return self2.drawShape(visuals, element, attrs);
      } else {
        return self2.drawConnection(visuals, element, attrs);
      }
    }
  });
  eventBus.on(["render.getShapePath", "render.getConnectionPath"], renderPriority, function(evt, element) {
    if (self2.canRender(element)) {
      if (evt.type === "render.getShapePath") {
        return self2.getShapePath(element);
      } else {
        return self2.getConnectionPath(element);
      }
    }
  });
}
BaseRenderer2.prototype.canRender = function(element) {
};
BaseRenderer2.prototype.drawShape = function(visuals, shape) {
};
BaseRenderer2.prototype.drawConnection = function(visuals, connection) {
};
BaseRenderer2.prototype.getShapePath = function(shape) {
};
BaseRenderer2.prototype.getConnectionPath = function(connection) {
};
function is3(element, type) {
  var bo = getBusinessObject2(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}
function getBusinessObject2(element) {
  return element && element.businessObject || element;
}
function getDi2(element) {
  return element && element.di;
}
function getLabelAttr2(semantic) {
  if (is3(semantic, "bpmn:FlowElement") || is3(semantic, "bpmn:Participant") || is3(semantic, "bpmn:Lane") || is3(semantic, "bpmn:SequenceFlow") || is3(semantic, "bpmn:MessageFlow") || is3(semantic, "bpmn:DataInput") || is3(semantic, "bpmn:DataOutput")) {
    return "name";
  }
  if (is3(semantic, "bpmn:TextAnnotation")) {
    return "text";
  }
  if (is3(semantic, "bpmn:Group")) {
    return "categoryValueRef";
  }
}
function getCategoryValue2(semantic) {
  var categoryValueRef = semantic["categoryValueRef"];
  if (!categoryValueRef) {
    return "";
  }
  return categoryValueRef.value || "";
}
function getLabel2(element) {
  var semantic = element.businessObject, attr3 = getLabelAttr2(semantic);
  if (attr3) {
    if (attr3 === "categoryValueRef") {
      return getCategoryValue2(semantic);
    }
    return semantic[attr3] || "";
  }
}
function isExpanded2(element, di) {
  if (is3(element, "bpmn:CallActivity")) {
    return false;
  }
  if (is3(element, "bpmn:SubProcess")) {
    di = di || getDi2(element);
    if (di && is3(di, "bpmndi:BPMNPlane")) {
      return true;
    }
    return di && !!di.isExpanded;
  }
  if (is3(element, "bpmn:Participant")) {
    return !!getBusinessObject2(element).processRef;
  }
  return true;
}
function isEventSubProcess2(element) {
  return element && !!getBusinessObject2(element).triggeredByEvent;
}
function componentsToPath2(elements) {
  return elements.flat().join(",").replace(/,?([A-z]),?/g, "$1");
}
var black2 = "hsl(225, 10%, 15%)";
function isTypedEvent2(event2, eventDefinitionType, filter2) {
  function matches3(definition, filter3) {
    return every(filter3, function(val, key) {
      return definition[key] == val;
    });
  }
  return some(event2.eventDefinitions, function(definition) {
    return definition.$type === eventDefinitionType && matches3(event2, filter2);
  });
}
function isThrowEvent2(event2) {
  return event2.$type === "bpmn:IntermediateThrowEvent" || event2.$type === "bpmn:EndEvent";
}
function isCollection2(element) {
  var dataObject = element.dataObjectRef;
  return element.isCollection || dataObject && dataObject.isCollection;
}
function getSemantic(element) {
  return element.businessObject;
}
function getFillColor2(element, defaultColor) {
  var di = getDi2(element);
  return di.get("color:background-color") || di.get("bioc:fill") || defaultColor || "white";
}
function getStrokeColor2(element, defaultColor) {
  var di = getDi2(element);
  return di.get("color:border-color") || di.get("bioc:stroke") || defaultColor || black2;
}
function getCirclePath2(shape) {
  var cx = shape.x + shape.width / 2, cy = shape.y + shape.height / 2, radius = shape.width / 2;
  var circlePath2 = [
    ["M", cx, cy],
    ["m", 0, -radius],
    ["a", radius, radius, 0, 1, 1, 0, 2 * radius],
    ["a", radius, radius, 0, 1, 1, 0, -2 * radius],
    ["z"]
  ];
  return componentsToPath2(circlePath2);
}
function getRoundRectPath2(shape, borderRadius) {
  var x6 = shape.x, y5 = shape.y, width = shape.width, height = shape.height;
  var roundRectPath = [
    ["M", x6 + borderRadius, y5],
    ["l", width - borderRadius * 2, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, borderRadius],
    ["l", 0, height - borderRadius * 2],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, borderRadius],
    ["l", borderRadius * 2 - width, 0],
    ["a", borderRadius, borderRadius, 0, 0, 1, -borderRadius, -borderRadius],
    ["l", 0, borderRadius * 2 - height],
    ["a", borderRadius, borderRadius, 0, 0, 1, borderRadius, -borderRadius],
    ["z"]
  ];
  return componentsToPath2(roundRectPath);
}
function getDiamondPath2(shape) {
  var width = shape.width, height = shape.height, x6 = shape.x, y5 = shape.y, halfWidth = width / 2, halfHeight = height / 2;
  var diamondPath = [
    ["M", x6 + halfWidth, y5],
    ["l", halfWidth, halfHeight],
    ["l", -halfWidth, halfHeight],
    ["l", -halfWidth, -halfHeight],
    ["z"]
  ];
  return componentsToPath2(diamondPath);
}
function getRectPath2(shape) {
  var x6 = shape.x, y5 = shape.y, width = shape.width, height = shape.height;
  var rectPath = [
    ["M", x6, y5],
    ["l", width, 0],
    ["l", 0, height],
    ["l", -width, 0],
    ["z"]
  ];
  return componentsToPath2(rectPath);
}
function transform3(gfx, x6, y5, angle, amount) {
  var translate4 = createTransform();
  translate4.setTranslate(x6, y5);
  var rotate3 = createTransform();
  rotate3.setRotate(angle || 0, 0, 0);
  var scale = createTransform();
  scale.setScale(amount || 1, amount || 1);
  transform(gfx, [translate4, rotate3, scale]);
}
function translate3(gfx, x6, y5) {
  var translate4 = createTransform();
  translate4.setTranslate(x6, y5);
  transform(gfx, translate4);
}
function rotate2(gfx, angle) {
  var rotate3 = createTransform();
  rotate3.setRotate(angle, 0, 0);
  transform(gfx, rotate3);
}
function createCommonjsModule2(fn2, module2) {
  return module2 = { exports: {} }, fn2(module2, module2.exports), module2.exports;
}
var hat_12 = createCommonjsModule2(function(module2) {
  var hat = module2.exports = function(bits, base) {
    if (!base) base = 16;
    if (bits === void 0) bits = 128;
    if (bits <= 0) return "0";
    var digits = Math.log(Math.pow(2, bits)) / Math.log(base);
    for (var i7 = 2; digits === Infinity; i7 *= 2) {
      digits = Math.log(Math.pow(2, bits / i7)) / Math.log(base) * i7;
    }
    var rem = digits - Math.floor(digits);
    var res = "";
    for (var i7 = 0; i7 < Math.floor(digits); i7++) {
      var x6 = Math.floor(Math.random() * base).toString(base);
      res = x6 + res;
    }
    if (rem) {
      var b4 = Math.pow(base, rem);
      var x6 = Math.floor(Math.random() * b4).toString(base);
      res = x6 + res;
    }
    var parsed = parseInt(res, base);
    if (parsed !== Infinity && parsed >= Math.pow(2, bits)) {
      return hat(bits, base);
    } else return res;
  };
  hat.rack = function(bits, base, expandBy) {
    var fn2 = function(data) {
      var iters = 0;
      do {
        if (iters++ > 10) {
          if (expandBy) bits += expandBy;
          else throw new Error("too many ID collisions, use more bits");
        }
        var id = hat(bits, base);
      } while (Object.hasOwnProperty.call(hats, id));
      hats[id] = data;
      return id;
    };
    var hats = fn2.hats = {};
    fn2.get = function(id) {
      return fn2.hats[id];
    };
    fn2.set = function(id, value) {
      fn2.hats[id] = value;
      return fn2;
    };
    fn2.bits = bits || 128;
    fn2.base = base || 16;
    return fn2;
  };
});
function Ids2(seed) {
  if (!(this instanceof Ids2)) {
    return new Ids2(seed);
  }
  seed = seed || [128, 36, 1];
  this._seed = seed.length ? hat_12.rack(seed[0], seed[1], seed[2]) : seed;
}
Ids2.prototype.next = function(element) {
  return this._seed(element || true);
};
Ids2.prototype.nextPrefixed = function(prefix3, element) {
  var id;
  do {
    id = prefix3 + this.next(true);
  } while (this.assigned(id));
  this.claim(id, element);
  return id;
};
Ids2.prototype.claim = function(id, element) {
  this._seed.set(id, element || true);
};
Ids2.prototype.assigned = function(id) {
  return this._seed.get(id) || false;
};
Ids2.prototype.unclaim = function(id) {
  delete this._seed.hats[id];
};
Ids2.prototype.clear = function() {
  var hats = this._seed.hats, id;
  for (id in hats) {
    this.unclaim(id);
  }
};
var RENDERER_IDS = new Ids2();
var TASK_BORDER_RADIUS2 = 10;
var INNER_OUTER_DIST2 = 7;
var DEFAULT_FILL_OPACITY = 0.95;
var HIGH_FILL_OPACITY = 0.35;
function BpmnRenderer2(config, eventBus, styles, pathMap, canvas, textRenderer, priority) {
  BaseRenderer2.call(this, eventBus, priority);
  var defaultFillColor = config.bpmnRenderer && config.bpmnRenderer.defaultFillColor, defaultStrokeColor = config.bpmnRenderer && config.bpmnRenderer.defaultStrokeColor;
  var rc = rough.svg(canvas._svg);
  var rendererId = RENDERER_IDS.next();
  var markers = {};
  function shapeStyle(attrs) {
    return styles.computeStyle(attrs, {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: black2,
      strokeWidth: 2,
      fill: "white"
    });
  }
  function lineStyle(attrs) {
    return styles.computeStyle(attrs, ["no-fill"], {
      strokeLinecap: "round",
      strokeLinejoin: "round",
      stroke: black2,
      strokeWidth: 2
    });
  }
  function addMarker(id, options) {
    var {
      ref = { x: 0, y: 0 },
      scale = 1,
      element
    } = options;
    var marker2 = create("marker", {
      id,
      viewBox: "0 0 20 20",
      refX: ref.x,
      refY: ref.y,
      markerWidth: 20 * scale,
      markerHeight: 20 * scale,
      orient: "auto"
    });
    append(marker2, element);
    var defs = query("defs", canvas._svg);
    if (!defs) {
      defs = create("defs");
      append(canvas._svg, defs);
    }
    append(defs, marker2);
    markers[id] = marker2;
  }
  function colorEscape(str) {
    return str.replace(/[^0-9a-zA-z]+/g, "_");
  }
  function marker(type, fill, stroke) {
    var id = type + "-" + colorEscape(fill) + "-" + colorEscape(stroke) + "-" + rendererId;
    if (!markers[id]) {
      createMarker(id, type, fill, stroke);
    }
    return "url(#" + id + ")";
  }
  function createMarker(id, type, fill, stroke) {
    if (type === "sequenceflow-end") {
      var sequenceflowEnd = create("path", {
        d: "M 1 5 L 11 10 L 1 15 Z",
        ...shapeStyle({
          fill: stroke,
          stroke,
          strokeWidth: 1
        })
      });
      addMarker(id, {
        element: sequenceflowEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5
      });
    }
    if (type === "messageflow-start") {
      var messageflowStart = create("circle", {
        cx: 6,
        cy: 6,
        r: 3.5,
        ...shapeStyle({
          fill,
          stroke,
          strokeWidth: 1,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: messageflowStart,
        ref: { x: 6, y: 6 }
      });
    }
    if (type === "messageflow-end") {
      var messageflowEnd = create("path", {
        d: "m 1 5 l 0 -3 l 7 3 l -7 3 z",
        ...shapeStyle({
          fill,
          stroke,
          strokeWidth: 1,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: messageflowEnd,
        ref: { x: 8.5, y: 5 }
      });
    }
    if (type === "association-start") {
      var associationStart = create("path", {
        d: "M 11 5 L 1 10 L 11 15",
        ...lineStyle({
          stroke,
          strokeWidth: 1.5,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: associationStart,
        ref: { x: 1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "association-end") {
      var associationEnd = create("path", {
        d: "M 1 5 L 11 10 L 1 15",
        ...lineStyle({
          stroke,
          strokeWidth: 1.5,
          // fix for safari / chrome / firefox bug not correctly
          // resetting stroke dash array
          strokeDasharray: [1e4, 1]
        })
      });
      addMarker(id, {
        element: associationEnd,
        ref: { x: 11, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-flow-marker") {
      var conditionalFlowMarker = create("path", {
        d: "M 0 10 L 8 6 L 16 10 L 8 14 Z",
        ...shapeStyle({
          fill,
          stroke
        })
      });
      addMarker(id, {
        element: conditionalFlowMarker,
        ref: { x: -1, y: 10 },
        scale: 0.5
      });
    }
    if (type === "conditional-default-flow-marker") {
      var defaultFlowMarker = create("path", {
        d: "M 6 4 L 10 16",
        ...shapeStyle({
          stroke
        })
      });
      addMarker(id, {
        element: defaultFlowMarker,
        ref: { x: 0, y: 10 },
        scale: 0.5
      });
    }
  }
  function drawCircle(parentGfx, width, height, offset, attrs) {
    if (isObject(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = shapeStyle({
      stroke: "black",
      strokeWidth: 2,
      fill: "white",
      fillStyle: "solid",
      roughness: 0.5,
      ...attrs
    });
    if (attrs.fill === "none") {
      delete attrs.fillOpacity;
    }
    var cx = width / 2, cy = height / 2;
    var circle = rc.circle(cx, cy, Math.round((width + height) / 2 - offset), attrs);
    append(parentGfx, circle);
    return circle;
  }
  function drawRect(parentGfx, width, height, r7, offset, attrs) {
    if (isObject(offset)) {
      attrs = offset;
      offset = 0;
    }
    offset = offset || 0;
    attrs = shapeStyle({
      stroke: "black",
      strokeWidth: 2,
      fill: "white",
      fillStyle: "solid",
      ...attrs
    });
    var rect = rc.rectangle(offset, offset, width - offset * 2, height - offset * 2, attrs);
    append(parentGfx, rect);
    return rect;
  }
  function drawDiamond(parentGfx, width, height, attrs) {
    var x_2 = width / 2;
    var y_2 = height / 2;
    var points = [{ x: x_2, y: 0 }, { x: width, y: y_2 }, { x: x_2, y: height }, { x: 0, y: y_2 }];
    var pointsArray = points.map(function(point) {
      return [point.x, point.y];
    });
    attrs = shapeStyle({
      stroke: "black",
      strokeWidth: 2,
      fill: "white",
      ...attrs
    });
    var polygon2 = rc.polygon(pointsArray, attrs);
    append(parentGfx, polygon2);
    return polygon2;
  }
  function drawLine(parentGfx, waypoints, attrs, radius) {
    attrs = lineStyle({
      ...attrs,
      roughness: 0.5
    });
    var line2 = rc.linearPath(waypoints.map(function(waypoint) {
      return [waypoint.x, waypoint.y];
    }), attrs);
    append(parentGfx, line2);
    attr(line2, attrs);
    return line2;
  }
  function drawConnectionSegments(parentGfx, waypoints, attrs) {
    return drawLine(parentGfx, waypoints, attrs);
  }
  function drawPath2(parentGfx, d5, attrs, hints) {
    attrs = lineStyle({
      strokeWidth: 2,
      stroke: "black",
      fillStyle: "solid",
      ...attrs
    });
    var path = rc.path(d5, attrs);
    attr(path, attrs);
    append(parentGfx, path);
    return path;
  }
  function drawMarker(type, parentGfx, path, attrs) {
    if (!attrs) {
      attrs = {};
    }
    return drawPath2(parentGfx, path, assign({ "data-marker": type }, assign(attrs, {
      roughness: 0.5
    })));
  }
  function as(type) {
    return function(parentGfx, element) {
      return handlers[type](parentGfx, element);
    };
  }
  function renderer(type) {
    return handlers[type];
  }
  function renderEventContent(element, parentGfx) {
    var event2 = getSemantic(element);
    var isThrowing = isThrowEvent2(event2);
    if (isTypedEvent2(event2, "bpmn:MessageEventDefinition")) {
      return renderer("bpmn:MessageEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:TimerEventDefinition")) {
      return renderer("bpmn:TimerEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:ConditionalEventDefinition")) {
      return renderer("bpmn:ConditionalEventDefinition")(parentGfx, element);
    }
    if (isTypedEvent2(event2, "bpmn:SignalEventDefinition")) {
      return renderer("bpmn:SignalEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:CancelEventDefinition") && isTypedEvent2(event2, "bpmn:TerminateEventDefinition", { parallelMultiple: false })) {
      return renderer("bpmn:MultipleEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:CancelEventDefinition") && isTypedEvent2(event2, "bpmn:TerminateEventDefinition", { parallelMultiple: true })) {
      return renderer("bpmn:ParallelMultipleEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:EscalationEventDefinition")) {
      return renderer("bpmn:EscalationEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:LinkEventDefinition")) {
      return renderer("bpmn:LinkEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:ErrorEventDefinition")) {
      return renderer("bpmn:ErrorEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:CancelEventDefinition")) {
      return renderer("bpmn:CancelEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:CompensateEventDefinition")) {
      return renderer("bpmn:CompensateEventDefinition")(parentGfx, element, isThrowing);
    }
    if (isTypedEvent2(event2, "bpmn:TerminateEventDefinition")) {
      return renderer("bpmn:TerminateEventDefinition")(parentGfx, element, isThrowing);
    }
    return null;
  }
  function renderLabel(parentGfx, label, options) {
    options = assign({
      size: {
        width: 100
      }
    }, options);
    var text = textRenderer.createText(label || "", options);
    classes(text).add("djs-label");
    append(parentGfx, text);
    return text;
  }
  function renderEmbeddedLabel(parentGfx, element, align) {
    var semantic = getSemantic(element);
    return renderLabel(parentGfx, semantic.name, {
      box: element,
      align,
      padding: 5,
      style: {
        fill: getStrokeColor2(element, defaultStrokeColor)
      }
    });
  }
  function renderExternalLabel(parentGfx, element) {
    var box = {
      width: 90,
      height: 30,
      x: element.width / 2 + element.x,
      y: element.height / 2 + element.y
    };
    var target = element.labelTarget;
    var align = target.y > element.y ? "center-bottom" : "center-top";
    return renderLabel(parentGfx, getLabel2(element), {
      box,
      align,
      fitBox: true,
      style: assign(
        {},
        textRenderer.getExternalStyle(),
        {
          fill: getStrokeColor2(element, defaultStrokeColor)
        }
      )
    });
  }
  function renderLaneLabel(parentGfx, text, element) {
    var textBox = renderLabel(parentGfx, text, {
      box: {
        height: 30,
        width: element.height
      },
      align: "center-middle",
      style: {
        fill: getStrokeColor2(element, defaultStrokeColor)
      }
    });
    var top = -1 * element.height;
    transform3(textBox, 0, -top, 270);
  }
  var handlers = this.handlers = {
    "bpmn:Event": function(parentGfx, element, attrs) {
      if (!("fillOpacity" in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }
      return drawCircle(parentGfx, element.width, element.height, attrs);
    },
    "bpmn:StartEvent": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.5
      };
      var semantic = getSemantic(element);
      var circle = renderer("bpmn:Event")(parentGfx, element, attrs);
      if (!semantic.isInterrupting) {
        attr(circle, {
          strokeDasharray: "6, 6",
          strokeLinecap: "round"
        });
      }
      renderEventContent(element, parentGfx);
      return circle;
    },
    "bpmn:MessageEventDefinition": function(parentGfx, element, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MESSAGE", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.235,
          my: 0.315
        }
      });
      var fill = isThrowing ? getStrokeColor2(element, defaultStrokeColor) : getFillColor2(element, defaultFillColor);
      var stroke = isThrowing ? getFillColor2(element, defaultFillColor) : getStrokeColor2(element, defaultStrokeColor);
      var messagePath = drawPath2(parentGfx, pathData, {
        strokeWidth: isThrowing ? 2 : 1,
        fill,
        stroke
      });
      return messagePath;
    },
    "bpmn:TimerEventDefinition": function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 0.2 * element.height, {
        strokeWidth: 2,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      var pathData = pathMap.getScaledPath("EVENT_TIMER_WH", {
        xScaleFactor: 0.75,
        yScaleFactor: 0.75,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.5,
          my: 0.5
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 2,
        strokeLinecap: "square",
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.2
      });
      for (var i7 = 0; i7 < 12; i7++) {
        var linePathData = pathMap.getScaledPath("EVENT_TIMER_LINE", {
          xScaleFactor: 0.75,
          yScaleFactor: 0.75,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.5,
            my: 0.5
          }
        });
        var width = element.width / 2;
        var height = element.height / 2;
        drawPath2(parentGfx, linePathData, {
          strokeWidth: 1,
          strokeLinecap: "square",
          transform: "rotate(" + i7 * 30 + "," + height + "," + width + ")",
          stroke: getStrokeColor2(element, defaultStrokeColor),
          roughness: 0.75
        });
      }
      return circle;
    },
    "bpmn:EscalationEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ESCALATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
    },
    "bpmn:ConditionalEventDefinition": function(parentGfx, event2) {
      var pathData = pathMap.getScaledPath("EVENT_CONDITIONAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.222
        }
      });
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: getStrokeColor2(event2, defaultStrokeColor),
        roughness: 0.5
      });
    },
    "bpmn:LinkEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_LINK", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.57,
          my: 0.263
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
    },
    "bpmn:ErrorEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_ERROR", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.2,
          my: 0.722
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
    },
    "bpmn:CancelEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_CANCEL_45", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.638,
          my: -0.055
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      var path = drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
      rotate2(path, 45);
      return path;
    },
    "bpmn:CompensateEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.22,
          my: 0.5
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
    },
    "bpmn:SignalEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_SIGNAL", {
        xScaleFactor: 0.9,
        yScaleFactor: 0.9,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.5,
          my: 0.2
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill,
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
    },
    "bpmn:MultipleEventDefinition": function(parentGfx, event2, isThrowing) {
      var pathData = pathMap.getScaledPath("EVENT_MULTIPLE", {
        xScaleFactor: 1.1,
        yScaleFactor: 1.1,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.222,
          my: 0.36
        }
      });
      var fill = isThrowing ? getStrokeColor2(event2, defaultStrokeColor) : "none";
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill
      });
    },
    "bpmn:ParallelMultipleEventDefinition": function(parentGfx, event2) {
      var pathData = pathMap.getScaledPath("EVENT_PARALLEL_MULTIPLE", {
        xScaleFactor: 1.2,
        yScaleFactor: 1.2,
        containerWidth: event2.width,
        containerHeight: event2.height,
        position: {
          mx: 0.458,
          my: 0.194
        }
      });
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor2(event2, defaultStrokeColor),
        stroke: getStrokeColor2(event2, defaultStrokeColor)
      });
    },
    "bpmn:EndEvent": function(parentGfx, element) {
      var circle = renderer("bpmn:Event")(parentGfx, element, {
        strokeWidth: 4,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      renderEventContent(element, parentGfx);
      return circle;
    },
    "bpmn:TerminateEventDefinition": function(parentGfx, element) {
      var circle = drawCircle(parentGfx, element.width, element.height, 14, {
        strokeWidth: 4,
        fill: getStrokeColor2(element, defaultStrokeColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        fillStyle: "solid"
      });
      return circle;
    },
    "bpmn:IntermediateEvent": function(parentGfx, element) {
      var outer = renderer("bpmn:Event")(parentGfx, element, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST2, {
        strokeWidth: 1,
        fill: getFillColor2(element, "none"),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      renderEventContent(element, parentGfx);
      return outer;
    },
    "bpmn:IntermediateCatchEvent": as("bpmn:IntermediateEvent"),
    "bpmn:IntermediateThrowEvent": as("bpmn:IntermediateEvent"),
    "bpmn:Activity": function(parentGfx, element, attrs) {
      attrs = attrs || {};
      if (!("fillOpacity" in attrs)) {
        attrs.fillOpacity = DEFAULT_FILL_OPACITY;
      }
      var pathData = getRoundRectPath2(assign({}, element, { x: 0, y: 0 }), TASK_BORDER_RADIUS2);
      return drawPath2(parentGfx, pathData, assign(attrs, {
        roughness: 0.4
      }));
    },
    "bpmn:Task": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      };
      var rect = renderer("bpmn:Activity")(parentGfx, element, attrs);
      renderEmbeddedLabel(parentGfx, element, "center-middle");
      attachTaskMarkers(parentGfx, element);
      return rect;
    },
    "bpmn:ServiceTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathDataBG = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 12,
          y: 18
        }
      });
      drawPath2(parentGfx, pathDataBG, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        simplification: 0.5,
        roughness: 0.1
      });
      var fillPathData = pathMap.getScaledPath("TASK_TYPE_SERVICE_FILL", {
        abspos: {
          x: 17.2,
          y: 18
        }
      });
      drawPath2(parentGfx, fillPathData, {
        strokeWidth: 0,
        fill: getFillColor2(element, defaultFillColor),
        simplification: 0.5,
        roughness: 0.1
      });
      var pathData = pathMap.getScaledPath("TASK_TYPE_SERVICE", {
        abspos: {
          x: 17,
          y: 22
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        simplification: 0.5,
        roughness: 0.1
      });
      return task;
    },
    "bpmn:UserTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var x6 = 15;
      var y5 = 12;
      var pathData = pathMap.getScaledPath("TASK_TYPE_USER_1", {
        abspos: {
          x: x6,
          y: y5
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.2
      });
      var pathData2 = pathMap.getScaledPath("TASK_TYPE_USER_2", {
        abspos: {
          x: x6,
          y: y5
        }
      });
      drawPath2(parentGfx, pathData2, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.2
      });
      var pathData3 = pathMap.getScaledPath("TASK_TYPE_USER_3", {
        abspos: {
          x: x6,
          y: y5
        }
      });
      drawPath2(parentGfx, pathData3, {
        strokeWidth: 1,
        fill: getStrokeColor2(element, defaultStrokeColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.2
      });
      return task;
    },
    "bpmn:ManualTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_MANUAL", {
        abspos: {
          x: 17,
          y: 15
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        simplification: 0.9
      });
      return task;
    },
    "bpmn:SendTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: 21,
        containerHeight: 14,
        position: {
          mx: 0.285,
          my: 0.357
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor2(element, defaultStrokeColor),
        stroke: getFillColor2(element, defaultFillColor)
      });
      return task;
    },
    "bpmn:ReceiveTask": function(parentGfx, element) {
      var semantic = getSemantic(element);
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData;
      if (semantic.instantiate) {
        drawCircle(parentGfx, 28, 28, 20 * 0.22, { strokeWidth: 1 });
        pathData = pathMap.getScaledPath("TASK_TYPE_INSTANTIATING_SEND", {
          abspos: {
            x: 7.77,
            y: 9.52
          }
        });
      } else {
        pathData = pathMap.getScaledPath("TASK_TYPE_SEND", {
          xScaleFactor: 0.9,
          yScaleFactor: 0.9,
          containerWidth: 21,
          containerHeight: 14,
          position: {
            mx: 0.3,
            my: 0.4
          }
        });
      }
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:ScriptTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var pathData = pathMap.getScaledPath("TASK_TYPE_SCRIPT", {
        abspos: {
          x: 15,
          y: 20
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.3
      });
      return task;
    },
    "bpmn:BusinessRuleTask": function(parentGfx, element) {
      var task = renderer("bpmn:Task")(parentGfx, element);
      var headerPathData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_HEADER", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      drawPath2(parentGfx, headerPathData, {
        roughness: 0.5,
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      var headerData = pathMap.getScaledPath("TASK_TYPE_BUSINESS_RULE_MAIN", {
        abspos: {
          x: 8,
          y: 8
        }
      });
      drawPath2(parentGfx, headerData, {
        roughness: 0.5,
        strokeWidth: 1,
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      return task;
    },
    "bpmn:SubProcess": function(parentGfx, element, attrs) {
      attrs = assign({
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      }, attrs);
      var rect = renderer("bpmn:Activity")(parentGfx, element, attrs);
      var expanded = isExpanded2(element);
      if (isEventSubProcess2(element)) {
        attr(rect, {
          strokeDasharray: "1,2"
        });
      }
      renderEmbeddedLabel(parentGfx, element, expanded ? "center-top" : "center-middle");
      if (expanded) {
        attachTaskMarkers(parentGfx, element);
      } else {
        attachTaskMarkers(parentGfx, element, ["SubProcessMarker"]);
      }
      return rect;
    },
    "bpmn:AdHocSubProcess": function(parentGfx, element) {
      return renderer("bpmn:SubProcess")(parentGfx, element);
    },
    "bpmn:Transaction": function(parentGfx, element) {
      var outer = renderer("bpmn:SubProcess")(parentGfx, element);
      var innerAttrs = styles.style(["no-fill", "no-events"], {
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      var pathData = getRoundRectPath2({
        x: INNER_OUTER_DIST2,
        y: INNER_OUTER_DIST2,
        width: element.width - 2 * INNER_OUTER_DIST2,
        height: element.height - 2 * INNER_OUTER_DIST2
      }, TASK_BORDER_RADIUS2);
      drawPath2(parentGfx, pathData, assign(innerAttrs, {
        roughness: 0.4
      }));
      return outer;
    },
    "bpmn:CallActivity": function(parentGfx, element) {
      return renderer("bpmn:SubProcess")(parentGfx, element, {
        strokeWidth: 5
      });
    },
    "bpmn:Participant": function(parentGfx, element) {
      var attrs = {
        fillOpacity: DEFAULT_FILL_OPACITY,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      };
      var lane = renderer("bpmn:Lane")(parentGfx, element, attrs);
      var expandedPool = isExpanded2(element);
      if (expandedPool) {
        drawLine(parentGfx, [
          { x: 30, y: 0 },
          { x: 30, y: element.height }
        ], {
          stroke: getStrokeColor2(element, defaultStrokeColor)
        });
        var text = getSemantic(element).name;
        renderLaneLabel(parentGfx, text, element);
      } else {
        var text2 = getSemantic(element).name;
        renderLabel(parentGfx, text2, {
          box: element,
          align: "center-middle",
          style: {
            fill: getStrokeColor2(element, defaultStrokeColor)
          }
        });
      }
      var participantMultiplicity = !!getSemantic(element).participantMultiplicity;
      if (participantMultiplicity) {
        renderer("ParticipantMultiplicityMarker")(parentGfx, element);
      }
      return lane;
    },
    "bpmn:Lane": function(parentGfx, element, attrs) {
      var rect = drawRect(parentGfx, element.width, element.height, 0, assign({
        fill: getFillColor2(element, defaultFillColor),
        fillOpacity: HIGH_FILL_OPACITY,
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.3
      }, attrs));
      var semantic = getSemantic(element);
      if (semantic.$type === "bpmn:Lane") {
        var text = semantic.name;
        renderLaneLabel(parentGfx, text, element);
      }
      return rect;
    },
    "bpmn:InclusiveGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.5, {
        strokeWidth: 2.5,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:ExclusiveGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_EXCLUSIVE", {
        xScaleFactor: 0.4,
        yScaleFactor: 0.4,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.32,
          my: 0.3
        }
      });
      if (getDi2(element).isMarkerVisible) {
        drawPath2(parentGfx, pathData, {
          strokeWidth: 1,
          fill: getStrokeColor2(element, defaultStrokeColor),
          stroke: getStrokeColor2(element, defaultStrokeColor)
        });
      }
      return diamond;
    },
    "bpmn:ComplexGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_COMPLEX", {
        xScaleFactor: 0.5,
        yScaleFactor: 0.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.26
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor2(element, defaultStrokeColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:ParallelGateway": function(parentGfx, element) {
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
        xScaleFactor: 0.6,
        yScaleFactor: 0.6,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.46,
          my: 0.2
        }
      });
      drawPath2(parentGfx, pathData, {
        strokeWidth: 1,
        fill: getStrokeColor2(element, defaultStrokeColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      return diamond;
    },
    "bpmn:EventBasedGateway": function(parentGfx, element) {
      var semantic = getSemantic(element);
      var diamond = renderer("bpmn:Gateway")(parentGfx, element);
      drawCircle(parentGfx, element.width, element.height, element.height * 0.4, {
        strokeWidth: 1,
        fill: "none",
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      var type = semantic.eventGatewayType;
      var instantiate = !!semantic.instantiate;
      function drawEvent() {
        var pathData2 = pathMap.getScaledPath("GATEWAY_EVENT_BASED", {
          xScaleFactor: 0.18,
          yScaleFactor: 0.18,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.36,
            my: 0.44
          }
        });
        drawPath2(parentGfx, pathData2, {
          strokeWidth: 2,
          fill: getFillColor2(element, defaultFillColor),
          stroke: getStrokeColor2(element, defaultStrokeColor)
        });
      }
      if (type === "Parallel") {
        var pathData = pathMap.getScaledPath("GATEWAY_PARALLEL", {
          xScaleFactor: 0.4,
          yScaleFactor: 0.4,
          containerWidth: element.width,
          containerHeight: element.height,
          position: {
            mx: 0.474,
            my: 0.296
          }
        });
        drawPath2(parentGfx, pathData, {
          strokeWidth: 1,
          fill: getFillColor2(element, defaultFillColor),
          stroke: getStrokeColor2(element, defaultStrokeColor)
        });
      } else if (type === "Exclusive") {
        if (!instantiate) {
          drawCircle(parentGfx, element.width, element.height, element.height * 0.55, {
            strokeWidth: 1,
            fill: getFillColor2(element, defaultFillColor),
            stroke: getStrokeColor2(element, defaultStrokeColor)
          });
        }
        drawEvent();
      }
      return diamond;
    },
    "bpmn:Gateway": function(parentGfx, element) {
      var attrs = {
        fill: getFillColor2(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor2(element, defaultStrokeColor)
      };
      return drawDiamond(parentGfx, element.width, element.height, attrs);
    },
    "bpmn:SequenceFlow": function(parentGfx, element) {
      var fill = getFillColor2(element, defaultFillColor), stroke = getStrokeColor2(element, defaultStrokeColor);
      var path = drawConnectionSegments(parentGfx, element.waypoints, {
        markerEnd: marker("sequenceflow-end", fill, stroke),
        stroke: getStrokeColor2(element, defaultStrokeColor),
        strokeLinejoin: "round",
        roughness: 0.5,
        bowing: 0
      });
      var sequenceFlow = getSemantic(element);
      var source;
      if (element.source) {
        source = element.source.businessObject;
        if (sequenceFlow.conditionExpression && source.$instanceOf("bpmn:Activity")) {
          attr(path, {
            markerStart: marker("conditional-flow-marker", fill, stroke)
          });
        }
        if (source.default && (source.$instanceOf("bpmn:Gateway") || source.$instanceOf("bpmn:Activity")) && source.default === sequenceFlow) {
          attr(path, {
            markerStart: marker("conditional-default-flow-marker", fill, stroke)
          });
        }
      }
      return path;
    },
    "bpmn:Association": function(parentGfx, element, attrs) {
      var semantic = getSemantic(element);
      var fill = getFillColor2(element, defaultFillColor), stroke = getStrokeColor2(element, defaultStrokeColor);
      attrs = assign({
        strokeDasharray: "1, 5",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.5,
        bowing: 0
      }, attrs || {});
      if (semantic.associationDirection === "One" || semantic.associationDirection === "Both") {
        attrs.markerEnd = marker("association-end", fill, stroke);
      }
      if (semantic.associationDirection === "Both") {
        attrs.markerStart = marker("association-start", fill, stroke);
      }
      return drawLine(parentGfx, element.waypoints, attrs);
    },
    "bpmn:DataInputAssociation": function(parentGfx, element) {
      var fill = getFillColor2(element, defaultFillColor), stroke = getStrokeColor2(element, defaultStrokeColor);
      return renderer("bpmn:Association")(parentGfx, element, {
        markerEnd: marker("association-end", fill, stroke)
      });
    },
    "bpmn:DataOutputAssociation": function(parentGfx, element) {
      var fill = getFillColor2(element, defaultFillColor), stroke = getStrokeColor2(element, defaultStrokeColor);
      return renderer("bpmn:Association")(parentGfx, element, {
        markerEnd: marker("association-end", fill, stroke)
      });
    },
    "bpmn:MessageFlow": function(parentGfx, element) {
      var semantic = getSemantic(element), di = getDi2(element);
      var fill = getFillColor2(element, defaultFillColor), stroke = getStrokeColor2(element, defaultStrokeColor);
      var path = drawConnectionSegments(parentGfx, element.waypoints, {
        markerEnd: marker("messageflow-end", fill, stroke),
        markerStart: marker("messageflow-start", fill, stroke),
        strokeDasharray: "10, 12",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        strokeWidth: "1.5px",
        stroke: getStrokeColor2(element, defaultStrokeColor),
        roughness: 0.5,
        bowing: 0
      });
      if (semantic.messageRef) {
        var midPoint = path.getPointAtLength(path.getTotalLength() / 2);
        var markerPathData = pathMap.getScaledPath("MESSAGE_FLOW_MARKER", {
          abspos: {
            x: midPoint.x,
            y: midPoint.y
          }
        });
        var messageAttrs = { strokeWidth: 1 };
        if (di.messageVisibleKind === "initiating") {
          messageAttrs.fill = "white";
          messageAttrs.stroke = "black";
        } else {
          messageAttrs.fill = "#888";
          messageAttrs.stroke = "white";
        }
        drawPath2(parentGfx, markerPathData, messageAttrs);
      }
      return path;
    },
    "bpmn:DataObject": function(parentGfx, element) {
      var pathData = pathMap.getScaledPath("DATA_OBJECT_PATH", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0.474,
          my: 0.296
        }
      });
      var elementObject = drawPath2(parentGfx, pathData, {
        fill: getFillColor2(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      var semantic = getSemantic(element);
      if (isCollection2(semantic)) {
        renderDataItemCollection(parentGfx, element);
      }
      return elementObject;
    },
    "bpmn:DataObjectReference": as("bpmn:DataObject"),
    "bpmn:DataInput": function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var elementObject = renderer("bpmn:DataObject")(parentGfx, element);
      drawPath2(parentGfx, arrowPathData, { strokeWidth: 1 });
      return elementObject;
    },
    "bpmn:DataOutput": function(parentGfx, element) {
      var arrowPathData = pathMap.getRawPath("DATA_ARROW");
      var elementObject = renderer("bpmn:DataObject")(parentGfx, element);
      drawPath2(parentGfx, arrowPathData, {
        strokeWidth: 1,
        fill: "black"
      });
      return elementObject;
    },
    "bpmn:DataStoreReference": function(parentGfx, element) {
      var DATA_STORE_PATH = pathMap.getScaledPath("DATA_STORE", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0.133
        }
      });
      var elementStore = drawPath2(parentGfx, DATA_STORE_PATH, {
        strokeWidth: 2,
        fill: getFillColor2(element, defaultFillColor),
        fillOpacity: DEFAULT_FILL_OPACITY,
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      return elementStore;
    },
    "bpmn:BoundaryEvent": function(parentGfx, element) {
      var semantic = getSemantic(element), cancel2 = semantic.cancelActivity;
      var attrs = {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      };
      var outerAttrs = assign({}, attrs, {
        fillOpacity: 1,
        roughness: 0.5
      });
      var innerAttrs = assign({}, attrs, {
        fill: "none",
        roughness: 0.5
      });
      var outer = renderer("bpmn:Event")(parentGfx, element, outerAttrs);
      if (!cancel2) {
        attr(outer, {
          strokeDasharray: "6, 6",
          strokeLinecap: "round"
        });
      }
      var inner = drawCircle(parentGfx, element.width, element.height, INNER_OUTER_DIST2, innerAttrs);
      if (!cancel2) {
        attr(inner, {
          strokeDasharray: "6, 6",
          strokeLinecap: "round"
        });
      }
      renderEventContent(element, parentGfx);
      return outer;
    },
    "bpmn:Group": function(parentGfx, element) {
      var pathData = getRoundRectPath2(assign({}, element, { x: 0, y: 0 }), TASK_BORDER_RADIUS2);
      return drawPath2(parentGfx, pathData, {
        strokeWidth: 1.5,
        strokeDasharray: "8,6,1,6",
        strokeLinecap: "round",
        strokeLinejoin: "round",
        stroke: getStrokeColor2(element, defaultStrokeColor),
        fill: "none",
        pointerEvents: "none",
        roughness: 0.5,
        bowing: 0
      });
    },
    "label": function(parentGfx, element) {
      return renderExternalLabel(parentGfx, element);
    },
    "bpmn:TextAnnotation": function(parentGfx, element) {
      var style = {
        "fill": "none",
        "stroke": "none"
      };
      var textElement = drawRect(parentGfx, element.width, element.height, 0, 0, style);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      drawPath2(parentGfx, textPathData, {
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      var text = getSemantic(element).text || "";
      renderLabel(parentGfx, text, {
        box: element,
        align: "left-top",
        padding: 5,
        style: {
          fill: getStrokeColor2(element, defaultStrokeColor)
        }
      });
      return textElement;
    },
    "ParticipantMultiplicityMarker": function(parentGfx, element) {
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: element.width / 2 / element.width,
          my: (element.height - 15) / element.height
        }
      });
      drawMarker("participant-multiplicity", parentGfx, markerPath);
    },
    "SubProcessMarker": function(parentGfx, element) {
      var markerRect = drawRect(parentGfx, 14, 14, 0, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
      translate3(markerRect, element.width / 2 - 7.5, element.height - 20);
      var markerPath = pathMap.getScaledPath("MARKER_SUB_PROCESS", {
        xScaleFactor: 1.5,
        yScaleFactor: 1.5,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 - 7.5) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("sub-process", parentGfx, markerPath, {
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
    },
    "ParallelMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_PARALLEL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.parallel) / element.width,
          my: (element.height - 20) / element.height
        }
      });
      drawMarker("parallel", parentGfx, markerPath, {
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
    },
    "SequentialMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_SEQUENTIAL", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.seq) / element.width,
          my: (element.height - 19) / element.height
        }
      });
      drawMarker("sequential", parentGfx, markerPath, {
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
    },
    "CompensationMarker": function(parentGfx, element, position) {
      var markerMath = pathMap.getScaledPath("MARKER_COMPENSATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.compensation) / element.width,
          my: (element.height - 13) / element.height
        }
      });
      drawMarker("compensation", parentGfx, markerMath, {
        strokeWidth: 1,
        fill: getFillColor2(element, defaultFillColor),
        stroke: getStrokeColor2(element, defaultStrokeColor)
      });
    },
    "LoopMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_LOOP", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.loop) / element.width,
          my: (element.height - 7) / element.height
        }
      });
      drawMarker("loop", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: "none",
        stroke: getStrokeColor2(element, defaultStrokeColor),
        strokeLinecap: "round",
        strokeMiterlimit: 0.5
      });
    },
    "AdhocMarker": function(parentGfx, element, position) {
      var markerPath = pathMap.getScaledPath("MARKER_ADHOC", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: (element.width / 2 + position.adhoc) / element.width,
          my: (element.height - 15) / element.height
        }
      });
      drawMarker("adhoc", parentGfx, markerPath, {
        strokeWidth: 1,
        fill: "black"
      });
    }
  };
  function attachTaskMarkers(parentGfx, element, taskMarkers) {
    var obj = getSemantic(element);
    var subprocess = taskMarkers && taskMarkers.indexOf("SubProcessMarker") !== -1;
    var position;
    if (subprocess) {
      position = {
        seq: -21,
        parallel: -22,
        compensation: -42,
        loop: -18,
        adhoc: 10
      };
    } else {
      position = {
        seq: -3,
        parallel: -6,
        compensation: -27,
        loop: 0,
        adhoc: 10
      };
    }
    forEach(taskMarkers, function(marker2) {
      renderer(marker2)(parentGfx, element, position);
    });
    if (obj.isForCompensation) {
      renderer("CompensationMarker")(parentGfx, element, position);
    }
    if (obj.$type === "bpmn:AdHocSubProcess") {
      renderer("AdhocMarker")(parentGfx, element, position);
    }
    var loopCharacteristics = obj.loopCharacteristics, isSequential = loopCharacteristics && loopCharacteristics.isSequential;
    if (loopCharacteristics) {
      if (isSequential === void 0) {
        renderer("LoopMarker")(parentGfx, element, position);
      }
      if (isSequential === false) {
        renderer("ParallelMarker")(parentGfx, element, position);
      }
      if (isSequential === true) {
        renderer("SequentialMarker")(parentGfx, element, position);
      }
    }
  }
  function renderDataItemCollection(parentGfx, element) {
    var yPosition = (element.height - 16) / element.height;
    var pathData = pathMap.getScaledPath("DATA_OBJECT_COLLECTION_PATH", {
      xScaleFactor: 1,
      yScaleFactor: 1,
      containerWidth: element.width,
      containerHeight: element.height,
      position: {
        mx: 0.451,
        my: yPosition
      }
    });
    drawPath2(parentGfx, pathData, {
      strokeWidth: 2
    });
  }
  this._drawPath = drawPath2;
}
e2(BpmnRenderer2, BaseRenderer2);
BpmnRenderer2.$inject = [
  "config",
  "eventBus",
  "styles",
  "pathMap",
  "canvas",
  "textRenderer"
];
BpmnRenderer2.prototype.canRender = function(element) {
  return is3(element, "bpmn:BaseElement");
};
BpmnRenderer2.prototype.drawShape = function(parentGfx, element) {
  var type = element.type;
  var h5 = this.handlers[type];
  return h5(parentGfx, element);
};
BpmnRenderer2.prototype.drawConnection = function(parentGfx, element) {
  var type = element.type;
  var h5 = this.handlers[type];
  return h5(parentGfx, element);
};
BpmnRenderer2.prototype.getShapePath = function(element) {
  if (is3(element, "bpmn:Event")) {
    return getCirclePath2(element);
  }
  if (is3(element, "bpmn:Activity")) {
    return getRoundRectPath2(element, TASK_BORDER_RADIUS2);
  }
  if (is3(element, "bpmn:Gateway")) {
    return getDiamondPath2(element);
  }
  return getRectPath2(element);
};
var index = {
  __init__: [
    "bpmnRenderer"
  ],
  bpmnRenderer: ["type", BpmnRenderer2]
};

// node_modules/bpmn-js/lib/BaseModeler.js
function BaseModeler(options) {
  BaseViewer.call(this, options);
  this.on("import.parse.complete", function(event2) {
    if (!event2.error) {
      this._collectIds(event2.definitions, event2.elementsById);
    }
  }, this);
  this.on("diagram.destroy", function() {
    this.get("moddle").ids.clear();
  }, this);
}
e(BaseModeler, BaseViewer);
BaseModeler.prototype._createModdle = function(options) {
  var moddle = BaseViewer.prototype._createModdle.call(this, options);
  moddle.ids = new index_esm_default([32, 36, 1]);
  return moddle;
};
BaseModeler.prototype._collectIds = function(definitions, elementsById) {
  var moddle = definitions.$model, ids3 = moddle.ids, id;
  ids3.clear();
  for (id in elementsById) {
    ids3.claim(id, elementsById[id]);
  }
};

// node_modules/diagram-js/lib/features/align-elements/AlignElements.js
function last(arr) {
  return arr && arr[arr.length - 1];
}
function sortTopOrMiddle(element) {
  return element.y;
}
function sortLeftOrCenter(element) {
  return element.x;
}
var ALIGNMENT_SORTING = {
  left: sortLeftOrCenter,
  center: sortLeftOrCenter,
  right: function(element) {
    return element.x + element.width;
  },
  top: sortTopOrMiddle,
  middle: sortTopOrMiddle,
  bottom: function(element) {
    return element.y + element.height;
  }
};
function AlignElements(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
AlignElements.$inject = ["modeling", "rules"];
AlignElements.prototype._getOrientationDetails = function(type) {
  var vertical = ["top", "bottom", "middle"], axis = "x", dimension = "width";
  if (vertical.indexOf(type) !== -1) {
    axis = "y";
    dimension = "height";
  }
  return {
    axis,
    dimension
  };
};
AlignElements.prototype._isType = function(type, types3) {
  return types3.indexOf(type) !== -1;
};
AlignElements.prototype._alignmentPosition = function(type, sortedElements) {
  var orientation = this._getOrientationDetails(type), axis = orientation.axis, dimension = orientation.dimension, alignment = {}, centers = {}, hasSharedCenters = false, centeredElements, firstElement, lastElement;
  function getMiddleOrTop(first2, last4) {
    return Math.round((first2[axis] + last4[axis] + last4[dimension]) / 2);
  }
  if (this._isType(type, ["left", "top"])) {
    alignment[type] = sortedElements[0][axis];
  } else if (this._isType(type, ["right", "bottom"])) {
    lastElement = last(sortedElements);
    alignment[type] = lastElement[axis] + lastElement[dimension];
  } else if (this._isType(type, ["center", "middle"])) {
    forEach(sortedElements, function(element) {
      var center2 = element[axis] + Math.round(element[dimension] / 2);
      if (centers[center2]) {
        centers[center2].elements.push(element);
      } else {
        centers[center2] = {
          elements: [element],
          center: center2
        };
      }
    });
    centeredElements = sortBy(centers, function(center2) {
      if (center2.elements.length > 1) {
        hasSharedCenters = true;
      }
      return center2.elements.length;
    });
    if (hasSharedCenters) {
      alignment[type] = last(centeredElements).center;
      return alignment;
    }
    firstElement = sortedElements[0];
    sortedElements = sortBy(sortedElements, function(element) {
      return element[axis] + element[dimension];
    });
    lastElement = last(sortedElements);
    alignment[type] = getMiddleOrTop(firstElement, lastElement);
  }
  return alignment;
};
AlignElements.prototype.trigger = function(elements, type) {
  var modeling = this._modeling, allowed;
  var filteredElements = filter(elements, function(element) {
    return !(element.waypoints || element.host || element.labelTarget);
  });
  allowed = this._rules.allowed("elements.align", { elements: filteredElements });
  if (isArray(allowed)) {
    filteredElements = allowed;
  }
  if (filteredElements.length < 2 || !allowed) {
    return;
  }
  var sortFn = ALIGNMENT_SORTING[type];
  var sortedElements = sortBy(filteredElements, sortFn);
  var alignment = this._alignmentPosition(type, sortedElements);
  modeling.alignElements(sortedElements, alignment);
};

// node_modules/diagram-js/lib/features/align-elements/index.js
var align_elements_default = {
  __init__: ["alignElements"],
  alignElements: ["type", AlignElements]
};

// node_modules/diagram-js/lib/features/scheduler/Scheduler.js
var Ids3 = new IdGenerator();
function Scheduler(eventBus) {
  this._scheduled = {};
  eventBus.on("diagram.destroy", () => {
    Object.keys(this._scheduled).forEach((id) => {
      this.cancel(id);
    });
  });
}
Scheduler.$inject = ["eventBus"];
Scheduler.prototype.schedule = function(taskFn, id = Ids3.next()) {
  this.cancel(id);
  const newScheduled = this._schedule(taskFn, id);
  this._scheduled[id] = newScheduled;
  return newScheduled.promise;
};
Scheduler.prototype._schedule = function(taskFn, id) {
  const deferred = defer();
  const executionId = setTimeout(() => {
    try {
      this._scheduled[id] = null;
      try {
        deferred.resolve(taskFn());
      } catch (error4) {
        deferred.reject(error4);
      }
    } catch (error4) {
      console.error("Scheduler#_schedule execution failed", error4);
    }
  });
  return {
    executionId,
    promise: deferred.promise
  };
};
Scheduler.prototype.cancel = function(id) {
  const scheduled = this._scheduled[id];
  if (scheduled) {
    this._cancel(scheduled);
    this._scheduled[id] = null;
  }
};
Scheduler.prototype._cancel = function(scheduled) {
  clearTimeout(scheduled.executionId);
};
function defer() {
  const deferred = {};
  deferred.promise = new Promise((resolve, reject) => {
    deferred.resolve = resolve;
    deferred.reject = reject;
  });
  return deferred;
}

// node_modules/diagram-js/lib/features/scheduler/index.js
var scheduler_default = {
  scheduler: ["type", Scheduler]
};

// node_modules/diagram-js/lib/features/context-pad/ContextPad.js
var MARKER_HIDDEN = "djs-element-hidden";
var entrySelector = ".entry";
var DEFAULT_PRIORITY4 = 1e3;
var CONTEXT_PAD_MARGIN = 8;
var HOVER_DELAY = 300;
function ContextPad(canvas, elementRegistry, eventBus, scheduler) {
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._eventBus = eventBus;
  this._scheduler = scheduler;
  this._current = null;
  this._init();
}
ContextPad.$inject = [
  "canvas",
  "elementRegistry",
  "eventBus",
  "scheduler"
];
ContextPad.prototype._init = function() {
  var self2 = this;
  this._eventBus.on("selection.changed", function(event2) {
    var selection2 = event2.newSelection;
    var target = selection2.length ? selection2.length === 1 ? selection2[0] : selection2 : null;
    if (target) {
      self2.open(target, true);
    } else {
      self2.close();
    }
  });
  this._eventBus.on("elements.changed", function(event2) {
    var elements = event2.elements, current = self2._current;
    if (!current) {
      return;
    }
    var target = current.target;
    var targets = isArray(target) ? target : [target];
    var targetsChanged = targets.filter(function(element) {
      return elements.includes(element);
    });
    if (targetsChanged.length) {
      self2.close();
      var targetsNew = targets.filter(function(element) {
        return self2._elementRegistry.get(element.id);
      });
      if (targetsNew.length) {
        self2._updateAndOpen(targetsNew.length > 1 ? targetsNew : targetsNew[0]);
      }
    }
  });
  this._eventBus.on("canvas.viewbox.changed", function() {
    self2._updatePosition();
  });
  this._eventBus.on("element.marker.update", function(event2) {
    if (!self2.isOpen()) {
      return;
    }
    var element = event2.element;
    var current = self2._current;
    var targets = isArray(current.target) ? current.target : [current.target];
    if (!targets.includes(element)) {
      return;
    }
    self2._updateVisibility();
  });
  this._container = this._createContainer();
};
ContextPad.prototype._createContainer = function() {
  var container = domify$1('<div class="djs-context-pad-parent"></div>');
  this._canvas.getContainer().appendChild(container);
  return container;
};
ContextPad.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY4;
  }
  this._eventBus.on("contextPad.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
ContextPad.prototype.getEntries = function(target) {
  var providers = this._getProviders();
  var provideFn = isArray(target) ? "getMultiElementContextPadEntries" : "getContextPadEntries";
  var entries = {};
  forEach(providers, function(provider) {
    if (!isFunction(provider[provideFn])) {
      return;
    }
    var entriesOrUpdater = provider[provideFn](target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
ContextPad.prototype.trigger = function(action, event2, autoActivate) {
  var self2 = this;
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr2(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  if (action === "mouseover") {
    this._timeout = setTimeout(function() {
      self2._mouseout = self2.triggerEntry(entry, "hover", originalEvent, autoActivate);
    }, HOVER_DELAY);
    return;
  } else if (action === "mouseout") {
    clearTimeout(this._timeout);
    if (this._mouseout) {
      this._mouseout();
      this._mouseout = null;
    }
    return;
  }
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
ContextPad.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  if (!this.isShown()) {
    return;
  }
  var target = this._current.target, entries = this._current.entries;
  var entry = entries[entryId];
  if (!entry) {
    return;
  }
  var handler = entry.action;
  if (this._eventBus.fire("contextPad.trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, target, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, target, autoActivate);
    }
  }
  event2.preventDefault();
};
ContextPad.prototype.open = function(target, force) {
  if (!force && this.isOpen(target)) {
    return;
  }
  this.close();
  this._updateAndOpen(target);
};
ContextPad.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "contextPad.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
ContextPad.prototype._updateAndOpen = function(target) {
  var entries = this.getEntries(target), html = this._createHtml(target), image;
  forEach(entries, function(entry, id) {
    var grouping = entry.group || "default", control = domify$1(entry.html || '<div class="entry" draggable="true"></div>'), container;
    attr2(control, "data-action", id);
    container = query("[data-group=" + escapeCSS(grouping) + "]", html);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr2(container, "data-group", grouping);
      html.appendChild(container);
    }
    container.appendChild(control);
    if (entry.className) {
      addClasses(control, entry.className);
    }
    if (entry.title) {
      attr2(control, "title", entry.title);
    }
    if (entry.imageUrl) {
      image = domify$1("<img>");
      attr2(image, "src", entry.imageUrl);
      image.style.width = "100%";
      image.style.height = "100%";
      control.appendChild(image);
    }
  });
  classes2(html).add("open");
  this._current = {
    entries,
    html,
    target
  };
  this._updatePosition();
  this._updateVisibility();
  this._eventBus.fire("contextPad.open", { current: this._current });
};
ContextPad.prototype._createHtml = function(target) {
  var self2 = this;
  var html = domify$1('<div class="djs-context-pad"></div>');
  delegate.bind(html, entrySelector, "click", function(event2) {
    self2.trigger("click", event2);
  });
  delegate.bind(html, entrySelector, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  delegate.bind(html, entrySelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(html, entrySelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  event.bind(html, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  this._container.appendChild(html);
  this._eventBus.fire("contextPad.create", {
    target,
    pad: html
  });
  return html;
};
ContextPad.prototype.getPad = function(target) {
  console.warn(new Error("ContextPad#getPad is deprecated and will be removed in future library versions, cf. https://github.com/bpmn-io/diagram-js/pull/888"));
  let html;
  if (this.isOpen() && targetsEqual(this._current.target, target)) {
    html = this._current.html;
  } else {
    html = this._createHtml(target);
  }
  return { html };
};
ContextPad.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  clearTimeout(this._timeout);
  this._container.innerHTML = "";
  this._eventBus.fire("contextPad.close", { current: this._current });
  this._current = null;
};
ContextPad.prototype.isOpen = function(target) {
  var current = this._current;
  if (!current) {
    return false;
  }
  if (!target) {
    return true;
  }
  var currentTarget = current.target;
  if (isArray(target) !== isArray(currentTarget)) {
    return false;
  }
  if (isArray(target)) {
    return target.length === currentTarget.length && every(target, function(element) {
      return currentTarget.includes(element);
    });
  } else {
    return currentTarget === target;
  }
};
ContextPad.prototype.isShown = function() {
  return this.isOpen() && classes2(this._current.html).has("open");
};
ContextPad.prototype.show = function() {
  if (!this.isOpen()) {
    return;
  }
  classes2(this._current.html).add("open");
  this._updatePosition();
  this._eventBus.fire("contextPad.show", { current: this._current });
};
ContextPad.prototype.hide = function() {
  if (!this.isOpen()) {
    return;
  }
  classes2(this._current.html).remove("open");
  this._eventBus.fire("contextPad.hide", { current: this._current });
};
ContextPad.prototype._getPosition = function(target) {
  if (!isArray(target) && isConnection(target)) {
    var viewbox = this._canvas.viewbox();
    var lastWaypoint = getLastWaypoint(target);
    var x6 = lastWaypoint.x * viewbox.scale - viewbox.x * viewbox.scale, y5 = lastWaypoint.y * viewbox.scale - viewbox.y * viewbox.scale;
    return {
      left: x6 + CONTEXT_PAD_MARGIN * this._canvas.zoom(),
      top: y5
    };
  }
  var container = this._canvas.getContainer();
  var containerBounds = container.getBoundingClientRect();
  var targetBounds = this._getTargetBounds(target);
  return {
    left: targetBounds.right - containerBounds.left + CONTEXT_PAD_MARGIN * this._canvas.zoom(),
    top: targetBounds.top - containerBounds.top
  };
};
ContextPad.prototype._updatePosition = function() {
  const updateFn = () => {
    if (!this.isOpen()) {
      return;
    }
    var html = this._current.html;
    var position = this._getPosition(this._current.target);
    if ("x" in position && "y" in position) {
      html.style.left = position.x + "px";
      html.style.top = position.y + "px";
    } else {
      [
        "top",
        "right",
        "bottom",
        "left"
      ].forEach(function(key) {
        if (key in position) {
          html.style[key] = position[key] + "px";
        }
      });
    }
  };
  this._scheduler.schedule(updateFn, "ContextPad#_updatePosition");
};
ContextPad.prototype._updateVisibility = function() {
  const updateFn = () => {
    if (!this.isOpen()) {
      return;
    }
    var self2 = this;
    var target = this._current.target;
    var targets = isArray(target) ? target : [target];
    var isHidden6 = targets.some(function(target2) {
      return self2._canvas.hasMarker(target2, MARKER_HIDDEN);
    });
    if (isHidden6) {
      self2.hide();
    } else {
      self2.show();
    }
  };
  this._scheduler.schedule(updateFn, "ContextPad#_updateVisibility");
};
ContextPad.prototype._getTargetBounds = function(target) {
  var self2 = this;
  var elements = isArray(target) ? target : [target];
  var elementsGfx = elements.map(function(element) {
    return self2._canvas.getGraphics(element);
  });
  return elementsGfx.reduce(function(bounds, elementGfx) {
    const elementBounds = elementGfx.getBoundingClientRect();
    bounds.top = Math.min(bounds.top, elementBounds.top);
    bounds.right = Math.max(bounds.right, elementBounds.right);
    bounds.bottom = Math.max(bounds.bottom, elementBounds.bottom);
    bounds.left = Math.min(bounds.left, elementBounds.left);
    bounds.x = bounds.left;
    bounds.y = bounds.top;
    bounds.width = bounds.right - bounds.left;
    bounds.height = bounds.bottom - bounds.top;
    return bounds;
  }, {
    top: Infinity,
    right: -Infinity,
    bottom: -Infinity,
    left: Infinity
  });
};
function addClasses(element, classNames) {
  var classes3 = classes2(element);
  classNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
  classNames.forEach(function(cls) {
    classes3.add(cls);
  });
}
function getLastWaypoint(connection) {
  return connection.waypoints[connection.waypoints.length - 1];
}
function targetsEqual(target, otherTarget) {
  target = isArray(target) ? target : [target];
  otherTarget = isArray(otherTarget) ? otherTarget : [otherTarget];
  return target.length === otherTarget.length && every(target, function(element) {
    return otherTarget.includes(element);
  });
}

// node_modules/diagram-js/lib/features/context-pad/index.js
var context_pad_default = {
  __depends__: [
    interaction_events_default,
    scheduler_default,
    overlays_default
  ],
  contextPad: ["type", ContextPad]
};

// node_modules/preact/dist/preact.module.js
var n;
var l;
var u;
var t;
var i;
var r;
var o;
var e3;
var f;
var c;
var s;
var a;
var h;
var p = {};
var v = [];
var y = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var d = Array.isArray;
function w(n4, l5) {
  for (var u6 in l5) n4[u6] = l5[u6];
  return n4;
}
function g(n4) {
  n4 && n4.parentNode && n4.parentNode.removeChild(n4);
}
function _(l5, u6, t7) {
  var i7, r7, o5, e8 = {};
  for (o5 in u6) "key" == o5 ? i7 = u6[o5] : "ref" == o5 ? r7 = u6[o5] : e8[o5] = u6[o5];
  if (arguments.length > 2 && (e8.children = arguments.length > 3 ? n.call(arguments, 2) : t7), "function" == typeof l5 && null != l5.defaultProps) for (o5 in l5.defaultProps) void 0 === e8[o5] && (e8[o5] = l5.defaultProps[o5]);
  return m(l5, e8, i7, r7, null);
}
function m(n4, t7, i7, r7, o5) {
  var e8 = { type: n4, props: t7, key: i7, ref: r7, __k: null, __: null, __b: 0, __e: null, __c: null, constructor: void 0, __v: null == o5 ? ++u : o5, __i: -1, __u: 0 };
  return null == o5 && null != l.vnode && l.vnode(e8), e8;
}
function k(n4) {
  return n4.children;
}
function x(n4, l5) {
  this.props = n4, this.context = l5;
}
function S(n4, l5) {
  if (null == l5) return n4.__ ? S(n4.__, n4.__i + 1) : null;
  for (var u6; l5 < n4.__k.length; l5++) if (null != (u6 = n4.__k[l5]) && null != u6.__e) return u6.__e;
  return "function" == typeof n4.type ? S(n4) : null;
}
function C(n4) {
  var l5, u6;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l5 = 0; l5 < n4.__k.length; l5++) if (null != (u6 = n4.__k[l5]) && null != u6.__e) {
      n4.__e = n4.__c.base = u6.__e;
      break;
    }
    return C(n4);
  }
}
function M(n4) {
  (!n4.__d && (n4.__d = true) && i.push(n4) && !$.__r++ || r !== l.debounceRendering) && ((r = l.debounceRendering) || o)($);
}
function $() {
  for (var n4, u6, t7, r7, o5, f6, c5, s5 = 1; i.length; ) i.length > s5 && i.sort(e3), n4 = i.shift(), s5 = i.length, n4.__d && (t7 = void 0, o5 = (r7 = (u6 = n4).__v).__e, f6 = [], c5 = [], u6.__P && ((t7 = w({}, r7)).__v = r7.__v + 1, l.vnode && l.vnode(t7), j(u6.__P, t7, r7, u6.__n, u6.__P.namespaceURI, 32 & r7.__u ? [o5] : null, f6, null == o5 ? S(r7) : o5, !!(32 & r7.__u), c5), t7.__v = r7.__v, t7.__.__k[t7.__i] = t7, z(f6, t7, c5), t7.__e != o5 && C(t7)));
  $.__r = 0;
}
function I(n4, l5, u6, t7, i7, r7, o5, e8, f6, c5, s5) {
  var a6, h5, y5, d5, w6, g6, _5 = t7 && t7.__k || v, m6 = l5.length;
  for (f6 = P(u6, l5, _5, f6, m6), a6 = 0; a6 < m6; a6++) null != (y5 = u6.__k[a6]) && (h5 = -1 === y5.__i ? p : _5[y5.__i] || p, y5.__i = a6, g6 = j(n4, y5, h5, i7, r7, o5, e8, f6, c5, s5), d5 = y5.__e, y5.ref && h5.ref != y5.ref && (h5.ref && V(h5.ref, null, y5), s5.push(y5.ref, y5.__c || d5, y5)), null == w6 && null != d5 && (w6 = d5), 4 & y5.__u || h5.__k === y5.__k ? f6 = A(y5, f6, n4) : "function" == typeof y5.type && void 0 !== g6 ? f6 = g6 : d5 && (f6 = d5.nextSibling), y5.__u &= -7);
  return u6.__e = w6, f6;
}
function P(n4, l5, u6, t7, i7) {
  var r7, o5, e8, f6, c5, s5 = u6.length, a6 = s5, h5 = 0;
  for (n4.__k = new Array(i7), r7 = 0; r7 < i7; r7++) null != (o5 = l5[r7]) && "boolean" != typeof o5 && "function" != typeof o5 ? (f6 = r7 + h5, (o5 = n4.__k[r7] = "string" == typeof o5 || "number" == typeof o5 || "bigint" == typeof o5 || o5.constructor == String ? m(null, o5, null, null, null) : d(o5) ? m(k, { children: o5 }, null, null, null) : void 0 === o5.constructor && o5.__b > 0 ? m(o5.type, o5.props, o5.key, o5.ref ? o5.ref : null, o5.__v) : o5).__ = n4, o5.__b = n4.__b + 1, e8 = null, -1 !== (c5 = o5.__i = L(o5, u6, f6, a6)) && (a6--, (e8 = u6[c5]) && (e8.__u |= 2)), null == e8 || null === e8.__v ? (-1 == c5 && (i7 > s5 ? h5-- : i7 < s5 && h5++), "function" != typeof o5.type && (o5.__u |= 4)) : c5 != f6 && (c5 == f6 - 1 ? h5-- : c5 == f6 + 1 ? h5++ : (c5 > f6 ? h5-- : h5++, o5.__u |= 4))) : n4.__k[r7] = null;
  if (a6) for (r7 = 0; r7 < s5; r7++) null != (e8 = u6[r7]) && 0 == (2 & e8.__u) && (e8.__e == t7 && (t7 = S(e8)), q(e8, e8));
  return t7;
}
function A(n4, l5, u6) {
  var t7, i7;
  if ("function" == typeof n4.type) {
    for (t7 = n4.__k, i7 = 0; t7 && i7 < t7.length; i7++) t7[i7] && (t7[i7].__ = n4, l5 = A(t7[i7], l5, u6));
    return l5;
  }
  n4.__e != l5 && (l5 && n4.type && !u6.contains(l5) && (l5 = S(n4)), u6.insertBefore(n4.__e, l5 || null), l5 = n4.__e);
  do {
    l5 = l5 && l5.nextSibling;
  } while (null != l5 && 8 == l5.nodeType);
  return l5;
}
function L(n4, l5, u6, t7) {
  var i7, r7, o5 = n4.key, e8 = n4.type, f6 = l5[u6];
  if (null === f6 && null == n4.key || f6 && o5 == f6.key && e8 === f6.type && 0 == (2 & f6.__u)) return u6;
  if (t7 > (null != f6 && 0 == (2 & f6.__u) ? 1 : 0)) for (i7 = u6 - 1, r7 = u6 + 1; i7 >= 0 || r7 < l5.length; ) {
    if (i7 >= 0) {
      if ((f6 = l5[i7]) && 0 == (2 & f6.__u) && o5 == f6.key && e8 === f6.type) return i7;
      i7--;
    }
    if (r7 < l5.length) {
      if ((f6 = l5[r7]) && 0 == (2 & f6.__u) && o5 == f6.key && e8 === f6.type) return r7;
      r7++;
    }
  }
  return -1;
}
function T(n4, l5, u6) {
  "-" == l5[0] ? n4.setProperty(l5, null == u6 ? "" : u6) : n4[l5] = null == u6 ? "" : "number" != typeof u6 || y.test(l5) ? u6 : u6 + "px";
}
function F(n4, l5, u6, t7, i7) {
  var r7;
  n: if ("style" == l5) if ("string" == typeof u6) n4.style.cssText = u6;
  else {
    if ("string" == typeof t7 && (n4.style.cssText = t7 = ""), t7) for (l5 in t7) u6 && l5 in u6 || T(n4.style, l5, "");
    if (u6) for (l5 in u6) t7 && u6[l5] === t7[l5] || T(n4.style, l5, u6[l5]);
  }
  else if ("o" == l5[0] && "n" == l5[1]) r7 = l5 != (l5 = l5.replace(f, "$1")), l5 = l5.toLowerCase() in n4 || "onFocusOut" == l5 || "onFocusIn" == l5 ? l5.toLowerCase().slice(2) : l5.slice(2), n4.l || (n4.l = {}), n4.l[l5 + r7] = u6, u6 ? t7 ? u6.u = t7.u : (u6.u = c, n4.addEventListener(l5, r7 ? a : s, r7)) : n4.removeEventListener(l5, r7 ? a : s, r7);
  else {
    if ("http://www.w3.org/2000/svg" == i7) l5 = l5.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" != l5 && "height" != l5 && "href" != l5 && "list" != l5 && "form" != l5 && "tabIndex" != l5 && "download" != l5 && "rowSpan" != l5 && "colSpan" != l5 && "role" != l5 && "popover" != l5 && l5 in n4) try {
      n4[l5] = null == u6 ? "" : u6;
      break n;
    } catch (n5) {
    }
    "function" == typeof u6 || (null == u6 || false === u6 && "-" != l5[4] ? n4.removeAttribute(l5) : n4.setAttribute(l5, "popover" == l5 && 1 == u6 ? "" : u6));
  }
}
function O(n4) {
  return function(u6) {
    if (this.l) {
      var t7 = this.l[u6.type + n4];
      if (null == u6.t) u6.t = c++;
      else if (u6.t < t7.u) return;
      return t7(l.event ? l.event(u6) : u6);
    }
  };
}
function j(n4, u6, t7, i7, r7, o5, e8, f6, c5, s5) {
  var a6, h5, p5, v5, y5, _5, m6, b4, S3, C5, M4, $4, P5, A6, H3, L4, T6, F6, O4 = u6.type;
  if (void 0 !== u6.constructor) return null;
  128 & t7.__u && (c5 = !!(32 & t7.__u), o5 = [f6 = u6.__e = t7.__e]), (a6 = l.__b) && a6(u6);
  n: if ("function" == typeof O4) try {
    if (b4 = u6.props, S3 = "prototype" in O4 && O4.prototype.render, C5 = (a6 = O4.contextType) && i7[a6.__c], M4 = a6 ? C5 ? C5.props.value : a6.__ : i7, t7.__c ? m6 = (h5 = u6.__c = t7.__c).__ = h5.__E : (S3 ? u6.__c = h5 = new O4(b4, M4) : (u6.__c = h5 = new x(b4, M4), h5.constructor = O4, h5.render = B), C5 && C5.sub(h5), h5.props = b4, h5.state || (h5.state = {}), h5.context = M4, h5.__n = i7, p5 = h5.__d = true, h5.__h = [], h5._sb = []), S3 && null == h5.__s && (h5.__s = h5.state), S3 && null != O4.getDerivedStateFromProps && (h5.__s == h5.state && (h5.__s = w({}, h5.__s)), w(h5.__s, O4.getDerivedStateFromProps(b4, h5.__s))), v5 = h5.props, y5 = h5.state, h5.__v = u6, p5) S3 && null == O4.getDerivedStateFromProps && null != h5.componentWillMount && h5.componentWillMount(), S3 && null != h5.componentDidMount && h5.__h.push(h5.componentDidMount);
    else {
      if (S3 && null == O4.getDerivedStateFromProps && b4 !== v5 && null != h5.componentWillReceiveProps && h5.componentWillReceiveProps(b4, M4), !h5.__e && (null != h5.shouldComponentUpdate && false === h5.shouldComponentUpdate(b4, h5.__s, M4) || u6.__v == t7.__v)) {
        for (u6.__v != t7.__v && (h5.props = b4, h5.state = h5.__s, h5.__d = false), u6.__e = t7.__e, u6.__k = t7.__k, u6.__k.some(function(n5) {
          n5 && (n5.__ = u6);
        }), $4 = 0; $4 < h5._sb.length; $4++) h5.__h.push(h5._sb[$4]);
        h5._sb = [], h5.__h.length && e8.push(h5);
        break n;
      }
      null != h5.componentWillUpdate && h5.componentWillUpdate(b4, h5.__s, M4), S3 && null != h5.componentDidUpdate && h5.__h.push(function() {
        h5.componentDidUpdate(v5, y5, _5);
      });
    }
    if (h5.context = M4, h5.props = b4, h5.__P = n4, h5.__e = false, P5 = l.__r, A6 = 0, S3) {
      for (h5.state = h5.__s, h5.__d = false, P5 && P5(u6), a6 = h5.render(h5.props, h5.state, h5.context), H3 = 0; H3 < h5._sb.length; H3++) h5.__h.push(h5._sb[H3]);
      h5._sb = [];
    } else do {
      h5.__d = false, P5 && P5(u6), a6 = h5.render(h5.props, h5.state, h5.context), h5.state = h5.__s;
    } while (h5.__d && ++A6 < 25);
    h5.state = h5.__s, null != h5.getChildContext && (i7 = w(w({}, i7), h5.getChildContext())), S3 && !p5 && null != h5.getSnapshotBeforeUpdate && (_5 = h5.getSnapshotBeforeUpdate(v5, y5)), T6 = (L4 = null != a6 && a6.type === k && null == a6.key) ? a6.props.children : a6, L4 && (a6.props.children = null), f6 = I(n4, d(T6) ? T6 : [T6], u6, t7, i7, r7, o5, e8, f6, c5, s5), h5.base = u6.__e, u6.__u &= -161, h5.__h.length && e8.push(h5), m6 && (h5.__E = h5.__ = null);
  } catch (n5) {
    if (u6.__v = null, c5 || null != o5) if (n5.then) {
      for (u6.__u |= c5 ? 160 : 128; f6 && 8 == f6.nodeType && f6.nextSibling; ) f6 = f6.nextSibling;
      o5[o5.indexOf(f6)] = null, u6.__e = f6;
    } else for (F6 = o5.length; F6--; ) g(o5[F6]);
    else u6.__e = t7.__e, u6.__k = t7.__k;
    l.__e(n5, u6, t7);
  }
  else null == o5 && u6.__v == t7.__v ? (u6.__k = t7.__k, u6.__e = t7.__e) : f6 = u6.__e = N(t7.__e, u6, t7, i7, r7, o5, e8, c5, s5);
  return (a6 = l.diffed) && a6(u6), 128 & u6.__u ? void 0 : f6;
}
function z(n4, u6, t7) {
  for (var i7 = 0; i7 < t7.length; i7++) V(t7[i7], t7[++i7], t7[++i7]);
  l.__c && l.__c(u6, n4), n4.some(function(u7) {
    try {
      n4 = u7.__h, u7.__h = [], n4.some(function(n5) {
        n5.call(u7);
      });
    } catch (n5) {
      l.__e(n5, u7.__v);
    }
  });
}
function N(u6, t7, i7, r7, o5, e8, f6, c5, s5) {
  var a6, h5, v5, y5, w6, _5, m6, b4 = i7.props, k6 = t7.props, x6 = t7.type;
  if ("svg" == x6 ? o5 = "http://www.w3.org/2000/svg" : "math" == x6 ? o5 = "http://www.w3.org/1998/Math/MathML" : o5 || (o5 = "http://www.w3.org/1999/xhtml"), null != e8) {
    for (a6 = 0; a6 < e8.length; a6++) if ((w6 = e8[a6]) && "setAttribute" in w6 == !!x6 && (x6 ? w6.localName == x6 : 3 == w6.nodeType)) {
      u6 = w6, e8[a6] = null;
      break;
    }
  }
  if (null == u6) {
    if (null == x6) return document.createTextNode(k6);
    u6 = document.createElementNS(o5, x6, k6.is && k6), c5 && (l.__m && l.__m(t7, e8), c5 = false), e8 = null;
  }
  if (null === x6) b4 === k6 || c5 && u6.data === k6 || (u6.data = k6);
  else {
    if (e8 = e8 && n.call(u6.childNodes), b4 = i7.props || p, !c5 && null != e8) for (b4 = {}, a6 = 0; a6 < u6.attributes.length; a6++) b4[(w6 = u6.attributes[a6]).name] = w6.value;
    for (a6 in b4) if (w6 = b4[a6], "children" == a6) ;
    else if ("dangerouslySetInnerHTML" == a6) v5 = w6;
    else if (!(a6 in k6)) {
      if ("value" == a6 && "defaultValue" in k6 || "checked" == a6 && "defaultChecked" in k6) continue;
      F(u6, a6, null, w6, o5);
    }
    for (a6 in k6) w6 = k6[a6], "children" == a6 ? y5 = w6 : "dangerouslySetInnerHTML" == a6 ? h5 = w6 : "value" == a6 ? _5 = w6 : "checked" == a6 ? m6 = w6 : c5 && "function" != typeof w6 || b4[a6] === w6 || F(u6, a6, w6, b4[a6], o5);
    if (h5) c5 || v5 && (h5.__html === v5.__html || h5.__html === u6.innerHTML) || (u6.innerHTML = h5.__html), t7.__k = [];
    else if (v5 && (u6.innerHTML = ""), I("template" === t7.type ? u6.content : u6, d(y5) ? y5 : [y5], t7, i7, r7, "foreignObject" == x6 ? "http://www.w3.org/1999/xhtml" : o5, e8, f6, e8 ? e8[0] : i7.__k && S(i7, 0), c5, s5), null != e8) for (a6 = e8.length; a6--; ) g(e8[a6]);
    c5 || (a6 = "value", "progress" == x6 && null == _5 ? u6.removeAttribute("value") : void 0 !== _5 && (_5 !== u6[a6] || "progress" == x6 && !_5 || "option" == x6 && _5 !== b4[a6]) && F(u6, a6, _5, b4[a6], o5), a6 = "checked", void 0 !== m6 && m6 !== u6[a6] && F(u6, a6, m6, b4[a6], o5));
  }
  return u6;
}
function V(n4, u6, t7) {
  try {
    if ("function" == typeof n4) {
      var i7 = "function" == typeof n4.__u;
      i7 && n4.__u(), i7 && null == u6 || (n4.__u = n4(u6));
    } else n4.current = u6;
  } catch (n5) {
    l.__e(n5, t7);
  }
}
function q(n4, u6, t7) {
  var i7, r7;
  if (l.unmount && l.unmount(n4), (i7 = n4.ref) && (i7.current && i7.current !== n4.__e || V(i7, null, u6)), null != (i7 = n4.__c)) {
    if (i7.componentWillUnmount) try {
      i7.componentWillUnmount();
    } catch (n5) {
      l.__e(n5, u6);
    }
    i7.base = i7.__P = null;
  }
  if (i7 = n4.__k) for (r7 = 0; r7 < i7.length; r7++) i7[r7] && q(i7[r7], u6, t7 || "function" != typeof n4.type);
  t7 || g(n4.__e), n4.__c = n4.__ = n4.__e = void 0;
}
function B(n4, l5, u6) {
  return this.constructor(n4, u6);
}
function D(u6, t7, i7) {
  var r7, o5, e8, f6;
  t7 == document && (t7 = document.documentElement), l.__ && l.__(u6, t7), o5 = (r7 = "function" == typeof i7) ? null : i7 && i7.__k || t7.__k, e8 = [], f6 = [], j(t7, u6 = (!r7 && i7 || t7).__k = _(k, null, [u6]), o5 || p, p, t7.namespaceURI, !r7 && i7 ? [i7] : o5 ? null : t7.firstChild ? n.call(t7.childNodes) : null, e8, !r7 && i7 ? i7 : o5 ? o5.__e : t7.firstChild, r7, f6), z(e8, u6, f6);
}
n = v.slice, l = { __e: function(n4, l5, u6, t7) {
  for (var i7, r7, o5; l5 = l5.__; ) if ((i7 = l5.__c) && !i7.__) try {
    if ((r7 = i7.constructor) && null != r7.getDerivedStateFromError && (i7.setState(r7.getDerivedStateFromError(n4)), o5 = i7.__d), null != i7.componentDidCatch && (i7.componentDidCatch(n4, t7 || {}), o5 = i7.__d), o5) return i7.__E = i7;
  } catch (l6) {
    n4 = l6;
  }
  throw n4;
} }, u = 0, t = function(n4) {
  return null != n4 && null == n4.constructor;
}, x.prototype.setState = function(n4, l5) {
  var u6;
  u6 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = w({}, this.state), "function" == typeof n4 && (n4 = n4(w({}, u6), this.props)), n4 && w(u6, n4), null != n4 && this.__v && (l5 && this._sb.push(l5), M(this));
}, x.prototype.forceUpdate = function(n4) {
  this.__v && (this.__e = true, n4 && this.__h.push(n4), M(this));
}, x.prototype.render = k, i = [], o = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, e3 = function(n4, l5) {
  return n4.__v.__b - l5.__v.__b;
}, $.__r = 0, f = /(PointerCapture)$|Capture$/i, c = 0, s = O(false), a = O(true), h = 0;

// node_modules/htm/dist/htm.module.js
var n2 = function(t7, s5, r7, e8) {
  var u6;
  s5[0] = 0;
  for (var h5 = 1; h5 < s5.length; h5++) {
    var p5 = s5[h5++], a6 = s5[h5] ? (s5[0] |= p5 ? 1 : 2, r7[s5[h5++]]) : s5[++h5];
    3 === p5 ? e8[0] = a6 : 4 === p5 ? e8[1] = Object.assign(e8[1] || {}, a6) : 5 === p5 ? (e8[1] = e8[1] || {})[s5[++h5]] = a6 : 6 === p5 ? e8[1][s5[++h5]] += a6 + "" : p5 ? (u6 = t7.apply(a6, n2(t7, a6, r7, ["", null])), e8.push(u6), a6[0] ? s5[0] |= 2 : (s5[h5 - 2] = 0, s5[h5] = u6)) : e8.push(a6);
  }
  return e8;
};
var t2 = /* @__PURE__ */ new Map();
function htm_module_default(s5) {
  var r7 = t2.get(this);
  return r7 || (r7 = /* @__PURE__ */ new Map(), t2.set(this, r7)), (r7 = n2(this, r7.get(s5) || (r7.set(s5, r7 = function(n4) {
    for (var t7, s6, r8 = 1, e8 = "", u6 = "", h5 = [0], p5 = function(n5) {
      1 === r8 && (n5 || (e8 = e8.replace(/^\s*\n\s*|\s*\n\s*$/g, ""))) ? h5.push(0, n5, e8) : 3 === r8 && (n5 || e8) ? (h5.push(3, n5, e8), r8 = 2) : 2 === r8 && "..." === e8 && n5 ? h5.push(4, n5, 0) : 2 === r8 && e8 && !n5 ? h5.push(5, 0, true, e8) : r8 >= 5 && ((e8 || !n5 && 5 === r8) && (h5.push(r8, 0, e8, s6), r8 = 6), n5 && (h5.push(r8, n5, 0, s6), r8 = 6)), e8 = "";
    }, a6 = 0; a6 < n4.length; a6++) {
      a6 && (1 === r8 && p5(), p5(a6));
      for (var l5 = 0; l5 < n4[a6].length; l5++) t7 = n4[a6][l5], 1 === r8 ? "<" === t7 ? (p5(), h5 = [h5], r8 = 3) : e8 += t7 : 4 === r8 ? "--" === e8 && ">" === t7 ? (r8 = 1, e8 = "") : e8 = t7 + e8[0] : u6 ? t7 === u6 ? u6 = "" : e8 += t7 : '"' === t7 || "'" === t7 ? u6 = t7 : ">" === t7 ? (p5(), r8 = 1) : r8 && ("=" === t7 ? (r8 = 5, s6 = e8, e8 = "") : "/" === t7 && (r8 < 5 || ">" === n4[a6][l5 + 1]) ? (p5(), 3 === r8 && (h5 = h5[0]), r8 = h5, (h5 = h5[0]).push(2, 0, r8), r8 = 0) : " " === t7 || "	" === t7 || "\n" === t7 || "\r" === t7 ? (p5(), r8 = 2) : e8 += t7), 3 === r8 && "!--" === e8 && (r8 = 4, h5 = h5[0]);
    }
    return p5(), h5;
  }(s5)), r7), arguments, [])).length > 1 ? r7 : r7[0];
}

// node_modules/htm/preact/index.module.js
var m2 = htm_module_default.bind(_);

// node_modules/preact/hooks/dist/hooks.module.js
var t3;
var r2;
var u2;
var i2;
var o2 = 0;
var f2 = [];
var c2 = l;
var e4 = c2.__b;
var a2 = c2.__r;
var v2 = c2.diffed;
var l2 = c2.__c;
var m3 = c2.unmount;
var s2 = c2.__;
function p2(n4, t7) {
  c2.__h && c2.__h(r2, n4, o2 || t7), o2 = 0;
  var u6 = r2.__H || (r2.__H = { __: [], __h: [] });
  return n4 >= u6.__.length && u6.__.push({}), u6.__[n4];
}
function d2(n4) {
  return o2 = 1, h2(D2, n4);
}
function h2(n4, u6, i7) {
  var o5 = p2(t3++, 2);
  if (o5.t = n4, !o5.__c && (o5.__ = [i7 ? i7(u6) : D2(void 0, u6), function(n5) {
    var t7 = o5.__N ? o5.__N[0] : o5.__[0], r7 = o5.t(t7, n5);
    t7 !== r7 && (o5.__N = [r7, o5.__[1]], o5.__c.setState({}));
  }], o5.__c = r2, !r2.__f)) {
    var f6 = function(n5, t7, r7) {
      if (!o5.__c.__H) return true;
      var u7 = o5.__c.__H.__.filter(function(n6) {
        return !!n6.__c;
      });
      if (u7.every(function(n6) {
        return !n6.__N;
      })) return !c5 || c5.call(this, n5, t7, r7);
      var i8 = o5.__c.props !== n5;
      return u7.forEach(function(n6) {
        if (n6.__N) {
          var t8 = n6.__[0];
          n6.__ = n6.__N, n6.__N = void 0, t8 !== n6.__[0] && (i8 = true);
        }
      }), c5 && c5.call(this, n5, t7, r7) || i8;
    };
    r2.__f = true;
    var c5 = r2.shouldComponentUpdate, e8 = r2.componentWillUpdate;
    r2.componentWillUpdate = function(n5, t7, r7) {
      if (this.__e) {
        var u7 = c5;
        c5 = void 0, f6(n5, t7, r7), c5 = u7;
      }
      e8 && e8.call(this, n5, t7, r7);
    }, r2.shouldComponentUpdate = f6;
  }
  return o5.__N || o5.__;
}
function y2(n4, u6) {
  var i7 = p2(t3++, 3);
  !c2.__s && C2(i7.__H, u6) && (i7.__ = n4, i7.u = u6, r2.__H.__h.push(i7));
}
function _2(n4, u6) {
  var i7 = p2(t3++, 4);
  !c2.__s && C2(i7.__H, u6) && (i7.__ = n4, i7.u = u6, r2.__h.push(i7));
}
function A2(n4) {
  return o2 = 5, T2(function() {
    return { current: n4 };
  }, []);
}
function T2(n4, r7) {
  var u6 = p2(t3++, 7);
  return C2(u6.__H, r7) && (u6.__ = n4(), u6.__H = r7, u6.__h = n4), u6.__;
}
function q2(n4, t7) {
  return o2 = 8, T2(function() {
    return n4;
  }, t7);
}
function j2() {
  for (var n4; n4 = f2.shift(); ) if (n4.__P && n4.__H) try {
    n4.__H.__h.forEach(z2), n4.__H.__h.forEach(B2), n4.__H.__h = [];
  } catch (t7) {
    n4.__H.__h = [], c2.__e(t7, n4.__v);
  }
}
c2.__b = function(n4) {
  r2 = null, e4 && e4(n4);
}, c2.__ = function(n4, t7) {
  n4 && t7.__k && t7.__k.__m && (n4.__m = t7.__k.__m), s2 && s2(n4, t7);
}, c2.__r = function(n4) {
  a2 && a2(n4), t3 = 0;
  var i7 = (r2 = n4.__c).__H;
  i7 && (u2 === r2 ? (i7.__h = [], r2.__h = [], i7.__.forEach(function(n5) {
    n5.__N && (n5.__ = n5.__N), n5.u = n5.__N = void 0;
  })) : (i7.__h.forEach(z2), i7.__h.forEach(B2), i7.__h = [], t3 = 0)), u2 = r2;
}, c2.diffed = function(n4) {
  v2 && v2(n4);
  var t7 = n4.__c;
  t7 && t7.__H && (t7.__H.__h.length && (1 !== f2.push(t7) && i2 === c2.requestAnimationFrame || ((i2 = c2.requestAnimationFrame) || w2)(j2)), t7.__H.__.forEach(function(n5) {
    n5.u && (n5.__H = n5.u), n5.u = void 0;
  })), u2 = r2 = null;
}, c2.__c = function(n4, t7) {
  t7.some(function(n5) {
    try {
      n5.__h.forEach(z2), n5.__h = n5.__h.filter(function(n6) {
        return !n6.__ || B2(n6);
      });
    } catch (r7) {
      t7.some(function(n6) {
        n6.__h && (n6.__h = []);
      }), t7 = [], c2.__e(r7, n5.__v);
    }
  }), l2 && l2(n4, t7);
}, c2.unmount = function(n4) {
  m3 && m3(n4);
  var t7, r7 = n4.__c;
  r7 && r7.__H && (r7.__H.__.forEach(function(n5) {
    try {
      z2(n5);
    } catch (n6) {
      t7 = n6;
    }
  }), r7.__H = void 0, t7 && c2.__e(t7, r7.__v));
};
var k2 = "function" == typeof requestAnimationFrame;
function w2(n4) {
  var t7, r7 = function() {
    clearTimeout(u6), k2 && cancelAnimationFrame(t7), setTimeout(n4);
  }, u6 = setTimeout(r7, 100);
  k2 && (t7 = requestAnimationFrame(r7));
}
function z2(n4) {
  var t7 = r2, u6 = n4.__c;
  "function" == typeof u6 && (n4.__c = void 0, u6()), r2 = t7;
}
function B2(n4) {
  var t7 = r2;
  n4.__c = n4.__(), r2 = t7;
}
function C2(n4, t7) {
  return !n4 || n4.length !== t7.length || t7.some(function(t8, r7) {
    return t8 !== n4[r7];
  });
}
function D2(n4, t7) {
  return "function" == typeof t7 ? t7(n4) : t7;
}

// node_modules/clsx/dist/clsx.mjs
function r3(e8) {
  var t7, f6, n4 = "";
  if ("string" == typeof e8 || "number" == typeof e8) n4 += e8;
  else if ("object" == typeof e8) if (Array.isArray(e8)) {
    var o5 = e8.length;
    for (t7 = 0; t7 < o5; t7++) e8[t7] && (f6 = r3(e8[t7])) && (n4 && (n4 += " "), n4 += f6);
  } else for (f6 in e8) e8[f6] && (n4 && (n4 += " "), n4 += f6);
  return n4;
}
function clsx() {
  for (var e8, t7, f6 = 0, n4 = "", o5 = arguments.length; f6 < o5; f6++) (e8 = arguments[f6]) && (t7 = r3(e8)) && (n4 && (n4 += " "), n4 += t7);
  return n4;
}
var clsx_default = clsx;

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuHeader.js
function PopupMenuHeader(props) {
  const {
    headerEntries,
    onSelect,
    selectedEntry,
    setSelectedEntry,
    title
  } = props;
  const groups = T2(() => groupEntries(headerEntries), [headerEntries]);
  return m2`
    <div class="djs-popup-header">
      <h3 class="djs-popup-title" title=${title}>${title}</h3>
      ${groups.map((group) => m2`
        <ul key=${group.id} class="djs-popup-header-group" data-header-group=${group.id}>

          ${group.entries.map((entry) => m2`
            <li key=${entry.id}>
              <${entry.action ? "button" : "span"}
                class=${getHeaderClasses(entry, entry === selectedEntry)}
                onClick=${(event2) => entry.action && onSelect(event2, entry)}
                title=${entry.title || entry.label}
                data-id=${entry.id}
                onMouseEnter=${() => entry.action && setSelectedEntry(entry)}
                onMouseLeave=${() => entry.action && setSelectedEntry(null)}
                onFocus=${() => entry.action && setSelectedEntry(entry)}
                onBlur=${() => entry.action && setSelectedEntry(null)}
              >
                ${entry.imageUrl && m2`<img class="djs-popup-entry-icon" src=${entry.imageUrl} alt="" />` || entry.imageHtml && m2`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${{ __html: entry.imageHtml }} />`}
                ${entry.label ? m2`
                  <span class="djs-popup-label">${entry.label}</span>
                ` : null}
              </${entry.action ? "button" : "span"}>
            </li>
          `)}
        </ul>
      `)}
    </div>
  `;
}
function groupEntries(entries) {
  return entries.reduce((groups, entry) => {
    const groupId = entry.group || "default";
    const group = groups.find((group2) => group2.id === groupId);
    if (group) {
      group.entries.push(entry);
    } else {
      groups.push({
        id: groupId,
        entries: [entry]
      });
    }
    return groups;
  }, []);
}
function getHeaderClasses(entry, selected) {
  return clsx_default(
    "entry",
    entry.className,
    entry.active ? "active" : "",
    entry.disabled ? "disabled" : "",
    selected ? "selected" : ""
  );
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuItem.js
function PopupMenuItem(props) {
  const {
    entry,
    selected,
    onMouseEnter,
    onMouseLeave,
    onAction
  } = props;
  return m2`
    <li
      class=${clsx_default("entry", { selected })}
      data-id=${entry.id}
      title=${entry.title || entry.label}
      tabIndex="0"
      onClick=${onAction}
      onFocus=${onMouseEnter}
      onBlur=${onMouseLeave}
      onMouseEnter=${onMouseEnter}
      onMouseLeave=${onMouseLeave}
      onDragStart=${(event2) => onAction(event2, entry, "dragstart")}
      draggable=${true}
    >
      <div class="djs-popup-entry-content">
        <span
          class=${clsx_default("djs-popup-entry-name", entry.className)}
        >
          ${entry.imageUrl && m2`<img class="djs-popup-entry-icon" src=${entry.imageUrl} alt="" />` || entry.imageHtml && m2`<div class="djs-popup-entry-icon" dangerouslySetInnerHTML=${{ __html: entry.imageHtml }} />`}

          ${entry.label ? m2`
            <span class="djs-popup-label">
              ${entry.label}
            </span>
          ` : null}
        </span>
        ${entry.description && m2`
          <span
            class="djs-popup-entry-description"
            title=${entry.description}
          >
            ${entry.description}
          </span>
        `}
      </div>
      ${entry.documentationRef && m2`
        <div class="djs-popup-entry-docs">
          <a
            href="${entry.documentationRef}"
            onClick=${(event2) => event2.stopPropagation()}
            title="Open element documentation"
            target="_blank"
            rel="noopener"
          >
            <svg width="12" height="12" viewBox="0 0 12 12" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M10.6368 10.6375V5.91761H11.9995V10.6382C11.9995 10.9973 11.8623 11.3141 11.5878 11.5885C11.3134 11.863 10.9966 12.0002 10.6375 12.0002H1.36266C0.982345 12.0002 0.660159 11.8681 0.396102 11.6041C0.132044 11.34 1.52588e-05 11.0178 1.52588e-05 10.6375V1.36267C1.52588e-05 0.98236 0.132044 0.660173 0.396102 0.396116C0.660159 0.132058 0.982345 2.95639e-05 1.36266 2.95639e-05H5.91624V1.36267H1.36266V10.6375H10.6368ZM12 0H7.2794L7.27873 1.36197H9.68701L3.06507 7.98391L4.01541 8.93425L10.6373 2.31231V4.72059H12V0Z" fill="#818798"/>
            </svg>
          </a>
        </div>
      `}
    </li>
  `;
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuList.js
function PopupMenuList(props) {
  const {
    selectedEntry,
    setSelectedEntry,
    entries,
    ...restProps
  } = props;
  const resultsRef = A2();
  const groups = T2(() => groupEntries2(entries), [entries]);
  _2(() => {
    const containerEl = resultsRef.current;
    if (!containerEl)
      return;
    const selectedEl = containerEl.querySelector(".selected");
    if (selectedEl) {
      scrollIntoView(selectedEl);
    }
  }, [selectedEntry]);
  return m2`
    <div class="djs-popup-results" ref=${resultsRef}>
      ${groups.map((group) => m2`
        ${group.name && m2`
          <div key=${group.id} class="entry-header" title=${group.name}>
            ${group.name}
          </div>
        `}
        <ul class="djs-popup-group" data-group=${group.id}>
          ${group.entries.map((entry) => m2`
            <${PopupMenuItem}
              key=${entry.id}
              entry=${entry}
              selected=${entry === selectedEntry}
              onMouseEnter=${() => setSelectedEntry(entry)}
              onMouseLeave=${() => setSelectedEntry(null)}
              ...${restProps}
            />
          `)}
        </ul>
      `)}
    </div>
  `;
}
function groupEntries2(entries) {
  const groups = [];
  const getGroup = (group) => groups.find((elem) => group.id === elem.id);
  const containsGroup = (group) => !!getGroup(group);
  const formatGroup = (group) => typeof group === "string" ? { id: group } : group;
  entries.forEach((entry) => {
    const group = entry.group ? formatGroup(entry.group) : { id: "default" };
    if (!containsGroup(group)) {
      groups.push({ ...group, entries: [entry] });
    } else {
      getGroup(group).entries.push(entry);
    }
  });
  return groups;
}
function scrollIntoView(el) {
  if (typeof el.scrollIntoViewIfNeeded === "function") {
    el.scrollIntoViewIfNeeded();
  } else {
    el.scrollIntoView({
      scrollMode: "if-needed",
      block: "nearest"
    });
  }
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenuComponent.js
function PopupMenuComponent(props) {
  const {
    onClose,
    onSelect,
    className,
    headerEntries,
    position,
    title,
    width,
    scale,
    search: search2,
    emptyPlaceholder,
    searchFn,
    entries: originalEntries,
    onOpened,
    onClosed
  } = props;
  const searchable = T2(() => {
    if (!isDefined(search2)) {
      return false;
    }
    return originalEntries.length > 5;
  }, [search2, originalEntries]);
  const [value, setValue] = d2("");
  const filterEntries = q2((originalEntries2, value2) => {
    if (!searchable) {
      return originalEntries2;
    }
    if (!value2.trim()) {
      return originalEntries2.filter(({ rank = 0 }) => rank >= 0);
    }
    const searchableEntries = originalEntries2.filter(({ searchable: searchable2 }) => searchable2 !== false);
    return searchFn(searchableEntries, value2, {
      keys: [
        "label",
        "description",
        "search"
      ]
    }).map(({ item }) => item);
  }, [searchable]);
  const [entries, setEntries] = d2(filterEntries(originalEntries, value));
  const [selectedEntry, setSelectedEntry] = d2(entries[0]);
  const updateEntries = q2((newEntries) => {
    if (!selectedEntry || !newEntries.includes(selectedEntry)) {
      setSelectedEntry(newEntries[0]);
    }
    setEntries(newEntries);
  }, [selectedEntry, setEntries, setSelectedEntry]);
  y2(() => {
    updateEntries(filterEntries(originalEntries, value));
  }, [value, originalEntries]);
  const keyboardSelect = q2((direction) => {
    const idx = entries.indexOf(selectedEntry);
    let nextIdx = idx + direction;
    if (nextIdx < 0) {
      nextIdx = entries.length - 1;
    }
    if (nextIdx >= entries.length) {
      nextIdx = 0;
    }
    setSelectedEntry(entries[nextIdx]);
  }, [entries, selectedEntry, setSelectedEntry]);
  const handleKeyDown = q2((event2) => {
    if (event2.key === "Enter" && selectedEntry) {
      return onSelect(event2, selectedEntry);
    }
    if (event2.key === "ArrowUp") {
      keyboardSelect(-1);
      return event2.preventDefault();
    }
    if (event2.key === "ArrowDown") {
      keyboardSelect(1);
      return event2.preventDefault();
    }
  }, [onSelect, selectedEntry, keyboardSelect]);
  const handleKey = q2((event2) => {
    if (matches(event2.target, "input")) {
      setValue(() => event2.target.value);
    }
  }, [setValue]);
  y2(() => {
    onOpened();
    return () => {
      onClosed();
    };
  }, []);
  const displayHeader = T2(() => title || headerEntries.length > 0, [title, headerEntries]);
  return m2`
    <${PopupMenuWrapper}
      onClose=${onClose}
      onKeyup=${handleKey}
      onKeydown=${handleKeyDown}
      className=${className}
      position=${position}
      width=${width}
      scale=${scale}
    >
      ${displayHeader && m2`
        <${PopupMenuHeader}
          headerEntries=${headerEntries}
          onSelect=${onSelect}
          selectedEntry=${selectedEntry}
          setSelectedEntry=${setSelectedEntry}
          title=${title}
        />
      `}
      ${originalEntries.length > 0 && m2`
        <div class="djs-popup-body">

          ${searchable && m2`
          <div class="djs-popup-search">
            <svg class="djs-popup-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
              <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
            </svg>
            <input type="text" spellcheck=${false} aria-label="${title}" />
          </div>
          `}

          <${PopupMenuList}
            entries=${entries}
            selectedEntry=${selectedEntry}
            setSelectedEntry=${setSelectedEntry}
            onAction=${onSelect}
          />
        </div>
      `}
    ${emptyPlaceholder && entries.length === 0 && m2`
      <div class="djs-popup-no-results">${isFunction(emptyPlaceholder) ? emptyPlaceholder(value) : emptyPlaceholder}</div>
    `}
    </${PopupMenuWrapper}>
  `;
}
function PopupMenuWrapper(props) {
  const {
    onClose,
    onKeydown,
    onKeyup,
    className,
    children,
    position: positionGetter
  } = props;
  const popupRef = A2();
  _2(() => {
    if (typeof positionGetter !== "function") {
      return;
    }
    const popupEl = popupRef.current;
    const position = positionGetter(popupEl);
    popupEl.style.left = `${position.x}px`;
    popupEl.style.top = `${position.y}px`;
  }, [popupRef.current, positionGetter]);
  _2(() => {
    const popupEl = popupRef.current;
    if (!popupEl) {
      return;
    }
    const inputEl = popupEl.querySelector("input");
    (inputEl || popupEl).focus();
  }, []);
  y2(() => {
    const handleKeyDown = (event2) => {
      if (event2.key === "Escape") {
        event2.preventDefault();
        return onClose();
      }
    };
    const handleClick = (event2) => {
      const popup = closest(event2.target, ".djs-popup", true);
      if (popup) {
        return;
      }
      return onClose();
    };
    document.documentElement.addEventListener("keydown", handleKeyDown);
    document.body.addEventListener("click", handleClick);
    return () => {
      document.documentElement.removeEventListener("keydown", handleKeyDown);
      document.body.removeEventListener("click", handleClick);
    };
  }, []);
  return m2`
    <div
      class=${clsx_default("djs-popup", className)}
      style=${getPopupStyle(props)}
      onKeydown=${onKeydown}
      onKeyup=${onKeyup}
      ref=${popupRef}
      tabIndex="-1"
    >
      ${children}
    </div>
  `;
}
function getPopupStyle(props) {
  return {
    transform: `scale(${props.scale})`,
    width: `${props.width}px`,
    "transform-origin": "top left"
  };
}

// node_modules/diagram-js/lib/features/popup-menu/PopupMenu.js
var DATA_REF = "data-id";
var CLOSE_EVENTS = [
  "contextPad.close",
  "canvas.viewbox.changing",
  "commandStack.changed"
];
var DEFAULT_PRIORITY5 = 1e3;
function PopupMenu(config, eventBus, canvas, search2) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._search = search2;
  this._current = null;
  var scale = isDefined(config && config.scale) ? config.scale : {
    min: 1,
    max: 1
  };
  this._config = {
    scale
  };
  eventBus.on("diagram.destroy", () => {
    this.close();
  });
  eventBus.on("element.changed", (event2) => {
    const element = this.isOpen() && this._current.target;
    if (event2.element === element) {
      this.refresh();
    }
  });
}
PopupMenu.$inject = [
  "config.popupMenu",
  "eventBus",
  "canvas",
  "search"
];
PopupMenu.prototype._render = function() {
  const {
    position: _position,
    providerId: className,
    entries,
    headerEntries,
    emptyPlaceholder,
    options
  } = this._current;
  const entriesArray = Object.entries(entries).map(
    ([key, value]) => ({ id: key, ...value })
  );
  const headerEntriesArray = Object.entries(headerEntries).map(
    ([key, value]) => ({ id: key, ...value })
  );
  const position = _position && ((container) => this._ensureVisible(container, _position));
  const scale = this._updateScale(this._current.container);
  const onClose = (result) => this.close(result);
  const onSelect = (event2, entry, action) => this.trigger(event2, entry, action);
  D(
    m2`
      <${PopupMenuComponent}
        onClose=${onClose}
        onSelect=${onSelect}
        position=${position}
        className=${className}
        entries=${entriesArray}
        headerEntries=${headerEntriesArray}
        emptyPlaceholder=${emptyPlaceholder}
        scale=${scale}
        onOpened=${this._onOpened.bind(this)}
        onClosed=${this._onClosed.bind(this)}
        searchFn=${this._search}
        ...${{ ...options }}
      />
    `,
    this._current.container
  );
};
PopupMenu.prototype.open = function(target, providerId, position, options) {
  if (!target) {
    throw new Error("target is missing");
  }
  if (!providerId) {
    throw new Error("providers for <" + providerId + "> not found");
  }
  if (!position) {
    throw new Error("position is missing");
  }
  if (this.isOpen()) {
    this.close();
  }
  const {
    entries,
    headerEntries,
    emptyPlaceholder
  } = this._getContext(target, providerId);
  this._current = {
    position,
    providerId,
    target,
    entries,
    headerEntries,
    emptyPlaceholder,
    container: this._createContainer({ provider: providerId }),
    options
  };
  this._emit("open");
  this._bindAutoClose();
  this._render();
};
PopupMenu.prototype.refresh = function() {
  if (!this.isOpen()) {
    return;
  }
  const {
    target,
    providerId
  } = this._current;
  const {
    entries,
    headerEntries,
    emptyPlaceholder
  } = this._getContext(target, providerId);
  this._current = {
    ...this._current,
    entries,
    headerEntries,
    emptyPlaceholder
  };
  this._emit("refresh");
  this._render();
};
PopupMenu.prototype._getContext = function(target, provider) {
  const providers = this._getProviders(provider);
  if (!providers || !providers.length) {
    throw new Error("provider for <" + provider + "> not found");
  }
  const entries = this._getEntries(target, providers);
  const headerEntries = this._getHeaderEntries(target, providers);
  const emptyPlaceholder = this._getEmptyPlaceholder(providers);
  return {
    entries,
    headerEntries,
    emptyPlaceholder,
    empty: !(Object.keys(entries).length || Object.keys(headerEntries).length)
  };
};
PopupMenu.prototype.close = function() {
  if (!this.isOpen()) {
    return;
  }
  this._emit("close");
  this.reset();
  this._canvas.restoreFocus();
  this._current = null;
};
PopupMenu.prototype.reset = function() {
  const container = this._current.container;
  D(null, container);
  remove2(container);
};
PopupMenu.prototype._emit = function(event2, payload) {
  this._eventBus.fire(`popupMenu.${event2}`, payload);
};
PopupMenu.prototype._onOpened = function() {
  this._emit("opened");
};
PopupMenu.prototype._onClosed = function() {
  this._emit("closed");
};
PopupMenu.prototype._createContainer = function(config) {
  var canvas = this._canvas, parent = canvas.getContainer();
  const container = domify$1(`<div class="djs-popup-parent djs-scrollable" data-popup=${config.provider}></div>`);
  parent.appendChild(container);
  return container;
};
PopupMenu.prototype._bindAutoClose = function() {
  this._eventBus.once(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._unbindAutoClose = function() {
  this._eventBus.off(CLOSE_EVENTS, this.close, this);
};
PopupMenu.prototype._updateScale = function() {
  var zoom2 = this._canvas.zoom();
  var scaleConfig = this._config.scale, minScale, maxScale, scale = zoom2;
  if (scaleConfig !== true) {
    if (scaleConfig === false) {
      minScale = 1;
      maxScale = 1;
    } else {
      minScale = scaleConfig.min;
      maxScale = scaleConfig.max;
    }
    if (isDefined(minScale) && zoom2 < minScale) {
      scale = minScale;
    }
    if (isDefined(maxScale) && zoom2 > maxScale) {
      scale = maxScale;
    }
  }
  return scale;
};
PopupMenu.prototype._ensureVisible = function(container, position) {
  var documentBounds = document.documentElement.getBoundingClientRect();
  var containerBounds = container.getBoundingClientRect();
  var overAxis = {}, left = position.x, top = position.y;
  if (position.x + containerBounds.width > documentBounds.width) {
    overAxis.x = true;
  }
  if (position.y + containerBounds.height > documentBounds.height) {
    overAxis.y = true;
  }
  if (overAxis.x && overAxis.y) {
    left = position.x - containerBounds.width;
    top = position.y - containerBounds.height;
  } else if (overAxis.x) {
    left = position.x - containerBounds.width;
    top = position.y;
  } else if (overAxis.y && position.y < containerBounds.height) {
    left = position.x;
    top = 10;
  } else if (overAxis.y) {
    left = position.x;
    top = position.y - containerBounds.height;
  }
  if (position.y < documentBounds.top) {
    top = position.y + containerBounds.height;
  }
  return {
    x: left,
    y: top
  };
};
PopupMenu.prototype.isEmpty = function(target, providerId) {
  if (!target) {
    throw new Error("target is missing");
  }
  if (!providerId) {
    throw new Error("provider ID is missing");
  }
  const providers = this._getProviders(providerId);
  if (!providers || !providers.length) {
    return true;
  }
  return this._getContext(target, providerId).empty;
};
PopupMenu.prototype.registerProvider = function(id, priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY5;
  }
  this._eventBus.on("popupMenu.getProviders." + id, priority, function(event2) {
    event2.providers.push(provider);
  });
};
PopupMenu.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "popupMenu.getProviders." + id,
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
PopupMenu.prototype._getEntries = function(target, providers) {
  var entries = {};
  forEach(providers, function(provider) {
    if (!provider.getPopupMenuEntries) {
      forEach(provider.getEntries(target), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("entry ID is missing");
        }
        entries[id] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuEntries(target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getHeaderEntries = function(target, providers) {
  var entries = {};
  forEach(providers, function(provider) {
    if (!provider.getPopupMenuHeaderEntries) {
      if (!provider.getHeaderEntries) {
        return;
      }
      forEach(provider.getHeaderEntries(target), function(entry) {
        var id = entry.id;
        if (!id) {
          throw new Error("entry ID is missing");
        }
        entries[id] = omit(entry, ["id"]);
      });
      return;
    }
    var entriesOrUpdater = provider.getPopupMenuHeaderEntries(target);
    if (isFunction(entriesOrUpdater)) {
      entries = entriesOrUpdater(entries);
    } else {
      forEach(entriesOrUpdater, function(entry, id) {
        entries[id] = entry;
      });
    }
  });
  return entries;
};
PopupMenu.prototype._getEmptyPlaceholder = function(providers) {
  const provider = providers.find(
    (provider2) => isFunction(provider2.getEmptyPlaceholder)
  );
  return provider && provider.getEmptyPlaceholder();
};
PopupMenu.prototype.isOpen = function() {
  return !!this._current;
};
PopupMenu.prototype.trigger = function(event2, entry, action = "click") {
  event2.preventDefault();
  if (!entry) {
    let element = closest(event2.delegateTarget || event2.target, ".entry", true);
    let entryId = attr2(element, DATA_REF);
    entry = { id: entryId, ...this._getEntry(entryId) };
  }
  const handler = entry.action;
  if (this._emit("trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, entry);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, entry);
    }
  }
};
PopupMenu.prototype._getEntry = function(entryId) {
  var entry = this._current.entries[entryId] || this._current.headerEntries[entryId];
  if (!entry) {
    throw new Error("entry not found");
  }
  return entry;
};

// node_modules/diagram-js/lib/features/search/search.js
function search(items, pattern, options) {
  const {
    keys: keys2
  } = options;
  pattern = pattern.trim().toLowerCase();
  if (!pattern) {
    throw new Error("<pattern> must not be empty");
  }
  const words = pattern.trim().toLowerCase().split(/\s+/);
  return items.flatMap((item) => {
    const tokens = matchItem(item, words, keys2);
    if (!tokens) {
      return [];
    }
    return {
      item,
      tokens
    };
  }).sort(createResultSorter(keys2));
}
function matchItem(item, words, keys2) {
  const {
    matchedWords,
    tokens
  } = keys2.reduce((result, key) => {
    const string = item[key];
    const {
      tokens: tokens2,
      matchedWords: matchedWords2
    } = matchString(string, words);
    return {
      tokens: {
        ...result.tokens,
        [key]: tokens2
      },
      matchedWords: {
        ...result.matchedWords,
        ...matchedWords2
      }
    };
  }, {
    matchedWords: {},
    tokens: {}
  });
  if (Object.keys(matchedWords).length !== words.length) {
    return null;
  }
  return tokens;
}
function createResultSorter(keys2) {
  return (resultA, resultB) => {
    for (const key of keys2) {
      const tokenComparison = compareTokens(
        resultA.tokens[key],
        resultB.tokens[key]
      );
      if (tokenComparison !== 0) {
        return tokenComparison;
      }
      const stringComparison = compareStrings(
        resultA.item[key],
        resultB.item[key]
      );
      if (stringComparison !== 0) {
        return stringComparison;
      }
      continue;
    }
    return 0;
  };
}
function compareTokens(tokensA, tokensB) {
  return scoreTokens(tokensB) - scoreTokens(tokensA);
}
function scoreTokens(tokens) {
  return tokens.reduce((sum, token) => sum + scoreToken(token), 0);
}
function scoreToken(token) {
  const modifier = Math.log(token.value.length);
  if (!token.match) {
    return -0.07 * modifier;
  }
  return (token.start ? token.end ? 131.9 : 7.87 : token.wordStart ? 2.19 : 1) * modifier;
}
function compareStrings(a6 = "", b4 = "") {
  return a6.localeCompare(b4);
}
function matchString(string, words) {
  if (!string) {
    return {
      tokens: [],
      matchedWords: {}
    };
  }
  const tokens = [];
  const matchedWords = {};
  const wordsEscaped = words.map(escapeRegexp);
  const regexpString = [
    `(?<all>${wordsEscaped.join("\\s+")})`,
    ...wordsEscaped
  ].join("|");
  const regexp = new RegExp(regexpString, "ig");
  let match;
  let lastIndex = 0;
  while (match = regexp.exec(string)) {
    const [value] = match;
    const startIndex = match.index;
    const endIndex = match.index + value.length;
    const start = startIndex === 0;
    const end = endIndex === string.length;
    const all2 = !!match.groups.all;
    const wordStart = start || /\s/.test(string.charAt(startIndex - 1));
    const wordEnd = end || /\s/.test(string.charAt(endIndex + 1));
    if (match.index > lastIndex) {
      tokens.push({
        value: string.slice(lastIndex, match.index),
        index: lastIndex
      });
    }
    tokens.push({
      value,
      index: match.index,
      match: true,
      wordStart,
      wordEnd,
      start,
      end,
      all: all2
    });
    const newMatchedWords = all2 ? words : [value];
    for (const word of newMatchedWords) {
      matchedWords[word.toLowerCase()] = true;
    }
    lastIndex = match.index + value.length;
  }
  if (lastIndex < string.length) {
    tokens.push({
      value: string.slice(lastIndex),
      index: lastIndex
    });
  }
  return {
    tokens,
    matchedWords
  };
}
function escapeRegexp(string) {
  return string.replace(/[/\-\\^$*+?.()|[\]{}]/g, "\\$&");
}

// node_modules/diagram-js/lib/features/search/index.js
var search_default = {
  search: ["value", search]
};

// node_modules/diagram-js/lib/features/popup-menu/index.js
var popup_menu_default = {
  __depends__: [search_default],
  __init__: ["popupMenu"],
  popupMenu: ["type", PopupMenu]
};

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsIcons.js
var icons = {
  align: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 2000 2000">
              <line x1="200" y1="150" x2="200" y2="1850" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
              <rect x="500" y="150" width="1300" height="700" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="500" y="1150" width="700" height="700" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  bottom: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="1650" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="350" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="850" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  center: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="900" y1="150" x2="900" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="250" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="500" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  left: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="100" y1="150" x2="100" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="100" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="100" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  right: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="1650" y1="150" x2="1650" y2="1650" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="350" y="150" width="1300" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="850" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  top: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="150" x2="1650" y2="150" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="150" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="150" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`,
  middle: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
            <line x1="150" y1="900" x2="1650" y2="900" style="stroke:currentColor;stroke-width:100;stroke-linecap:round;"/>
            <rect x="150" y="250" width="600" height="1300" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
            <rect x="1050" y="500" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
          </svg>`
};
var AlignElementsIcons_default = icons;

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsContextPadProvider.js
var LOW_PRIORITY5 = 900;
function AlignElementsContextPadProvider(contextPad, popupMenu, translate4, canvas) {
  contextPad.registerProvider(LOW_PRIORITY5, this);
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._translate = translate4;
  this._canvas = canvas;
}
AlignElementsContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "translate",
  "canvas"
];
AlignElementsContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var actions = {};
  if (this._isAllowed(elements)) {
    assign(actions, this._getEntries(elements));
  }
  return actions;
};
AlignElementsContextPadProvider.prototype._isAllowed = function(elements) {
  return !this._popupMenu.isEmpty(elements, "align-elements");
};
AlignElementsContextPadProvider.prototype._getEntries = function() {
  var self2 = this;
  return {
    "align-elements": {
      group: "align-elements",
      title: self2._translate("Align elements"),
      html: `<div class="entry">${AlignElementsIcons_default["align"]}</div>`,
      action: {
        click: function(event2, target) {
          var position = self2._getMenuPosition(target);
          assign(position, {
            cursor: {
              x: event2.x,
              y: event2.y
            }
          });
          self2._popupMenu.open(target, "align-elements", position);
        }
      }
    }
  };
};
AlignElementsContextPadProvider.prototype._getMenuPosition = function(elements) {
  var Y_OFFSET = 5;
  var pad = this._contextPad.getPad(elements).html;
  var padRect = pad.getBoundingClientRect();
  var pos = {
    x: padRect.left,
    y: padRect.bottom + Y_OFFSET
  };
  return pos;
};

// node_modules/bpmn-js/lib/features/align-elements/AlignElementsMenuProvider.js
var ALIGNMENT_OPTIONS = [
  "left",
  "center",
  "right",
  "top",
  "middle",
  "bottom"
];
function AlignElementsMenuProvider(popupMenu, alignElements, translate4, rules) {
  this._alignElements = alignElements;
  this._translate = translate4;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", this);
}
AlignElementsMenuProvider.$inject = [
  "popupMenu",
  "alignElements",
  "translate",
  "rules"
];
AlignElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var entries = {};
  if (this._isAllowed(target)) {
    assign(entries, this._getEntries(target));
  }
  return entries;
};
AlignElementsMenuProvider.prototype._isAllowed = function(target) {
  return this._rules.allowed("elements.align", { elements: target });
};
AlignElementsMenuProvider.prototype._getEntries = function(target) {
  var alignElements = this._alignElements, translate4 = this._translate, popupMenu = this._popupMenu;
  var entries = {};
  forEach(ALIGNMENT_OPTIONS, function(alignment) {
    entries["align-elements-" + alignment] = {
      group: "align",
      title: translate4("Align elements " + alignment),
      className: "bjs-align-elements-menu-entry",
      imageHtml: AlignElementsIcons_default[alignment],
      action: function() {
        alignElements.trigger(target, alignment);
        popupMenu.close();
      }
    };
  });
  return entries;
};

// node_modules/diagram-js/lib/features/rules/RuleProvider.js
function RuleProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.init();
}
RuleProvider.$inject = ["eventBus"];
e(RuleProvider, CommandInterceptor);
RuleProvider.prototype.addRule = function(actions, priority, fn2) {
  var self2 = this;
  if (typeof actions === "string") {
    actions = [actions];
  }
  actions.forEach(function(action) {
    self2.canExecute(action, priority, function(context, action2, event2) {
      return fn2(context);
    }, true);
  });
};
RuleProvider.prototype.init = function() {
};

// node_modules/bpmn-js/lib/features/align-elements/BpmnAlignElements.js
function BpmnAlignElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnAlignElements.$inject = ["eventBus"];
e(BpmnAlignElements, RuleProvider);
BpmnAlignElements.prototype.init = function() {
  this.addRule("elements.align", function(context) {
    var elements = context.elements;
    var filteredElements = filter(elements, function(element) {
      return !(element.waypoints || element.host || element.labelTarget);
    });
    filteredElements = getParents(filteredElements);
    if (filteredElements.length < 2) {
      return false;
    }
    return filteredElements;
  });
};

// node_modules/bpmn-js/lib/features/align-elements/index.js
var align_elements_default2 = {
  __depends__: [
    align_elements_default,
    context_pad_default,
    popup_menu_default
  ],
  __init__: [
    "alignElementsContextPadProvider",
    "alignElementsMenuProvider",
    "bpmnAlignElements"
  ],
  alignElementsContextPadProvider: ["type", AlignElementsContextPadProvider],
  alignElementsMenuProvider: ["type", AlignElementsMenuProvider],
  bpmnAlignElements: ["type", BpmnAlignElements]
};

// node_modules/diagram-js/lib/features/auto-place/AutoPlaceUtil.js
var PLACEMENT_DETECTION_PAD = 10;
var DEFAULT_DISTANCE = 50;
var DEFAULT_MAX_DISTANCE = 250;
function findFreePosition(source, element, position, getNextPosition) {
  var connectedAtPosition;
  while (connectedAtPosition = getConnectedAtPosition(source, position, element)) {
    position = getNextPosition(element, position, connectedAtPosition);
  }
  return position;
}
function generateGetNextPosition(nextPositionDirection) {
  return function(element, previousPosition, connectedAtPosition) {
    var nextPosition = {
      x: previousPosition.x,
      y: previousPosition.y
    };
    ["x", "y"].forEach(function(axis) {
      var nextPositionDirectionForAxis = nextPositionDirection[axis];
      if (!nextPositionDirectionForAxis) {
        return;
      }
      var dimension = axis === "x" ? "width" : "height";
      var margin = nextPositionDirectionForAxis.margin, minDistance = nextPositionDirectionForAxis.minDistance;
      if (margin < 0) {
        nextPosition[axis] = Math.min(
          connectedAtPosition[axis] + margin - element[dimension] / 2,
          previousPosition[axis] - minDistance + margin
        );
      } else {
        nextPosition[axis] = Math.max(
          connectedAtPosition[axis] + connectedAtPosition[dimension] + margin + element[dimension] / 2,
          previousPosition[axis] + minDistance + margin
        );
      }
    });
    return nextPosition;
  };
}
function getConnectedAtPosition(source, position, element) {
  var bounds = {
    x: position.x - element.width / 2,
    y: position.y - element.height / 2,
    width: element.width,
    height: element.height
  };
  var closure = getAutoPlaceClosure(source);
  return find(closure, function(target) {
    if (target === element) {
      return false;
    }
    var orientation = getOrientation(target, bounds, PLACEMENT_DETECTION_PAD);
    return orientation === "intersect";
  });
}
function getConnectedDistance(source, hints) {
  if (!hints) {
    hints = {};
  }
  function getDefaultWeight(connection) {
    return connection.source === source ? 1 : -1;
  }
  var defaultDistance = hints.defaultDistance || DEFAULT_DISTANCE, direction = hints.direction || "e", filter2 = hints.filter, getWeight = hints.getWeight || getDefaultWeight, maxDistance = hints.maxDistance || DEFAULT_MAX_DISTANCE, reference = hints.reference || "start";
  if (!filter2) {
    filter2 = noneFilter;
  }
  function getDistance4(a6, b4) {
    if (direction === "n") {
      if (reference === "start") {
        return asTRBL(a6).top - asTRBL(b4).bottom;
      } else if (reference === "center") {
        return asTRBL(a6).top - getMid(b4).y;
      } else {
        return asTRBL(a6).top - asTRBL(b4).top;
      }
    } else if (direction === "w") {
      if (reference === "start") {
        return asTRBL(a6).left - asTRBL(b4).right;
      } else if (reference === "center") {
        return asTRBL(a6).left - getMid(b4).x;
      } else {
        return asTRBL(a6).left - asTRBL(b4).left;
      }
    } else if (direction === "s") {
      if (reference === "start") {
        return asTRBL(b4).top - asTRBL(a6).bottom;
      } else if (reference === "center") {
        return getMid(b4).y - asTRBL(a6).bottom;
      } else {
        return asTRBL(b4).bottom - asTRBL(a6).bottom;
      }
    } else {
      if (reference === "start") {
        return asTRBL(b4).left - asTRBL(a6).right;
      } else if (reference === "center") {
        return getMid(b4).x - asTRBL(a6).right;
      } else {
        return asTRBL(b4).right - asTRBL(a6).right;
      }
    }
  }
  var sourcesDistances = source.incoming.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance4 = weight < 0 ? getDistance4(connection.source, source) : getDistance4(source, connection.source);
    return {
      id: connection.source.id,
      distance: distance4,
      weight
    };
  });
  var targetsDistances = source.outgoing.filter(filter2).map(function(connection) {
    var weight = getWeight(connection);
    var distance4 = weight > 0 ? getDistance4(source, connection.target) : getDistance4(connection.target, source);
    return {
      id: connection.target.id,
      distance: distance4,
      weight
    };
  });
  var distances = sourcesDistances.concat(targetsDistances).reduce(function(accumulator, currentValue) {
    accumulator[currentValue.id + "__weight_" + currentValue.weight] = currentValue;
    return accumulator;
  }, {});
  var distancesGrouped = reduce(distances, function(accumulator, currentValue) {
    var distance4 = currentValue.distance, weight = currentValue.weight;
    if (distance4 < 0 || distance4 > maxDistance) {
      return accumulator;
    }
    if (!accumulator[String(distance4)]) {
      accumulator[String(distance4)] = 0;
    }
    accumulator[String(distance4)] += 1 * weight;
    if (!accumulator.distance || accumulator[accumulator.distance] < accumulator[String(distance4)]) {
      accumulator.distance = distance4;
    }
    return accumulator;
  }, {});
  return distancesGrouped.distance || defaultDistance;
}
function getAutoPlaceClosure(source) {
  var allConnected = getConnected(source);
  if (source.host) {
    allConnected = allConnected.concat(getConnected(source.host));
  }
  if (source.attachers) {
    allConnected = allConnected.concat(source.attachers.reduce(function(shapes, attacher) {
      return shapes.concat(getConnected(attacher));
    }, []));
  }
  return allConnected;
}
function getConnected(element) {
  return getTargets(element).concat(getSources(element));
}
function getSources(shape) {
  return shape.incoming.map(function(connection) {
    return connection.source;
  });
}
function getTargets(shape) {
  return shape.outgoing.map(function(connection) {
    return connection.target;
  });
}
function noneFilter() {
  return true;
}

// node_modules/diagram-js/lib/features/auto-place/AutoPlace.js
var LOW_PRIORITY6 = 100;
function AutoPlace(eventBus, modeling, canvas) {
  eventBus.on("autoPlace", LOW_PRIORITY6, function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition(source, shape);
  });
  eventBus.on("autoPlace.end", function(event2) {
    canvas.scrollToElement(event2.shape);
  });
  this.append = function(source, shape, hints) {
    eventBus.fire("autoPlace.start", {
      source,
      shape
    });
    var position = eventBus.fire("autoPlace", {
      source,
      shape
    });
    var newShape = modeling.appendShape(source, shape, position, source.parent, hints);
    eventBus.fire("autoPlace.end", {
      source,
      shape: newShape
    });
    return newShape;
  };
}
AutoPlace.$inject = [
  "eventBus",
  "modeling",
  "canvas"
];
function getNewShapePosition(source, element, hints) {
  if (!hints) {
    hints = {};
  }
  var distance4 = hints.defaultDistance || DEFAULT_DISTANCE;
  var sourceMid = getMid(source), sourceTrbl = asTRBL(source);
  return {
    x: sourceTrbl.right + distance4 + element.width / 2,
    y: sourceMid.y
  };
}

// node_modules/diagram-js/lib/features/auto-place/AutoPlaceSelectionBehavior.js
function AutoPlaceSelectionBehavior(eventBus, selection2) {
  eventBus.on("autoPlace.end", 500, function(e8) {
    selection2.select(e8.shape);
  });
}
AutoPlaceSelectionBehavior.$inject = [
  "eventBus",
  "selection"
];

// node_modules/diagram-js/lib/features/auto-place/index.js
var auto_place_default = {
  __init__: ["autoPlaceSelectionBehavior"],
  autoPlace: ["type", AutoPlace],
  autoPlaceSelectionBehavior: ["type", AutoPlaceSelectionBehavior]
};

// node_modules/bpmn-js/lib/features/modeling/util/ModelingUtil.js
function getParent2(element, anyType) {
  if (isString(anyType)) {
    anyType = [anyType];
  }
  while (element = element.parent) {
    if (isAny(element, anyType)) {
      return element;
    }
  }
  return null;
}
function isDirectionHorizontal(element, elementRegistry) {
  var parent = getParent2(element, "bpmn:Process");
  if (parent) {
    return true;
  }
  var types3 = ["bpmn:Participant", "bpmn:Lane"];
  parent = getParent2(element, types3);
  if (parent) {
    return isHorizontal(parent);
  } else if (isAny(element, types3)) {
    return isHorizontal(element);
  }
  var process2;
  for (process2 = getBusinessObject(element); process2; process2 = process2.$parent) {
    if (is(process2, "bpmn:Process")) {
      break;
    }
  }
  if (!elementRegistry) {
    return true;
  }
  var pool = elementRegistry.find(function(shape) {
    var businessObject = getBusinessObject(shape);
    return businessObject && businessObject.get("processRef") === process2;
  });
  if (!pool) {
    return true;
  }
  return isHorizontal(pool);
}

// node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlaceUtil.js
function getNewShapePosition2(source, element, elementRegistry) {
  var placeHorizontally = isDirectionHorizontal(source, elementRegistry);
  if (is(element, "bpmn:TextAnnotation")) {
    return getTextAnnotationPosition(source, element, placeHorizontally);
  }
  if (isAny(element, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    return getDataElementPosition(source, element, placeHorizontally);
  }
  if (is(element, "bpmn:FlowNode")) {
    return getFlowNodePosition(source, element, placeHorizontally);
  }
}
function getFlowNodePosition(source, element, placeHorizontally) {
  var sourceTrbl = asTRBL(source);
  var sourceMid = getMid(source);
  var placement = placeHorizontally ? {
    directionHint: "e",
    minDistance: 80,
    baseOrientation: "left",
    boundaryOrientation: "top",
    start: "top",
    end: "bottom"
  } : {
    directionHint: "s",
    minDistance: 90,
    baseOrientation: "top",
    boundaryOrientation: "left",
    start: "left",
    end: "right"
  };
  var connectedDistance = getConnectedDistance(source, {
    filter: function(connection) {
      return is(connection, "bpmn:SequenceFlow");
    },
    direction: placement.directionHint
  });
  var margin = 30, minDistance = placement.minDistance, orientation = placement.baseOrientation;
  if (is(source, "bpmn:BoundaryEvent")) {
    orientation = getOrientation(source, source.host, -25);
    if (orientation.indexOf(placement.boundaryOrientation) !== -1) {
      margin *= -1;
    }
  }
  var position = placeHorizontally ? {
    x: sourceTrbl.right + connectedDistance + element.width / 2,
    y: sourceMid.y + getDistance(orientation, minDistance, placement)
  } : {
    x: sourceMid.x + getDistance(orientation, minDistance, placement),
    y: sourceTrbl.bottom + connectedDistance + element.height / 2
  };
  var nextPosition = {
    margin,
    minDistance
  };
  var nextPositionDirection = placeHorizontally ? {
    y: nextPosition
  } : {
    x: nextPosition
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDistance(orientation, minDistance, placement) {
  if (orientation.includes(placement.start)) {
    return -1 * minDistance;
  } else if (orientation.includes(placement.end)) {
    return minDistance;
  } else {
    return 0;
  }
}
function getTextAnnotationPosition(source, element, placeHorizontally) {
  var sourceTrbl = asTRBL(source);
  var position = placeHorizontally ? {
    x: sourceTrbl.right + element.width / 2,
    y: sourceTrbl.top - 50 - element.height / 2
  } : {
    x: sourceTrbl.right + 50 + element.width / 2,
    y: sourceTrbl.bottom + element.height / 2
  };
  if (isConnection(source)) {
    position = getMid(source);
    if (placeHorizontally) {
      position.x += 100;
      position.y -= 50;
    } else {
      position.x += 100;
      position.y += 50;
    }
  }
  var nextPosition = {
    margin: placeHorizontally ? -30 : 30,
    minDistance: 20
  };
  var nextPositionDirection = placeHorizontally ? {
    y: nextPosition
  } : {
    x: nextPosition
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}
function getDataElementPosition(source, element, placeHorizontally) {
  var sourceTrbl = asTRBL(source);
  var position = placeHorizontally ? {
    x: sourceTrbl.right - 10 + element.width / 2,
    y: sourceTrbl.bottom + 40 + element.width / 2
  } : {
    x: sourceTrbl.left - 40 - element.width / 2,
    y: sourceTrbl.bottom - 10 + element.height / 2
  };
  var nextPosition = {
    margin: 30,
    minDistance: 30
  };
  var nextPositionDirection = placeHorizontally ? {
    x: nextPosition
  } : {
    y: nextPosition
  };
  return findFreePosition(source, element, position, generateGetNextPosition(nextPositionDirection));
}

// node_modules/bpmn-js/lib/features/auto-place/BpmnAutoPlace.js
function AutoPlace2(eventBus, elementRegistry) {
  eventBus.on("autoPlace", function(context) {
    var shape = context.shape, source = context.source;
    return getNewShapePosition2(source, shape, elementRegistry);
  });
}
AutoPlace2.$inject = ["eventBus", "elementRegistry"];

// node_modules/bpmn-js/lib/features/auto-place/index.js
var auto_place_default2 = {
  __depends__: [auto_place_default],
  __init__: ["bpmnAutoPlace"],
  bpmnAutoPlace: ["type", AutoPlace2]
};

// node_modules/diagram-js/lib/features/auto-resize/AutoResize.js
function AutoResize(eventBus, elementRegistry, modeling, rules) {
  CommandInterceptor.call(this, eventBus);
  this._elementRegistry = elementRegistry;
  this._modeling = modeling;
  this._rules = rules;
  var self2 = this;
  this.postExecuted(["shape.create"], function(event2) {
    var context = event2.context, hints = context.hints || {}, shape = context.shape, parent = context.parent || context.newParent;
    if (hints.autoResize === false) {
      return;
    }
    self2._expand([shape], parent);
  });
  this.postExecuted(["elements.move"], function(event2) {
    var context = event2.context, elements = flatten(values(context.closure.topLevel)), hints = context.hints;
    var autoResize = hints ? hints.autoResize : true;
    if (autoResize === false) {
      return;
    }
    var expandings = groupBy(elements, function(element) {
      return element.parent.id;
    });
    forEach(expandings, function(elements2, parentId) {
      if (isArray(autoResize)) {
        elements2 = elements2.filter(function(element) {
          return find(autoResize, matchPattern({ id: element.id }));
        });
      }
      self2._expand(elements2, parentId);
    });
  });
  this.postExecuted(["shape.toggleCollapse"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (shape.collapsed) {
      return;
    }
    self2._expand(shape.children || [], shape);
  });
  this.postExecuted(["shape.resize"], function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, parent = shape.parent;
    if (hints && hints.autoResize === false) {
      return;
    }
    if (parent) {
      self2._expand([shape], parent);
    }
  });
}
AutoResize.$inject = [
  "eventBus",
  "elementRegistry",
  "modeling",
  "rules"
];
e(AutoResize, CommandInterceptor);
AutoResize.prototype._getOptimalBounds = function(elements, target) {
  var offset = this.getOffset(target), padding = this.getPadding(target);
  var elementsTrbl = asTRBL(getBBox(elements)), targetTrbl = asTRBL(target);
  var newTrbl = {};
  if (elementsTrbl.top - targetTrbl.top < padding.top) {
    newTrbl.top = elementsTrbl.top - offset.top;
  }
  if (elementsTrbl.left - targetTrbl.left < padding.left) {
    newTrbl.left = elementsTrbl.left - offset.left;
  }
  if (targetTrbl.right - elementsTrbl.right < padding.right) {
    newTrbl.right = elementsTrbl.right + offset.right;
  }
  if (targetTrbl.bottom - elementsTrbl.bottom < padding.bottom) {
    newTrbl.bottom = elementsTrbl.bottom + offset.bottom;
  }
  return asBounds(assign({}, targetTrbl, newTrbl));
};
AutoResize.prototype._expand = function(elements, target) {
  if (typeof target === "string") {
    target = this._elementRegistry.get(target);
  }
  var allowed = this._rules.allowed("element.autoResize", {
    elements,
    target
  });
  if (!allowed) {
    return;
  }
  var newBounds = this._getOptimalBounds(elements, target);
  if (!boundsChanged(newBounds, target)) {
    return;
  }
  var resizeDirections = getResizeDirections(pick(target, ["x", "y", "width", "height"]), newBounds);
  this.resize(target, newBounds, {
    autoResize: resizeDirections
  });
  var parent = target.parent;
  if (parent) {
    this._expand([target], parent);
  }
};
AutoResize.prototype.getOffset = function(shape) {
  return { top: 60, bottom: 60, left: 100, right: 100 };
};
AutoResize.prototype.getPadding = function(shape) {
  return { top: 2, bottom: 2, left: 15, right: 15 };
};
AutoResize.prototype.resize = function(shape, newBounds, hints) {
  this._modeling.resizeShape(shape, newBounds, null, hints);
};
function boundsChanged(newBounds, oldBounds) {
  return newBounds.x !== oldBounds.x || newBounds.y !== oldBounds.y || newBounds.width !== oldBounds.width || newBounds.height !== oldBounds.height;
}
function getResizeDirections(oldBounds, newBounds) {
  var directions2 = "";
  oldBounds = asTRBL(oldBounds);
  newBounds = asTRBL(newBounds);
  if (oldBounds.top > newBounds.top) {
    directions2 = directions2.concat("n");
  }
  if (oldBounds.right < newBounds.right) {
    directions2 = directions2.concat("w");
  }
  if (oldBounds.bottom < newBounds.bottom) {
    directions2 = directions2.concat("s");
  }
  if (oldBounds.left > newBounds.left) {
    directions2 = directions2.concat("e");
  }
  return directions2;
}

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResize.js
function BpmnAutoResize(injector) {
  injector.invoke(AutoResize, this);
}
BpmnAutoResize.$inject = [
  "injector"
];
e(BpmnAutoResize, AutoResize);
BpmnAutoResize.prototype.resize = function(target, newBounds, hints) {
  if (is(target, "bpmn:Participant")) {
    this._modeling.resizeLane(target, newBounds, null, hints);
  } else {
    this._modeling.resizeShape(target, newBounds, null, hints);
  }
};

// node_modules/diagram-js/lib/features/auto-resize/AutoResizeProvider.js
function AutoResizeProvider(eventBus) {
  RuleProvider.call(this, eventBus);
  var self2 = this;
  this.addRule("element.autoResize", function(context) {
    return self2.canResize(context.elements, context.target);
  });
}
AutoResizeProvider.$inject = ["eventBus"];
e(AutoResizeProvider, RuleProvider);
AutoResizeProvider.prototype.canResize = function(elements, target) {
  return false;
};

// node_modules/bpmn-js/lib/features/auto-resize/BpmnAutoResizeProvider.js
function BpmnAutoResizeProvider(eventBus, modeling) {
  AutoResizeProvider.call(this, eventBus);
  this._modeling = modeling;
}
e(BpmnAutoResizeProvider, AutoResizeProvider);
BpmnAutoResizeProvider.$inject = [
  "eventBus",
  "modeling"
];
BpmnAutoResizeProvider.prototype.canResize = function(elements, target) {
  if (is(target.di, "bpmndi:BPMNPlane")) {
    return false;
  }
  if (!is(target, "bpmn:Participant") && !is(target, "bpmn:Lane") && !is(target, "bpmn:SubProcess")) {
    return false;
  }
  var canResize2 = true;
  forEach(elements, function(element) {
    if (is(element, "bpmn:Lane") || isLabel(element)) {
      canResize2 = false;
      return;
    }
  });
  return canResize2;
};

// node_modules/bpmn-js/lib/features/auto-resize/index.js
var auto_resize_default = {
  __init__: [
    "bpmnAutoResize",
    "bpmnAutoResizeProvider"
  ],
  bpmnAutoResize: ["type", BpmnAutoResize],
  bpmnAutoResizeProvider: ["type", BpmnAutoResizeProvider]
};

// node_modules/diagram-js/lib/features/hover-fix/HoverFix.js
var HIGH_PRIORITY = 1500;
function HoverFix(elementRegistry, eventBus, injector) {
  var self2 = this;
  var dragging = injector.get("dragging", false);
  function ensureHover(event2) {
    if (event2.hover) {
      return;
    }
    var originalEvent = event2.originalEvent;
    var gfx = self2._findTargetGfx(originalEvent);
    var element = gfx && elementRegistry.get(gfx);
    if (gfx && element) {
      event2.stopPropagation();
      dragging.hover({ element, gfx });
      dragging.move(originalEvent);
    }
  }
  if (dragging) {
    eventBus.on("drag.start", function(event2) {
      eventBus.once("drag.move", HIGH_PRIORITY, function(event3) {
        ensureHover(event3);
      });
    });
  }
  (function() {
    var hoverGfx;
    var hover;
    eventBus.on("element.hover", function(event2) {
      hoverGfx = event2.gfx;
      hover = event2.element;
    });
    eventBus.on("element.hover", HIGH_PRIORITY, function(event2) {
      if (hover) {
        eventBus.fire("element.out", {
          element: hover,
          gfx: hoverGfx
        });
      }
    });
    eventBus.on("element.out", function() {
      hoverGfx = null;
      hover = null;
    });
  })();
  this._findTargetGfx = function(event2) {
    var position, target;
    if (!(event2 instanceof MouseEvent)) {
      return;
    }
    position = toPoint(event2);
    target = document.elementFromPoint(position.x, position.y);
    return getGfx(target);
  };
}
HoverFix.$inject = [
  "elementRegistry",
  "eventBus",
  "injector"
];
function getGfx(target) {
  return closest(target, "svg, .djs-element", true);
}

// node_modules/diagram-js/lib/features/hover-fix/index.js
var hover_fix_default = {
  __init__: [
    "hoverFix"
  ],
  hoverFix: ["type", HoverFix]
};

// node_modules/diagram-js/lib/features/dragging/Dragging.js
var round2 = Math.round;
var DRAG_ACTIVE_CLS = "djs-drag-active";
function preventDefault(event2) {
  event2.preventDefault();
}
function isTouchEvent(event2) {
  return typeof TouchEvent !== "undefined" && event2 instanceof TouchEvent;
}
function getLength(point) {
  return Math.sqrt(Math.pow(point.x, 2) + Math.pow(point.y, 2));
}
function Dragging(eventBus, canvas, selection2, elementRegistry) {
  var defaultOptions = {
    threshold: 5,
    trapClick: true
  };
  var context;
  function toLocalPoint(globalPosition) {
    var viewbox = canvas.viewbox();
    var clientRect = canvas._container.getBoundingClientRect();
    return {
      x: viewbox.x + (globalPosition.x - clientRect.left) / viewbox.scale,
      y: viewbox.y + (globalPosition.y - clientRect.top) / viewbox.scale
    };
  }
  function fire(type, dragContext) {
    dragContext = dragContext || context;
    var event2 = eventBus.createEvent(
      assign(
        {},
        dragContext.payload,
        dragContext.data,
        { isTouch: dragContext.isTouch }
      )
    );
    if (eventBus.fire("drag." + type, event2) === false) {
      return false;
    }
    return eventBus.fire(dragContext.prefix + "." + type, event2);
  }
  function restoreSelection(previousSelection) {
    var existingSelection = previousSelection.filter(function(element) {
      return elementRegistry.get(element.id);
    });
    existingSelection.length && selection2.select(existingSelection);
  }
  function move2(event2, activate) {
    var payload = context.payload, displacement = context.displacement;
    var globalStart = context.globalStart, globalCurrent = toPoint(event2), globalDelta = delta(globalCurrent, globalStart);
    var localStart = context.localStart, localCurrent = toLocalPoint(globalCurrent), localDelta = delta(localCurrent, localStart);
    if (!context.active && (activate || getLength(globalDelta) > context.threshold)) {
      assign(payload, {
        x: round2(localStart.x + displacement.x),
        y: round2(localStart.y + displacement.y),
        dx: 0,
        dy: 0
      }, { originalEvent: event2 });
      if (false === fire("start")) {
        return cancel2();
      }
      context.active = true;
      if (!context.keepSelection) {
        payload.previousSelection = selection2.get();
        selection2.select(null);
      }
      if (context.cursor) {
        set3(context.cursor);
      }
      canvas.addMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    }
    stopPropagation(event2);
    if (context.active) {
      assign(payload, {
        x: round2(localCurrent.x + displacement.x),
        y: round2(localCurrent.y + displacement.y),
        dx: round2(localDelta.x),
        dy: round2(localDelta.y)
      }, { originalEvent: event2 });
      fire("move");
    }
  }
  function end(event2) {
    var previousContext, returnValue = true;
    if (context.active) {
      if (event2) {
        context.payload.originalEvent = event2;
        stopPropagation(event2);
      }
      returnValue = fire("end");
    }
    if (returnValue === false) {
      fire("rejected");
    }
    previousContext = cleanup(returnValue !== true);
    fire("ended", previousContext);
  }
  function checkCancel(event2) {
    if (isKey("Escape", event2)) {
      preventDefault(event2);
      cancel2();
    }
  }
  function trapClickAndEnd(event2) {
    var untrap;
    if (context.active) {
      untrap = install(eventBus);
      setTimeout(untrap, 400);
      preventDefault(event2);
    }
    end(event2);
  }
  function trapTouch(event2) {
    move2(event2);
  }
  function hover(event2) {
    var payload = context.payload;
    payload.hoverGfx = event2.gfx;
    payload.hover = event2.element;
    fire("hover");
  }
  function out(event2) {
    fire("out");
    var payload = context.payload;
    payload.hoverGfx = null;
    payload.hover = null;
  }
  function cancel2(restore) {
    var previousContext;
    if (!context) {
      return;
    }
    var wasActive = context.active;
    if (wasActive) {
      fire("cancel");
    }
    previousContext = cleanup(restore);
    if (wasActive) {
      fire("canceled", previousContext);
    }
  }
  function cleanup(restore) {
    var previousContext, endDrag;
    fire("cleanup");
    unset();
    if (context.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    event.unbind(document, "mousemove", move2);
    event.unbind(document, "dragstart", preventDefault);
    event.unbind(document, "selectstart", preventDefault);
    event.unbind(document, "mousedown", endDrag, true);
    event.unbind(document, "mouseup", endDrag, true);
    event.unbind(document, "keyup", checkCancel);
    event.unbind(document, "touchstart", trapTouch, true);
    event.unbind(document, "touchcancel", cancel2, true);
    event.unbind(document, "touchmove", move2, true);
    event.unbind(document, "touchend", end, true);
    eventBus.off("element.hover", hover);
    eventBus.off("element.out", out);
    canvas.removeMarker(canvas.getRootElement(), DRAG_ACTIVE_CLS);
    var previousSelection = context.payload.previousSelection;
    if (restore !== false && previousSelection && !selection2.get().length) {
      restoreSelection(previousSelection);
    }
    previousContext = context;
    context = null;
    return previousContext;
  }
  function init(event2, relativeTo, prefix3, options) {
    if (context) {
      cancel2(false);
    }
    if (typeof relativeTo === "string") {
      options = prefix3;
      prefix3 = relativeTo;
      relativeTo = null;
    }
    options = assign({}, defaultOptions, options || {});
    var data = options.data || {}, originalEvent, globalStart, localStart, endDrag, isTouch;
    if (options.trapClick) {
      endDrag = trapClickAndEnd;
    } else {
      endDrag = end;
    }
    if (event2) {
      originalEvent = getOriginal(event2) || event2;
      globalStart = toPoint(event2);
      stopPropagation(event2);
      if (originalEvent.type === "dragstart") {
        preventDefault(originalEvent);
      }
    } else {
      originalEvent = null;
      globalStart = { x: 0, y: 0 };
    }
    localStart = toLocalPoint(globalStart);
    if (!relativeTo) {
      relativeTo = localStart;
    }
    isTouch = isTouchEvent(originalEvent);
    context = assign({
      prefix: prefix3,
      data,
      payload: {},
      globalStart,
      displacement: delta(relativeTo, localStart),
      localStart,
      isTouch
    }, options);
    if (!options.manual) {
      if (isTouch) {
        event.bind(document, "touchstart", trapTouch, true);
        event.bind(document, "touchcancel", cancel2, true);
        event.bind(document, "touchmove", move2, true);
        event.bind(document, "touchend", end, true);
      } else {
        event.bind(document, "mousemove", move2);
        event.bind(document, "dragstart", preventDefault);
        event.bind(document, "selectstart", preventDefault);
        event.bind(document, "mousedown", endDrag, true);
        event.bind(document, "mouseup", endDrag, true);
      }
      event.bind(document, "keyup", checkCancel);
      eventBus.on("element.hover", hover);
      eventBus.on("element.out", out);
    }
    fire("init");
    if (options.autoActivate) {
      move2(event2, true);
    }
  }
  eventBus.on("diagram.destroy", cancel2);
  this.init = init;
  this.move = move2;
  this.hover = hover;
  this.out = out;
  this.end = end;
  this.cancel = cancel2;
  this.context = function() {
    return context;
  };
  this.setOptions = function(options) {
    assign(defaultOptions, options);
  };
}
Dragging.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "elementRegistry"
];

// node_modules/diagram-js/lib/features/dragging/index.js
var dragging_default = {
  __depends__: [
    hover_fix_default,
    selection_default
  ],
  dragging: ["type", Dragging]
};

// node_modules/diagram-js/lib/features/auto-scroll/AutoScroll.js
function AutoScroll(config, eventBus, canvas) {
  this._canvas = canvas;
  this._opts = assign({
    scrollThresholdIn: [20, 20, 20, 20],
    scrollThresholdOut: [0, 0, 0, 0],
    scrollRepeatTimeout: 15,
    scrollStep: 10
  }, config);
  var self2 = this;
  eventBus.on("drag.move", function(e8) {
    var point = self2._toBorderPoint(e8);
    self2.startScroll(point);
  });
  eventBus.on(["drag.cleanup"], function() {
    self2.stopScroll();
  });
}
AutoScroll.$inject = [
  "config.autoScroll",
  "eventBus",
  "canvas"
];
AutoScroll.prototype.startScroll = function(point) {
  var canvas = this._canvas;
  var opts = this._opts;
  var self2 = this;
  var clientRect = canvas.getContainer().getBoundingClientRect();
  var diff = [
    point.x,
    point.y,
    clientRect.width - point.x,
    clientRect.height - point.y
  ];
  this.stopScroll();
  var dx = 0, dy = 0;
  for (var i7 = 0; i7 < 4; i7++) {
    if (between(diff[i7], opts.scrollThresholdOut[i7], opts.scrollThresholdIn[i7])) {
      if (i7 === 0) {
        dx = opts.scrollStep;
      } else if (i7 == 1) {
        dy = opts.scrollStep;
      } else if (i7 == 2) {
        dx = -opts.scrollStep;
      } else if (i7 == 3) {
        dy = -opts.scrollStep;
      }
    }
  }
  if (dx !== 0 || dy !== 0) {
    canvas.scroll({ dx, dy });
    this._scrolling = setTimeout(function() {
      self2.startScroll(point);
    }, opts.scrollRepeatTimeout);
  }
};
function between(val, start, end) {
  if (start < val && val < end) {
    return true;
  }
  return false;
}
AutoScroll.prototype.stopScroll = function() {
  clearTimeout(this._scrolling);
};
AutoScroll.prototype.setOptions = function(options) {
  this._opts = assign({}, this._opts, options);
};
AutoScroll.prototype._toBorderPoint = function(event2) {
  var clientRect = this._canvas._container.getBoundingClientRect();
  var globalPosition = toPoint(event2.originalEvent);
  return {
    x: globalPosition.x - clientRect.left,
    y: globalPosition.y - clientRect.top
  };
};

// node_modules/diagram-js/lib/features/auto-scroll/index.js
var auto_scroll_default = {
  __depends__: [
    dragging_default
  ],
  __init__: ["autoScroll"],
  autoScroll: ["type", AutoScroll]
};

// node_modules/diagram-js/lib/features/rules/Rules.js
function Rules(injector) {
  this._commandStack = injector.get("commandStack", false);
}
Rules.$inject = ["injector"];
Rules.prototype.allowed = function(action, context) {
  var allowed = true;
  var commandStack = this._commandStack;
  if (commandStack) {
    allowed = commandStack.canExecute(action, context);
  }
  return allowed === void 0 ? true : allowed;
};

// node_modules/diagram-js/lib/features/rules/index.js
var rules_default = {
  __init__: ["rules"],
  rules: ["type", Rules]
};

// node_modules/diagram-js/lib/util/LineIntersection.js
var round3 = Math.round;
var max = Math.max;
function circlePath(center2, r7) {
  var x6 = center2.x, y5 = center2.y;
  return [
    ["M", x6, y5],
    ["m", 0, -r7],
    ["a", r7, r7, 0, 1, 1, 0, 2 * r7],
    ["a", r7, r7, 0, 1, 1, 0, -2 * r7],
    ["z"]
  ];
}
function linePath(points) {
  var segments = [];
  points.forEach(function(p5, idx) {
    segments.push([idx === 0 ? "M" : "L", p5.x, p5.y]);
  });
  return segments;
}
var INTERSECTION_THRESHOLD = 10;
function getBendpointIntersection(waypoints, reference) {
  var i7, w6;
  for (i7 = 0; w6 = waypoints[i7]; i7++) {
    if (pointDistance(w6, reference) <= INTERSECTION_THRESHOLD) {
      return {
        point: waypoints[i7],
        bendpoint: true,
        index: i7
      };
    }
  }
  return null;
}
function getPathIntersection(waypoints, reference) {
  var intersections = findPathIntersections(circlePath(reference, INTERSECTION_THRESHOLD), linePath(waypoints));
  var a6 = intersections[0], b4 = intersections[intersections.length - 1], idx;
  if (!a6) {
    return null;
  }
  if (a6 !== b4) {
    if (a6.segment2 !== b4.segment2) {
      idx = max(a6.segment2, b4.segment2) - 1;
      return {
        point: waypoints[idx],
        bendpoint: true,
        index: idx
      };
    }
    return {
      point: {
        x: round3(a6.x + b4.x) / 2,
        y: round3(a6.y + b4.y) / 2
      },
      index: a6.segment2
    };
  }
  return {
    point: {
      x: round3(a6.x),
      y: round3(a6.y)
    },
    index: a6.segment2
  };
}
function getApproxIntersection(waypoints, reference) {
  return getBendpointIntersection(waypoints, reference) || getPathIntersection(waypoints, reference);
}

// node_modules/diagram-js/lib/features/bendpoints/GeometricUtil.js
function vectorLength2(vector) {
  return Math.sqrt(Math.pow(vector.x, 2) + Math.pow(vector.y, 2));
}
function getAngle(line2) {
  return Math.atan((line2[1].y - line2[0].y) / (line2[1].x - line2[0].x));
}
function rotateVector(vector, angle) {
  return !angle ? vector : {
    x: Math.cos(angle) * vector.x - Math.sin(angle) * vector.y,
    y: Math.sin(angle) * vector.x + Math.cos(angle) * vector.y
  };
}
function solveLambaSystem(a6, b4, c5) {
  var system = [
    { n: a6[0] - c5[0], lambda: b4[0] },
    { n: a6[1] - c5[1], lambda: b4[1] }
  ];
  var n4 = system[0].n * b4[0] + system[1].n * b4[1], l5 = system[0].lambda * b4[0] + system[1].lambda * b4[1];
  return -n4 / l5;
}
function perpendicularFoot(point, line2) {
  var a6 = line2[0], b4 = line2[1];
  var bd = { x: b4.x - a6.x, y: b4.y - a6.y };
  var r7 = solveLambaSystem([a6.x, a6.y], [bd.x, bd.y], [point.x, point.y]);
  return { x: a6.x + r7 * bd.x, y: a6.y + r7 * bd.y };
}
function getDistancePointLine(point, line2) {
  var pfPoint = perpendicularFoot(point, line2);
  var connectionVector = {
    x: pfPoint.x - point.x,
    y: pfPoint.y - point.y
  };
  return vectorLength2(connectionVector);
}
function getDistancePointPoint(point1, point2) {
  return vectorLength2({
    x: point1.x - point2.x,
    y: point1.y - point2.y
  });
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointUtil.js
var BENDPOINT_CLS = "djs-bendpoint";
var SEGMENT_DRAGGER_CLS = "djs-segment-dragger";
function toCanvasCoordinates(canvas, event2) {
  var position = toPoint(event2), clientRect = canvas._container.getBoundingClientRect(), offset;
  offset = {
    x: clientRect.left,
    y: clientRect.top
  };
  var viewbox = canvas.viewbox();
  return {
    x: viewbox.x + (position.x - offset.x) / viewbox.scale,
    y: viewbox.y + (position.y - offset.y) / viewbox.scale
  };
}
function getConnectionIntersection(canvas, waypoints, event2) {
  var localPosition = toCanvasCoordinates(canvas, event2), intersection2 = getApproxIntersection(waypoints, localPosition);
  return intersection2;
}
function addBendpoint(parentGfx, cls) {
  var groupGfx = create("g");
  classes(groupGfx).add(BENDPOINT_CLS);
  append(parentGfx, groupGfx);
  var visual = create("circle");
  attr(visual, {
    cx: 0,
    cy: 0,
    r: 4
  });
  classes(visual).add("djs-visual");
  append(groupGfx, visual);
  var hit = create("circle");
  attr(hit, {
    cx: 0,
    cy: 0,
    r: 10
  });
  classes(hit).add("djs-hit");
  append(groupGfx, hit);
  if (cls) {
    classes(groupGfx).add(cls);
  }
  return groupGfx;
}
function createParallelDragger(parentGfx, segmentStart, segmentEnd, alignment) {
  var draggerGfx = create("g");
  append(parentGfx, draggerGfx);
  var width = 18, height = 6, padding = 11, hitWidth = calculateHitWidth(segmentStart, segmentEnd, alignment), hitHeight = height + padding;
  var visual = create("rect");
  attr(visual, {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  });
  classes(visual).add("djs-visual");
  append(draggerGfx, visual);
  var hit = create("rect");
  attr(hit, {
    x: -hitWidth / 2,
    y: -hitHeight / 2,
    width: hitWidth,
    height: hitHeight
  });
  classes(hit).add("djs-hit");
  append(draggerGfx, hit);
  rotate(draggerGfx, alignment === "v" ? 90 : 0, 0, 0);
  return draggerGfx;
}
function addSegmentDragger(parentGfx, segmentStart, segmentEnd) {
  var groupGfx = create("g"), mid4 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd);
  append(parentGfx, groupGfx);
  createParallelDragger(groupGfx, segmentStart, segmentEnd, alignment);
  classes(groupGfx).add(SEGMENT_DRAGGER_CLS);
  classes(groupGfx).add(alignment === "h" ? "horizontal" : "vertical");
  translate(groupGfx, mid4.x, mid4.y);
  return groupGfx;
}
function calculateSegmentMoveRegion(segmentLength) {
  return Math.abs(Math.round(segmentLength * 2 / 3));
}
function getClosestPointOnConnection(position, connection) {
  var segment = getClosestSegment(position, connection);
  return perpendicularFoot(position, segment);
}
function calculateHitWidth(segmentStart, segmentEnd, alignment) {
  var segmentLengthXAxis = segmentEnd.x - segmentStart.x, segmentLengthYAxis = segmentEnd.y - segmentStart.y;
  return alignment === "h" ? calculateSegmentMoveRegion(segmentLengthXAxis) : calculateSegmentMoveRegion(segmentLengthYAxis);
}
function getClosestSegment(position, connection) {
  var waypoints = connection.waypoints;
  var minDistance = Infinity, segmentIndex;
  for (var i7 = 0; i7 < waypoints.length - 1; i7++) {
    var start = waypoints[i7], end = waypoints[i7 + 1], distance4 = getDistancePointLine(position, [start, end]);
    if (distance4 < minDistance) {
      minDistance = distance4;
      segmentIndex = i7;
    }
  }
  return [waypoints[segmentIndex], waypoints[segmentIndex + 1]];
}

// node_modules/diagram-js/lib/features/bendpoints/Bendpoints.js
function Bendpoints(eventBus, canvas, interactionEvents, bendpointMove, connectionSegmentMove) {
  function isIntersectionMiddle(intersection2, waypoints, treshold) {
    var idx = intersection2.index, p5 = intersection2.point, p0, p1, mid4, aligned, xDelta, yDelta;
    if (idx <= 0 || intersection2.bendpoint) {
      return false;
    }
    p0 = waypoints[idx - 1];
    p1 = waypoints[idx];
    mid4 = getMidPoint(p0, p1), aligned = pointsAligned(p0, p1);
    xDelta = Math.abs(p5.x - mid4.x);
    yDelta = Math.abs(p5.y - mid4.y);
    return aligned && xDelta <= treshold && yDelta <= treshold;
  }
  function calculateIntersectionThreshold(connection, intersection2) {
    var waypoints = connection.waypoints, relevantSegment, alignment, segmentLength, threshold;
    if (intersection2.index <= 0 || intersection2.bendpoint) {
      return null;
    }
    relevantSegment = {
      start: waypoints[intersection2.index - 1],
      end: waypoints[intersection2.index]
    };
    alignment = pointsAligned(relevantSegment.start, relevantSegment.end);
    if (!alignment) {
      return null;
    }
    if (alignment === "h") {
      segmentLength = relevantSegment.end.x - relevantSegment.start.x;
    } else {
      segmentLength = relevantSegment.end.y - relevantSegment.start.y;
    }
    threshold = calculateSegmentMoveRegion(segmentLength) / 2;
    return threshold;
  }
  function activateBendpointMove(event2, connection) {
    var waypoints = connection.waypoints, intersection2 = getConnectionIntersection(canvas, waypoints, event2), threshold;
    if (!intersection2) {
      return;
    }
    threshold = calculateIntersectionThreshold(connection, intersection2);
    if (isIntersectionMiddle(intersection2, waypoints, threshold)) {
      connectionSegmentMove.start(event2, connection, intersection2.index);
    } else {
      bendpointMove.start(event2, connection, intersection2.index, !intersection2.bendpoint);
    }
    return true;
  }
  function bindInteractionEvents(node2, eventName, element) {
    event.bind(node2, eventName, function(event2) {
      interactionEvents.triggerMouseEvent(eventName, event2, element);
      event2.stopPropagation();
    });
  }
  function getBendpointsContainer(element, create3) {
    var layer = canvas.getLayer("overlays"), gfx = query('.djs-bendpoints[data-element-id="' + escapeCSS(element.id) + '"]', layer);
    if (!gfx && create3) {
      gfx = create("g");
      attr(gfx, { "data-element-id": element.id });
      classes(gfx).add("djs-bendpoints");
      append(layer, gfx);
      bindInteractionEvents(gfx, "mousedown", element);
      bindInteractionEvents(gfx, "click", element);
      bindInteractionEvents(gfx, "dblclick", element);
    }
    return gfx;
  }
  function getSegmentDragger(idx, parentGfx) {
    return query(
      '.djs-segment-dragger[data-segment-idx="' + idx + '"]',
      parentGfx
    );
  }
  function createBendpoints(gfx, connection) {
    connection.waypoints.forEach(function(p5, idx) {
      var bendpoint = addBendpoint(gfx);
      append(gfx, bendpoint);
      translate(bendpoint, p5.x, p5.y);
    });
    addBendpoint(gfx, "floating");
  }
  function createSegmentDraggers(gfx, connection) {
    var waypoints = connection.waypoints;
    var segmentStart, segmentEnd, segmentDraggerGfx;
    for (var i7 = 1; i7 < waypoints.length; i7++) {
      segmentStart = waypoints[i7 - 1];
      segmentEnd = waypoints[i7];
      if (pointsAligned(segmentStart, segmentEnd)) {
        segmentDraggerGfx = addSegmentDragger(gfx, segmentStart, segmentEnd);
        attr(segmentDraggerGfx, { "data-segment-idx": i7 });
        bindInteractionEvents(segmentDraggerGfx, "mousemove", connection);
      }
    }
  }
  function clearBendpoints(gfx) {
    forEach(all("." + BENDPOINT_CLS, gfx), function(node2) {
      remove(node2);
    });
  }
  function clearSegmentDraggers(gfx) {
    forEach(all("." + SEGMENT_DRAGGER_CLS, gfx), function(node2) {
      remove(node2);
    });
  }
  function addHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (!gfx) {
      gfx = getBendpointsContainer(connection, true);
      createBendpoints(gfx, connection);
      createSegmentDraggers(gfx, connection);
    }
    return gfx;
  }
  function updateHandles(connection) {
    var gfx = getBendpointsContainer(connection);
    if (gfx) {
      clearSegmentDraggers(gfx);
      clearBendpoints(gfx);
      createSegmentDraggers(gfx, connection);
      createBendpoints(gfx, connection);
    }
  }
  function updateFloatingBendpointPosition(parentGfx, intersection2) {
    var floating = query(".floating", parentGfx), point = intersection2.point;
    if (!floating) {
      return;
    }
    translate(floating, point.x, point.y);
  }
  function updateSegmentDraggerPosition(parentGfx, intersection2, waypoints) {
    var draggerGfx = getSegmentDragger(intersection2.index, parentGfx), segmentStart = waypoints[intersection2.index - 1], segmentEnd = waypoints[intersection2.index], point = intersection2.point, mid4 = getMidPoint(segmentStart, segmentEnd), alignment = pointsAligned(segmentStart, segmentEnd), draggerVisual, relativePosition;
    if (!draggerGfx) {
      return;
    }
    draggerVisual = getDraggerVisual(draggerGfx);
    relativePosition = {
      x: point.x - mid4.x,
      y: point.y - mid4.y
    };
    if (alignment === "v") {
      relativePosition = {
        x: relativePosition.y,
        y: relativePosition.x
      };
    }
    translate(draggerVisual, relativePosition.x, relativePosition.y);
  }
  eventBus.on("connection.changed", function(event2) {
    updateHandles(event2.element);
  });
  eventBus.on("connection.remove", function(event2) {
    var gfx = getBendpointsContainer(event2.element);
    if (gfx) {
      remove(gfx);
    }
  });
  eventBus.on("element.marker.update", function(event2) {
    var element = event2.element, bendpointsGfx;
    if (!element.waypoints) {
      return;
    }
    bendpointsGfx = addHandles(element);
    if (event2.add) {
      classes(bendpointsGfx).add(event2.marker);
    } else {
      classes(bendpointsGfx).remove(event2.marker);
    }
  });
  eventBus.on("element.mousemove", function(event2) {
    var element = event2.element, waypoints = element.waypoints, bendpointsGfx, intersection2;
    if (waypoints) {
      bendpointsGfx = getBendpointsContainer(element, true);
      intersection2 = getConnectionIntersection(canvas, waypoints, event2.originalEvent);
      if (!intersection2) {
        return;
      }
      updateFloatingBendpointPosition(bendpointsGfx, intersection2);
      if (!intersection2.bendpoint) {
        updateSegmentDraggerPosition(bendpointsGfx, intersection2, waypoints);
      }
    }
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = event2.originalEvent, element = event2.element;
    if (!element.waypoints) {
      return;
    }
    return activateBendpointMove(originalEvent, element);
  });
  eventBus.on("selection.changed", function(event2) {
    var newSelection = event2.newSelection, primary = newSelection[0];
    if (primary && primary.waypoints) {
      addHandles(primary);
    }
  });
  eventBus.on("element.hover", function(event2) {
    var element = event2.element;
    if (element.waypoints) {
      addHandles(element);
      interactionEvents.registerEvent(event2.gfx, "mousemove", "element.mousemove");
    }
  });
  eventBus.on("element.out", function(event2) {
    interactionEvents.unregisterEvent(event2.gfx, "mousemove", "element.mousemove");
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    if (element.waypoints) {
      var bendpointContainer = getBendpointsContainer(element);
      if (bendpointContainer) {
        attr(bendpointContainer, { "data-element-id": newId });
      }
    }
  });
  this.addHandles = addHandles;
  this.updateHandles = updateHandles;
  this.getBendpointsContainer = getBendpointsContainer;
  this.getSegmentDragger = getSegmentDragger;
}
Bendpoints.$inject = [
  "eventBus",
  "canvas",
  "interactionEvents",
  "bendpointMove",
  "connectionSegmentMove"
];
function getDraggerVisual(draggerGfx) {
  return query(".djs-visual", draggerGfx);
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointMove.js
var round4 = Math.round;
var RECONNECT_START = "reconnectStart";
var RECONNECT_END = "reconnectEnd";
var UPDATE_WAYPOINTS = "updateWaypoints";
function BendpointMove(injector, eventBus, canvas, dragging, rules, modeling) {
  this._injector = injector;
  this.start = function(event2, connection, bendpointIndex, insert) {
    var gfx = canvas.getGraphics(connection), source = connection.source, target = connection.target, waypoints = connection.waypoints, type;
    if (!insert && bendpointIndex === 0) {
      type = RECONNECT_START;
    } else if (!insert && bendpointIndex === waypoints.length - 1) {
      type = RECONNECT_END;
    } else {
      type = UPDATE_WAYPOINTS;
    }
    var command = type === UPDATE_WAYPOINTS ? "connection.updateWaypoints" : "connection.reconnect";
    var allowed = rules.allowed(command, {
      connection,
      source,
      target
    });
    if (allowed === false) {
      allowed = rules.allowed(command, {
        connection,
        source: target,
        target: source
      });
    }
    if (allowed === false) {
      return;
    }
    dragging.init(event2, "bendpoint.move", {
      data: {
        connection,
        connectionGfx: gfx,
        context: {
          allowed,
          bendpointIndex,
          connection,
          source,
          target,
          insert,
          type
        }
      }
    });
  };
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hover = event2.hover, type = context.type;
    context.hover = hover;
    var allowed;
    if (!hover) {
      return;
    }
    var command = type === UPDATE_WAYPOINTS ? "connection.updateWaypoints" : "connection.reconnect";
    allowed = context.allowed = rules.allowed(command, {
      connection,
      source: type === RECONNECT_START ? hover : source,
      target: type === RECONNECT_END ? hover : target
    });
    if (allowed) {
      context.source = type === RECONNECT_START ? hover : source;
      context.target = type === RECONNECT_END ? hover : target;
      return;
    }
    if (allowed === false) {
      allowed = context.allowed = rules.allowed(command, {
        connection,
        source: type === RECONNECT_END ? hover : target,
        target: type === RECONNECT_START ? hover : source
      });
    }
    if (allowed) {
      context.source = type === RECONNECT_END ? hover : target;
      context.target = type === RECONNECT_START ? hover : source;
    }
  });
  eventBus.on(["bendpoint.move.out", "bendpoint.move.cleanup"], function(event2) {
    var context = event2.context, type = context.type;
    context.hover = null;
    context.source = null;
    context.target = null;
    if (type !== UPDATE_WAYPOINTS) {
      context.allowed = false;
    }
  });
  eventBus.on("bendpoint.move.end", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, newWaypoints = connection.waypoints.slice(), source = context.source, target = context.target, type = context.type, hints = context.hints || {};
    var docking = {
      x: round4(event2.x),
      y: round4(event2.y)
    };
    if (!allowed) {
      return false;
    }
    if (type === UPDATE_WAYPOINTS) {
      if (insert) {
        newWaypoints.splice(bendpointIndex, 0, docking);
      } else {
        newWaypoints[bendpointIndex] = docking;
      }
      hints.bendpointMove = {
        insert,
        bendpointIndex
      };
      newWaypoints = this.cropWaypoints(connection, newWaypoints);
      modeling.updateWaypoints(connection, filterRedundantWaypoints(newWaypoints), hints);
    } else {
      if (type === RECONNECT_START) {
        hints.docking = "source";
        if (isReverse(context)) {
          hints.docking = "target";
          hints.newWaypoints = newWaypoints.reverse();
        }
      } else if (type === RECONNECT_END) {
        hints.docking = "target";
        if (isReverse(context)) {
          hints.docking = "source";
          hints.newWaypoints = newWaypoints.reverse();
        }
      }
      modeling.reconnect(connection, source, target, docking, hints);
    }
  }, this);
}
BendpointMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "rules",
  "modeling"
];
BendpointMove.prototype.cropWaypoints = function(connection, newWaypoints) {
  var connectionDocking = this._injector.get("connectionDocking", false);
  if (!connectionDocking) {
    return newWaypoints;
  }
  var waypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
  newWaypoints = connection.waypoints;
  connection.waypoints = waypoints;
  return newWaypoints;
};
function isReverse(context) {
  var hover = context.hover, source = context.source, target = context.target, type = context.type;
  if (type === RECONNECT_START) {
    return hover && target && hover === target && source !== target;
  }
  if (type === RECONNECT_END) {
    return hover && source && hover === source && source !== target;
  }
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointMovePreview.js
var RECONNECT_START2 = "reconnectStart";
var RECONNECT_END2 = "reconnectEnd";
var UPDATE_WAYPOINTS2 = "updateWaypoints";
var MARKER_OK = "connect-ok";
var MARKER_NOT_OK = "connect-not-ok";
var MARKER_CONNECT_HOVER = "connect-hover";
var MARKER_CONNECT_UPDATING = "djs-updating";
var MARKER_DRAGGER = "djs-dragging";
var HIGH_PRIORITY2 = 1100;
function BendpointMovePreview(bendpointMove, injector, eventBus, canvas) {
  this._injector = injector;
  var connectionPreview = injector.get("connectionPreview", false);
  eventBus.on("bendpoint.move.start", function(event2) {
    var context = event2.context, bendpointIndex = context.bendpointIndex, connection = context.connection, insert = context.insert, waypoints = connection.waypoints, newWaypoints = waypoints.slice();
    context.waypoints = waypoints;
    if (insert) {
      newWaypoints.splice(bendpointIndex, 0, { x: event2.x, y: event2.y });
    }
    connection.waypoints = newWaypoints;
    var draggerGfx = context.draggerGfx = addBendpoint(canvas.getLayer("overlays"));
    classes(draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_DRAGGER);
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING);
  });
  eventBus.on("bendpoint.move.hover", function(event2) {
    var context = event2.context, allowed = context.allowed, hover = context.hover, type = context.type;
    if (hover) {
      canvas.addMarker(hover, MARKER_CONNECT_HOVER);
      if (type === UPDATE_WAYPOINTS2) {
        return;
      }
      if (allowed) {
        canvas.removeMarker(hover, MARKER_NOT_OK);
        canvas.addMarker(hover, MARKER_OK);
      } else if (allowed === false) {
        canvas.removeMarker(hover, MARKER_OK);
        canvas.addMarker(hover, MARKER_NOT_OK);
      }
    }
  });
  eventBus.on([
    "bendpoint.move.out",
    "bendpoint.move.cleanup"
  ], HIGH_PRIORITY2, function(event2) {
    var context = event2.context, hover = context.hover, target = context.target;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
  });
  eventBus.on("bendpoint.move.move", function(event2) {
    var context = event2.context, allowed = context.allowed, bendpointIndex = context.bendpointIndex, draggerGfx = context.draggerGfx, hover = context.hover, type = context.type, connection = context.connection, source = connection.source, target = connection.target, newWaypoints = connection.waypoints.slice(), bendpoint = { x: event2.x, y: event2.y }, hints = context.hints || {}, drawPreviewHints = {};
    if (connectionPreview) {
      if (hints.connectionStart) {
        drawPreviewHints.connectionStart = hints.connectionStart;
      }
      if (hints.connectionEnd) {
        drawPreviewHints.connectionEnd = hints.connectionEnd;
      }
      if (type === RECONNECT_START2) {
        if (isReverse(context)) {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = target;
          drawPreviewHints.target = hover || source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || source;
          drawPreviewHints.target = target;
        }
      } else if (type === RECONNECT_END2) {
        if (isReverse(context)) {
          drawPreviewHints.connectionStart = drawPreviewHints.connectionStart || bendpoint;
          drawPreviewHints.source = hover || target;
          drawPreviewHints.target = source;
          newWaypoints = newWaypoints.reverse();
        } else {
          drawPreviewHints.connectionEnd = drawPreviewHints.connectionEnd || bendpoint;
          drawPreviewHints.source = source;
          drawPreviewHints.target = hover || target;
        }
      } else {
        drawPreviewHints.noCropping = true;
        drawPreviewHints.noLayout = true;
        newWaypoints[bendpointIndex] = bendpoint;
      }
      if (type === UPDATE_WAYPOINTS2) {
        newWaypoints = bendpointMove.cropWaypoints(connection, newWaypoints);
      }
      drawPreviewHints.waypoints = newWaypoints;
      connectionPreview.drawPreview(context, allowed, drawPreviewHints);
    }
    translate(draggerGfx, event2.x, event2.y);
  }, this);
  eventBus.on([
    "bendpoint.move.end",
    "bendpoint.move.cancel"
  ], HIGH_PRIORITY2, function(event2) {
    var context = event2.context, connection = context.connection, draggerGfx = context.draggerGfx, hover = context.hover, target = context.target, waypoints = context.waypoints;
    connection.waypoints = waypoints;
    remove(draggerGfx);
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING);
    canvas.removeMarker(connection, MARKER_DRAGGER);
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK);
      canvas.removeMarker(hover, target ? MARKER_OK : MARKER_NOT_OK);
    }
    if (connectionPreview) {
      connectionPreview.cleanUp(context);
    }
  });
}
BendpointMovePreview.$inject = [
  "bendpointMove",
  "injector",
  "eventBus",
  "canvas"
];

// node_modules/diagram-js/lib/features/bendpoints/ConnectionSegmentMove.js
var MARKER_CONNECT_HOVER2 = "connect-hover";
var MARKER_CONNECT_UPDATING2 = "djs-updating";
function axisAdd(point, axis, delta2) {
  return axisSet(point, axis, point[axis] + delta2);
}
function axisSet(point, axis, value) {
  return {
    x: axis === "x" ? value : point.x,
    y: axis === "y" ? value : point.y
  };
}
function axisFenced(position, segmentStart, segmentEnd, axis) {
  var maxValue = Math.max(segmentStart[axis], segmentEnd[axis]), minValue = Math.min(segmentStart[axis], segmentEnd[axis]);
  var padding = 20;
  var fencedValue = Math.min(Math.max(minValue + padding, position[axis]), maxValue - padding);
  return axisSet(segmentStart, axis, fencedValue);
}
function flipAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getDocking(point, referenceElement, moveAxis) {
  var referenceMid, inverseAxis;
  if (point.original) {
    return point.original;
  } else {
    referenceMid = getMid(referenceElement);
    inverseAxis = flipAxis(moveAxis);
    return axisSet(point, inverseAxis, referenceMid[inverseAxis]);
  }
}
function ConnectionSegmentMove(injector, eventBus, canvas, dragging, graphicsFactory, modeling) {
  var connectionDocking = injector.get("connectionDocking", false);
  this.start = function(event2, connection, idx) {
    var context, gfx = canvas.getGraphics(connection), segmentStartIndex = idx - 1, segmentEndIndex = idx, waypoints = connection.waypoints, segmentStart = waypoints[segmentStartIndex], segmentEnd = waypoints[segmentEndIndex], intersection2 = getConnectionIntersection(canvas, waypoints, event2), direction, axis, dragPosition;
    direction = pointsAligned(segmentStart, segmentEnd);
    if (!direction) {
      return;
    }
    axis = direction === "v" ? "x" : "y";
    if (segmentStartIndex === 0) {
      segmentStart = getDocking(segmentStart, connection.source, axis);
    }
    if (segmentEndIndex === waypoints.length - 1) {
      segmentEnd = getDocking(segmentEnd, connection.target, axis);
    }
    if (intersection2) {
      dragPosition = intersection2.point;
    } else {
      dragPosition = {
        x: (segmentStart.x + segmentEnd.x) / 2,
        y: (segmentStart.y + segmentEnd.y) / 2
      };
    }
    context = {
      connection,
      segmentStartIndex,
      segmentEndIndex,
      segmentStart,
      segmentEnd,
      axis,
      dragPosition
    };
    dragging.init(event2, dragPosition, "connectionSegment.move", {
      cursor: axis === "x" ? "resize-ew" : "resize-ns",
      data: {
        connection,
        connectionGfx: gfx,
        context
      }
    });
  };
  function cropConnection(connection, newWaypoints) {
    if (!connectionDocking) {
      return newWaypoints;
    }
    var oldWaypoints = connection.waypoints, croppedWaypoints;
    connection.waypoints = newWaypoints;
    croppedWaypoints = connectionDocking.getCroppedWaypoints(connection);
    connection.waypoints = oldWaypoints;
    return croppedWaypoints;
  }
  function redrawConnection(data) {
    graphicsFactory.update("connection", data.connection, data.connectionGfx);
  }
  function updateDragger(context, segmentOffset, event2) {
    var newWaypoints = context.newWaypoints, segmentStartIndex = context.segmentStartIndex + segmentOffset, segmentStart = newWaypoints[segmentStartIndex], segmentEndIndex = context.segmentEndIndex + segmentOffset, segmentEnd = newWaypoints[segmentEndIndex], axis = flipAxis(context.axis);
    var draggerPosition = axisFenced(event2, segmentStart, segmentEnd, axis);
    translate(context.draggerGfx, draggerPosition.x, draggerPosition.y);
  }
  function filterRedundantWaypoints2(waypoints, segmentStartIndex) {
    var segmentOffset = 0;
    var filteredWaypoints = waypoints.filter(function(r7, idx) {
      if (pointsOnLine(waypoints[idx - 1], waypoints[idx + 1], r7)) {
        segmentOffset = idx <= segmentStartIndex ? segmentOffset - 1 : segmentOffset;
        return false;
      }
      return true;
    });
    return {
      waypoints: filteredWaypoints,
      segmentOffset
    };
  }
  eventBus.on("connectionSegment.move.start", function(event2) {
    var context = event2.context, connection = event2.connection, layer = canvas.getLayer("overlays");
    context.originalWaypoints = connection.waypoints.slice();
    context.draggerGfx = addSegmentDragger(layer, context.segmentStart, context.segmentEnd);
    classes(context.draggerGfx).add("djs-dragging");
    canvas.addMarker(connection, MARKER_CONNECT_UPDATING2);
  });
  eventBus.on("connectionSegment.move.move", function(event2) {
    var context = event2.context, connection = context.connection, segmentStartIndex = context.segmentStartIndex, segmentEndIndex = context.segmentEndIndex, segmentStart = context.segmentStart, segmentEnd = context.segmentEnd, axis = context.axis;
    var newWaypoints = context.originalWaypoints.slice(), newSegmentStart = axisAdd(segmentStart, axis, event2["d" + axis]), newSegmentEnd = axisAdd(segmentEnd, axis, event2["d" + axis]);
    var waypointCount = newWaypoints.length, segmentOffset = 0;
    newWaypoints[segmentStartIndex] = newSegmentStart;
    newWaypoints[segmentEndIndex] = newSegmentEnd;
    var sourceToSegmentOrientation, targetToSegmentOrientation;
    if (segmentStartIndex < 2) {
      sourceToSegmentOrientation = getOrientation(connection.source, newSegmentStart);
      if (segmentStartIndex === 1) {
        if (sourceToSegmentOrientation === "intersect") {
          newWaypoints.shift();
          newWaypoints[0] = newSegmentStart;
          segmentOffset--;
        }
      } else {
        if (sourceToSegmentOrientation !== "intersect") {
          newWaypoints.unshift(segmentStart);
          segmentOffset++;
        }
      }
    }
    if (segmentEndIndex > waypointCount - 3) {
      targetToSegmentOrientation = getOrientation(connection.target, newSegmentEnd);
      if (segmentEndIndex === waypointCount - 2) {
        if (targetToSegmentOrientation === "intersect") {
          newWaypoints.pop();
          newWaypoints[newWaypoints.length - 1] = newSegmentEnd;
        }
      } else {
        if (targetToSegmentOrientation !== "intersect") {
          newWaypoints.push(segmentEnd);
        }
      }
    }
    context.newWaypoints = connection.waypoints = cropConnection(connection, newWaypoints);
    updateDragger(context, segmentOffset, event2);
    context.newSegmentStartIndex = segmentStartIndex + segmentOffset;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.hover", function(event2) {
    event2.context.hover = event2.hover;
    canvas.addMarker(event2.hover, MARKER_CONNECT_HOVER2);
  });
  eventBus.on([
    "connectionSegment.move.out",
    "connectionSegment.move.cleanup"
  ], function(event2) {
    var hover = event2.context.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_CONNECT_HOVER2);
    }
  });
  eventBus.on("connectionSegment.move.cleanup", function(event2) {
    var context = event2.context, connection = context.connection;
    if (context.draggerGfx) {
      remove(context.draggerGfx);
    }
    canvas.removeMarker(connection, MARKER_CONNECT_UPDATING2);
  });
  eventBus.on([
    "connectionSegment.move.cancel",
    "connectionSegment.move.end"
  ], function(event2) {
    var context = event2.context, connection = context.connection;
    connection.waypoints = context.originalWaypoints;
    redrawConnection(event2);
  });
  eventBus.on("connectionSegment.move.end", function(event2) {
    var context = event2.context, connection = context.connection, newWaypoints = context.newWaypoints, newSegmentStartIndex = context.newSegmentStartIndex;
    newWaypoints = newWaypoints.map(function(p5) {
      return {
        original: p5.original,
        x: Math.round(p5.x),
        y: Math.round(p5.y)
      };
    });
    var filtered = filterRedundantWaypoints2(newWaypoints, newSegmentStartIndex);
    var filteredWaypoints = filtered.waypoints, croppedWaypoints = cropConnection(connection, filteredWaypoints), segmentOffset = filtered.segmentOffset;
    var hints = {
      segmentMove: {
        segmentStartIndex: context.segmentStartIndex,
        newSegmentStartIndex: newSegmentStartIndex + segmentOffset
      }
    };
    modeling.updateWaypoints(connection, croppedWaypoints, hints);
  });
}
ConnectionSegmentMove.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "dragging",
  "graphicsFactory",
  "modeling"
];

// node_modules/diagram-js/lib/features/snapping/SnapUtil.js
var abs2 = Math.abs;
var round5 = Math.round;
function snapTo(value, values2, tolerance) {
  tolerance = tolerance === void 0 ? 10 : tolerance;
  var idx, snapValue;
  for (idx = 0; idx < values2.length; idx++) {
    snapValue = values2[idx];
    if (abs2(snapValue - value) <= tolerance) {
      return snapValue;
    }
  }
}
function topLeft(bounds) {
  return {
    x: bounds.x,
    y: bounds.y
  };
}
function bottomRight(bounds) {
  return {
    x: bounds.x + bounds.width,
    y: bounds.y + bounds.height
  };
}
function mid(bounds, defaultValue) {
  if (!bounds || isNaN(bounds.x) || isNaN(bounds.y)) {
    return defaultValue;
  }
  return {
    x: round5(bounds.x + bounds.width / 2),
    y: round5(bounds.y + bounds.height / 2)
  };
}
function isSnapped(event2, axis) {
  var snapped = event2.snapped;
  if (!snapped) {
    return false;
  }
  if (typeof axis === "string") {
    return snapped[axis];
  }
  return snapped.x && snapped.y;
}
function setSnapped(event2, axis, value) {
  if (typeof axis !== "string") {
    throw new Error("axis must be in [x, y]");
  }
  if (typeof value !== "number" && value !== false) {
    throw new Error("value must be Number or false");
  }
  var delta2, previousValue = event2[axis];
  var snapped = event2.snapped = event2.snapped || {};
  if (value === false) {
    snapped[axis] = false;
  } else {
    snapped[axis] = true;
    delta2 = value - previousValue;
    event2[axis] += delta2;
    event2["d" + axis] += delta2;
  }
  return previousValue;
}
function getChildren2(parent) {
  return parent.children || [];
}

// node_modules/diagram-js/lib/features/bendpoints/BendpointSnapping.js
var abs3 = Math.abs;
var round6 = Math.round;
var TOLERANCE = 10;
function BendpointSnapping(eventBus) {
  function snapTo2(values2, value) {
    if (isArray(values2)) {
      var i7 = values2.length;
      while (i7--) if (abs3(values2[i7] - value) <= TOLERANCE) {
        return values2[i7];
      }
    } else {
      values2 = +values2;
      var rem = value % values2;
      if (rem < TOLERANCE) {
        return value - rem;
      }
      if (rem > values2 - TOLERANCE) {
        return value - rem + values2;
      }
    }
    return value;
  }
  function getSnapPoint(element, event2) {
    if (element.waypoints) {
      return getClosestPointOnConnection(event2, element);
    }
    if (element.width) {
      return {
        x: round6(element.width / 2 + element.x),
        y: round6(element.height / 2 + element.y)
      };
    }
  }
  function getConnectionSegmentSnaps(event2) {
    var context = event2.context, snapPoints = context.snapPoints, connection = context.connection, waypoints = connection.waypoints, segmentStart = context.segmentStart, segmentStartIndex = context.segmentStartIndex, segmentEnd = context.segmentEnd, segmentEndIndex = context.segmentEndIndex, axis = context.axis;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [
      waypoints[segmentStartIndex - 1],
      segmentStart,
      segmentEnd,
      waypoints[segmentEndIndex + 1]
    ];
    if (segmentStartIndex < 2) {
      referenceWaypoints.unshift(getSnapPoint(connection.source, event2));
    }
    if (segmentEndIndex > waypoints.length - 3) {
      referenceWaypoints.unshift(getSnapPoint(connection.target, event2));
    }
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach(referenceWaypoints, function(p5) {
      if (p5) {
        p5 = p5.original || p5;
        if (axis === "y") {
          snapPoints.horizontal.push(p5.y);
        }
        if (axis === "x") {
          snapPoints.vertical.push(p5.x);
        }
      }
    });
    return snapPoints;
  }
  eventBus.on("connectionSegment.move.move", 1500, function(event2) {
    var snapPoints = getConnectionSegmentSnaps(event2), x6 = event2.x, y5 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(snapPoints.vertical, x6);
    sy = snapTo2(snapPoints.horizontal, y5);
    var cx = x6 - sx, cy = y5 - sy;
    assign(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: sx,
      y: sy
    });
    if (cx || snapPoints.vertical.indexOf(x6) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y5) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
  function getBendpointSnaps(context) {
    var snapPoints = context.snapPoints, waypoints = context.connection.waypoints, bendpointIndex = context.bendpointIndex;
    if (snapPoints) {
      return snapPoints;
    }
    var referenceWaypoints = [waypoints[bendpointIndex - 1], waypoints[bendpointIndex + 1]];
    context.snapPoints = snapPoints = { horizontal: [], vertical: [] };
    forEach(referenceWaypoints, function(p5) {
      if (p5) {
        p5 = p5.original || p5;
        snapPoints.horizontal.push(p5.y);
        snapPoints.vertical.push(p5.x);
      }
    });
    return snapPoints;
  }
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], 1500, function(event2) {
    var context = event2.context, hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2);
    if (!isConnection(hover) || !hoverMid || !hoverMid.x || !hoverMid.y) {
      return;
    }
    setSnapped(event2, "x", hoverMid.x);
    setSnapped(event2, "y", hoverMid.y);
  });
  eventBus.on(["bendpoint.move.move", "bendpoint.move.end"], 1500, function(event2) {
    var context = event2.context, snapPoints = getBendpointSnaps(context), hover = context.hover, hoverMid = hover && getSnapPoint(hover, event2), x6 = event2.x, y5 = event2.y, sx, sy;
    if (!snapPoints) {
      return;
    }
    sx = snapTo2(hoverMid ? snapPoints.vertical.concat([hoverMid.x]) : snapPoints.vertical, x6);
    sy = snapTo2(hoverMid ? snapPoints.horizontal.concat([hoverMid.y]) : snapPoints.horizontal, y5);
    var cx = x6 - sx, cy = y5 - sy;
    assign(event2, {
      dx: event2.dx - cx,
      dy: event2.dy - cy,
      x: event2.x - cx,
      y: event2.y - cy
    });
    if (cx || snapPoints.vertical.indexOf(x6) !== -1) {
      setSnapped(event2, "x", sx);
    }
    if (cy || snapPoints.horizontal.indexOf(y5) !== -1) {
      setSnapped(event2, "y", sy);
    }
  });
}
BendpointSnapping.$inject = ["eventBus"];

// node_modules/diagram-js/lib/features/bendpoints/index.js
var bendpoints_default = {
  __depends__: [
    dragging_default,
    rules_default
  ],
  __init__: ["bendpoints", "bendpointSnapping", "bendpointMovePreview"],
  bendpoints: ["type", Bendpoints],
  bendpointMove: ["type", BendpointMove],
  bendpointMovePreview: ["type", BendpointMovePreview],
  connectionSegmentMove: ["type", ConnectionSegmentMove],
  bendpointSnapping: ["type", BendpointSnapping]
};

// node_modules/diagram-js/lib/features/connect/Connect.js
function Connect(eventBus, dragging, modeling, rules) {
  function canConnect2(source, target) {
    return rules.allowed("connection.create", {
      source,
      target
    });
  }
  function canConnectReverse(source, target) {
    return canConnect2(target, source);
  }
  eventBus.on("connect.hover", function(event2) {
    var context = event2.context, start = context.start, hover = event2.hover, canExecute;
    context.hover = hover;
    canExecute = context.canExecute = canConnect2(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = start;
      context.target = hover;
      return;
    }
    canExecute = context.canExecute = canConnectReverse(start, hover);
    if (isNil(canExecute)) {
      return;
    }
    if (canExecute !== false) {
      context.source = hover;
      context.target = start;
    }
  });
  eventBus.on(["connect.out", "connect.cleanup"], function(event2) {
    var context = event2.context;
    context.hover = null;
    context.source = null;
    context.target = null;
    context.canExecute = false;
  });
  eventBus.on("connect.end", function(event2) {
    var context = event2.context, canExecute = context.canExecute, connectionStart = context.connectionStart, connectionEnd = {
      x: event2.x,
      y: event2.y
    }, source = context.source, target = context.target;
    if (!canExecute) {
      return false;
    }
    var attrs = null, hints = {
      connectionStart: isReverse2(context) ? connectionEnd : connectionStart,
      connectionEnd: isReverse2(context) ? connectionStart : connectionEnd
    };
    if (isObject(canExecute)) {
      attrs = canExecute;
    }
    context.connection = modeling.connect(source, target, attrs, hints);
  });
  this.start = function(event2, start, connectionStart, autoActivate) {
    if (!isObject(connectionStart)) {
      autoActivate = connectionStart;
      connectionStart = getMid(start);
    }
    dragging.init(event2, "connect", {
      autoActivate,
      data: {
        shape: start,
        context: {
          start,
          connectionStart
        }
      }
    });
  };
}
Connect.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "rules"
];
function isReverse2(context) {
  var hover = context.hover, source = context.source, target = context.target;
  return hover && source && hover === source && source !== target;
}

// node_modules/diagram-js/lib/features/connect/ConnectPreview.js
var HIGH_PRIORITY3 = 1100;
var LOW_PRIORITY7 = 900;
var MARKER_OK2 = "connect-ok";
var MARKER_NOT_OK2 = "connect-not-ok";
function ConnectPreview(injector, eventBus, canvas) {
  var connectionPreview = injector.get("connectionPreview", false);
  connectionPreview && eventBus.on("connect.move", function(event2) {
    var context = event2.context, canConnect2 = context.canExecute, hover = context.hover, source = context.source, start = context.start, startPosition = context.startPosition, target = context.target, connectionStart = context.connectionStart || startPosition, connectionEnd = context.connectionEnd || {
      x: event2.x,
      y: event2.y
    }, previewStart = connectionStart, previewEnd = connectionEnd;
    if (isReverse2(context)) {
      previewStart = connectionEnd;
      previewEnd = connectionStart;
    }
    connectionPreview.drawPreview(context, canConnect2, {
      source: source || start,
      target: target || hover,
      connectionStart: previewStart,
      connectionEnd: previewEnd
    });
  });
  eventBus.on("connect.hover", LOW_PRIORITY7, function(event2) {
    var context = event2.context, hover = event2.hover, canExecute = context.canExecute;
    if (canExecute === null) {
      return;
    }
    canvas.addMarker(hover, canExecute ? MARKER_OK2 : MARKER_NOT_OK2);
  });
  eventBus.on([
    "connect.out",
    "connect.cleanup"
  ], HIGH_PRIORITY3, function(event2) {
    var hover = event2.hover;
    if (hover) {
      canvas.removeMarker(hover, MARKER_OK2);
      canvas.removeMarker(hover, MARKER_NOT_OK2);
    }
  });
  connectionPreview && eventBus.on("connect.cleanup", function(event2) {
    connectionPreview.cleanUp(event2.context);
  });
}
ConnectPreview.$inject = [
  "injector",
  "eventBus",
  "canvas"
];

// node_modules/diagram-js/lib/features/connect/index.js
var connect_default = {
  __depends__: [
    selection_default,
    rules_default,
    dragging_default
  ],
  __init__: [
    "connectPreview"
  ],
  connect: ["type", Connect],
  connectPreview: ["type", ConnectPreview]
};

// node_modules/diagram-js/lib/features/connection-preview/ConnectionPreview.js
var MARKER_CONNECTION_PREVIEW = "djs-dragger";
function ConnectionPreview(injector, canvas, graphicsFactory, elementFactory) {
  this._canvas = canvas;
  this._graphicsFactory = graphicsFactory;
  this._elementFactory = elementFactory;
  this._connectionDocking = injector.get("connectionDocking", false);
  this._layouter = injector.get("layouter", false);
}
ConnectionPreview.$inject = [
  "injector",
  "canvas",
  "graphicsFactory",
  "elementFactory"
];
ConnectionPreview.prototype.drawPreview = function(context, canConnect2, hints) {
  hints = hints || {};
  var connectionPreviewGfx = context.connectionPreviewGfx, getConnection = context.getConnection, source = hints.source, target = hints.target, waypoints = hints.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, noLayout = hints.noLayout, noCropping = hints.noCropping, noNoop = hints.noNoop, connection;
  var self2 = this;
  if (!connectionPreviewGfx) {
    connectionPreviewGfx = context.connectionPreviewGfx = this.createConnectionPreviewGfx();
  }
  clear(connectionPreviewGfx);
  if (!getConnection) {
    getConnection = context.getConnection = cacheReturnValues(function(canConnect3, source2, target2) {
      return self2.getConnection(canConnect3, source2, target2);
    });
  }
  if (canConnect2) {
    connection = getConnection(canConnect2, source, target);
  }
  if (!connection) {
    !noNoop && this.drawNoopPreview(connectionPreviewGfx, hints);
    return;
  }
  connection.waypoints = waypoints || [];
  if (this._layouter && !noLayout) {
    connection.waypoints = this._layouter.layoutConnection(connection, {
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints: hints.waypoints || connection.waypoints
    });
  }
  if (!connection.waypoints || !connection.waypoints.length) {
    connection.waypoints = [
      source ? getMid(source) : connectionStart,
      target ? getMid(target) : connectionEnd
    ];
  }
  if (this._connectionDocking && (source || target) && !noCropping) {
    connection.waypoints = this._connectionDocking.getCroppedWaypoints(connection, source, target);
  }
  this._graphicsFactory.drawConnection(connectionPreviewGfx, connection, {
    stroke: "var(--element-dragger-color)"
  });
};
ConnectionPreview.prototype.drawNoopPreview = function(connectionPreviewGfx, hints) {
  var source = hints.source, target = hints.target, start = hints.connectionStart || getMid(source), end = hints.connectionEnd || getMid(target);
  var waypoints = this.cropWaypoints(start, end, source, target);
  var connection = this.createNoopConnection(waypoints[0], waypoints[1]);
  append(connectionPreviewGfx, connection);
};
ConnectionPreview.prototype.cropWaypoints = function(start, end, source, target) {
  var graphicsFactory = this._graphicsFactory, sourcePath = source && graphicsFactory.getShapePath(source), targetPath = target && graphicsFactory.getShapePath(target), connectionPath = graphicsFactory.getConnectionPath({ waypoints: [start, end] });
  start = source && getElementLineIntersection(sourcePath, connectionPath, true) || start;
  end = target && getElementLineIntersection(targetPath, connectionPath, false) || end;
  return [start, end];
};
ConnectionPreview.prototype.cleanUp = function(context) {
  if (context && context.connectionPreviewGfx) {
    remove(context.connectionPreviewGfx);
  }
};
ConnectionPreview.prototype.getConnection = function(canConnect2) {
  var attrs = ensureConnectionAttrs(canConnect2);
  return this._elementFactory.createConnection(attrs);
};
ConnectionPreview.prototype.createConnectionPreviewGfx = function() {
  var gfx = create("g");
  attr(gfx, {
    pointerEvents: "none"
  });
  classes(gfx).add(MARKER_CONNECTION_PREVIEW);
  append(this._canvas.getActiveLayer(), gfx);
  return gfx;
};
ConnectionPreview.prototype.createNoopConnection = function(start, end) {
  return createLine([start, end], {
    "stroke": "#333",
    "strokeDasharray": [1],
    "strokeWidth": 2,
    "pointer-events": "none"
  });
};
function cacheReturnValues(fn2) {
  var returnValues = {};
  return function(firstArgument) {
    var key = JSON.stringify(firstArgument);
    var returnValue = returnValues[key];
    if (!returnValue) {
      returnValue = returnValues[key] = fn2.apply(null, arguments);
    }
    return returnValue;
  };
}
function ensureConnectionAttrs(canConnect2) {
  if (isObject(canConnect2)) {
    return canConnect2;
  } else {
    return {};
  }
}

// node_modules/diagram-js/lib/features/connection-preview/index.js
var connection_preview_default = {
  __init__: ["connectionPreview"],
  connectionPreview: ["type", ConnectionPreview]
};

// node_modules/diagram-js/lib/features/preview-support/PreviewSupport.js
var cloneIds = new IdGenerator("ps");
var MARKER_TYPES = [
  "marker-start",
  "marker-mid",
  "marker-end"
];
var NODES_CAN_HAVE_MARKER = [
  "circle",
  "ellipse",
  "line",
  "path",
  "polygon",
  "polyline",
  "path",
  "rect"
];
function PreviewSupport(elementRegistry, eventBus, canvas, styles) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._styles = styles;
}
PreviewSupport.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas",
  "styles"
];
PreviewSupport.prototype.cleanUp = function() {
  console.warn("PreviewSupport#cleanUp is deprecated and will be removed in future versions. You do not need to manually clean up previews anymore. cf. https://github.com/bpmn-io/diagram-js/pull/906");
};
PreviewSupport.prototype.getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};
PreviewSupport.prototype.addDragger = function(element, group, gfx, className = "djs-dragger") {
  gfx = gfx || this.getGfx(element);
  var dragger = clone(gfx);
  var bbox = gfx.getBoundingClientRect();
  this._cloneMarkers(getVisual(dragger), className);
  attr(dragger, this._styles.cls(className, [], {
    x: bbox.top,
    y: bbox.left
  }));
  append(group, dragger);
  attr(dragger, "data-preview-support-element-id", element.id);
  return dragger;
};
PreviewSupport.prototype.addFrame = function(shape, group) {
  var frame = create("rect", {
    class: "djs-resize-overlay",
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  });
  append(group, frame);
  attr(frame, "data-preview-support-element-id", shape.id);
  return frame;
};
PreviewSupport.prototype._cloneMarkers = function(gfx, className = "djs-dragger", rootGfx = gfx) {
  var self2 = this;
  if (gfx.childNodes) {
    gfx.childNodes.forEach((childNode) => {
      self2._cloneMarkers(childNode, className, rootGfx);
    });
  }
  if (!canHaveMarker(gfx)) {
    return;
  }
  MARKER_TYPES.forEach(function(markerType) {
    if (attr(gfx, markerType)) {
      var marker = getMarker(gfx, markerType, self2._canvas.getContainer());
      marker && self2._cloneMarker(rootGfx, gfx, marker, markerType, className);
    }
  });
};
PreviewSupport.prototype._cloneMarker = function(parentGfx, gfx, marker, markerType, className = "djs-dragger") {
  var clonedMarkerId = [marker.id, className, cloneIds.next()].join("-");
  var copiedMarker = query("marker#" + marker.id, parentGfx);
  parentGfx = parentGfx || this._canvas._svg;
  var clonedMarker = copiedMarker || clone(marker);
  clonedMarker.id = clonedMarkerId;
  classes(clonedMarker).add(className);
  var defs = query(":scope > defs", parentGfx);
  if (!defs) {
    defs = create("defs");
    append(parentGfx, defs);
  }
  append(defs, clonedMarker);
  var reference = idToReference(clonedMarker.id);
  attr(gfx, markerType, reference);
};
function getMarker(node2, markerType, parentNode) {
  var id = referenceToId(attr(node2, markerType));
  return query("marker#" + id, parentNode || document);
}
function referenceToId(reference) {
  return reference.match(/url\(['"]?#([^'"]*)['"]?\)/)[1];
}
function idToReference(id) {
  return "url(#" + id + ")";
}
function canHaveMarker(node2) {
  return NODES_CAN_HAVE_MARKER.indexOf(node2.nodeName) !== -1;
}

// node_modules/diagram-js/lib/features/preview-support/index.js
var preview_support_default = {
  __init__: ["previewSupport"],
  previewSupport: ["type", PreviewSupport]
};

// node_modules/diagram-js/lib/features/complex-preview/ComplexPreview.js
var LAYER_NAME = "complex-preview";
var ComplexPreview = class {
  constructor(canvas, graphicsFactory, previewSupport) {
    this._canvas = canvas;
    this._graphicsFactory = graphicsFactory;
    this._previewSupport = previewSupport;
    this._markers = [];
  }
  /**
   * Create complex preview.
   *
   * @param {CreateOptions} options
   */
  create(options) {
    this.cleanUp();
    const {
      created = [],
      moved = [],
      removed = [],
      resized = []
    } = options;
    const layer = this._canvas.getLayer(LAYER_NAME);
    created.filter((element) => !isHidden(element)).forEach((element) => {
      let gfx;
      if (isConnection(element)) {
        gfx = this._graphicsFactory._createContainer("connection", create("g"));
        this._graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = this._graphicsFactory._createContainer("shape", create("g"));
        this._graphicsFactory.drawShape(getVisual(gfx), element);
        translate(gfx, element.x, element.y);
      }
      this._previewSupport.addDragger(element, layer, gfx);
    });
    moved.forEach(({ element, delta: delta2 }) => {
      this._previewSupport.addDragger(element, layer, void 0, "djs-dragging");
      this._canvas.addMarker(element, "djs-element-hidden");
      this._markers.push([element, "djs-element-hidden"]);
      const dragger = this._previewSupport.addDragger(element, layer);
      if (isConnection(element)) {
        translate(dragger, delta2.x, delta2.y);
      } else {
        translate(dragger, element.x + delta2.x, element.y + delta2.y);
      }
    });
    removed.forEach((element) => {
      this._previewSupport.addDragger(element, layer, void 0, "djs-dragging");
      this._canvas.addMarker(element, "djs-element-hidden");
      this._markers.push([element, "djs-element-hidden"]);
    });
    resized.forEach(({ shape, bounds }) => {
      this._canvas.addMarker(shape, "djs-hidden");
      this._markers.push([shape, "djs-hidden"]);
      this._previewSupport.addDragger(shape, layer, void 0, "djs-dragging");
      const gfx = this._graphicsFactory._createContainer("shape", create("g"));
      this._graphicsFactory.drawShape(getVisual(gfx), shape, {
        width: bounds.width,
        height: bounds.height
      });
      translate(gfx, bounds.x, bounds.y);
      this._previewSupport.addDragger(shape, layer, gfx);
    });
  }
  cleanUp() {
    clear(this._canvas.getLayer(LAYER_NAME));
    this._markers.forEach(([element, marker]) => this._canvas.removeMarker(element, marker));
    this._markers = [];
  }
  show() {
    this._canvas.showLayer(LAYER_NAME);
  }
  hide() {
    this._canvas.hideLayer(LAYER_NAME);
  }
};
ComplexPreview.$inject = [
  "canvas",
  "graphicsFactory",
  "previewSupport"
];
function isHidden(element) {
  return element.hidden;
}

// node_modules/diagram-js/lib/features/complex-preview/index.js
var complex_preview_default = {
  __depends__: [preview_support_default],
  __init__: ["complexPreview"],
  complexPreview: ["type", ComplexPreview]
};

// node_modules/bpmn-js/lib/features/modeling/behavior/AdaptiveLabelPositioningBehavior.js
var ALIGNMENTS = [
  "top",
  "bottom",
  "left",
  "right"
];
var ELEMENT_LABEL_DISTANCE2 = 10;
function AdaptiveLabelPositioningBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted([
    "connection.create",
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source, target = connection.target, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(source);
      checkLabelAdjustment(target);
    }
  });
  this.postExecuted([
    "label.create"
  ], function(event2) {
    var context = event2.context, shape = context.shape, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      checkLabelAdjustment(shape.labelTarget);
    }
  });
  this.postExecuted([
    "elements.create"
  ], function(event2) {
    var context = event2.context, elements = context.elements, hints = context.hints || {};
    if (hints.createElementsBehavior !== false) {
      elements.forEach(function(element) {
        checkLabelAdjustment(element);
      });
    }
  });
  function checkLabelAdjustment(element) {
    if (!hasExternalLabel(element)) {
      return;
    }
    if (isConnection(element)) {
      return;
    }
    var optimalPosition = getOptimalPosition(element);
    if (!optimalPosition) {
      return;
    }
    adjustLabelPosition(element, optimalPosition);
  }
  function adjustLabelPosition(element, orientation) {
    var elementMid = getMid(element), label = element.label, labelMid = getMid(label);
    if (!label.parent) {
      return;
    }
    var elementTrbl = asTRBL(element);
    var newLabelMid;
    switch (orientation) {
      case "top":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.top - ELEMENT_LABEL_DISTANCE2 - label.height / 2
        };
        break;
      case "left":
        newLabelMid = {
          x: elementTrbl.left - ELEMENT_LABEL_DISTANCE2 - label.width / 2,
          y: elementMid.y
        };
        break;
      case "bottom":
        newLabelMid = {
          x: elementMid.x,
          y: elementTrbl.bottom + ELEMENT_LABEL_DISTANCE2 + label.height / 2
        };
        break;
      case "right":
        newLabelMid = {
          x: elementTrbl.right + ELEMENT_LABEL_DISTANCE2 + label.width / 2,
          y: elementMid.y
        };
        break;
    }
    var delta2 = delta(newLabelMid, labelMid);
    modeling.moveShape(label, delta2);
  }
}
e(AdaptiveLabelPositioningBehavior, CommandInterceptor);
AdaptiveLabelPositioningBehavior.$inject = [
  "eventBus",
  "modeling"
];
function getTakenHostAlignments(element) {
  var hostElement = element.host, elementMid = getMid(element), hostOrientation = getOrientation(elementMid, hostElement);
  var freeAlignments;
  if (hostOrientation.indexOf("-") >= 0) {
    freeAlignments = hostOrientation.split("-");
  } else {
    freeAlignments = [hostOrientation];
  }
  var takenAlignments = ALIGNMENTS.filter(function(alignment) {
    return freeAlignments.indexOf(alignment) === -1;
  });
  return takenAlignments;
}
function getTakenConnectionAlignments(element) {
  var elementMid = getMid(element);
  var takenAlignments = [].concat(
    element.incoming.map(function(c5) {
      return c5.waypoints[c5.waypoints.length - 2];
    }),
    element.outgoing.map(function(c5) {
      return c5.waypoints[1];
    })
  ).map(function(point) {
    return getApproximateOrientation(elementMid, point);
  });
  return takenAlignments;
}
function getOptimalPosition(element) {
  var labelMid = getMid(element.label);
  var elementMid = getMid(element);
  var labelOrientation = getApproximateOrientation(elementMid, labelMid);
  if (!isAligned(labelOrientation)) {
    return;
  }
  var takenAlignments = getTakenConnectionAlignments(element);
  if (element.host) {
    var takenHostAlignments = getTakenHostAlignments(element);
    takenAlignments = takenAlignments.concat(takenHostAlignments);
  }
  var freeAlignments = ALIGNMENTS.filter(function(alignment) {
    return takenAlignments.indexOf(alignment) === -1;
  });
  if (freeAlignments.indexOf(labelOrientation) !== -1) {
    return;
  }
  return freeAlignments[0];
}
function getApproximateOrientation(p0, p1) {
  return getOrientation(p1, p0, 5);
}
function isAligned(orientation) {
  return ALIGNMENTS.indexOf(orientation) !== -1;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/AppendBehavior.js
function AppendBehavior(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.append", function(context) {
    var source = context.source, shape = context.shape;
    if (!context.position) {
      if (is(shape, "bpmn:TextAnnotation")) {
        context.position = {
          x: source.x + source.width / 2 + 75,
          y: source.y - 50 - shape.height / 2
        };
      } else {
        context.position = {
          x: source.x + source.width + 80 + shape.width / 2,
          y: source.y + source.height / 2
        };
      }
    }
  }, true);
}
e(AppendBehavior, CommandInterceptor);
AppendBehavior.$inject = [
  "eventBus"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/AssociationBehavior.js
function AssociationBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecute("shape.move", function(context) {
    var newParent = context.newParent, shape = context.shape;
    var associations2 = filter(shape.incoming.concat(shape.outgoing), function(connection) {
      return is(connection, "bpmn:Association");
    });
    forEach(associations2, function(association) {
      modeling.moveConnection(association, { x: 0, y: 0 }, newParent);
    });
  }, true);
}
e(AssociationBehavior, CommandInterceptor);
AssociationBehavior.$inject = [
  "injector",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/AttachEventBehavior.js
var LOW_PRIORITY8 = 500;
function AttachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY8, function(context) {
    var elements = context.elements;
    elements = elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace(shape, host);
    });
    if (elements.length !== 1) {
      return;
    }
    elements.map(function(element) {
      return elements.indexOf(element);
    }).forEach(function(index5) {
      var host = elements[index5];
      context.elements[index5] = self2._replaceShape(elements[index5], host);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY8, function(context) {
    var shapes = context.shapes, host = context.newHost;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    if (shouldReplace(shape, host)) {
      context.shapes = [self2._replaceShape(shape, host)];
    }
  }, true);
}
AttachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e(AttachEventBehavior, CommandInterceptor);
AttachEventBehavior.prototype._replaceShape = function(shape, host) {
  var eventDefinition = getEventDefinition(shape);
  var boundaryEvent = {
    type: "bpmn:BoundaryEvent",
    host
  };
  if (eventDefinition) {
    boundaryEvent.eventDefinitionType = eventDefinition.$type;
  }
  return this._bpmnReplace.replaceElement(shape, boundaryEvent, { layoutConnection: false });
};
function getEventDefinition(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace(shape, host) {
  return !isLabel(shape) && isAny(shape, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!host;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/BoundaryEventBehavior.js
function BoundaryEventBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getBoundaryEvents(element) {
    return filter(element.attachers, function(attacher) {
      return is(attacher, "bpmn:BoundaryEvent");
    });
  }
  this.postExecute("connection.create", function(event2) {
    var source = event2.context.source, target = event2.context.target, boundaryEvents = getBoundaryEvents(target);
    if (is(source, "bpmn:EventBasedGateway") && is(target, "bpmn:ReceiveTask") && boundaryEvents.length > 0) {
      modeling.removeElements(boundaryEvents);
    }
  });
  this.postExecute("connection.reconnect", function(event2) {
    var oldSource = event2.context.oldSource, newSource = event2.context.newSource;
    if (is(oldSource, "bpmn:Gateway") && is(newSource, "bpmn:EventBasedGateway")) {
      forEach(newSource.outgoing, function(connection) {
        var target = connection.target, attachedboundaryEvents = getBoundaryEvents(target);
        if (is(target, "bpmn:ReceiveTask") && attachedboundaryEvents.length > 0) {
          modeling.removeElements(attachedboundaryEvents);
        }
      });
    }
  });
}
BoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(BoundaryEventBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CompensateBoundaryEventBehavior.js
function CompensateBoundaryEventBehavior(eventBus, modeling, bpmnRules) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.replace", handleReplacement, true);
  this.postExecuted("shape.replace", handleReplacementPostExecuted, true);
  this.preExecute("connection.create", handleNewConnection, true);
  this.postExecuted("connection.delete", handleConnectionRemoval, true);
  this.postExecuted("connection.reconnect", handleReconnection, true);
  this.postExecuted("element.updateProperties", handlePropertiesUpdate, true);
  function handleConnectionRemoval(context) {
    const source = context.source, target = context.target;
    if (isCompensationBoundaryEvent(source) && isForCompensation(target)) {
      removeIsForCompensationProperty(target);
    }
  }
  function handleNewConnection(context) {
    const connection = context.connection, source = context.source, target = context.target;
    if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(target)) {
      addIsForCompensationProperty(target);
      removeExistingAssociations(source, [connection]);
    }
  }
  function handleReconnection(context) {
    const newTarget = context.newTarget, oldSource = context.oldSource, oldTarget = context.oldTarget;
    if (oldTarget !== newTarget) {
      const source = oldSource;
      if (isForCompensation(oldTarget)) {
        removeIsForCompensationProperty(oldTarget);
      }
      if (isCompensationBoundaryEvent(source) && isForCompensationAllowed(newTarget)) {
        addIsForCompensationProperty(newTarget);
      }
    }
  }
  function handlePropertiesUpdate(context) {
    const { element } = context;
    if (isForCompensation(element)) {
      removeDisallowedConnections(element);
      removeAttachments(element);
    } else if (isForCompensationAllowed(element)) {
      removeIncomingCompensationAssociations(element);
    }
  }
  function handleReplacement(context) {
    const {
      newData,
      oldShape
    } = context;
    if (isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType !== "bpmn:CompensateEventDefinition" || newData.type !== "bpmn:BoundaryEvent") {
      const targetConnection = oldShape.outgoing.find(
        ({ target }) => isForCompensation(target)
      );
      if (targetConnection && targetConnection.target) {
        context._connectionTarget = targetConnection.target;
      }
    } else if (!isCompensationBoundaryEvent(context.oldShape) && newData.eventDefinitionType === "bpmn:CompensateEventDefinition" && newData.type === "bpmn:BoundaryEvent") {
      const targetConnection = oldShape.outgoing.find(
        ({ target }) => isForCompensationAllowed(target)
      );
      if (targetConnection && targetConnection.target) {
        context._connectionTarget = targetConnection.target;
      }
      removeOutgoingSequenceFlows(oldShape);
    }
  }
  function handleReplacementPostExecuted(context) {
    const { _connectionTarget: target, newShape } = context;
    if (target) {
      modeling.connect(newShape, target);
    }
  }
  function addIsForCompensationProperty(target) {
    modeling.updateProperties(target, { isForCompensation: true });
  }
  function removeIsForCompensationProperty(target) {
    modeling.updateProperties(target, { isForCompensation: void 0 });
  }
  function removeDisallowedConnections(element) {
    for (const connection of element.incoming) {
      if (!bpmnRules.canConnect(connection.source, element)) {
        modeling.removeConnection(connection);
      }
    }
    for (const connection of element.outgoing) {
      if (!bpmnRules.canConnect(element, connection.target)) {
        modeling.removeConnection(connection);
      }
    }
  }
  function removeExistingAssociations(boundaryEvent, ignoredAssociations) {
    const associations2 = boundaryEvent.outgoing.filter((connection) => is(connection, "bpmn:Association"));
    const associationsToRemove = associations2.filter((association) => {
      return isForCompensation(association.target) && !ignoredAssociations.includes(association);
    });
    associationsToRemove.forEach((association) => modeling.removeConnection(association));
  }
  function removeAttachments(element) {
    const attachments = element.attachers.slice();
    if (!attachments.length) {
      return;
    }
    modeling.removeElements(attachments);
  }
  function removeIncomingCompensationAssociations(element) {
    const compensationAssociations = element.incoming.filter(
      (connection) => isCompensationBoundaryEvent(connection.source)
    );
    modeling.removeElements(compensationAssociations);
  }
  function removeOutgoingSequenceFlows(element) {
    const sequenceFlows = element.outgoing.filter(
      (connection) => is(connection, "bpmn:SequenceFlow")
    );
    modeling.removeElements(sequenceFlows);
  }
}
e(CompensateBoundaryEventBehavior, CommandInterceptor);
CompensateBoundaryEventBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules"
];
function isForCompensation(element) {
  const bo = getBusinessObject(element);
  return bo && bo.get("isForCompensation");
}
function isCompensationBoundaryEvent(element) {
  return element && is(element, "bpmn:BoundaryEvent") && hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}
function isForCompensationAllowed(element) {
  return element && is(element, "bpmn:Activity") && !isEventSubProcess(element);
}

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateBehavior.js
function CreateBehavior(injector) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.create", 1500, function(event2) {
    var context = event2.context, parent = context.parent, shape = context.shape;
    if (is(parent, "bpmn:Lane") && !is(shape, "bpmn:Lane")) {
      context.parent = getParent2(parent, "bpmn:Participant");
    }
  });
}
CreateBehavior.$inject = ["injector"];
e(CreateBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateDataObjectBehavior.js
function CreateDataObjectBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:DataObjectReference") && shape.type !== "label") {
      var dataObject = bpmnFactory.create("bpmn:DataObject");
      shape.businessObject.dataObjectRef = dataObject;
    }
  });
}
CreateDataObjectBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e(CreateDataObjectBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/CreateParticipantBehavior.js
var HORIZONTAL_PARTICIPANT_PADDING = 20;
var VERTICAL_PARTICIPANT_PADDING = 20;
var PARTICIPANT_BORDER_WIDTH = 30;
var HIGH_PRIORITY4 = 2e3;
function CreateParticipantBehavior(canvas, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGH_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is(shape, "bpmn:Participant") || !is(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var children = rootElement.children.filter(function(element) {
      return !is(element, "bpmn:Group") && !isLabel(element) && !isConnection(element);
    });
    if (!children.length) {
      return;
    }
    var childrenBBox = getBBox(children);
    var participantBounds = getParticipantBounds(shape, childrenBBox);
    assign(shape, participantBounds);
    context.createConstraints = getParticipantCreateConstraints(shape, childrenBBox);
  });
  eventBus.on("create.start", HIGH_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement(), rootElementGfx = canvas.getGraphics(rootElement);
    function ensureHoveringProcess(event3) {
      event3.element = rootElement;
      event3.gfx = rootElementGfx;
    }
    if (is(shape, "bpmn:Participant") && is(rootElement, "bpmn:Process")) {
      eventBus.on("element.hover", HIGH_PRIORITY4, ensureHoveringProcess);
      eventBus.once("create.cleanup", function() {
        eventBus.off("element.hover", ensureHoveringProcess);
      });
    }
  });
  function getOrCreateCollaboration() {
    var rootElement = canvas.getRootElement();
    if (is(rootElement, "bpmn:Collaboration")) {
      return rootElement;
    }
    return modeling.makeCollaboration();
  }
  this.preExecute("elements.create", HIGH_PRIORITY4, function(context) {
    var elements = context.elements, parent = context.parent, participant = findParticipant(elements), hints;
    if (participant && is(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      hints = context.hints = context.hints || {};
      hints.participant = participant;
      hints.process = parent;
      hints.processRef = getBusinessObject(participant).get("processRef");
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (is(shape, "bpmn:Participant") && is(parent, "bpmn:Process")) {
      context.parent = getOrCreateCollaboration();
      context.process = parent;
      context.processRef = getBusinessObject(shape).get("processRef");
    }
  }, true);
  this.execute("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || hints.process, shape = context.shape, participant = hints.participant;
    if (process2 && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", getBusinessObject(process2));
    }
  }, true);
  this.revert("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || hints.process, processRef = context.processRef || hints.processRef, shape = context.shape, participant = hints.participant;
    if (process2 && (!participant || shape === participant)) {
      getBusinessObject(shape).set("processRef", processRef);
    }
  }, true);
  this.postExecute("shape.create", function(context) {
    var hints = context.hints || {}, process2 = context.process || context.hints.process, shape = context.shape, participant = hints.participant;
    if (process2) {
      var children = process2.children.slice();
      if (!participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, shape);
      } else if (shape === participant) {
        modeling.moveElements(children, { x: 0, y: 0 }, participant);
      }
    }
  }, true);
}
CreateParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling"
];
e(CreateParticipantBehavior, CommandInterceptor);
function getParticipantBounds(shape, childrenBBox) {
  childrenBBox = {
    width: childrenBBox.width + HORIZONTAL_PARTICIPANT_PADDING * 2 + PARTICIPANT_BORDER_WIDTH,
    height: childrenBBox.height + VERTICAL_PARTICIPANT_PADDING * 2
  };
  var width = Math.max(shape.width, childrenBBox.width), height = Math.max(shape.height, childrenBBox.height);
  return {
    x: -width / 2,
    y: -height / 2,
    width,
    height
  };
}
function getParticipantCreateConstraints(shape, childrenBBox) {
  childrenBBox = asTRBL(childrenBBox);
  return {
    bottom: childrenBBox.top + shape.height / 2 - VERTICAL_PARTICIPANT_PADDING,
    left: childrenBBox.right - shape.width / 2 + HORIZONTAL_PARTICIPANT_PADDING,
    top: childrenBBox.bottom - shape.height / 2 + VERTICAL_PARTICIPANT_PADDING,
    right: childrenBBox.left + shape.width / 2 - HORIZONTAL_PARTICIPANT_PADDING - PARTICIPANT_BORDER_WIDTH
  };
}
function findParticipant(elements) {
  return find(elements, function(element) {
    return is(element, "bpmn:Participant");
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DataInputAssociationBehavior.js
var TARGET_REF_PLACEHOLDER_NAME = "__targetRef_placeholder";
function DataInputAssociationBehavior(eventBus, bpmnFactory) {
  CommandInterceptor.call(this, eventBus);
  this.executed([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  this.reverted([
    "connection.create",
    "connection.delete",
    "connection.move",
    "connection.reconnect"
  ], ifDataInputAssociation(fixTargetRef));
  function usesTargetRef(element, targetRef, removedConnection) {
    var inputAssociations = element.get("dataInputAssociations");
    return find(inputAssociations, function(association) {
      return association !== removedConnection && association.targetRef === targetRef;
    });
  }
  function getTargetRef(element, create3) {
    var properties = element.get("properties");
    var targetRefProp = find(properties, function(p5) {
      return p5.name === TARGET_REF_PLACEHOLDER_NAME;
    });
    if (!targetRefProp && create3) {
      targetRefProp = bpmnFactory.create("bpmn:Property", {
        name: TARGET_REF_PLACEHOLDER_NAME
      });
      add2(properties, targetRefProp);
    }
    return targetRefProp;
  }
  function cleanupTargetRef(element, connection) {
    var targetRefProp = getTargetRef(element);
    if (!targetRefProp) {
      return;
    }
    if (!usesTargetRef(element, targetRefProp, connection)) {
      remove3(element.get("properties"), targetRefProp);
    }
  }
  function fixTargetRef(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject, target = connection.target, targetBo = target && target.businessObject, newTarget = context.newTarget, newTargetBo = newTarget && newTarget.businessObject, oldTarget = context.oldTarget || context.target, oldTargetBo = oldTarget && oldTarget.businessObject;
    var dataAssociation = connection.businessObject, targetRefProp;
    if (oldTargetBo && oldTargetBo !== targetBo) {
      cleanupTargetRef(oldTargetBo, connectionBo);
    }
    if (newTargetBo && newTargetBo !== targetBo) {
      cleanupTargetRef(newTargetBo, connectionBo);
    }
    if (targetBo) {
      targetRefProp = getTargetRef(targetBo, true);
      dataAssociation.targetRef = targetRefProp;
    } else {
      dataAssociation.targetRef = null;
    }
  }
}
DataInputAssociationBehavior.$inject = [
  "eventBus",
  "bpmnFactory"
];
e(DataInputAssociationBehavior, CommandInterceptor);
function ifDataInputAssociation(fn2) {
  return function(event2) {
    var context = event2.context, connection = context.connection;
    if (is(connection, "bpmn:DataInputAssociation")) {
      return fn2(event2);
    }
  };
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateSemanticParentHandler.js
function UpdateSemanticParentHandler(bpmnUpdater) {
  this._bpmnUpdater = bpmnUpdater;
}
UpdateSemanticParentHandler.$inject = ["bpmnUpdater"];
UpdateSemanticParentHandler.prototype.execute = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, newSemanticParent = context.newSemanticParent, newDiParent = context.newDiParent;
  context.oldSemanticParent = dataStoreBo.$parent;
  context.oldDiParent = dataStoreDi.$parent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, newSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, newDiParent);
  return [];
};
UpdateSemanticParentHandler.prototype.revert = function(context) {
  var dataStoreBo = context.dataStoreBo, dataStoreDi = context.dataStoreDi, oldSemanticParent = context.oldSemanticParent, oldDiParent = context.oldDiParent;
  this._bpmnUpdater.updateSemanticParent(dataStoreBo, oldSemanticParent);
  this._bpmnUpdater.updateDiParent(dataStoreDi, oldDiParent);
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/behavior/DataStoreBehavior.js
function DataStoreBehavior(canvas, commandStack, elementRegistry, eventBus) {
  CommandInterceptor.call(this, eventBus);
  commandStack.registerHandler("dataStore.updateContainment", UpdateSemanticParentHandler);
  function getFirstParticipantWithProcessRef() {
    return elementRegistry.filter(function(element) {
      return is(element, "bpmn:Participant") && getBusinessObject(element).processRef;
    })[0];
  }
  function getDataStores(element) {
    return element.children.filter(function(child) {
      return is(child, "bpmn:DataStoreReference") && !child.labelTarget;
    });
  }
  function updateDataStoreParent(dataStore, newDataStoreParent) {
    var dataStoreBo = dataStore.businessObject || dataStore;
    newDataStoreParent = newDataStoreParent || getFirstParticipantWithProcessRef();
    if (newDataStoreParent) {
      var newDataStoreParentBo = newDataStoreParent.businessObject || newDataStoreParent;
      commandStack.execute("dataStore.updateContainment", {
        dataStoreBo,
        dataStoreDi: getDi(dataStore),
        newSemanticParent: newDataStoreParentBo.processRef || newDataStoreParentBo,
        newDiParent: getDi(newDataStoreParent)
      });
    }
  }
  this.preExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label") {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = false;
    }
  });
  this.preExecute("elements.move", function(event2) {
    var context = event2.context, shapes = context.shapes;
    var dataStoreReferences = shapes.filter(function(shape) {
      return is(shape, "bpmn:DataStoreReference");
    });
    if (dataStoreReferences.length) {
      if (!context.hints) {
        context.hints = {};
      }
      context.hints.autoResize = shapes.filter(function(shape) {
        return !is(shape, "bpmn:DataStoreReference");
      });
    }
  });
  this.postExecute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent;
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is(parent, "bpmn:Collaboration")) {
      updateDataStoreParent(shape);
    }
  });
  this.postExecute("shape.move", function(event2) {
    var context = event2.context, shape = context.shape, oldParent = context.oldParent, parent = shape.parent;
    if (is(oldParent, "bpmn:Collaboration")) {
      return;
    }
    if (is(shape, "bpmn:DataStoreReference") && shape.type !== "label" && is(parent, "bpmn:Collaboration")) {
      var participant = is(oldParent, "bpmn:Participant") ? oldParent : getAncestor(oldParent, "bpmn:Participant");
      updateDataStoreParent(shape, participant);
    }
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (isAny(shape, ["bpmn:Participant", "bpmn:SubProcess"]) && is(rootElement, "bpmn:Collaboration")) {
      getDataStores(rootElement).filter(function(dataStore) {
        return isDescendant(dataStore, shape);
      }).forEach(function(dataStore) {
        updateDataStoreParent(dataStore);
      });
    }
  });
  this.postExecute("canvas.updateRoot", function(event2) {
    var context = event2.context, oldRoot = context.oldRoot, newRoot = context.newRoot;
    var dataStores = getDataStores(oldRoot);
    dataStores.forEach(function(dataStore) {
      if (is(newRoot, "bpmn:Process")) {
        updateDataStoreParent(dataStore, newRoot);
      }
    });
  });
}
DataStoreBehavior.$inject = [
  "canvas",
  "commandStack",
  "elementRegistry",
  "eventBus"
];
e(DataStoreBehavior, CommandInterceptor);
function isDescendant(descendant, ancestor) {
  var descendantBo = descendant.businessObject || descendant, ancestorBo = ancestor.businessObject || ancestor;
  while (descendantBo.$parent) {
    if (descendantBo.$parent === ancestorBo.processRef || ancestorBo) {
      return true;
    }
    descendantBo = descendantBo.$parent;
  }
  return false;
}
function getAncestor(element, type) {
  while (element.parent) {
    if (is(element.parent, type)) {
      return element.parent;
    }
    element = element.parent;
  }
}

// node_modules/diagram-js/lib/features/resize/ResizeUtil.js
var max2 = Math.max;
var min = Math.min;
var DEFAULT_CHILD_BOX_PADDING = 20;
function substractTRBL(trblA, trblB) {
  return {
    top: trblA.top - trblB.top,
    right: trblA.right - trblB.right,
    bottom: trblA.bottom - trblB.bottom,
    left: trblA.left - trblB.left
  };
}
function resizeBounds(bounds, direction, delta2) {
  var dx = delta2.x, dy = delta2.y;
  var newBounds = {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  };
  if (direction.indexOf("n") !== -1) {
    newBounds.y = bounds.y + dy;
    newBounds.height = bounds.height - dy;
  } else if (direction.indexOf("s") !== -1) {
    newBounds.height = bounds.height + dy;
  }
  if (direction.indexOf("e") !== -1) {
    newBounds.width = bounds.width + dx;
  } else if (direction.indexOf("w") !== -1) {
    newBounds.x = bounds.x + dx;
    newBounds.width = bounds.width - dx;
  }
  return newBounds;
}
function resizeTRBL(bounds, resize) {
  return {
    x: bounds.x + (resize.left || 0),
    y: bounds.y + (resize.top || 0),
    width: bounds.width - (resize.left || 0) + (resize.right || 0),
    height: bounds.height - (resize.top || 0) + (resize.bottom || 0)
  };
}
function applyConstraints(attr3, trbl, resizeConstraints) {
  var value = trbl[attr3], minValue = resizeConstraints.min && resizeConstraints.min[attr3], maxValue = resizeConstraints.max && resizeConstraints.max[attr3];
  if (isNumber(minValue)) {
    value = (/top|left/.test(attr3) ? min : max2)(value, minValue);
  }
  if (isNumber(maxValue)) {
    value = (/top|left/.test(attr3) ? max2 : min)(value, maxValue);
  }
  return value;
}
function ensureConstraints(currentBounds, resizeConstraints) {
  if (!resizeConstraints) {
    return currentBounds;
  }
  var currentTrbl = asTRBL(currentBounds);
  return asBounds({
    top: applyConstraints("top", currentTrbl, resizeConstraints),
    right: applyConstraints("right", currentTrbl, resizeConstraints),
    bottom: applyConstraints("bottom", currentTrbl, resizeConstraints),
    left: applyConstraints("left", currentTrbl, resizeConstraints)
  });
}
function getMinResizeBounds(direction, currentBounds, minDimensions, childrenBounds) {
  var currentBox = asTRBL(currentBounds);
  var minBox = {
    top: /n/.test(direction) ? currentBox.bottom - minDimensions.height : currentBox.top,
    left: /w/.test(direction) ? currentBox.right - minDimensions.width : currentBox.left,
    bottom: /s/.test(direction) ? currentBox.top + minDimensions.height : currentBox.bottom,
    right: /e/.test(direction) ? currentBox.left + minDimensions.width : currentBox.right
  };
  var childrenBox = childrenBounds ? asTRBL(childrenBounds) : minBox;
  var combinedBox = {
    top: min(minBox.top, childrenBox.top),
    left: min(minBox.left, childrenBox.left),
    bottom: max2(minBox.bottom, childrenBox.bottom),
    right: max2(minBox.right, childrenBox.right)
  };
  return asBounds(combinedBox);
}
function asPadding(mayBePadding, defaultValue) {
  if (typeof mayBePadding !== "undefined") {
    return mayBePadding;
  } else {
    return DEFAULT_CHILD_BOX_PADDING;
  }
}
function addPadding(bbox, padding) {
  var left, right, top, bottom;
  if (typeof padding === "object") {
    left = asPadding(padding.left);
    right = asPadding(padding.right);
    top = asPadding(padding.top);
    bottom = asPadding(padding.bottom);
  } else {
    left = right = top = bottom = asPadding(padding);
  }
  return {
    x: bbox.x - left,
    y: bbox.y - top,
    width: bbox.width + left + right,
    height: bbox.height + top + bottom
  };
}
function isBBoxChild(element) {
  if (element.waypoints) {
    return false;
  }
  if (element.type === "label") {
    return false;
  }
  return true;
}
function computeChildrenBBox(shapeOrChildren, padding) {
  var elements;
  if (shapeOrChildren.length === void 0) {
    elements = filter(shapeOrChildren.children, isBBoxChild);
  } else {
    elements = shapeOrChildren;
  }
  if (elements.length) {
    return addPadding(getBBox(elements), padding);
  }
}

// node_modules/bpmn-js/lib/features/modeling/util/LaneUtil.js
var abs4 = Math.abs;
function getTRBLResize(oldBounds, newBounds) {
  return substractTRBL(asTRBL(newBounds), asTRBL(oldBounds));
}
var LANE_PARENTS = [
  "bpmn:Participant",
  "bpmn:Process",
  "bpmn:SubProcess"
];
var LANE_INDENTATION = 30;
function collectLanes(shape, collectedShapes) {
  collectedShapes = collectedShapes || [];
  shape.children.filter(function(s5) {
    if (is(s5, "bpmn:Lane")) {
      collectLanes(s5, collectedShapes);
      collectedShapes.push(s5);
    }
  });
  return collectedShapes;
}
function getChildLanes(shape) {
  return shape.children.filter(function(c5) {
    return is(c5, "bpmn:Lane");
  });
}
function getLanesRoot(shape) {
  return getParent2(shape, LANE_PARENTS) || shape;
}
function computeLanesResize(shape, newBounds) {
  var rootElement = getLanesRoot(shape);
  var initialShapes = is(rootElement, "bpmn:Process") ? [] : [rootElement];
  var allLanes = collectLanes(rootElement, initialShapes), shapeTrbl = asTRBL(shape), shapeNewTrbl = asTRBL(newBounds), trblResize = getTRBLResize(shape, newBounds), resizeNeeded = [];
  var isHorizontalLane = isHorizontal(shape);
  allLanes.forEach(function(other) {
    if (other === shape) {
      return;
    }
    var topResize = isHorizontalLane ? 0 : trblResize.top, rightResize = isHorizontalLane ? trblResize.right : 0, bottomResize = isHorizontalLane ? 0 : trblResize.bottom, leftResize = isHorizontalLane ? trblResize.left : 0;
    var otherTrbl = asTRBL(other);
    if (trblResize.top) {
      if (abs4(otherTrbl.bottom - shapeTrbl.top) < 10) {
        bottomResize = shapeNewTrbl.top - otherTrbl.bottom;
      }
      if (abs4(otherTrbl.top - shapeTrbl.top) < 5) {
        topResize = shapeNewTrbl.top - otherTrbl.top;
      }
    }
    if (trblResize.left) {
      if (abs4(otherTrbl.right - shapeTrbl.left) < 10) {
        rightResize = shapeNewTrbl.left - otherTrbl.right;
      }
      if (abs4(otherTrbl.left - shapeTrbl.left) < 5) {
        leftResize = shapeNewTrbl.left - otherTrbl.left;
      }
    }
    if (trblResize.bottom) {
      if (abs4(otherTrbl.top - shapeTrbl.bottom) < 10) {
        topResize = shapeNewTrbl.bottom - otherTrbl.top;
      }
      if (abs4(otherTrbl.bottom - shapeTrbl.bottom) < 5) {
        bottomResize = shapeNewTrbl.bottom - otherTrbl.bottom;
      }
    }
    if (trblResize.right) {
      if (abs4(otherTrbl.left - shapeTrbl.right) < 10) {
        leftResize = shapeNewTrbl.right - otherTrbl.left;
      }
      if (abs4(otherTrbl.right - shapeTrbl.right) < 5) {
        rightResize = shapeNewTrbl.right - otherTrbl.right;
      }
    }
    if (topResize || rightResize || bottomResize || leftResize) {
      resizeNeeded.push({
        shape: other,
        newBounds: resizeTRBL(other, {
          top: topResize,
          right: rightResize,
          bottom: bottomResize,
          left: leftResize
        })
      });
    }
  });
  return resizeNeeded;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DeleteLaneBehavior.js
var LOW_PRIORITY9 = 500;
function DeleteLaneBehavior(eventBus, spaceTool) {
  CommandInterceptor.call(this, eventBus);
  function compensateLaneDelete(shape, oldParent) {
    var isHorizontalLane = isHorizontal(shape);
    var siblings = getChildLanes(oldParent);
    var topAffected = [];
    var bottomAffected = [];
    var leftAffected = [];
    var rightAffected = [];
    eachElement(siblings, function(element) {
      if (isHorizontalLane) {
        if (element.y > shape.y) {
          bottomAffected.push(element);
        } else {
          topAffected.push(element);
        }
      } else {
        if (element.x > shape.x) {
          rightAffected.push(element);
        } else {
          leftAffected.push(element);
        }
      }
      return element.children;
    });
    if (!siblings.length) {
      return;
    }
    var offset;
    if (isHorizontalLane) {
      if (bottomAffected.length && topAffected.length) {
        offset = shape.height / 2;
      } else {
        offset = shape.height;
      }
    } else {
      if (rightAffected.length && leftAffected.length) {
        offset = shape.width / 2;
      } else {
        offset = shape.width;
      }
    }
    var topAdjustments, bottomAdjustments, leftAdjustments, rightAdjustments;
    if (topAffected.length) {
      topAdjustments = spaceTool.calculateAdjustments(
        topAffected,
        "y",
        offset,
        shape.y - 10
      );
      spaceTool.makeSpace(
        topAdjustments.movingShapes,
        topAdjustments.resizingShapes,
        { x: 0, y: offset },
        "s"
      );
    }
    if (bottomAffected.length) {
      bottomAdjustments = spaceTool.calculateAdjustments(
        bottomAffected,
        "y",
        -offset,
        shape.y + shape.height + 10
      );
      spaceTool.makeSpace(
        bottomAdjustments.movingShapes,
        bottomAdjustments.resizingShapes,
        { x: 0, y: -offset },
        "n"
      );
    }
    if (leftAffected.length) {
      leftAdjustments = spaceTool.calculateAdjustments(
        leftAffected,
        "x",
        offset,
        shape.x - 10
      );
      spaceTool.makeSpace(
        leftAdjustments.movingShapes,
        leftAdjustments.resizingShapes,
        { x: offset, y: 0 },
        "e"
      );
    }
    if (rightAffected.length) {
      rightAdjustments = spaceTool.calculateAdjustments(
        rightAffected,
        "x",
        -offset,
        shape.x + shape.width + 10
      );
      spaceTool.makeSpace(
        rightAdjustments.movingShapes,
        rightAdjustments.resizingShapes,
        { x: -offset, y: 0 },
        "w"
      );
    }
  }
  this.postExecuted("shape.delete", LOW_PRIORITY9, function(event2) {
    var context = event2.context, hints = context.hints, shape = context.shape, oldParent = context.oldParent;
    if (!is(shape, "bpmn:Lane")) {
      return;
    }
    if (hints && hints.nested) {
      return;
    }
    compensateLaneDelete(shape, oldParent);
  });
}
DeleteLaneBehavior.$inject = [
  "eventBus",
  "spaceTool"
];
e(DeleteLaneBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/DetachEventBehavior.js
var LOW_PRIORITY10 = 500;
function DetachEventBehavior(bpmnReplace, injector) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  var self2 = this;
  this.postExecuted("elements.create", LOW_PRIORITY10, function(context) {
    var elements = context.elements;
    elements.filter(function(shape) {
      var host = shape.host;
      return shouldReplace2(shape, host);
    }).map(function(shape) {
      return elements.indexOf(shape);
    }).forEach(function(index5) {
      context.elements[index5] = self2._replaceShape(elements[index5]);
    });
  }, true);
  this.preExecute("elements.move", LOW_PRIORITY10, function(context) {
    var shapes = context.shapes, newHost = context.newHost;
    shapes.forEach(function(shape, index5) {
      var host = shape.host;
      if (shouldReplace2(shape, includes(shapes, host) ? host : newHost)) {
        shapes[index5] = self2._replaceShape(shape);
      }
    });
  }, true);
}
DetachEventBehavior.$inject = [
  "bpmnReplace",
  "injector"
];
e(DetachEventBehavior, CommandInterceptor);
DetachEventBehavior.prototype._replaceShape = function(shape) {
  var eventDefinition = getEventDefinition2(shape), intermediateEvent;
  if (eventDefinition) {
    intermediateEvent = {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: eventDefinition.$type
    };
  } else {
    intermediateEvent = {
      type: "bpmn:IntermediateThrowEvent"
    };
  }
  return this._bpmnReplace.replaceElement(shape, intermediateEvent, { layoutConnection: false });
};
function getEventDefinition2(element) {
  var businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function shouldReplace2(shape, host) {
  return !isLabel(shape) && is(shape, "bpmn:BoundaryEvent") && !host;
}
function includes(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/DropOnFlowBehavior.js
function DropOnFlowBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  function insertShape(shape, targetFlow, positionOrBounds) {
    var waypoints = targetFlow.waypoints, waypointsBefore, waypointsAfter, dockingPoint, source, target, incomingConnection, outgoingConnection, oldOutgoing = shape.outgoing.slice(), oldIncoming = shape.incoming.slice();
    var mid4;
    if (isNumber(positionOrBounds.width)) {
      mid4 = getMid(positionOrBounds);
    } else {
      mid4 = positionOrBounds;
    }
    var intersection2 = getApproxIntersection(waypoints, mid4);
    if (intersection2) {
      waypointsBefore = waypoints.slice(0, intersection2.index);
      waypointsAfter = waypoints.slice(intersection2.index + (intersection2.bendpoint ? 1 : 0));
      if (!waypointsBefore.length || !waypointsAfter.length) {
        return;
      }
      dockingPoint = intersection2.bendpoint ? waypoints[intersection2.index] : mid4;
      if (waypointsBefore.length === 1 || !isPointInsideBBox3(shape, waypointsBefore[waypointsBefore.length - 1])) {
        waypointsBefore.push(copy(dockingPoint));
      }
      if (waypointsAfter.length === 1 || !isPointInsideBBox3(shape, waypointsAfter[0])) {
        waypointsAfter.unshift(copy(dockingPoint));
      }
    }
    source = targetFlow.source;
    target = targetFlow.target;
    if (bpmnRules.canConnect(source, shape, targetFlow)) {
      modeling.reconnectEnd(targetFlow, shape, waypointsBefore || mid4);
      incomingConnection = targetFlow;
    }
    if (bpmnRules.canConnect(shape, target, targetFlow)) {
      if (!incomingConnection) {
        modeling.reconnectStart(targetFlow, shape, waypointsAfter || mid4);
        outgoingConnection = targetFlow;
      } else {
        outgoingConnection = modeling.connect(
          shape,
          target,
          { type: targetFlow.type, waypoints: waypointsAfter }
        );
      }
    }
    var duplicateConnections = [].concat(
      incomingConnection && filter(oldIncoming, function(connection) {
        return connection.source === incomingConnection.source;
      }) || [],
      outgoingConnection && filter(oldOutgoing, function(connection) {
        return connection.target === outgoingConnection.target;
      }) || []
    );
    if (duplicateConnections.length) {
      modeling.removeElements(duplicateConnections);
    }
  }
  this.preExecute("elements.move", function(context) {
    var newParent = context.newParent, shapes = context.shapes, delta2 = context.delta, shape = shapes[0];
    if (!shape || !newParent) {
      return;
    }
    if (newParent && newParent.waypoints) {
      context.newParent = newParent = newParent.parent;
    }
    var shapeMid = getMid(shape);
    var newShapeMid = {
      x: shapeMid.x + delta2.x,
      y: shapeMid.y + delta2.y
    };
    var connection = find(newParent.children, function(element) {
      var canInsert2 = bpmnRules.canInsert(shapes, element);
      return canInsert2 && getApproxIntersection(element.waypoints, newShapeMid);
    });
    if (connection) {
      context.targetFlow = connection;
      context.position = newShapeMid;
    }
  }, true);
  this.postExecuted("elements.move", function(context) {
    var shapes = context.shapes, targetFlow = context.targetFlow, position = context.position;
    if (targetFlow) {
      insertShape(shapes[0], targetFlow, position);
    }
  }, true);
  this.preExecute("shape.create", function(context) {
    var parent = context.parent, shape = context.shape;
    if (bpmnRules.canInsert(shape, parent)) {
      context.targetFlow = parent;
      context.parent = parent.parent;
    }
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, targetFlow = context.targetFlow, positionOrBounds = context.position;
    if (targetFlow) {
      insertShape(shape, targetFlow, positionOrBounds);
    }
  }, true);
}
e(DropOnFlowBehavior, CommandInterceptor);
DropOnFlowBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function isPointInsideBBox3(bbox, point) {
  var x6 = point.x, y5 = point.y;
  return x6 >= bbox.x && x6 <= bbox.x + bbox.width && y5 >= bbox.y && y5 <= bbox.y + bbox.height;
}
function copy(obj) {
  return assign({}, obj);
}

// node_modules/bpmn-js/lib/features/modeling/behavior/EventBasedGatewayBehavior.js
function EventBasedGatewayBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecuted("connection.create", function(event2) {
    var context = event2.context, connection = context.connection, source = context.source, target = context.target, hints = context.hints;
    if (hints && hints.createElementsBehavior === false) {
      return;
    }
    if (!isSequenceFlow(connection)) {
      return;
    }
    var sequenceFlows = [];
    if (is(source, "bpmn:EventBasedGateway")) {
      sequenceFlows = target.incoming.filter(
        (flow) => flow !== connection && isSequenceFlow(flow)
      );
    } else {
      sequenceFlows = target.incoming.filter(
        (flow) => flow !== connection && isSequenceFlow(flow) && is(flow.source, "bpmn:EventBasedGateway")
      );
    }
    sequenceFlows.forEach(function(sequenceFlow) {
      modeling.removeConnection(sequenceFlow);
    });
  });
  this.preExecuted("shape.replace", function(event2) {
    var context = event2.context, newShape = context.newShape;
    if (!is(newShape, "bpmn:EventBasedGateway")) {
      return;
    }
    var targets = newShape.outgoing.filter(isSequenceFlow).reduce(function(targets2, sequenceFlow) {
      if (!targets2.includes(sequenceFlow.target)) {
        return targets2.concat(sequenceFlow.target);
      }
      return targets2;
    }, []);
    targets.forEach(function(target) {
      target.incoming.filter(isSequenceFlow).forEach(function(sequenceFlow) {
        const sequenceFlowsFromNewShape = target.incoming.filter(isSequenceFlow).filter(function(sequenceFlow2) {
          return sequenceFlow2.source === newShape;
        });
        if (sequenceFlow.source !== newShape || sequenceFlowsFromNewShape.length > 1) {
          modeling.removeConnection(sequenceFlow);
        }
      });
    });
  });
}
EventBasedGatewayBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(EventBasedGatewayBehavior, CommandInterceptor);
function isSequenceFlow(connection) {
  return is(connection, "bpmn:SequenceFlow");
}

// node_modules/bpmn-js/lib/features/modeling/behavior/FixHoverBehavior.js
var HIGH_PRIORITY5 = 1500;
var HIGHEST_PRIORITY = 2e3;
function FixHoverBehavior(elementRegistry, eventBus, canvas) {
  eventBus.on([
    "create.hover",
    "create.move",
    "create.out",
    "create.end",
    "shape.move.hover",
    "shape.move.move",
    "shape.move.out",
    "shape.move.end"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context, shape = context.shape || event2.shape, hover = event2.hover;
    if (is(hover, "bpmn:Lane") && !isAny(shape, ["bpmn:Lane", "bpmn:Participant"])) {
      event2.hover = getLanesRoot(hover);
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
    var rootElement = canvas.getRootElement();
    if (hover !== rootElement && (shape.labelTarget || isAny(shape, ["bpmn:Group", "bpmn:TextAnnotation"]))) {
      event2.hover = rootElement;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.hover",
    "connect.out",
    "connect.end",
    "connect.cleanup",
    "global-connect.hover",
    "global-connect.out",
    "global-connect.end",
    "global-connect.cleanup"
  ], HIGH_PRIORITY5, function(event2) {
    var hover = event2.hover;
    if (is(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "bendpoint.move.hover"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context, hover = event2.hover, type = context.type;
    if (is(hover, "bpmn:Lane") && /reconnect/.test(type)) {
      event2.hover = getLanesRoot(hover) || hover;
      event2.hoverGfx = elementRegistry.getGraphics(event2.hover);
    }
  });
  eventBus.on([
    "connect.start"
  ], HIGH_PRIORITY5, function(event2) {
    var context = event2.context, start = context.start;
    if (is(start, "bpmn:Lane")) {
      context.start = getLanesRoot(start) || start;
    }
  });
  eventBus.on("shape.move.start", HIGHEST_PRIORITY, function(event2) {
    var shape = event2.shape;
    if (is(shape, "bpmn:Lane")) {
      event2.shape = getLanesRoot(shape) || shape;
    }
  });
  eventBus.on("spaceTool.move", HIGHEST_PRIORITY, function(event2) {
    var hover = event2.hover;
    if (hover && is(hover, "bpmn:Lane")) {
      event2.hover = getLanesRoot(hover);
    }
  });
}
FixHoverBehavior.$inject = [
  "elementRegistry",
  "eventBus",
  "canvas"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/util/CategoryUtil.js
function createCategory(bpmnFactory) {
  return bpmnFactory.create("bpmn:Category");
}
function createCategoryValue(bpmnFactory) {
  return bpmnFactory.create("bpmn:CategoryValue");
}
function linkCategoryValue(categoryValue, category, definitions) {
  add2(category.get("categoryValue"), categoryValue);
  categoryValue.$parent = category;
  add2(definitions.get("rootElements"), category);
  category.$parent = definitions;
  return categoryValue;
}
function unlinkCategoryValue(categoryValue) {
  var category = categoryValue.$parent;
  if (category) {
    remove3(category.get("categoryValue"), categoryValue);
    categoryValue.$parent = null;
  }
  return categoryValue;
}
function unlinkCategory(category) {
  var definitions = category.$parent;
  if (definitions) {
    remove3(definitions.get("rootElements"), category);
    category.$parent = null;
  }
  return category;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/GroupBehavior.js
var LOWER_PRIORITY = 770;
function GroupBehavior(bpmnFactory, bpmnjs, elementRegistry, eventBus, injector, moddleCopy) {
  injector.invoke(CommandInterceptor, this);
  function getGroupElements() {
    return elementRegistry.filter(function(e8) {
      return is(e8, "bpmn:Group");
    });
  }
  function isReferencedCategory(elements, category) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      var _category = businessObject.categoryValueRef && businessObject.categoryValueRef.$parent;
      return _category === category;
    });
  }
  function isReferencedCategoryValue(elements, categoryValue) {
    return elements.some(function(element) {
      var businessObject = getBusinessObject(element);
      return businessObject.categoryValueRef === categoryValue;
    });
  }
  function removeCategoryValue(categoryValue, category, businessObject) {
    var groups = getGroupElements().filter(function(element) {
      return element.businessObject !== businessObject;
    });
    if (category && !isReferencedCategory(groups, category)) {
      unlinkCategory(category);
    }
    if (categoryValue && !isReferencedCategoryValue(groups, categoryValue)) {
      unlinkCategoryValue(categoryValue);
    }
  }
  function addCategoryValue(categoryValue, category) {
    return linkCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function setCategoryValue(element, context) {
    var businessObject = getBusinessObject(element), categoryValue = businessObject.categoryValueRef;
    if (!categoryValue) {
      categoryValue = businessObject.categoryValueRef = context.categoryValue = context.categoryValue || createCategoryValue(bpmnFactory);
    }
    var category = categoryValue.$parent;
    if (!category) {
      category = categoryValue.$parent = context.category = context.category || createCategory(bpmnFactory);
    }
    addCategoryValue(categoryValue, category, bpmnjs.getDefinitions());
  }
  function unsetCategoryValue(element, context) {
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(element);
    if (categoryValue) {
      businessObject.categoryValueRef = null;
      removeCategoryValue(categoryValue, category, businessObject);
    } else {
      removeCategoryValue(null, businessObject.categoryValueRef.$parent, businessObject);
    }
  }
  this.execute("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is(labelTarget, "bpmn:Group")) {
      return;
    }
    setCategoryValue(labelTarget, context);
  });
  this.revert("label.create", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget;
    if (!is(labelTarget, "bpmn:Group")) {
      return;
    }
    unsetCategoryValue(labelTarget, context);
  });
  this.execute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, businessObject = getBusinessObject(shape);
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var categoryValue = context.categoryValue = businessObject.categoryValueRef, category;
    if (categoryValue) {
      category = context.category = categoryValue.$parent;
      removeCategoryValue(categoryValue, category, businessObject);
      businessObject.categoryValueRef = null;
    }
  });
  this.reverted("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    var category = context.category, categoryValue = context.categoryValue, businessObject = getBusinessObject(shape);
    if (categoryValue) {
      businessObject.categoryValueRef = categoryValue;
      addCategoryValue(categoryValue, category);
    }
  });
  this.execute("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      setCategoryValue(shape, context);
    }
  });
  this.reverted("shape.create", function(event2) {
    var context = event2.context, shape = context.shape;
    if (!is(shape, "bpmn:Group") || shape.labelTarget) {
      return;
    }
    if (getBusinessObject(shape).categoryValueRef) {
      unsetCategoryValue(shape, context);
    }
  });
  function copy2(bo, clone4) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone4);
  }
  eventBus.on("copyPaste.copyElement", LOWER_PRIORITY, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is(element, "bpmn:Group") || element.labelTarget) {
      return;
    }
    var groupBo = getBusinessObject(element);
    if (groupBo.categoryValueRef) {
      var categoryValue = groupBo.categoryValueRef;
      descriptor.categoryValue = copy2(categoryValue, true);
      if (categoryValue.$parent) {
        descriptor.category = copy2(categoryValue.$parent, true);
      }
    }
  });
  eventBus.on("copyPaste.pasteElement", LOWER_PRIORITY, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, categoryValue = descriptor.categoryValue, category = descriptor.category;
    if (categoryValue) {
      categoryValue = businessObject.categoryValueRef = copy2(categoryValue);
    }
    if (category) {
      categoryValue.$parent = copy2(category);
    }
    delete descriptor.category;
    delete descriptor.categoryValue;
  });
}
GroupBehavior.$inject = [
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry",
  "eventBus",
  "injector",
  "moddleCopy"
];
e(GroupBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LineIntersect.js
function lineIntersect(l1s, l1e, l2s, l2e) {
  var denominator, a6, b4, c5, numerator;
  denominator = (l2e.y - l2s.y) * (l1e.x - l1s.x) - (l2e.x - l2s.x) * (l1e.y - l1s.y);
  if (denominator == 0) {
    return null;
  }
  a6 = l1s.y - l2s.y;
  b4 = l1s.x - l2s.x;
  numerator = (l2e.x - l2s.x) * a6 - (l2e.y - l2s.y) * b4;
  c5 = numerator / denominator;
  return {
    x: Math.round(l1s.x + c5 * (l1e.x - l1s.x)),
    y: Math.round(l1s.y + c5 * (l1e.y - l1s.y))
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ImportDockingFix.js
function ImportDockingFix(eventBus) {
  function adjustDocking(startPoint, nextPoint, elementMid) {
    var elementTop = {
      x: elementMid.x,
      y: elementMid.y - 50
    };
    var elementLeft = {
      x: elementMid.x - 50,
      y: elementMid.y
    };
    var verticalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementTop), horizontalIntersect = lineIntersect(startPoint, nextPoint, elementMid, elementLeft);
    var centerIntersect;
    if (verticalIntersect && horizontalIntersect) {
      if (getDistance2(verticalIntersect, elementMid) > getDistance2(horizontalIntersect, elementMid)) {
        centerIntersect = horizontalIntersect;
      } else {
        centerIntersect = verticalIntersect;
      }
    } else {
      centerIntersect = verticalIntersect || horizontalIntersect;
    }
    startPoint.original = centerIntersect;
  }
  function fixDockings(connection) {
    var waypoints = connection.waypoints;
    adjustDocking(
      waypoints[0],
      waypoints[1],
      getMid(connection.source)
    );
    adjustDocking(
      waypoints[waypoints.length - 1],
      waypoints[waypoints.length - 2],
      getMid(connection.target)
    );
  }
  eventBus.on("bpmnElement.added", function(e8) {
    var element = e8.element;
    if (element.waypoints) {
      fixDockings(element);
    }
  });
}
ImportDockingFix.$inject = [
  "eventBus"
];
function getDistance2(p1, p22) {
  return Math.sqrt(Math.pow(p1.x - p22.x, 2) + Math.pow(p1.y - p22.y, 2));
}

// node_modules/bpmn-js/lib/features/modeling/behavior/IsHorizontalFix.js
function IsHorizontalFix(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var elementTypesToUpdate = [
    "bpmn:Participant",
    "bpmn:Lane"
  ];
  this.executed(["shape.move", "shape.create", "shape.resize"], function(event2) {
    var shape = event2.context.shape, bo = getBusinessObject(shape), di = getDi(shape);
    if (isAny(bo, elementTypesToUpdate)) {
      var isHorizontal5 = di.get("isHorizontal");
      if (isHorizontal5 === void 0) {
        isHorizontal5 = true;
      }
      di.set("isHorizontal", isHorizontal5);
    }
  });
}
IsHorizontalFix.$inject = ["eventBus"];
e(IsHorizontalFix, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LineAttachmentUtil.js
var sqrt = Math.sqrt;
var min2 = Math.min;
var max3 = Math.max;
var abs5 = Math.abs;
function sq(n4) {
  return Math.pow(n4, 2);
}
function getDistance3(p1, p22) {
  return sqrt(sq(p1.x - p22.x) + sq(p1.y - p22.y));
}
function getAttachment(point, line2) {
  var idx = 0, segmentStart, segmentEnd, segmentStartDistance, segmentEndDistance, attachmentPosition, minDistance, intersections, attachment, attachmentDistance, closestAttachmentDistance, closestAttachment;
  for (idx = 0; idx < line2.length - 1; idx++) {
    segmentStart = line2[idx];
    segmentEnd = line2[idx + 1];
    if (pointsEqual(segmentStart, segmentEnd)) {
      intersections = [segmentStart];
    } else {
      segmentStartDistance = getDistance3(point, segmentStart);
      segmentEndDistance = getDistance3(point, segmentEnd);
      minDistance = min2(segmentStartDistance, segmentEndDistance);
      intersections = getCircleSegmentIntersections(segmentStart, segmentEnd, point, minDistance);
    }
    if (intersections.length < 1) {
      throw new Error("expected between [1, 2] circle -> line intersections");
    }
    if (intersections.length === 1) {
      attachment = {
        type: "bendpoint",
        position: intersections[0],
        segmentIndex: idx,
        bendpointIndex: pointsEqual(segmentStart, intersections[0]) ? idx : idx + 1
      };
    }
    if (intersections.length === 2) {
      attachmentPosition = mid2(intersections[0], intersections[1]);
      attachment = {
        type: "segment",
        position: attachmentPosition,
        segmentIndex: idx,
        relativeLocation: getDistance3(segmentStart, attachmentPosition) / getDistance3(segmentStart, segmentEnd)
      };
    }
    attachmentDistance = getDistance3(attachment.position, point);
    if (!closestAttachment || closestAttachmentDistance > attachmentDistance) {
      closestAttachment = attachment;
      closestAttachmentDistance = attachmentDistance;
    }
  }
  return closestAttachment;
}
function getCircleSegmentIntersections(s1, s22, cc, cr) {
  var baX = s22.x - s1.x;
  var baY = s22.y - s1.y;
  var caX = cc.x - s1.x;
  var caY = cc.y - s1.y;
  var a6 = baX * baX + baY * baY;
  var bBy2 = baX * caX + baY * caY;
  var c5 = caX * caX + caY * caY - cr * cr;
  var pBy2 = bBy2 / a6;
  var q6 = c5 / a6;
  var disc = pBy2 * pBy2 - q6;
  if (disc < 0 && disc > -1e-6) {
    disc = 0;
  }
  if (disc < 0) {
    return [];
  }
  var tmpSqrt = sqrt(disc);
  var abScalingFactor1 = -pBy2 + tmpSqrt;
  var abScalingFactor2 = -pBy2 - tmpSqrt;
  var i1 = {
    x: s1.x - baX * abScalingFactor1,
    y: s1.y - baY * abScalingFactor1
  };
  if (disc === 0) {
    return [i1];
  }
  var i22 = {
    x: s1.x - baX * abScalingFactor2,
    y: s1.y - baY * abScalingFactor2
  };
  return [i1, i22].filter(function(p5) {
    return isPointInSegment(p5, s1, s22);
  });
}
function isPointInSegment(p5, segmentStart, segmentEnd) {
  return fenced(p5.x, segmentStart.x, segmentEnd.x) && fenced(p5.y, segmentStart.y, segmentEnd.y);
}
function fenced(n4, rangeStart, rangeEnd) {
  return n4 >= min2(rangeStart, rangeEnd) - EQUAL_THRESHOLD && n4 <= max3(rangeStart, rangeEnd) + EQUAL_THRESHOLD;
}
function mid2(p1, p22) {
  return {
    x: (p1.x + p22.x) / 2,
    y: (p1.y + p22.y) / 2
  };
}
var EQUAL_THRESHOLD = 0.1;
function pointsEqual(p1, p22) {
  return abs5(p1.x - p22.x) <= EQUAL_THRESHOLD && abs5(p1.y - p22.y) <= EQUAL_THRESHOLD;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LayoutUtil.js
function findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints) {
  var index5 = attachment.segmentIndex;
  var offset = newWaypoints.length - oldWaypoints.length;
  if (hints.segmentMove) {
    var oldSegmentStartIndex = hints.segmentMove.segmentStartIndex, newSegmentStartIndex = hints.segmentMove.newSegmentStartIndex;
    if (index5 === oldSegmentStartIndex) {
      return newSegmentStartIndex;
    }
    if (index5 >= newSegmentStartIndex) {
      return index5 + offset < newSegmentStartIndex ? newSegmentStartIndex : index5 + offset;
    }
    return index5;
  }
  if (hints.bendpointMove) {
    var insert = hints.bendpointMove.insert, bendpointIndex = hints.bendpointMove.bendpointIndex, newIndex;
    if (offset === 0) {
      return index5;
    }
    if (index5 >= bendpointIndex) {
      newIndex = insert ? index5 + 1 : index5 - 1;
    }
    if (index5 < bendpointIndex) {
      newIndex = index5;
      if (insert && attachment.type !== "bendpoint" && bendpointIndex - 1 === index5) {
        var rel = relativePositionMidWaypoint(newWaypoints, bendpointIndex);
        if (rel < attachment.relativeLocation) {
          newIndex++;
        }
      }
    }
    return newIndex;
  }
  if (offset === 0) {
    return index5;
  }
  if (hints.connectionStart && index5 === 0) {
    return 0;
  }
  if (hints.connectionEnd && index5 === oldWaypoints.length - 2) {
    return newWaypoints.length - 2;
  }
  return Math.floor((newWaypoints.length - 2) / 2);
}
function getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints) {
  var dx = 0, dy = 0;
  var oldPosition = {
    point: position,
    delta: { x: 0, y: 0 }
  };
  var attachment = getAttachment(position, oldWaypoints), oldLabelLineIndex = attachment.segmentIndex, newLabelLineIndex = findNewLineStartIndex(oldWaypoints, newWaypoints, attachment, hints);
  if (newLabelLineIndex < 0 || newLabelLineIndex > newWaypoints.length - 2 || newLabelLineIndex === null) {
    return oldPosition;
  }
  var oldLabelLine = getLine(oldWaypoints, oldLabelLineIndex), newLabelLine = getLine(newWaypoints, newLabelLineIndex), oldFoot = attachment.position;
  var relativeFootPosition = getRelativeFootPosition(oldLabelLine, oldFoot), angleDelta = getAngleDelta(oldLabelLine, newLabelLine);
  if (attachment.type === "bendpoint") {
    var offset = newWaypoints.length - oldWaypoints.length, oldBendpointIndex = attachment.bendpointIndex, oldBendpoint = oldWaypoints[oldBendpointIndex];
    if (newWaypoints.indexOf(oldBendpoint) !== -1) {
      return oldPosition;
    }
    if (offset === 0) {
      var newBendpoint = newWaypoints[oldBendpointIndex];
      dx = newBendpoint.x - attachment.position.x, dy = newBendpoint.y - attachment.position.y;
      return {
        delta: {
          x: dx,
          y: dy
        },
        point: {
          x: position.x + dx,
          y: position.y + dy
        }
      };
    }
    if (offset < 0 && oldBendpointIndex !== 0 && oldBendpointIndex < oldWaypoints.length - 1) {
      relativeFootPosition = relativePositionMidWaypoint(oldWaypoints, oldBendpointIndex);
    }
  }
  var newFoot = {
    x: (newLabelLine[1].x - newLabelLine[0].x) * relativeFootPosition + newLabelLine[0].x,
    y: (newLabelLine[1].y - newLabelLine[0].y) * relativeFootPosition + newLabelLine[0].y
  };
  var newLabelVector = rotateVector({
    x: position.x - oldFoot.x,
    y: position.y - oldFoot.y
  }, angleDelta);
  dx = newFoot.x + newLabelVector.x - position.x;
  dy = newFoot.y + newLabelVector.y - position.y;
  return {
    point: roundPoint(newFoot),
    delta: roundPoint({
      x: dx,
      y: dy
    })
  };
}
function relativePositionMidWaypoint(waypoints, idx) {
  var distanceSegment1 = getDistancePointPoint(waypoints[idx - 1], waypoints[idx]), distanceSegment2 = getDistancePointPoint(waypoints[idx], waypoints[idx + 1]);
  var relativePosition = distanceSegment1 / (distanceSegment1 + distanceSegment2);
  return relativePosition;
}
function getAngleDelta(l1, l22) {
  var a1 = getAngle(l1), a22 = getAngle(l22);
  return a22 - a1;
}
function getLine(waypoints, idx) {
  return [waypoints[idx], waypoints[idx + 1]];
}
function getRelativeFootPosition(line2, foot) {
  var length2 = getDistancePointPoint(line2[0], line2[1]), lengthToFoot = getDistancePointPoint(line2[0], foot);
  return length2 === 0 ? 0 : lengthToFoot / length2;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/LabelLayoutUtil.js
function getLabelAdjustment(label, newWaypoints, oldWaypoints, hints) {
  var labelPosition = getMid(label);
  return getAnchorPointAdjustment(labelPosition, newWaypoints, oldWaypoints, hints).delta;
}

// node_modules/diagram-js/lib/util/AttachUtil.js
function getNewAttachPoint(point, oldBounds, newBounds) {
  var oldCenter = center(oldBounds), newCenter = center(newBounds), oldDelta = delta(point, oldCenter);
  var newDelta = {
    x: oldDelta.x * (newBounds.width / oldBounds.width),
    y: oldDelta.y * (newBounds.height / oldBounds.height)
  };
  return roundPoint({
    x: newCenter.x + newDelta.x,
    y: newCenter.y + newDelta.y
  });
}
function getNewAttachShapeDelta(shape, oldBounds, newBounds) {
  var shapeCenter = center(shape), oldCenter = center(oldBounds), newCenter = center(newBounds), shapeDelta = delta(shape, shapeCenter), oldCenterDelta = delta(shapeCenter, oldCenter), stickyPositionDelta = getStickyPositionDelta(shapeCenter, oldBounds, newBounds);
  if (stickyPositionDelta) {
    return stickyPositionDelta;
  }
  var newCenterDelta = {
    x: oldCenterDelta.x * (newBounds.width / oldBounds.width),
    y: oldCenterDelta.y * (newBounds.height / oldBounds.height)
  };
  var newShapeCenter = {
    x: newCenter.x + newCenterDelta.x,
    y: newCenter.y + newCenterDelta.y
  };
  return roundPoint({
    x: newShapeCenter.x + shapeDelta.x - shape.x,
    y: newShapeCenter.y + shapeDelta.y - shape.y
  });
}
function getStickyPositionDelta(oldShapeCenter, oldBounds, newBounds) {
  var oldTRBL = asTRBL(oldBounds), newTRBL = asTRBL(newBounds);
  if (isMoved(oldTRBL, newTRBL)) {
    return null;
  }
  var oldOrientation = getOrientation(oldBounds, oldShapeCenter), stickyPositionDelta, newShapeCenter, newOrientation;
  if (oldOrientation === "top") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.bottom - oldTRBL.bottom
    };
  } else if (oldOrientation === "bottom") {
    stickyPositionDelta = {
      x: 0,
      y: newTRBL.top - oldTRBL.top
    };
  } else if (oldOrientation === "right") {
    stickyPositionDelta = {
      x: newTRBL.left - oldTRBL.left,
      y: 0
    };
  } else if (oldOrientation === "left") {
    stickyPositionDelta = {
      x: newTRBL.right - oldTRBL.right,
      y: 0
    };
  } else {
    return null;
  }
  newShapeCenter = {
    x: oldShapeCenter.x + stickyPositionDelta.x,
    y: oldShapeCenter.y + stickyPositionDelta.y
  };
  newOrientation = getOrientation(newBounds, newShapeCenter);
  if (newOrientation !== oldOrientation) {
    return null;
  }
  return stickyPositionDelta;
}
function isMoved(oldTRBL, newTRBL) {
  return isHorizontallyMoved(oldTRBL, newTRBL) || isVerticallyMoved(oldTRBL, newTRBL);
}
function isHorizontallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.right !== newTRBL.right && oldTRBL.left !== newTRBL.left;
}
function isVerticallyMoved(oldTRBL, newTRBL) {
  return oldTRBL.top !== newTRBL.top && oldTRBL.bottom !== newTRBL.bottom;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LabelBehavior.js
var NAME_PROPERTY = "name";
var TEXT_PROPERTY = "text";
function LabelBehavior(eventBus, modeling, bpmnFactory, textRenderer) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("element.updateProperties", onPropertyUpdate);
  this.postExecute("element.updateModdleProperties", (e8) => {
    const elementBo = getBusinessObject(e8.context.element);
    if (elementBo === e8.context.moddleElement) {
      onPropertyUpdate(e8);
    }
  });
  function onPropertyUpdate(e8) {
    var context = e8.context, element = context.element, properties = context.properties;
    if (NAME_PROPERTY in properties) {
      modeling.updateLabel(element, properties[NAME_PROPERTY]);
    }
    if (TEXT_PROPERTY in properties && is(element, "bpmn:TextAnnotation")) {
      var newBounds = textRenderer.getTextAnnotationBounds(
        {
          x: element.x,
          y: element.y,
          width: element.width,
          height: element.height
        },
        properties[TEXT_PROPERTY] || ""
      );
      modeling.updateLabel(element, properties.text, newBounds);
    }
  }
  this.postExecute(["shape.create", "connection.create"], function(e8) {
    var context = e8.context, hints = context.hints || {};
    if (hints.createElementsBehavior === false) {
      return;
    }
    var element = context.shape || context.connection;
    if (isLabel(element) || !isLabelExternal(element)) {
      return;
    }
    if (!getLabel(element)) {
      return;
    }
    modeling.updateLabel(element, getLabel(element));
  });
  this.postExecute("shape.delete", function(event2) {
    var context = event2.context, labelTarget = context.labelTarget, hints = context.hints || {};
    if (labelTarget && hints.unsetLabel !== false) {
      modeling.updateLabel(labelTarget, null, null, { removeShape: false });
    }
  });
  function getVisibleLabelAdjustment(event2) {
    var context = event2.context, connection = context.connection, label = connection.label, hints = assign({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getLabelAdjustment(label, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context, hints = context.hints || {};
    if (hints.labelBehavior === false) {
      return;
    }
    var connection = context.connection, label = connection.label, labelAdjustment;
    if (!label || !label.parent) {
      return;
    }
    labelAdjustment = getVisibleLabelAdjustment(event2);
    modeling.moveShape(label, labelAdjustment);
  });
  this.postExecute(["shape.replace"], function(event2) {
    var context = event2.context, newShape = context.newShape, oldShape = context.oldShape;
    var businessObject = getBusinessObject(newShape);
    if (businessObject && isLabelExternal(businessObject) && oldShape.label && newShape.label) {
      newShape.label.x = oldShape.label.x;
      newShape.label.y = oldShape.label.y;
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, newBounds = context.newBounds, oldBounds = context.oldBounds;
    if (hasExternalLabel(shape)) {
      var label = shape.label, labelMid = getMid(label), edges = asEdges(oldBounds);
      var referencePoint = getReferencePoint(labelMid, edges);
      var delta2 = getReferencePointDelta(referencePoint, oldBounds, newBounds);
      modeling.moveShape(label, delta2);
    }
  });
}
e(LabelBehavior, CommandInterceptor);
LabelBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnFactory",
  "textRenderer"
];
function getReferencePointDelta(referencePoint, oldBounds, newBounds) {
  var newReferencePoint = getNewAttachPoint(referencePoint, oldBounds, newBounds);
  return roundPoint(delta(newReferencePoint, referencePoint));
}
function getReferencePoint(point, lines) {
  if (!lines.length) {
    return;
  }
  var nearestLine = getNearestLine(point, lines);
  return perpendicularFoot(point, nearestLine);
}
function asEdges(bounds) {
  return [
    [
      // top
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      }
    ],
    [
      // right
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      // bottom
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      },
      {
        x: bounds.x + (bounds.width || 0),
        y: bounds.y + (bounds.height || 0)
      }
    ],
    [
      // left
      {
        x: bounds.x,
        y: bounds.y
      },
      {
        x: bounds.x,
        y: bounds.y + (bounds.height || 0)
      }
    ]
  ];
}
function getNearestLine(point, lines) {
  var distances = lines.map(function(l5) {
    return {
      line: l5,
      distance: getDistancePointLine(point, l5)
    };
  });
  var sorted = sortBy(distances, "distance");
  return sorted[0].line;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/ConnectionLayoutUtil.js
function getConnectionAdjustment(position, newWaypoints, oldWaypoints, hints) {
  return getAnchorPointAdjustment(position, newWaypoints, oldWaypoints, hints).point;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/LayoutConnectionBehavior.js
function LayoutConnectionBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  function getnewAnchorPoint(event2, point) {
    var context = event2.context, connection = context.connection, hints = assign({}, context.hints), newWaypoints = context.newWaypoints || connection.waypoints, oldWaypoints = context.oldWaypoints;
    if (typeof hints.startChanged === "undefined") {
      hints.startChanged = !!hints.connectionStart;
    }
    if (typeof hints.endChanged === "undefined") {
      hints.endChanged = !!hints.connectionEnd;
    }
    return getConnectionAdjustment(point, newWaypoints, oldWaypoints, hints);
  }
  this.postExecute([
    "connection.layout",
    "connection.updateWaypoints"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = getnewAnchorPoint(event2, endPoint);
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = getnewAnchorPoint(event2, startpoint);
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
  this.postExecute([
    "connection.move"
  ], function(event2) {
    var context = event2.context;
    var connection = context.connection, outgoing = connection.outgoing, incoming = connection.incoming, delta2 = context.delta;
    incoming.forEach(function(connection2) {
      var endPoint = connection2.waypoints[connection2.waypoints.length - 1];
      var newEndpoint = {
        x: endPoint.x + delta2.x,
        y: endPoint.y + delta2.y
      };
      var newWaypoints = [].concat(connection2.waypoints.slice(0, -1), [newEndpoint]);
      modeling.updateWaypoints(connection2, newWaypoints);
    });
    outgoing.forEach(function(connection2) {
      var startpoint = connection2.waypoints[0];
      var newStartpoint = {
        x: startpoint.x + delta2.x,
        y: startpoint.y + delta2.y
      };
      var newWaypoints = [].concat([newStartpoint], connection2.waypoints.slice(1));
      modeling.updateWaypoints(connection2, newWaypoints);
    });
  });
}
e(LayoutConnectionBehavior, CommandInterceptor);
LayoutConnectionBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/diagram-js/lib/features/modeling/cmd/helper/AnchorsHelper.js
function getResizedSourceAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[0];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[waypointsInsideNewBounds.length - 1];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getResizedTargetAnchor(connection, shape, oldBounds) {
  var waypoints = safeGetWaypoints(connection), waypointsInsideNewBounds = getWaypointsInsideBounds(waypoints, shape), oldAnchor = waypoints[waypoints.length - 1];
  if (waypointsInsideNewBounds.length) {
    return waypointsInsideNewBounds[0];
  }
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, shape);
}
function getMovedSourceAnchor(connection, source, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(source, moveDelta), oldAnchor = waypoints[0];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, source);
}
function getMovedTargetAnchor(connection, target, moveDelta) {
  var waypoints = safeGetWaypoints(connection), oldBounds = subtract(target, moveDelta), oldAnchor = waypoints[waypoints.length - 1];
  return getNewAttachPoint(oldAnchor.original || oldAnchor, oldBounds, target);
}
function subtract(bounds, delta2) {
  return {
    x: bounds.x - delta2.x,
    y: bounds.y - delta2.y,
    width: bounds.width,
    height: bounds.height
  };
}
function safeGetWaypoints(connection) {
  var waypoints = connection.waypoints;
  if (!waypoints.length) {
    throw new Error("connection#" + connection.id + ": no waypoints");
  }
  return waypoints;
}
function getWaypointsInsideBounds(waypoints, bounds) {
  var originalWaypoints = map(waypoints, getOriginal2);
  return filter(originalWaypoints, function(waypoint) {
    return isInsideBounds(waypoint, bounds);
  });
}
function isInsideBounds(point, bounds) {
  return getOrientation(bounds, point, 1) === "intersect";
}
function getOriginal2(point) {
  return point.original || point;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/MessageFlowBehavior.js
function MessageFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecute("shape.replace", function(context) {
    var oldShape = context.oldShape, newShape = context.newShape;
    if (!isParticipantCollapse(oldShape, newShape)) {
      return;
    }
    var messageFlows = getMessageFlows(oldShape);
    messageFlows.incoming.forEach(function(incoming) {
      var anchor = getResizedTargetAnchor(incoming, newShape, oldShape);
      modeling.reconnectEnd(incoming, newShape, anchor);
    });
    messageFlows.outgoing.forEach(function(outgoing) {
      var anchor = getResizedSourceAnchor(outgoing, newShape, oldShape);
      modeling.reconnectStart(outgoing, newShape, anchor);
    });
  }, true);
}
MessageFlowBehavior.$inject = ["eventBus", "modeling"];
e(MessageFlowBehavior, CommandInterceptor);
function isParticipantCollapse(oldShape, newShape) {
  return is(oldShape, "bpmn:Participant") && isExpanded(oldShape) && is(newShape, "bpmn:Participant") && !isExpanded(newShape);
}
function getMessageFlows(parent) {
  var elements = selfAndAllChildren([parent], false);
  var incoming = [], outgoing = [];
  elements.forEach(function(element) {
    if (element === parent) {
      return;
    }
    element.incoming.forEach(function(connection) {
      if (is(connection, "bpmn:MessageFlow")) {
        incoming.push(connection);
      }
    });
    element.outgoing.forEach(function(connection) {
      if (is(connection, "bpmn:MessageFlow")) {
        outgoing.push(connection);
      }
    });
  }, []);
  return {
    incoming,
    outgoing
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/util/NonInterruptingUtil.js
var NON_INTERRUPTING_EVENT_TYPES = [
  "bpmn:MessageEventDefinition",
  "bpmn:TimerEventDefinition",
  "bpmn:EscalationEventDefinition",
  "bpmn:ConditionalEventDefinition",
  "bpmn:SignalEventDefinition"
];
function canBeNonInterrupting(shape) {
  const businessObject = getBusinessObject(shape);
  if (!is(businessObject, "bpmn:BoundaryEvent") && !(is(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent))) {
    return false;
  }
  const eventDefinitions = businessObject.get("eventDefinitions");
  if (!eventDefinitions || !eventDefinitions.length) {
    return false;
  }
  return NON_INTERRUPTING_EVENT_TYPES.some((event2) => is(eventDefinitions[0], event2));
}
function getInterruptingProperty(shape) {
  return is(shape, "bpmn:BoundaryEvent") ? "cancelActivity" : "isInterrupting";
}

// node_modules/bpmn-js/lib/features/modeling/behavior/NonInterruptingBehavior.js
function NonInterruptingBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    const oldShape = event2.context.oldShape;
    const newShape = event2.context.newShape;
    const hints = event2.context.hints;
    if (!canBeNonInterrupting(newShape)) {
      return;
    }
    const property = getInterruptingProperty(newShape);
    const isExplicitChange = hints.targetElement && hints.targetElement[property] !== void 0;
    if (isExplicitChange) {
      return;
    }
    const isOldInterrupting = getBusinessObject(oldShape).get(property);
    const isNewInterruptingDefault = getBusinessObject(newShape).get(property);
    if (isOldInterrupting === isNewInterruptingDefault) {
      return;
    }
    modeling.updateProperties(newShape, {
      [property]: isOldInterrupting
    });
  });
}
NonInterruptingBehavior.$inject = ["injector", "modeling"];
e(NonInterruptingBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveEmbeddedLabelBoundsBehavior.js
function RemoveEmbeddedLabelBoundsBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.resize", function(context) {
    var shape = context.shape;
    var di = getDi(shape), label = di && di.get("label"), bounds = label && label.get("bounds");
    if (bounds) {
      modeling.updateModdleProperties(shape, label, {
        bounds: void 0
      });
    }
  }, true);
}
e(RemoveEmbeddedLabelBoundsBehavior, CommandInterceptor);
RemoveEmbeddedLabelBoundsBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveElementBehavior.js
function RemoveElementBehavior(eventBus, bpmnRules, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(e8) {
    var shape = e8.context.shape;
    if (shape.incoming.length !== 1 || shape.outgoing.length !== 1) {
      return;
    }
    var inConnection = shape.incoming[0], outConnection = shape.outgoing[0];
    if (!is(inConnection, "bpmn:SequenceFlow") || !is(outConnection, "bpmn:SequenceFlow")) {
      return;
    }
    if (bpmnRules.canConnect(inConnection.source, outConnection.target, inConnection)) {
      var newWaypoints = getNewWaypoints(inConnection.waypoints, outConnection.waypoints);
      modeling.reconnectEnd(inConnection, outConnection.target, newWaypoints);
    }
  });
}
e(RemoveElementBehavior, CommandInterceptor);
RemoveElementBehavior.$inject = [
  "eventBus",
  "bpmnRules",
  "modeling"
];
function getDocking2(point) {
  return point.original || point;
}
function getNewWaypoints(inWaypoints, outWaypoints) {
  var intersection2 = lineIntersect(
    getDocking2(inWaypoints[inWaypoints.length - 2]),
    getDocking2(inWaypoints[inWaypoints.length - 1]),
    getDocking2(outWaypoints[1]),
    getDocking2(outWaypoints[0])
  );
  if (intersection2) {
    return [].concat(
      inWaypoints.slice(0, inWaypoints.length - 1),
      [intersection2],
      outWaypoints.slice(1)
    );
  } else {
    return [
      getDocking2(inWaypoints[0]),
      getDocking2(outWaypoints[outWaypoints.length - 1])
    ];
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/RemoveParticipantBehavior.js
function RemoveParticipantBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("shape.delete", function(context) {
    var shape = context.shape, parent = shape.parent;
    if (is(shape, "bpmn:Participant")) {
      context.collaborationRoot = parent;
    }
  }, true);
  this.postExecute("shape.delete", function(context) {
    var collaborationRoot = context.collaborationRoot;
    if (collaborationRoot && !collaborationRoot.businessObject.participants.length) {
      var process2 = modeling.makeProcess();
      var children = collaborationRoot.children.slice();
      modeling.moveElements(children, { x: 0, y: 0 }, process2);
    }
  }, true);
}
RemoveParticipantBehavior.$inject = ["eventBus", "modeling"];
e(RemoveParticipantBehavior, CommandInterceptor);

// node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceConnectionBehavior.js
function ReplaceConnectionBehavior(eventBus, modeling, bpmnRules, injector) {
  CommandInterceptor.call(this, eventBus);
  var dragging = injector.get("dragging", false);
  function fixConnection(connection) {
    var source = connection.source, target = connection.target, parent = connection.parent;
    if (!parent) {
      return;
    }
    var replacementType, remove4;
    if (is(connection, "bpmn:SequenceFlow")) {
      if (!bpmnRules.canConnectSequenceFlow(source, target)) {
        remove4 = true;
      }
      if (bpmnRules.canConnectMessageFlow(source, target)) {
        replacementType = "bpmn:MessageFlow";
      }
    }
    if (is(connection, "bpmn:MessageFlow")) {
      if (!bpmnRules.canConnectMessageFlow(source, target)) {
        remove4 = true;
      }
      if (bpmnRules.canConnectSequenceFlow(source, target)) {
        replacementType = "bpmn:SequenceFlow";
      }
    }
    if (remove4) {
      modeling.removeConnection(connection);
    }
    if (replacementType) {
      modeling.connect(source, target, {
        type: replacementType,
        waypoints: connection.waypoints.slice()
      });
    }
  }
  function replaceReconnectedConnection(event2) {
    var context = event2.context, connection = context.connection, source = context.newSource || connection.source, target = context.newTarget || connection.target, allowed, replacement;
    allowed = bpmnRules.canConnect(source, target);
    if (!allowed || allowed.type === connection.type) {
      return;
    }
    replacement = modeling.connect(source, target, {
      type: allowed.type,
      associationDirection: allowed.associationDirection,
      waypoints: connection.waypoints.slice()
    });
    if (connection.parent) {
      modeling.removeConnection(connection);
    }
    context.connection = replacement;
    if (dragging) {
      cleanDraggingSelection(connection, replacement);
    }
  }
  function cleanDraggingSelection(oldConnection, newConnection) {
    var context = dragging.context(), previousSelection = context && context.payload.previousSelection, index5;
    if (!previousSelection || !previousSelection.length) {
      return;
    }
    index5 = previousSelection.indexOf(oldConnection);
    if (index5 === -1) {
      return;
    }
    previousSelection.splice(index5, 1, newConnection);
  }
  this.postExecuted("elements.move", function(context) {
    var closure = context.closure, allConnections = closure.allConnections;
    forEach(allConnections, fixConnection);
  }, true);
  this.preExecute("connection.reconnect", replaceReconnectedConnection);
  this.postExecuted("element.updateProperties", function(event2) {
    var context = event2.context, properties = context.properties, element = context.element, businessObject = element.businessObject, connection;
    if (properties.default) {
      connection = find(
        element.outgoing,
        matchPattern({ id: element.businessObject.default.id })
      );
      if (connection) {
        modeling.updateProperties(connection, { conditionExpression: void 0 });
      }
    }
    if (properties.conditionExpression && businessObject.sourceRef.default === businessObject) {
      modeling.updateProperties(element.source, { default: void 0 });
    }
  });
}
e(ReplaceConnectionBehavior, CommandInterceptor);
ReplaceConnectionBehavior.$inject = [
  "eventBus",
  "modeling",
  "bpmnRules",
  "injector"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ReplaceElementBehaviour.js
function ReplaceElementBehaviour(bpmnReplace, bpmnRules, elementRegistry, injector, modeling, selection2) {
  injector.invoke(CommandInterceptor, this);
  this._bpmnReplace = bpmnReplace;
  this._elementRegistry = elementRegistry;
  this._selection = selection2;
  this.postExecuted(["elements.create"], 500, function(event2) {
    var context = event2.context, target = context.parent, elements = context.elements;
    var elementReplacements = reduce(elements, function(replacements, element) {
      var canReplace2 = bpmnRules.canReplace([element], element.host || element.parent || target);
      return canReplace2 ? replacements.concat(canReplace2.replacements) : replacements;
    }, []);
    if (elementReplacements.length) {
      this._replaceElements(elements, elementReplacements);
    }
  }, this);
  this.postExecuted(["elements.move"], 500, function(event2) {
    var context = event2.context, target = context.newParent, newHost = context.newHost, elements = [];
    forEach(context.closure.topLevel, function(topLevelElements) {
      if (isEventSubProcess(topLevelElements)) {
        elements = elements.concat(topLevelElements.children);
      } else {
        elements = elements.concat(topLevelElements);
      }
    });
    if (elements.length === 1 && newHost) {
      target = newHost;
    }
    var canReplace2 = bpmnRules.canReplace(elements, target);
    if (canReplace2) {
      this._replaceElements(elements, canReplace2.replacements, newHost);
    }
  }, this);
  this.postExecute(["shape.replace"], 1500, function(e8) {
    var context = e8.context, oldShape = context.oldShape, newShape = context.newShape, attachers = oldShape.attachers, canReplace2;
    if (attachers && attachers.length) {
      canReplace2 = bpmnRules.canReplace(attachers, newShape);
      this._replaceElements(attachers, canReplace2.replacements);
    }
  }, this);
  this.postExecuted(["shape.replace"], 1500, function(e8) {
    var context = e8.context, oldShape = context.oldShape, newShape = context.newShape;
    modeling.unclaimId(oldShape.businessObject.id, oldShape.businessObject);
    modeling.updateProperties(newShape, { id: oldShape.id });
  });
}
e(ReplaceElementBehaviour, CommandInterceptor);
ReplaceElementBehaviour.prototype._replaceElements = function(elements, newElements) {
  var elementRegistry = this._elementRegistry, bpmnReplace = this._bpmnReplace, selection2 = this._selection;
  forEach(newElements, function(replacement) {
    var newElement = {
      type: replacement.newElementType
    };
    var oldElement = elementRegistry.get(replacement.oldElementId);
    var idx = elements.indexOf(oldElement);
    elements[idx] = bpmnReplace.replaceElement(oldElement, newElement, { select: false });
  });
  if (newElements) {
    selection2.select(elements);
  }
};
ReplaceElementBehaviour.$inject = [
  "bpmnReplace",
  "bpmnRules",
  "elementRegistry",
  "injector",
  "modeling",
  "selection"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ResizeBehavior.js
var HIGH_PRIORITY6 = 1500;
var GROUP_MIN_DIMENSIONS = { width: 140, height: 120 };
var LANE_MIN_DIMENSIONS = { width: 300, height: 60 };
var VERTICAL_LANE_MIN_DIMENSIONS = { width: 60, height: 300 };
var PARTICIPANT_MIN_DIMENSIONS = { width: 300, height: 150 };
var VERTICAL_PARTICIPANT_MIN_DIMENSIONS = { width: 150, height: 300 };
var SUB_PROCESS_MIN_DIMENSIONS = { width: 140, height: 120 };
var TEXT_ANNOTATION_MIN_DIMENSIONS = { width: 50, height: 30 };
function ResizeBehavior(eventBus) {
  eventBus.on("resize.start", HIGH_PRIORITY6, function(event2) {
    var context = event2.context, shape = context.shape, direction = context.direction, balanced = context.balanced;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      context.resizeConstraints = getParticipantResizeConstraints(shape, direction, balanced);
    }
    if (is(shape, "bpmn:SubProcess") && isExpanded(shape)) {
      context.minDimensions = SUB_PROCESS_MIN_DIMENSIONS;
    }
    if (is(shape, "bpmn:TextAnnotation")) {
      context.minDimensions = TEXT_ANNOTATION_MIN_DIMENSIONS;
    }
  });
}
ResizeBehavior.$inject = ["eventBus"];
var abs6 = Math.abs;
var min3 = Math.min;
var max4 = Math.max;
function addToTrbl(trbl, attr3, value, choice) {
  var current = trbl[attr3];
  trbl[attr3] = current === void 0 ? value : choice(value, current);
}
function addMin(trbl, attr3, value) {
  return addToTrbl(trbl, attr3, value, min3);
}
function addMax(trbl, attr3, value) {
  return addToTrbl(trbl, attr3, value, max4);
}
var LANE_PADDING = { top: 20, left: 50, right: 20, bottom: 20 };
var VERTICAL_LANE_PADDING = { top: 50, left: 20, right: 20, bottom: 20 };
function getParticipantResizeConstraints(laneShape, resizeDirection, balanced) {
  var lanesRoot = getLanesRoot(laneShape);
  var isFirst = true, isLast = true;
  var allLanes = collectLanes(lanesRoot, [lanesRoot]);
  var laneTrbl = asTRBL(laneShape);
  var maxTrbl = {}, minTrbl = {};
  var isHorizontalLane = isHorizontal(laneShape);
  var minDimensions = isHorizontalLane ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
  if (/n/.test(resizeDirection)) {
    minTrbl.top = laneTrbl.bottom - minDimensions.height;
  } else if (/e/.test(resizeDirection)) {
    minTrbl.right = laneTrbl.left + minDimensions.width;
  } else if (/s/.test(resizeDirection)) {
    minTrbl.bottom = laneTrbl.top + minDimensions.height;
  } else if (/w/.test(resizeDirection)) {
    minTrbl.left = laneTrbl.right - minDimensions.width;
  }
  allLanes.forEach(function(other) {
    var otherTrbl = asTRBL(other);
    if (isHorizontalLane) {
      if (otherTrbl.top < laneTrbl.top - 10) {
        isFirst = false;
      }
      if (otherTrbl.bottom > laneTrbl.bottom + 10) {
        isLast = false;
      }
    } else {
      if (otherTrbl.left < laneTrbl.left - 10) {
        isFirst = false;
      }
      if (otherTrbl.right > laneTrbl.right + 10) {
        isLast = false;
      }
    }
    if (/n/.test(resizeDirection)) {
      if (balanced && abs6(laneTrbl.top - otherTrbl.bottom) < 10) {
        addMax(maxTrbl, "top", otherTrbl.top + minDimensions.height);
      }
      if (abs6(laneTrbl.top - otherTrbl.top) < 5) {
        addMin(minTrbl, "top", otherTrbl.bottom - minDimensions.height);
      }
    }
    if (/e/.test(resizeDirection)) {
      if (balanced && abs6(laneTrbl.right - otherTrbl.left) < 10) {
        addMin(maxTrbl, "right", otherTrbl.right - minDimensions.width);
      }
      if (abs6(laneTrbl.right - otherTrbl.right) < 5) {
        addMax(minTrbl, "right", otherTrbl.left + minDimensions.width);
      }
    }
    if (/s/.test(resizeDirection)) {
      if (balanced && abs6(laneTrbl.bottom - otherTrbl.top) < 10) {
        addMin(maxTrbl, "bottom", otherTrbl.bottom - minDimensions.height);
      }
      if (abs6(laneTrbl.bottom - otherTrbl.bottom) < 5) {
        addMax(minTrbl, "bottom", otherTrbl.top + minDimensions.height);
      }
    }
    if (/w/.test(resizeDirection)) {
      if (balanced && abs6(laneTrbl.left - otherTrbl.right) < 10) {
        addMax(maxTrbl, "left", otherTrbl.left + minDimensions.width);
      }
      if (abs6(laneTrbl.left - otherTrbl.left) < 5) {
        addMin(minTrbl, "left", otherTrbl.right - minDimensions.width);
      }
    }
  });
  var flowElements = lanesRoot.children.filter(function(s5) {
    return !s5.hidden && !s5.waypoints && (is(s5, "bpmn:FlowElement") || is(s5, "bpmn:Artifact"));
  });
  var padding = isHorizontalLane ? LANE_PADDING : VERTICAL_LANE_PADDING;
  flowElements.forEach(function(flowElement) {
    var flowElementTrbl = asTRBL(flowElement);
    if (/n/.test(resizeDirection) && (!isHorizontalLane || isFirst)) {
      addMin(minTrbl, "top", flowElementTrbl.top - padding.top);
    }
    if (/e/.test(resizeDirection) && (isHorizontalLane || isLast)) {
      addMax(minTrbl, "right", flowElementTrbl.right + padding.right);
    }
    if (/s/.test(resizeDirection) && (!isHorizontalLane || isLast)) {
      addMax(minTrbl, "bottom", flowElementTrbl.bottom + padding.bottom);
    }
    if (/w/.test(resizeDirection) && (isHorizontalLane || isFirst)) {
      addMin(minTrbl, "left", flowElementTrbl.left - padding.left);
    }
  });
  return {
    min: minTrbl,
    max: maxTrbl
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/ResizeLaneBehavior.js
var SLIGHTLY_HIGHER_PRIORITY = 1001;
function ResizeLaneBehavior(eventBus, modeling) {
  eventBus.on("resize.start", SLIGHTLY_HIGHER_PRIORITY + 500, function(event2) {
    var context = event2.context, shape = context.shape;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      context.balanced = !hasPrimaryModifier(event2);
    }
  });
  eventBus.on("resize.end", SLIGHTLY_HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (is(shape, "bpmn:Lane") || is(shape, "bpmn:Participant")) {
      if (canExecute) {
        newBounds = roundBounds(newBounds);
        modeling.resizeLane(shape, newBounds, context.balanced);
      }
      return false;
    }
  });
}
ResizeLaneBehavior.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/RootElementReferenceBehavior.js
var LOW_PRIORITY11 = 500;
function RootElementReferenceBehavior(bpmnjs, eventBus, injector, moddleCopy, bpmnFactory) {
  injector.invoke(CommandInterceptor, this);
  function canHaveRootElementReference(element) {
    return isAny(element, ["bpmn:ReceiveTask", "bpmn:SendTask"]) || hasAnyEventDefinition(element, [
      "bpmn:ErrorEventDefinition",
      "bpmn:EscalationEventDefinition",
      "bpmn:MessageEventDefinition",
      "bpmn:SignalEventDefinition"
    ]);
  }
  function hasRootElement(rootElement) {
    var definitions = bpmnjs.getDefinitions(), rootElements = definitions.get("rootElements");
    return !!find(rootElements, matchPattern({ id: rootElement.id }));
  }
  function getRootElementReferencePropertyName(eventDefinition) {
    if (is(eventDefinition, "bpmn:ErrorEventDefinition")) {
      return "errorRef";
    } else if (is(eventDefinition, "bpmn:EscalationEventDefinition")) {
      return "escalationRef";
    } else if (is(eventDefinition, "bpmn:MessageEventDefinition")) {
      return "messageRef";
    } else if (is(eventDefinition, "bpmn:SignalEventDefinition")) {
      return "signalRef";
    }
  }
  function getRootElement4(businessObject) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.get("messageRef");
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.get(getRootElementReferencePropertyName(eventDefinition));
  }
  function setRootElement(businessObject, rootElement) {
    if (isAny(businessObject, ["bpmn:ReceiveTask", "bpmn:SendTask"])) {
      return businessObject.set("messageRef", rootElement);
    }
    var eventDefinitions = businessObject.get("eventDefinitions"), eventDefinition = eventDefinitions[0];
    return eventDefinition.set(getRootElementReferencePropertyName(eventDefinition), rootElement);
  }
  this.executed([
    "shape.create",
    "element.updateProperties",
    "element.updateModdleProperties"
  ], function(context) {
    var shape = context.shape || context.element;
    if (!canHaveRootElementReference(shape)) {
      return;
    }
    var businessObject = getBusinessObject(shape), rootElement = getRootElement4(businessObject), rootElements;
    if (rootElement && !hasRootElement(rootElement)) {
      rootElements = bpmnjs.getDefinitions().get("rootElements");
      add2(rootElements, rootElement);
      context.addedRootElement = rootElement;
    }
  }, true);
  this.reverted([
    "shape.create",
    "element.updateProperties",
    "element.updateModdleProperties"
  ], function(context) {
    var addedRootElement = context.addedRootElement;
    if (!addedRootElement) {
      return;
    }
    var rootElements = bpmnjs.getDefinitions().get("rootElements");
    remove3(rootElements, addedRootElement);
  }, true);
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (element.labelTarget || !canHaveRootElementReference(element)) {
      return;
    }
    var businessObject = getBusinessObject(element), rootElement = getRootElement4(businessObject);
    if (rootElement) {
      descriptor.referencedRootElement = rootElement;
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY11, function(context) {
    var descriptor = context.descriptor, businessObject = descriptor.businessObject, referencedRootElement = descriptor.referencedRootElement;
    if (!referencedRootElement) {
      return;
    }
    if (!hasRootElement(referencedRootElement)) {
      referencedRootElement = moddleCopy.copyElement(
        referencedRootElement,
        bpmnFactory.create(referencedRootElement.$type)
      );
    }
    setRootElement(businessObject, referencedRootElement);
    delete descriptor.referencedRootElement;
  });
}
RootElementReferenceBehavior.$inject = [
  "bpmnjs",
  "eventBus",
  "injector",
  "moddleCopy",
  "bpmnFactory"
];
e(RootElementReferenceBehavior, CommandInterceptor);
function hasAnyEventDefinition(element, types3) {
  if (!isArray(types3)) {
    types3 = [types3];
  }
  return some(types3, function(type) {
    return hasEventDefinition(element, type);
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SpaceToolBehavior.js
var max5 = Math.max;
function SpaceToolBehavior(eventBus) {
  eventBus.on("spaceTool.getMinDimensions", function(context) {
    var shapes = context.shapes, axis = context.axis, start = context.start, minDimensions = {};
    forEach(shapes, function(shape) {
      var id = shape.id;
      if (is(shape, "bpmn:Participant")) {
        minDimensions[id] = getParticipantMinDimensions(shape, axis, start);
      }
      if (is(shape, "bpmn:Lane")) {
        minDimensions[id] = isHorizontal(shape) ? LANE_MIN_DIMENSIONS : VERTICAL_LANE_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:SubProcess") && isExpanded(shape)) {
        minDimensions[id] = SUB_PROCESS_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:TextAnnotation")) {
        minDimensions[id] = TEXT_ANNOTATION_MIN_DIMENSIONS;
      }
      if (is(shape, "bpmn:Group")) {
        minDimensions[id] = GROUP_MIN_DIMENSIONS;
      }
    });
    return minDimensions;
  });
}
SpaceToolBehavior.$inject = ["eventBus"];
function isHorizontalAxis(axis) {
  return axis === "x";
}
function getParticipantMinDimensions(participant, axis, start) {
  var isHorizontalLane = isHorizontal(participant);
  if (!hasChildLanes(participant)) {
    return isHorizontalLane ? PARTICIPANT_MIN_DIMENSIONS : VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
  }
  var isHorizontalResize = isHorizontalAxis(axis);
  var minDimensions = {};
  if (isHorizontalResize) {
    if (isHorizontalLane) {
      minDimensions = PARTICIPANT_MIN_DIMENSIONS;
    } else {
      minDimensions = {
        width: getParticipantMinWidth(participant, start, isHorizontalResize),
        height: VERTICAL_PARTICIPANT_MIN_DIMENSIONS.height
      };
    }
  } else {
    if (isHorizontalLane) {
      minDimensions = {
        width: PARTICIPANT_MIN_DIMENSIONS.width,
        height: getParticipantMinHeight(participant, start, isHorizontalResize)
      };
    } else {
      minDimensions = VERTICAL_PARTICIPANT_MIN_DIMENSIONS;
    }
  }
  return minDimensions;
}
function getParticipantMinHeight(participant, start, isHorizontalResize) {
  var lanesMinHeight;
  lanesMinHeight = getLanesMinHeight(participant, start, isHorizontalResize);
  return max5(PARTICIPANT_MIN_DIMENSIONS.height, lanesMinHeight);
}
function getParticipantMinWidth(participant, start, isHorizontalResize) {
  var lanesMinWidth;
  lanesMinWidth = getLanesMinWidth(participant, start, isHorizontalResize);
  return max5(VERTICAL_PARTICIPANT_MIN_DIMENSIONS.width, lanesMinWidth);
}
function hasChildLanes(element) {
  return !!getChildLanes(element).length;
}
function getLanesMinHeight(participant, resizeStart, isHorizontalResize) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
  return participant.height - resizedLane.height + LANE_MIN_DIMENSIONS.height;
}
function getLanesMinWidth(participant, resizeStart, isHorizontalResize) {
  var lanes = getChildLanes(participant), resizedLane;
  resizedLane = findResizedLane(lanes, resizeStart, isHorizontalResize);
  return participant.width - resizedLane.width + VERTICAL_LANE_MIN_DIMENSIONS.width;
}
function findResizedLane(lanes, resizeStart, isHorizontalResize) {
  var i7, lane, childLanes;
  for (i7 = 0; i7 < lanes.length; i7++) {
    lane = lanes[i7];
    if (!isHorizontalResize && resizeStart >= lane.y && resizeStart <= lane.y + lane.height || isHorizontalResize && resizeStart >= lane.x && resizeStart <= lane.x + lane.width) {
      childLanes = getChildLanes(lane);
      if (childLanes.length) {
        return findResizedLane(childLanes, resizeStart, isHorizontalResize);
      }
      return lane;
    }
  }
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SubProcessPlaneBehavior.js
var LOW_PRIORITY12 = 400;
var HIGH_PRIORITY7 = 600;
var DEFAULT_POSITION2 = {
  x: 180,
  y: 160
};
function SubProcessPlaneBehavior(canvas, eventBus, modeling, elementFactory, bpmnFactory, bpmnjs, elementRegistry) {
  CommandInterceptor.call(this, eventBus);
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._bpmnFactory = bpmnFactory;
  this._bpmnjs = bpmnjs;
  this._elementRegistry = elementRegistry;
  var self2 = this;
  function isCollapsedSubProcess2(element) {
    return is(element, "bpmn:SubProcess") && !isExpanded(element);
  }
  function createRoot3(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    var businessObject = getBusinessObject(shape);
    rootElement = self2._addDiagram(rootElement || businessObject);
    context.newRootElement = canvas.addRootElement(rootElement);
  }
  function removeRoot(context) {
    var shape = context.shape;
    var businessObject = getBusinessObject(shape);
    self2._removeDiagram(businessObject);
    var rootElement = context.newRootElement = elementRegistry.get(getPlaneIdFromShape(businessObject));
    canvas.removeRootElement(rootElement);
  }
  this.executed("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot3(context);
  }, true);
  this.postExecuted("shape.create", function(context) {
    var shape = context.shape, rootElement = context.newRootElement;
    if (!rootElement || !shape.children) {
      return;
    }
    self2._showRecursively(shape.children);
    self2._moveChildrenToShape(shape, rootElement);
  }, true);
  this.reverted("shape.create", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.preExecuted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    var attachedRoot = elementRegistry.get(getPlaneIdFromShape(shape));
    if (!attachedRoot) {
      return;
    }
    modeling.removeElements(attachedRoot.children.slice());
  }, true);
  this.executed("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    removeRoot(context);
  }, true);
  this.reverted("shape.delete", function(context) {
    var shape = context.shape;
    if (!isCollapsedSubProcess2(shape)) {
      return;
    }
    createRoot3(context);
  }, true);
  this.preExecuted("shape.replace", function(context) {
    var oldShape = context.oldShape;
    var newShape = context.newShape;
    if (!isCollapsedSubProcess2(oldShape) || !isCollapsedSubProcess2(newShape)) {
      return;
    }
    context.oldRoot = canvas.removeRootElement(getPlaneIdFromShape(oldShape));
  }, true);
  this.postExecuted("shape.replace", function(context) {
    var newShape = context.newShape, source = context.oldRoot, target = canvas.findRoot(getPlaneIdFromShape(newShape));
    if (!source || !target) {
      return;
    }
    var elements = source.children;
    modeling.moveElements(elements, { x: 0, y: 0 }, target);
  }, true);
  this.executed("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(newId));
      elementRegistry.updateId(oldId, newId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(oldId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(toPlaneId(oldId), toPlaneId(newId));
  }, true);
  this.reverted("element.updateProperties", function(context) {
    var shape = context.element;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var properties = context.properties;
    var oldProperties = context.oldProperties;
    var oldId = oldProperties.id, newId = properties.id;
    if (oldId === newId) {
      return;
    }
    if (isPlane(shape)) {
      elementRegistry.updateId(shape, toPlaneId(oldId));
      elementRegistry.updateId(newId, oldId);
      return;
    }
    var planeElement = elementRegistry.get(toPlaneId(newId));
    if (!planeElement) {
      return;
    }
    elementRegistry.updateId(planeElement, toPlaneId(oldId));
  }, true);
  eventBus.on("element.changed", function(context) {
    var element = context.element;
    if (!isPlane(element)) {
      return;
    }
    var plane = element;
    var primaryShape = elementRegistry.get(getShapeIdFromPlane(plane));
    if (!primaryShape || primaryShape === plane) {
      return;
    }
    eventBus.fire("element.changed", { element: primaryShape });
  });
  this.executed("shape.toggleCollapse", LOW_PRIORITY12, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot3(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.reverted("shape.toggleCollapse", LOW_PRIORITY12, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!isExpanded(shape)) {
      createRoot3(context);
      self2._showRecursively(shape.children);
    } else {
      removeRoot(context);
    }
  }, true);
  this.postExecuted("shape.toggleCollapse", HIGH_PRIORITY7, function(context) {
    var shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    var rootElement = context.newRootElement;
    if (!rootElement) {
      return;
    }
    if (!isExpanded(shape)) {
      self2._moveChildrenToShape(shape, rootElement);
    } else {
      self2._moveChildrenToShape(rootElement, shape);
    }
  }, true);
  eventBus.on("copyPaste.createTree", function(context) {
    var element = context.element, children = context.children;
    if (!isCollapsedSubProcess2(element)) {
      return;
    }
    var id = getPlaneIdFromShape(element);
    var parent = elementRegistry.get(id);
    if (parent) {
      children.push.apply(children, parent.children);
    }
  });
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    var parent = element.parent;
    var isPlane3 = is(getDi(parent), "bpmndi:BPMNPlane");
    if (!isPlane3) {
      return;
    }
    var parentId = getShapeIdFromPlane(parent);
    var referencedShape = find(elements, function(element2) {
      return element2.id === parentId;
    });
    if (!referencedShape) {
      return;
    }
    descriptor.parent = referencedShape.id;
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor;
    if (!descriptor.parent) {
      return;
    }
    if (isCollapsedSubProcess2(descriptor.parent) || descriptor.parent.hidden) {
      descriptor.hidden = true;
    }
  });
}
e(SubProcessPlaneBehavior, CommandInterceptor);
SubProcessPlaneBehavior.prototype._moveChildrenToShape = function(source, target) {
  var modeling = this._modeling;
  var children = source.children;
  var offset;
  if (!children) {
    return;
  }
  children = children.concat(children.reduce(function(labels, child) {
    if (child.label && child.label.parent !== source) {
      return labels.concat(child.label);
    }
    return labels;
  }, []));
  var visibleChildren = children.filter(function(child) {
    return !child.hidden;
  });
  if (!visibleChildren.length) {
    modeling.moveElements(children, { x: 0, y: 0 }, target, { autoResize: false });
    return;
  }
  var childrenBounds = getBBox(visibleChildren);
  if (!target.x) {
    offset = {
      x: DEFAULT_POSITION2.x - childrenBounds.x,
      y: DEFAULT_POSITION2.y - childrenBounds.y
    };
  } else {
    var targetMid = getMid(target);
    var childrenMid = getMid(childrenBounds);
    offset = {
      x: targetMid.x - childrenMid.x,
      y: targetMid.y - childrenMid.y
    };
  }
  modeling.moveElements(children, offset, target, { autoResize: false });
};
SubProcessPlaneBehavior.prototype._showRecursively = function(elements, hidden) {
  var self2 = this;
  var result = [];
  elements.forEach(function(element) {
    element.hidden = !!hidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(
        self2._showRecursively(element.children, element.collapsed || hidden)
      );
    }
  });
  return result;
};
SubProcessPlaneBehavior.prototype._addDiagram = function(planeElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  if (!planeElement.businessObject) {
    planeElement = this._createNewDiagram(planeElement);
  }
  diagrams.push(planeElement.di.$parent);
  return planeElement;
};
SubProcessPlaneBehavior.prototype._createNewDiagram = function(bpmnElement) {
  var bpmnFactory = this._bpmnFactory, elementFactory = this._elementFactory;
  var diPlane = bpmnFactory.create("bpmndi:BPMNPlane", {
    bpmnElement
  });
  var diDiagram = bpmnFactory.create("bpmndi:BPMNDiagram", {
    plane: diPlane
  });
  diPlane.$parent = diDiagram;
  var planeElement = elementFactory.createRoot({
    id: getPlaneIdFromShape(bpmnElement),
    type: bpmnElement.$type,
    di: diPlane,
    businessObject: bpmnElement,
    collapsed: true
  });
  return planeElement;
};
SubProcessPlaneBehavior.prototype._removeDiagram = function(rootElement) {
  var bpmnjs = this._bpmnjs;
  var diagrams = bpmnjs.getDefinitions().diagrams;
  var removedDiagram = find(diagrams, function(diagram) {
    return diagram.plane.bpmnElement.id === rootElement.id;
  });
  diagrams.splice(diagrams.indexOf(removedDiagram), 1);
  return removedDiagram;
};
SubProcessPlaneBehavior.$inject = [
  "canvas",
  "eventBus",
  "modeling",
  "elementFactory",
  "bpmnFactory",
  "bpmnjs",
  "elementRegistry"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/SubProcessStartEventBehavior.js
function SubProcessStartEventBehavior(injector, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.postExecuted("shape.replace", function(event2) {
    var oldShape = event2.context.oldShape, newShape = event2.context.newShape;
    if (!is(newShape, "bpmn:SubProcess") || !(is(oldShape, "bpmn:Task") || is(oldShape, "bpmn:CallActivity")) || !isExpanded(newShape)) {
      return;
    }
    var position = getStartEventPosition(newShape);
    modeling.createShape({ type: "bpmn:StartEvent" }, position, newShape);
  });
}
SubProcessStartEventBehavior.$inject = [
  "injector",
  "modeling"
];
e(SubProcessStartEventBehavior, CommandInterceptor);
function getStartEventPosition(shape) {
  return {
    x: shape.x + shape.width / 6,
    y: shape.y + shape.height / 2
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/TextAnnotationBehavior.js
function TextAnnotationBehavior(eventBus) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.create", function(context) {
    const { target } = context;
    if (!is(target, "bpmn:TextAnnotation")) {
      return;
    }
    context.parent = target.parent;
  }, true);
  this.preExecute(["shape.create", "shape.resize", "elements.move"], function(context) {
    const shapes = context.shapes || [context.shape];
    if (shapes.length === 1 && is(shapes[0], "bpmn:TextAnnotation")) {
      context.hints = context.hints || {};
      context.hints.autoResize = false;
    }
  }, true);
}
e(TextAnnotationBehavior, CommandInterceptor);
TextAnnotationBehavior.$inject = [
  "eventBus"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ToggleCollapseConnectionBehaviour.js
function ToggleCollapseConnectionBehaviour(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted("shape.toggleCollapse", 1500, function(context) {
    var shape = context.shape;
    if (isExpanded(shape)) {
      return;
    }
    var allChildren = selfAndAllChildren(shape);
    allChildren.forEach(function(child) {
      var incomingConnections = child.incoming.slice(), outgoingConnections = child.outgoing.slice();
      forEach(incomingConnections, function(c5) {
        handleConnection(c5, true);
      });
      forEach(outgoingConnections, function(c5) {
        handleConnection(c5, false);
      });
    });
    function handleConnection(c5, incoming) {
      if (allChildren.indexOf(c5.source) !== -1 && allChildren.indexOf(c5.target) !== -1) {
        return;
      }
      if (incoming) {
        modeling.reconnectEnd(c5, shape, getMid(shape));
      } else {
        modeling.reconnectStart(c5, shape, getMid(shape));
      }
    }
  }, true);
}
e(ToggleCollapseConnectionBehaviour, CommandInterceptor);
ToggleCollapseConnectionBehaviour.$inject = [
  "eventBus",
  "modeling"
];

// node_modules/bpmn-js/lib/features/modeling/behavior/ToggleElementCollapseBehaviour.js
var LOW_PRIORITY13 = 500;
function ToggleElementCollapseBehaviour(eventBus, elementFactory, modeling) {
  CommandInterceptor.call(this, eventBus);
  function hideEmptyLabels(children) {
    if (children.length) {
      children.forEach(function(child) {
        if (child.type === "label" && !child.businessObject.name) {
          child.hidden = true;
        }
      });
    }
  }
  function expandedBounds(shape, defaultSize) {
    var children = shape.children, newBounds = defaultSize, visibleElements, visibleBBox;
    visibleElements = filterVisible(children).concat([shape]);
    visibleBBox = computeChildrenBBox(visibleElements);
    if (visibleBBox) {
      newBounds.width = Math.max(visibleBBox.width, newBounds.width);
      newBounds.height = Math.max(visibleBBox.height, newBounds.height);
      newBounds.x = visibleBBox.x + (visibleBBox.width - newBounds.width) / 2;
      newBounds.y = visibleBBox.y + (visibleBBox.height - newBounds.height) / 2;
    } else {
      newBounds.x = shape.x + (shape.width - newBounds.width) / 2;
      newBounds.y = shape.y + (shape.height - newBounds.height) / 2;
    }
    return newBounds;
  }
  function collapsedBounds(shape, defaultSize) {
    return {
      x: shape.x + (shape.width - defaultSize.width) / 2,
      y: shape.y + (shape.height - defaultSize.height) / 2,
      width: defaultSize.width,
      height: defaultSize.height
    };
  }
  this.executed(["shape.toggleCollapse"], LOW_PRIORITY13, function(e8) {
    var context = e8.context, shape = context.shape;
    if (!is(shape, "bpmn:SubProcess")) {
      return;
    }
    if (!shape.collapsed) {
      hideEmptyLabels(shape.children);
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.reverted(["shape.toggleCollapse"], LOW_PRIORITY13, function(e8) {
    var context = e8.context;
    var shape = context.shape;
    if (!shape.collapsed) {
      getDi(shape).isExpanded = true;
    } else {
      getDi(shape).isExpanded = false;
    }
  });
  this.postExecuted(["shape.toggleCollapse"], LOW_PRIORITY13, function(e8) {
    var shape = e8.context.shape, defaultSize = elementFactory.getDefaultSize(shape), newBounds;
    if (shape.collapsed) {
      newBounds = collapsedBounds(shape, defaultSize);
    } else {
      newBounds = expandedBounds(shape, defaultSize);
    }
    modeling.resizeShape(shape, newBounds, null, {
      autoResize: shape.collapsed ? false : "nwse"
    });
  });
}
e(ToggleElementCollapseBehaviour, CommandInterceptor);
ToggleElementCollapseBehaviour.$inject = [
  "eventBus",
  "elementFactory",
  "modeling"
];
function filterVisible(elements) {
  return elements.filter(function(e8) {
    return !e8.hidden;
  });
}

// node_modules/bpmn-js/lib/features/modeling/behavior/UnclaimIdBehavior.js
function UnclaimIdBehavior(canvas, injector, moddle, modeling) {
  injector.invoke(CommandInterceptor, this);
  this.preExecute("shape.delete", function(event2) {
    var context = event2.context, shape = context.shape, shapeBo = shape.businessObject;
    if (isLabel(shape)) {
      return;
    }
    if (is(shape, "bpmn:Participant") && isExpanded(shape)) {
      moddle.ids.unclaim(shapeBo.processRef.id);
    }
    modeling.unclaimId(shapeBo.id, shapeBo);
  });
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, connectionBo = connection.businessObject;
    modeling.unclaimId(connectionBo.id, connectionBo);
  });
  this.preExecute("canvas.updateRoot", function() {
    var rootElement = canvas.getRootElement(), rootElementBo = rootElement.businessObject;
    if (is(rootElement, "bpmn:Collaboration")) {
      moddle.ids.unclaim(rootElementBo.id);
    }
  });
}
e(UnclaimIdBehavior, CommandInterceptor);
UnclaimIdBehavior.$inject = ["canvas", "injector", "moddle", "modeling"];

// node_modules/bpmn-js/lib/features/modeling/behavior/UnsetDefaultFlowBehavior.js
function DeleteSequenceFlowBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.preExecute("connection.delete", function(event2) {
    var context = event2.context, connection = context.connection, source = connection.source;
    if (isDefaultFlow(connection, source)) {
      modeling.updateProperties(source, {
        "default": null
      });
    }
  });
}
e(DeleteSequenceFlowBehavior, CommandInterceptor);
DeleteSequenceFlowBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isDefaultFlow(connection, source) {
  if (!is(connection, "bpmn:SequenceFlow")) {
    return false;
  }
  var sourceBo = getBusinessObject(source), sequenceFlow = getBusinessObject(connection);
  return sourceBo.get("default") === sequenceFlow;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/UpdateFlowNodeRefsBehavior.js
var LOW_PRIORITY14 = 500;
var HIGH_PRIORITY8 = 5e3;
function UpdateFlowNodeRefsBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  var context;
  function initContext() {
    context = context || new UpdateContext();
    context.enter();
    return context;
  }
  function getContext() {
    if (!context) {
      throw new Error("out of bounds release");
    }
    return context;
  }
  function releaseContext() {
    if (!context) {
      throw new Error("out of bounds release");
    }
    var triggerUpdate = context.leave();
    if (triggerUpdate) {
      modeling.updateLaneRefs(context.flowNodes, context.lanes);
      context = null;
    }
    return triggerUpdate;
  }
  var laneRefUpdateEvents = [
    "spaceTool",
    "lane.add",
    "lane.resize",
    "lane.split",
    "elements.create",
    "elements.delete",
    "elements.move",
    "shape.create",
    "shape.delete",
    "shape.move",
    "shape.resize"
  ];
  this.preExecute(laneRefUpdateEvents, HIGH_PRIORITY8, function(event2) {
    initContext();
  });
  this.postExecuted(laneRefUpdateEvents, LOW_PRIORITY14, function(event2) {
    releaseContext();
  });
  this.preExecute([
    "shape.create",
    "shape.move",
    "shape.delete",
    "shape.resize"
  ], function(event2) {
    var context2 = event2.context, shape = context2.shape;
    var updateContext = getContext();
    if (shape.labelTarget) {
      return;
    }
    if (is(shape, "bpmn:Lane")) {
      updateContext.addLane(shape);
    }
    if (is(shape, "bpmn:FlowNode")) {
      updateContext.addFlowNode(shape);
    }
  });
}
UpdateFlowNodeRefsBehavior.$inject = [
  "eventBus",
  "modeling"
];
e(UpdateFlowNodeRefsBehavior, CommandInterceptor);
function UpdateContext() {
  this.flowNodes = [];
  this.lanes = [];
  this.counter = 0;
  this.addLane = function(lane) {
    this.lanes.push(lane);
  };
  this.addFlowNode = function(flowNode) {
    this.flowNodes.push(flowNode);
  };
  this.enter = function() {
    this.counter++;
  };
  this.leave = function() {
    this.counter--;
    return !this.counter;
  };
}

// node_modules/bpmn-js/lib/features/modeling/behavior/SetCompensationActivityAfterPasteBehavior.js
function SetCompensationActivityAfterPasteBehavior(eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  this.postExecuted("elements.create", function(event2) {
    const context = event2.context, elements = context.elements;
    for (const element of elements) {
      if (isForCompensation2(element) && !isConnectedToCompensationBoundaryEvent(element)) {
        modeling.updateProperties(element, { isForCompensation: void 0 });
      }
    }
  });
}
e(SetCompensationActivityAfterPasteBehavior, CommandInterceptor);
SetCompensationActivityAfterPasteBehavior.$inject = [
  "eventBus",
  "modeling"
];
function isForCompensation2(element) {
  const bo = getBusinessObject(element);
  return bo && bo.isForCompensation;
}
function isCompensationBoundaryEvent2(element) {
  return element && is(element, "bpmn:BoundaryEvent") && hasEventDefinition(element, "bpmn:CompensateEventDefinition");
}
function isConnectedToCompensationBoundaryEvent(element) {
  const compensationAssociations = element.incoming.filter(
    (connection) => isCompensationBoundaryEvent2(connection.source)
  );
  if (compensationAssociations.length > 0) {
    return true;
  }
  return false;
}

// node_modules/bpmn-js/lib/features/modeling/behavior/index.js
var behavior_default = {
  __init__: [
    "adaptiveLabelPositioningBehavior",
    "appendBehavior",
    "associationBehavior",
    "attachEventBehavior",
    "boundaryEventBehavior",
    "compensateBoundaryEventBehaviour",
    "createBehavior",
    "createDataObjectBehavior",
    "createParticipantBehavior",
    "dataInputAssociationBehavior",
    "dataStoreBehavior",
    "deleteLaneBehavior",
    "detachEventBehavior",
    "dropOnFlowBehavior",
    "eventBasedGatewayBehavior",
    "fixHoverBehavior",
    "groupBehavior",
    "importDockingFix",
    "isHorizontalFix",
    "labelBehavior",
    "layoutConnectionBehavior",
    "messageFlowBehavior",
    "nonInterruptingBehavior",
    "removeElementBehavior",
    "removeEmbeddedLabelBoundsBehavior",
    "removeParticipantBehavior",
    "replaceConnectionBehavior",
    "replaceElementBehaviour",
    "resizeBehavior",
    "resizeLaneBehavior",
    "rootElementReferenceBehavior",
    "spaceToolBehavior",
    "subProcessPlaneBehavior",
    "subProcessStartEventBehavior",
    "textAnnotationBehavior",
    "toggleCollapseConnectionBehaviour",
    "toggleElementCollapseBehaviour",
    "unclaimIdBehavior",
    "updateFlowNodeRefsBehavior",
    "unsetDefaultFlowBehavior",
    "setCompensationActivityAfterPasteBehavior"
  ],
  adaptiveLabelPositioningBehavior: ["type", AdaptiveLabelPositioningBehavior],
  appendBehavior: ["type", AppendBehavior],
  associationBehavior: ["type", AssociationBehavior],
  attachEventBehavior: ["type", AttachEventBehavior],
  boundaryEventBehavior: ["type", BoundaryEventBehavior],
  compensateBoundaryEventBehaviour: ["type", CompensateBoundaryEventBehavior],
  createBehavior: ["type", CreateBehavior],
  createDataObjectBehavior: ["type", CreateDataObjectBehavior],
  createParticipantBehavior: ["type", CreateParticipantBehavior],
  dataInputAssociationBehavior: ["type", DataInputAssociationBehavior],
  dataStoreBehavior: ["type", DataStoreBehavior],
  deleteLaneBehavior: ["type", DeleteLaneBehavior],
  detachEventBehavior: ["type", DetachEventBehavior],
  dropOnFlowBehavior: ["type", DropOnFlowBehavior],
  eventBasedGatewayBehavior: ["type", EventBasedGatewayBehavior],
  fixHoverBehavior: ["type", FixHoverBehavior],
  groupBehavior: ["type", GroupBehavior],
  importDockingFix: ["type", ImportDockingFix],
  isHorizontalFix: ["type", IsHorizontalFix],
  labelBehavior: ["type", LabelBehavior],
  layoutConnectionBehavior: ["type", LayoutConnectionBehavior],
  messageFlowBehavior: ["type", MessageFlowBehavior],
  nonInterruptingBehavior: ["type", NonInterruptingBehavior],
  removeElementBehavior: ["type", RemoveElementBehavior],
  removeEmbeddedLabelBoundsBehavior: ["type", RemoveEmbeddedLabelBoundsBehavior],
  removeParticipantBehavior: ["type", RemoveParticipantBehavior],
  replaceConnectionBehavior: ["type", ReplaceConnectionBehavior],
  replaceElementBehaviour: ["type", ReplaceElementBehaviour],
  resizeBehavior: ["type", ResizeBehavior],
  resizeLaneBehavior: ["type", ResizeLaneBehavior],
  rootElementReferenceBehavior: ["type", RootElementReferenceBehavior],
  spaceToolBehavior: ["type", SpaceToolBehavior],
  subProcessPlaneBehavior: ["type", SubProcessPlaneBehavior],
  subProcessStartEventBehavior: ["type", SubProcessStartEventBehavior],
  textAnnotationBehavior: ["type", TextAnnotationBehavior],
  toggleCollapseConnectionBehaviour: ["type", ToggleCollapseConnectionBehaviour],
  toggleElementCollapseBehaviour: ["type", ToggleElementCollapseBehaviour],
  unclaimIdBehavior: ["type", UnclaimIdBehavior],
  unsetDefaultFlowBehavior: ["type", DeleteSequenceFlowBehavior],
  updateFlowNodeRefsBehavior: ["type", UpdateFlowNodeRefsBehavior],
  setCompensationActivityAfterPasteBehavior: ["type", SetCompensationActivityAfterPasteBehavior]
};

// node_modules/bpmn-js/lib/features/snapping/BpmnSnappingUtil.js
function getBoundaryAttachment(position, targetBounds) {
  var orientation = getOrientation(position, targetBounds, -15);
  if (orientation !== "intersect") {
    return orientation;
  } else {
    return null;
  }
}

// node_modules/bpmn-js/lib/features/rules/BpmnRules.js
function BpmnRules(eventBus) {
  RuleProvider.call(this, eventBus);
}
e(BpmnRules, RuleProvider);
BpmnRules.$inject = ["eventBus"];
BpmnRules.prototype.init = function() {
  this.addRule("connection.start", function(context) {
    var source = context.source;
    return canStartConnection(source);
  });
  this.addRule("connection.create", function(context) {
    var source = context.source, target = context.target, hints = context.hints || {}, targetParent = hints.targetParent, targetAttach = hints.targetAttach;
    if (targetAttach) {
      return false;
    }
    if (targetParent) {
      target.parent = targetParent;
    }
    try {
      return canConnect(source, target);
    } finally {
      if (targetParent) {
        target.parent = null;
      }
    }
  });
  this.addRule("connection.reconnect", function(context) {
    var connection = context.connection, source = context.source, target = context.target;
    return canConnect(source, target, connection);
  });
  this.addRule("connection.updateWaypoints", function(context) {
    return {
      type: context.connection.type
    };
  });
  this.addRule("shape.resize", function(context) {
    var shape = context.shape, newBounds = context.newBounds;
    return canResize(shape, newBounds);
  });
  this.addRule("elements.create", function(context) {
    var elements = context.elements, position = context.position, target = context.target;
    if (isConnection(target) && !canInsert(elements, target, position)) {
      return false;
    }
    return every(elements, function(element) {
      if (isConnection(element)) {
        return canConnect(element.source, element.target, element);
      }
      if (element.host) {
        return canAttach(element, element.host, null, position);
      }
      return canCreate(element, target, null, position);
    });
  });
  this.addRule("elements.move", function(context) {
    var target = context.target, shapes = context.shapes, position = context.position;
    return canAttach(shapes, target, null, position) || canReplace(shapes, target, position) || canMove(shapes, target, position) || canInsert(shapes, target, position);
  });
  this.addRule("shape.create", function(context) {
    return canCreate(
      context.shape,
      context.target,
      context.source,
      context.position
    );
  });
  this.addRule("shape.attach", function(context) {
    return canAttach(
      context.shape,
      context.target,
      null,
      context.position
    );
  });
  this.addRule("element.copy", function(context) {
    var element = context.element, elements = context.elements;
    return canCopy(elements, element);
  });
};
BpmnRules.prototype.canConnectMessageFlow = canConnectMessageFlow;
BpmnRules.prototype.canConnectSequenceFlow = canConnectSequenceFlow;
BpmnRules.prototype.canConnectDataAssociation = canConnectDataAssociation;
BpmnRules.prototype.canConnectAssociation = canConnectAssociation;
BpmnRules.prototype.canConnectCompensationAssociation = canConnectCompensationAssociation;
BpmnRules.prototype.canMove = canMove;
BpmnRules.prototype.canAttach = canAttach;
BpmnRules.prototype.canReplace = canReplace;
BpmnRules.prototype.canDrop = canDrop;
BpmnRules.prototype.canInsert = canInsert;
BpmnRules.prototype.canCreate = canCreate;
BpmnRules.prototype.canConnect = canConnect;
BpmnRules.prototype.canResize = canResize;
BpmnRules.prototype.canCopy = canCopy;
function canStartConnection(element) {
  if (nonExistingOrLabel(element)) {
    return null;
  }
  return isAny(element, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference",
    "bpmn:Group",
    "bpmn:TextAnnotation"
  ]);
}
function nonExistingOrLabel(element) {
  return !element || isLabel(element);
}
function isSame(a6, b4) {
  return a6 === b4;
}
function getOrganizationalParent(element) {
  do {
    if (is(element, "bpmn:Process")) {
      return getBusinessObject(element);
    }
    if (is(element, "bpmn:Participant")) {
      return getBusinessObject(element).processRef || getBusinessObject(element);
    }
  } while (element = element.parent);
}
function isTextAnnotation(element) {
  return is(element, "bpmn:TextAnnotation");
}
function isGroup(element) {
  return is(element, "bpmn:Group") && !element.labelTarget;
}
function isCompensationBoundary(element) {
  return is(element, "bpmn:BoundaryEvent") && hasEventDefinition2(element, "bpmn:CompensateEventDefinition");
}
function isForCompensation3(element) {
  return getBusinessObject(element).isForCompensation;
}
function isSameOrganization(a6, b4) {
  var parentA = getOrganizationalParent(a6), parentB = getOrganizationalParent(b4);
  return parentA === parentB;
}
function isMessageFlowSource(element) {
  return is(element, "bpmn:InteractionNode") && !is(element, "bpmn:BoundaryEvent") && (!is(element, "bpmn:Event") || is(element, "bpmn:ThrowEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition"));
}
function isMessageFlowTarget(element) {
  return is(element, "bpmn:InteractionNode") && !isForCompensation3(element) && (!is(element, "bpmn:Event") || is(element, "bpmn:CatchEvent") && hasEventDefinitionOrNone(element, "bpmn:MessageEventDefinition")) && !(is(element, "bpmn:BoundaryEvent") && !hasEventDefinition2(element, "bpmn:MessageEventDefinition"));
}
function getScopeParent(element) {
  var parent = element;
  while (parent = parent.parent) {
    if (is(parent, "bpmn:FlowElementsContainer")) {
      return getBusinessObject(parent);
    }
    if (is(parent, "bpmn:Participant")) {
      return getBusinessObject(parent).processRef;
    }
  }
  return null;
}
function isSameScope(a6, b4) {
  var scopeParentA = getScopeParent(a6), scopeParentB = getScopeParent(b4);
  return scopeParentA === scopeParentB;
}
function hasEventDefinition2(element, eventDefinition) {
  var businessObject = getBusinessObject(element);
  return !!find(businessObject.eventDefinitions || [], function(definition) {
    return is(definition, eventDefinition);
  });
}
function hasEventDefinitionOrNone(element, eventDefinition) {
  var businessObject = getBusinessObject(element);
  return (businessObject.eventDefinitions || []).every(function(definition) {
    return is(definition, eventDefinition);
  });
}
function isSequenceFlowSource(element) {
  return is(element, "bpmn:FlowNode") && !is(element, "bpmn:EndEvent") && !isEventSubProcess(element) && !(is(element, "bpmn:IntermediateThrowEvent") && hasEventDefinition2(element, "bpmn:LinkEventDefinition")) && !isCompensationBoundary(element) && !isForCompensation3(element);
}
function isSequenceFlowTarget(element) {
  return is(element, "bpmn:FlowNode") && !is(element, "bpmn:StartEvent") && !is(element, "bpmn:BoundaryEvent") && !isEventSubProcess(element) && !(is(element, "bpmn:IntermediateCatchEvent") && hasEventDefinition2(element, "bpmn:LinkEventDefinition")) && !isForCompensation3(element);
}
function isEventBasedTarget(element) {
  return is(element, "bpmn:ReceiveTask") || is(element, "bpmn:IntermediateCatchEvent") && (hasEventDefinition2(element, "bpmn:MessageEventDefinition") || hasEventDefinition2(element, "bpmn:TimerEventDefinition") || hasEventDefinition2(element, "bpmn:ConditionalEventDefinition") || hasEventDefinition2(element, "bpmn:SignalEventDefinition"));
}
function getParents2(element) {
  var parents = [];
  while (element) {
    element = element.parent;
    if (element) {
      parents.push(element);
    }
  }
  return parents;
}
function isParent(possibleParent, element) {
  var allParents = getParents2(element);
  return allParents.indexOf(possibleParent) !== -1;
}
function canConnect(source, target, connection) {
  if (nonExistingOrLabel(source) || nonExistingOrLabel(target)) {
    return null;
  }
  if (!is(connection, "bpmn:DataAssociation")) {
    if (canConnectMessageFlow(source, target)) {
      return { type: "bpmn:MessageFlow" };
    }
    if (canConnectSequenceFlow(source, target)) {
      return { type: "bpmn:SequenceFlow" };
    }
  }
  var connectDataAssociation = canConnectDataAssociation(source, target);
  if (connectDataAssociation) {
    return connectDataAssociation;
  }
  if (canConnectCompensationAssociation(source, target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "One"
    };
  }
  if (canConnectAssociation(source, target)) {
    return {
      type: "bpmn:Association",
      associationDirection: "None"
    };
  }
  return false;
}
function canDrop(element, target) {
  if (isLabel(element) || isGroup(element)) {
    return true;
  }
  if (is(target, "bpmn:Participant") && !isExpanded(target)) {
    return false;
  }
  if (is(element, "bpmn:Participant")) {
    return is(target, "bpmn:Process") || is(target, "bpmn:Collaboration");
  }
  if (isAny(element, ["bpmn:DataInput", "bpmn:DataOutput"])) {
    if (element.parent) {
      return target === element.parent;
    }
  }
  if (is(element, "bpmn:Lane")) {
    return is(target, "bpmn:Participant") || is(target, "bpmn:Lane");
  }
  if (is(element, "bpmn:BoundaryEvent") && !isDroppableBoundaryEvent(element)) {
    return false;
  }
  if (is(element, "bpmn:FlowElement") && !is(element, "bpmn:DataStoreReference")) {
    if (is(target, "bpmn:FlowElementsContainer")) {
      return isExpanded(target);
    }
    return isAny(target, ["bpmn:Participant", "bpmn:Lane"]);
  }
  if (is(element, "bpmn:DataStoreReference") && is(target, "bpmn:Collaboration")) {
    return some(getBusinessObject(target).get("participants"), function(participant) {
      return !!participant.get("processRef");
    });
  }
  if (isAny(element, ["bpmn:Artifact", "bpmn:DataAssociation", "bpmn:DataStoreReference"])) {
    return isAny(target, [
      "bpmn:Collaboration",
      "bpmn:Lane",
      "bpmn:Participant",
      "bpmn:Process",
      "bpmn:SubProcess"
    ]);
  }
  if (is(element, "bpmn:MessageFlow")) {
    return is(target, "bpmn:Collaboration") || element.source.parent == target || element.target.parent == target;
  }
  return false;
}
function isDroppableBoundaryEvent(event2) {
  return getBusinessObject(event2).cancelActivity && (hasNoEventDefinition(event2) || hasCommonBoundaryIntermediateEventDefinition(event2));
}
function isBoundaryEvent(element) {
  return !isLabel(element) && is(element, "bpmn:BoundaryEvent");
}
function isLane(element) {
  return is(element, "bpmn:Lane");
}
function isBoundaryCandidate(element) {
  if (isBoundaryEvent(element)) {
    return true;
  }
  if (is(element, "bpmn:IntermediateThrowEvent") && hasNoEventDefinition(element)) {
    return true;
  }
  return is(element, "bpmn:IntermediateCatchEvent") && hasCommonBoundaryIntermediateEventDefinition(element);
}
function hasNoEventDefinition(element) {
  var businessObject = getBusinessObject(element);
  return businessObject && !(businessObject.eventDefinitions && businessObject.eventDefinitions.length);
}
function hasCommonBoundaryIntermediateEventDefinition(element) {
  return hasOneOfEventDefinitions(element, [
    "bpmn:MessageEventDefinition",
    "bpmn:TimerEventDefinition",
    "bpmn:SignalEventDefinition",
    "bpmn:ConditionalEventDefinition"
  ]);
}
function hasOneOfEventDefinitions(element, eventDefinitions) {
  return eventDefinitions.some(function(definition) {
    return hasEventDefinition2(element, definition);
  });
}
function isReceiveTaskAfterEventBasedGateway(element) {
  return is(element, "bpmn:ReceiveTask") && find(element.incoming, function(incoming) {
    return is(incoming.source, "bpmn:EventBasedGateway");
  });
}
function canAttach(elements, target, source, position) {
  if (!Array.isArray(elements)) {
    elements = [elements];
  }
  if (elements.length !== 1) {
    return false;
  }
  var element = elements[0];
  if (isLabel(element)) {
    return false;
  }
  if (!isBoundaryCandidate(element)) {
    return false;
  }
  if (isEventSubProcess(target)) {
    return false;
  }
  if (!is(target, "bpmn:Activity") || isForCompensation3(target)) {
    return false;
  }
  if (position && !getBoundaryAttachment(position, target)) {
    return false;
  }
  if (isReceiveTaskAfterEventBasedGateway(target)) {
    return false;
  }
  return "attach";
}
function canReplace(elements, target, position) {
  if (!target) {
    return false;
  }
  var canExecute = {
    replacements: []
  };
  forEach(elements, function(element) {
    if (!isEventSubProcess(target)) {
      if (is(element, "bpmn:StartEvent") && element.type !== "label" && canDrop(element, target)) {
        if (!isInterrupting(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasErrorEventDefinition(element) || hasEscalationEventDefinition(element) || hasCompensateEventDefinition(element)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
        if (hasOneOfEventDefinitions(
          element,
          [
            "bpmn:MessageEventDefinition",
            "bpmn:TimerEventDefinition",
            "bpmn:SignalEventDefinition",
            "bpmn:ConditionalEventDefinition"
          ]
        ) && is(target, "bpmn:SubProcess")) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:StartEvent"
          });
        }
      }
    }
    if (!is(target, "bpmn:Transaction")) {
      if (hasEventDefinition2(element, "bpmn:CancelEventDefinition") && element.type !== "label") {
        if (is(element, "bpmn:EndEvent") && canDrop(element, target)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:EndEvent"
          });
        }
        if (is(element, "bpmn:BoundaryEvent") && canAttach(element, target, null, position)) {
          canExecute.replacements.push({
            oldElementId: element.id,
            newElementType: "bpmn:BoundaryEvent"
          });
        }
      }
    }
  });
  return canExecute.replacements.length ? canExecute : false;
}
function canMove(elements, target) {
  if (some(elements, isLane)) {
    return false;
  }
  if (!target) {
    return true;
  }
  return elements.every(function(element) {
    return canDrop(element, target);
  });
}
function canCreate(shape, target, source, position) {
  if (!target) {
    return false;
  }
  if (isLabel(shape) || isGroup(shape)) {
    return true;
  }
  if (isSame(source, target)) {
    return false;
  }
  if (source && isParent(source, target)) {
    return false;
  }
  return canDrop(shape, target, position) || canInsert(shape, target, position);
}
function canResize(shape, newBounds) {
  if (is(shape, "bpmn:SubProcess")) {
    return isExpanded(shape) && (!newBounds || newBounds.width >= 100 && newBounds.height >= 80);
  }
  if (is(shape, "bpmn:Lane")) {
    return true;
  }
  if (is(shape, "bpmn:Participant")) {
    return true;
  }
  if (isTextAnnotation(shape)) {
    return true;
  }
  if (isGroup(shape)) {
    return true;
  }
  return false;
}
function isOneTextAnnotation(source, target) {
  var sourceTextAnnotation = isTextAnnotation(source), targetTextAnnotation = isTextAnnotation(target);
  return (sourceTextAnnotation || targetTextAnnotation) && sourceTextAnnotation !== targetTextAnnotation;
}
function canConnectAssociation(source, target) {
  if (isParent(target, source) || isParent(source, target)) {
    return false;
  }
  if (isOneTextAnnotation(source, target)) {
    return true;
  }
  return !!canConnectDataAssociation(source, target);
}
function canConnectCompensationAssociation(source, target) {
  return isSameScope(source, target) && isCompensationBoundary(source) && is(target, "bpmn:Activity") && !isHostOfElement(target, source) && !isEventSubProcess(target);
}
function canConnectMessageFlow(source, target) {
  if (getRootElement(source) && !getRootElement(target)) {
    return false;
  }
  return isMessageFlowSource(source) && isMessageFlowTarget(target) && !isSameOrganization(source, target);
}
function canConnectSequenceFlow(source, target) {
  return isSequenceFlowSource(source) && isSequenceFlowTarget(target) && isSameScope(source, target) && !(is(source, "bpmn:EventBasedGateway") && !isEventBasedTarget(target));
}
function canConnectDataAssociation(source, target) {
  if (isAny(source, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(target, ["bpmn:Activity", "bpmn:ThrowEvent"])) {
    return { type: "bpmn:DataInputAssociation" };
  }
  if (isAny(target, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"]) && isAny(source, ["bpmn:Activity", "bpmn:CatchEvent"])) {
    return { type: "bpmn:DataOutputAssociation" };
  }
  return false;
}
function canInsert(shape, connection, position) {
  if (!connection) {
    return false;
  }
  if (Array.isArray(shape)) {
    if (shape.length !== 1) {
      return false;
    }
    shape = shape[0];
  }
  if (connection.source === shape || connection.target === shape) {
    return false;
  }
  return isAny(connection, ["bpmn:SequenceFlow", "bpmn:MessageFlow"]) && !isLabel(connection) && is(shape, "bpmn:FlowNode") && !is(shape, "bpmn:BoundaryEvent") && canDrop(shape, connection.parent, position);
}
function includes2(elements, element) {
  return elements && element && elements.indexOf(element) !== -1;
}
function canCopy(elements, element) {
  if (isLabel(element)) {
    return true;
  }
  if (is(element, "bpmn:Lane") && !includes2(elements, element.parent)) {
    return false;
  }
  return true;
}
function getRootElement(element) {
  return getParent2(element, "bpmn:Process") || getParent2(element, "bpmn:Collaboration");
}
function isHostOfElement(potentialHost, element) {
  return potentialHost.attachers.includes(element);
}

// node_modules/bpmn-js/lib/features/rules/index.js
var rules_default2 = {
  __depends__: [
    rules_default
  ],
  __init__: ["bpmnRules"],
  bpmnRules: ["type", BpmnRules]
};

// node_modules/bpmn-js/lib/features/di-ordering/BpmnDiOrdering.js
var HIGH_PRIORITY9 = 2e3;
function BpmnDiOrdering(eventBus, canvas) {
  eventBus.on("saveXML.start", HIGH_PRIORITY9, orderDi);
  function orderDi() {
    var rootElements = canvas.getRootElements();
    forEach(rootElements, function(root) {
      var rootDi = getDi(root), elements, diElements;
      elements = selfAndAllChildren([root], false);
      elements = filter(elements, function(element) {
        return element !== root && !element.labelTarget;
      });
      diElements = map(elements, getDi);
      rootDi.set("planeElement", diElements);
    });
  }
}
BpmnDiOrdering.$inject = ["eventBus", "canvas"];

// node_modules/bpmn-js/lib/features/di-ordering/index.js
var di_ordering_default = {
  __init__: [
    "bpmnDiOrdering"
  ],
  bpmnDiOrdering: ["type", BpmnDiOrdering]
};

// node_modules/diagram-js/lib/features/ordering/OrderingProvider.js
function OrderingProvider(eventBus) {
  CommandInterceptor.call(this, eventBus);
  var self2 = this;
  this.preExecute(["shape.create", "connection.create"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.parent = ordering.parent;
      }
      context.parentIndex = ordering.index;
    }
  });
  this.preExecute(["shape.move", "connection.move"], function(event2) {
    var context = event2.context, element = context.shape || context.connection, parent = context.newParent || element.parent;
    var ordering = self2.getOrdering(element, parent);
    if (ordering) {
      if (ordering.parent !== void 0) {
        context.newParent = ordering.parent;
      }
      context.newParentIndex = ordering.index;
    }
  });
}
OrderingProvider.prototype.getOrdering = function(element, newParent) {
  return null;
};
e(OrderingProvider, CommandInterceptor);

// node_modules/bpmn-js/lib/features/ordering/BpmnOrderingProvider.js
function BpmnOrderingProvider(eventBus, canvas) {
  OrderingProvider.call(this, eventBus);
  var orders = [
    { type: "bpmn:SubProcess", order: { level: 6 } },
    // handle SequenceFlow(s) like message flows and render them always on top
    {
      type: "bpmn:SequenceFlow",
      order: {
        level: 9,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    // handle DataAssociation(s) like message flows and render them always on top
    {
      type: "bpmn:DataAssociation",
      order: {
        level: 9,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    {
      type: "bpmn:TextAnnotation",
      order: {
        level: 9
      }
    },
    {
      type: "bpmn:MessageFlow",
      order: {
        level: 9,
        containers: ["bpmn:Collaboration"]
      }
    },
    {
      type: "bpmn:Association",
      order: {
        level: 6,
        containers: [
          "bpmn:Participant",
          "bpmn:FlowElementsContainer",
          "bpmn:Collaboration"
        ]
      }
    },
    { type: "bpmn:BoundaryEvent", order: { level: 8 } },
    {
      type: "bpmn:Group",
      order: {
        level: 10,
        containers: [
          "bpmn:Collaboration",
          "bpmn:FlowElementsContainer"
        ]
      }
    },
    { type: "bpmn:FlowElement", order: { level: 5 } },
    { type: "bpmn:Participant", order: { level: -2 } },
    { type: "bpmn:Lane", order: { level: -1 } }
  ];
  function computeOrder(element) {
    if (element.labelTarget) {
      return { level: 10 };
    }
    var entry = find(orders, function(o5) {
      return isAny(element, [o5.type]);
    });
    return entry && entry.order || { level: 1 };
  }
  function getOrder(element) {
    var order = element.order;
    if (!order) {
      element.order = order = computeOrder(element);
    }
    if (!order) {
      throw new Error(`no order for <${element.id}>`);
    }
    return order;
  }
  function findActualParent(element, newParent, containers) {
    var actualParent = newParent;
    while (actualParent) {
      if (isAny(actualParent, containers)) {
        break;
      }
      actualParent = actualParent.parent;
    }
    if (!actualParent) {
      throw new Error(`no parent for <${element.id}> in <${newParent && newParent.id}>`);
    }
    return actualParent;
  }
  this.getOrdering = function(element, newParent) {
    if (element.labelTarget || is(element, "bpmn:TextAnnotation")) {
      return {
        parent: canvas.findRoot(newParent) || canvas.getRootElement(),
        index: -1
      };
    }
    var elementOrder = getOrder(element);
    if (elementOrder.containers) {
      newParent = findActualParent(element, newParent, elementOrder.containers);
    }
    var currentIndex = newParent.children.indexOf(element);
    var insertIndex = findIndex(newParent.children, function(child) {
      if (!element.labelTarget && child.labelTarget) {
        return false;
      }
      return elementOrder.level < getOrder(child).level;
    });
    if (insertIndex !== -1) {
      if (currentIndex !== -1 && currentIndex < insertIndex) {
        insertIndex -= 1;
      }
    }
    return {
      index: insertIndex,
      parent: newParent
    };
  };
}
BpmnOrderingProvider.$inject = ["eventBus", "canvas"];
e(BpmnOrderingProvider, OrderingProvider);

// node_modules/bpmn-js/lib/features/ordering/index.js
var ordering_default = {
  __init__: ["bpmnOrderingProvider"],
  bpmnOrderingProvider: ["type", BpmnOrderingProvider]
};

// node_modules/diagram-js/lib/features/clipboard/Clipboard.js
function Clipboard() {
}
Clipboard.prototype.get = function() {
  return this._data;
};
Clipboard.prototype.set = function(data) {
  this._data = data;
};
Clipboard.prototype.clear = function() {
  var data = this._data;
  delete this._data;
  return data;
};
Clipboard.prototype.isEmpty = function() {
  return !this._data;
};

// node_modules/diagram-js/lib/features/clipboard/index.js
var clipboard_default = {
  clipboard: ["type", Clipboard]
};

// node_modules/diagram-js/lib/features/create/Create.js
var MARKER_OK3 = "drop-ok";
var MARKER_NOT_OK3 = "drop-not-ok";
var MARKER_ATTACH = "attach-ok";
var MARKER_NEW_PARENT = "new-parent";
var PREFIX = "create";
var HIGH_PRIORITY10 = 2e3;
function Create(canvas, dragging, eventBus, modeling, rules) {
  function canCreate2(elements, target, position, source, hints) {
    if (!target) {
      return false;
    }
    elements = filter(elements, function(element) {
      var labelTarget = element.labelTarget;
      return !element.parent && !(isLabel(element) && elements.indexOf(labelTarget) !== -1);
    });
    var shape = find(elements, function(element) {
      return !isConnection(element);
    });
    var attach = false, connect = false, create3 = false;
    if (isSingleShape(elements)) {
      attach = rules.allowed("shape.attach", {
        position,
        shape,
        target
      });
    }
    if (!attach) {
      if (isSingleShape(elements)) {
        create3 = rules.allowed("shape.create", {
          position,
          shape,
          source,
          target
        });
      } else {
        create3 = rules.allowed("elements.create", {
          elements,
          position,
          target
        });
      }
    }
    var connectionTarget = hints.connectionTarget;
    if (create3 || attach) {
      if (shape && source) {
        connect = rules.allowed("connection.create", {
          source: connectionTarget === source ? shape : source,
          target: connectionTarget === source ? source : shape,
          hints: {
            targetParent: target,
            targetAttach: attach
          }
        });
      }
      return {
        attach,
        connect
      };
    }
    if (create3 === null || attach === null) {
      return null;
    }
    return false;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH, MARKER_OK3, MARKER_NOT_OK3, MARKER_NEW_PARENT].forEach(function(m6) {
      if (m6 === marker) {
        canvas.addMarker(element, m6);
      } else {
        canvas.removeMarker(element, m6);
      }
    });
  }
  eventBus.on(["create.move", "create.hover"], function(event2) {
    var context = event2.context, elements = context.elements, hover = event2.hover, source = context.source, hints = context.hints || {};
    if (!hover) {
      context.canExecute = false;
      context.target = null;
      return;
    }
    ensureConstraints2(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    var canExecute = context.canExecute = hover && canCreate2(elements, hover, position, source, hints);
    if (hover && canExecute !== null) {
      context.target = hover;
      if (canExecute && canExecute.attach) {
        setMarker(hover, MARKER_ATTACH);
      } else {
        setMarker(hover, canExecute ? MARKER_NEW_PARENT : MARKER_NOT_OK3);
      }
    }
  });
  eventBus.on(["create.end", "create.out", "create.cleanup"], function(event2) {
    var hover = event2.hover;
    if (hover) {
      setMarker(hover, null);
    }
  });
  eventBus.on("create.end", function(event2) {
    var context = event2.context, source = context.source, shape = context.shape, elements = context.elements, target = context.target, canExecute = context.canExecute, attach = canExecute && canExecute.attach, connect = canExecute && canExecute.connect, hints = context.hints || {};
    if (canExecute === false || !target) {
      return false;
    }
    ensureConstraints2(event2);
    var position = {
      x: event2.x,
      y: event2.y
    };
    if (connect) {
      shape = modeling.appendShape(source, shape, position, target, {
        attach,
        connection: connect === true ? {} : connect,
        connectionTarget: hints.connectionTarget
      });
    } else {
      elements = modeling.createElements(elements, position, target, assign({}, hints, {
        attach
      }));
      shape = find(elements, function(element) {
        return !isConnection(element);
      });
    }
    assign(context, {
      elements,
      shape
    });
    assign(event2, {
      elements,
      shape
    });
  });
  function cancel2() {
    var context = dragging.context();
    if (context && context.prefix === PREFIX) {
      dragging.cancel();
    }
  }
  eventBus.on("create.init", function() {
    eventBus.on("elements.changed", cancel2);
    eventBus.once(["create.cancel", "create.end"], HIGH_PRIORITY10, function() {
      eventBus.off("elements.changed", cancel2);
    });
  });
  this.start = function(event2, elements, context) {
    if (!isArray(elements)) {
      elements = [elements];
    }
    var shape = find(elements, function(element) {
      return !isConnection(element);
    });
    if (!shape) {
      return;
    }
    context = assign({
      elements,
      hints: {},
      shape
    }, context || {});
    forEach(elements, function(element) {
      if (!isNumber(element.x)) {
        element.x = 0;
      }
      if (!isNumber(element.y)) {
        element.y = 0;
      }
    });
    var visibleElements = filter(elements, function(element) {
      return !element.hidden;
    });
    var bbox = getBBox(visibleElements);
    forEach(elements, function(element) {
      if (isConnection(element)) {
        element.waypoints = map(element.waypoints, function(waypoint) {
          return {
            x: waypoint.x - bbox.x - bbox.width / 2,
            y: waypoint.y - bbox.y - bbox.height / 2
          };
        });
      }
      assign(element, {
        x: element.x - bbox.x - bbox.width / 2,
        y: element.y - bbox.y - bbox.height / 2
      });
    });
    dragging.init(event2, PREFIX, {
      cursor: "grabbing",
      autoActivate: true,
      data: {
        shape,
        elements,
        context
      }
    });
  };
}
Create.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules"
];
function ensureConstraints2(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  if (createConstraints.left) {
    event2.x = Math.max(event2.x, createConstraints.left);
  }
  if (createConstraints.right) {
    event2.x = Math.min(event2.x, createConstraints.right);
  }
  if (createConstraints.top) {
    event2.y = Math.max(event2.y, createConstraints.top);
  }
  if (createConstraints.bottom) {
    event2.y = Math.min(event2.y, createConstraints.bottom);
  }
}
function isSingleShape(elements) {
  return elements && elements.length === 1 && !isConnection(elements[0]);
}

// node_modules/diagram-js/lib/features/create/CreatePreview.js
var LOW_PRIORITY15 = 750;
function CreatePreview(canvas, eventBus, graphicsFactory, previewSupport, styles) {
  function createDragGroup(elements) {
    var dragGroup = create("g");
    attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
    var childrenGfx = create("g");
    elements.forEach(function(element) {
      var gfx;
      if (element.hidden) {
        return;
      }
      if (element.waypoints) {
        gfx = graphicsFactory._createContainer("connection", childrenGfx);
        graphicsFactory.drawConnection(getVisual(gfx), element);
      } else {
        gfx = graphicsFactory._createContainer("shape", childrenGfx);
        graphicsFactory.drawShape(getVisual(gfx), element);
        translate(gfx, element.x, element.y);
      }
      previewSupport.addDragger(element, dragGroup, gfx);
    });
    return dragGroup;
  }
  eventBus.on("create.move", LOW_PRIORITY15, function(event2) {
    var hover = event2.hover, context = event2.context, elements = context.elements, dragGroup = context.dragGroup;
    if (!dragGroup) {
      dragGroup = context.dragGroup = createDragGroup(elements);
    }
    var activeLayer;
    if (hover) {
      if (!dragGroup.parentNode) {
        activeLayer = canvas.getActiveLayer();
        append(activeLayer, dragGroup);
      }
      translate(dragGroup, event2.x, event2.y);
    } else {
      remove(dragGroup);
    }
  });
  eventBus.on("create.cleanup", function(event2) {
    var context = event2.context, dragGroup = context.dragGroup;
    if (dragGroup) {
      remove(dragGroup);
    }
  });
}
CreatePreview.$inject = [
  "canvas",
  "eventBus",
  "graphicsFactory",
  "previewSupport",
  "styles"
];

// node_modules/diagram-js/lib/features/create/index.js
var create_default = {
  __depends__: [
    dragging_default,
    preview_support_default,
    rules_default,
    selection_default
  ],
  __init__: [
    "create",
    "createPreview"
  ],
  create: ["type", Create],
  createPreview: ["type", CreatePreview]
};

// node_modules/diagram-js/lib/features/mouse/Mouse.js
function Mouse(eventBus) {
  var self2 = this;
  this._lastMoveEvent = null;
  function setLastMoveEvent(mousemoveEvent) {
    self2._lastMoveEvent = mousemoveEvent;
  }
  eventBus.on("canvas.init", function(context) {
    var svg = self2._svg = context.svg;
    svg.addEventListener("mousemove", setLastMoveEvent);
  });
  eventBus.on("canvas.destroy", function() {
    self2._lastMouseEvent = null;
    self2._svg.removeEventListener("mousemove", setLastMoveEvent);
  });
}
Mouse.$inject = ["eventBus"];
Mouse.prototype.getLastMoveEvent = function() {
  return this._lastMoveEvent || createMoveEvent(0, 0);
};
function createMoveEvent(x6, y5) {
  var event2 = document.createEvent("MouseEvent");
  var screenX = x6, screenY = y5, clientX = x6, clientY = y5;
  if (event2.initMouseEvent) {
    event2.initMouseEvent(
      "mousemove",
      true,
      true,
      window,
      0,
      screenX,
      screenY,
      clientX,
      clientY,
      false,
      false,
      false,
      false,
      0,
      null
    );
  }
  return event2;
}

// node_modules/diagram-js/lib/features/mouse/index.js
var mouse_default = {
  __init__: ["mouse"],
  mouse: ["type", Mouse]
};

// node_modules/diagram-js/lib/features/copy-paste/CopyPaste.js
function CopyPaste(canvas, create3, clipboard, elementFactory, eventBus, modeling, mouse, rules) {
  this._canvas = canvas;
  this._create = create3;
  this._clipboard = clipboard;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._mouse = mouse;
  this._rules = rules;
  eventBus.on("copyPaste.copyElement", function(context) {
    var descriptor = context.descriptor, element = context.element, elements = context.elements;
    descriptor.priority = 1;
    descriptor.id = element.id;
    var parentCopied = find(elements, function(e8) {
      return e8 === element.parent;
    });
    if (parentCopied) {
      descriptor.parent = element.parent.id;
    }
    if (isAttacher(element)) {
      descriptor.priority = 2;
      descriptor.host = element.host.id;
    }
    if (isConnection(element)) {
      descriptor.priority = 3;
      descriptor.source = element.source.id;
      descriptor.target = element.target.id;
      descriptor.waypoints = copyWaypoints(element);
    }
    if (isLabel(element)) {
      descriptor.priority = 4;
      descriptor.labelTarget = element.labelTarget.id;
    }
    forEach(["x", "y", "width", "height"], function(property) {
      if (isNumber(element[property])) {
        descriptor[property] = element[property];
      }
    });
    descriptor.hidden = element.hidden;
    descriptor.collapsed = element.collapsed;
  });
  eventBus.on("copyPaste.pasteElements", function(context) {
    var hints = context.hints;
    assign(hints, {
      createElementsBehavior: false
    });
  });
}
CopyPaste.$inject = [
  "canvas",
  "create",
  "clipboard",
  "elementFactory",
  "eventBus",
  "modeling",
  "mouse",
  "rules"
];
CopyPaste.prototype.copy = function(elements) {
  var allowed, tree;
  if (!isArray(elements)) {
    elements = elements ? [elements] : [];
  }
  allowed = this._eventBus.fire("copyPaste.canCopyElements", {
    elements
  });
  if (allowed === false) {
    tree = {};
  } else {
    tree = this.createTree(isArray(allowed) ? allowed : elements);
  }
  this._clipboard.set(tree);
  this._eventBus.fire("copyPaste.elementsCopied", {
    elements,
    tree
  });
  return tree;
};
CopyPaste.prototype.paste = function(context) {
  var tree = this._clipboard.get();
  if (this._clipboard.isEmpty()) {
    return;
  }
  var hints = context && context.hints || {};
  this._eventBus.fire("copyPaste.pasteElements", {
    hints
  });
  var elements = this._createElements(tree);
  if (context && context.element && context.point) {
    return this._paste(elements, context.element, context.point, hints);
  }
  this._create.start(this._mouse.getLastMoveEvent(), elements, {
    hints: hints || {}
  });
};
CopyPaste.prototype._paste = function(elements, target, position, hints) {
  forEach(elements, function(element) {
    if (!isNumber(element.x)) {
      element.x = 0;
    }
    if (!isNumber(element.y)) {
      element.y = 0;
    }
  });
  var bbox = getBBox(elements);
  forEach(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = map(element.waypoints, function(waypoint) {
        return {
          x: waypoint.x - bbox.x - bbox.width / 2,
          y: waypoint.y - bbox.y - bbox.height / 2
        };
      });
    }
    assign(element, {
      x: element.x - bbox.x - bbox.width / 2,
      y: element.y - bbox.y - bbox.height / 2
    });
  });
  return this._modeling.createElements(elements, position, target, assign({}, hints));
};
CopyPaste.prototype._createElements = function(tree) {
  var self2 = this;
  var eventBus = this._eventBus;
  var cache = {};
  var elements = [];
  forEach(tree, function(branch, depth) {
    depth = parseInt(depth, 10);
    branch = sortBy(branch, "priority");
    forEach(branch, function(descriptor) {
      var attrs = assign({}, omit(descriptor, ["priority"]));
      if (cache[descriptor.parent]) {
        attrs.parent = cache[descriptor.parent];
      } else {
        delete attrs.parent;
      }
      eventBus.fire("copyPaste.pasteElement", {
        cache,
        descriptor: attrs
      });
      var element;
      if (isConnection(attrs)) {
        attrs.source = cache[descriptor.source];
        attrs.target = cache[descriptor.target];
        element = cache[descriptor.id] = self2.createConnection(attrs);
        elements.push(element);
        return;
      }
      if (isLabel(attrs)) {
        attrs.labelTarget = cache[attrs.labelTarget];
        element = cache[descriptor.id] = self2.createLabel(attrs);
        elements.push(element);
        return;
      }
      if (attrs.host) {
        attrs.host = cache[attrs.host];
      }
      element = cache[descriptor.id] = self2.createShape(attrs);
      elements.push(element);
    });
  });
  return elements;
};
CopyPaste.prototype.createConnection = function(attrs) {
  var connection = this._elementFactory.createConnection(omit(attrs, ["id"]));
  return connection;
};
CopyPaste.prototype.createLabel = function(attrs) {
  var label = this._elementFactory.createLabel(omit(attrs, ["id"]));
  return label;
};
CopyPaste.prototype.createShape = function(attrs) {
  var shape = this._elementFactory.createShape(omit(attrs, ["id"]));
  return shape;
};
CopyPaste.prototype.hasRelations = function(element, elements) {
  var labelTarget, source, target;
  if (isConnection(element)) {
    source = find(elements, matchPattern({ id: element.source.id }));
    target = find(elements, matchPattern({ id: element.target.id }));
    if (!source || !target) {
      return false;
    }
  }
  if (isLabel(element)) {
    labelTarget = find(elements, matchPattern({ id: element.labelTarget.id }));
    if (!labelTarget) {
      return false;
    }
  }
  return true;
};
CopyPaste.prototype.createTree = function(elements) {
  var rules = this._rules, self2 = this;
  var tree = {}, elementsData = [];
  var parents = getParents(elements);
  function canCopy2(element, elements2) {
    return rules.allowed("element.copy", {
      element,
      elements: elements2
    });
  }
  function addElementData(element, depth) {
    var foundElementData = find(elementsData, function(elementsData2) {
      return element === elementsData2.element;
    });
    if (!foundElementData) {
      elementsData.push({
        element,
        depth
      });
      return;
    }
    if (foundElementData.depth < depth) {
      elementsData = removeElementData(foundElementData, elementsData);
      elementsData.push({
        element: foundElementData.element,
        depth
      });
    }
  }
  function removeElementData(elementData2, elementsData2) {
    var index5 = elementsData2.indexOf(elementData2);
    if (index5 !== -1) {
      elementsData2.splice(index5, 1);
    }
    return elementsData2;
  }
  eachElement(parents, function(element, _index, depth) {
    if (isLabel(element)) {
      return;
    }
    forEach(element.labels, function(label) {
      addElementData(label, depth);
    });
    function addRelatedElements(elements2) {
      elements2 && elements2.length && forEach(elements2, function(element2) {
        forEach(element2.labels, function(label) {
          addElementData(label, depth);
        });
        addElementData(element2, depth);
      });
    }
    forEach([element.attachers, element.incoming, element.outgoing], addRelatedElements);
    addElementData(element, depth);
    var children = [];
    if (element.children) {
      children = element.children.slice();
    }
    self2._eventBus.fire("copyPaste.createTree", {
      element,
      children
    });
    return children;
  });
  elements = map(elementsData, function(elementData2) {
    return elementData2.element;
  });
  elementsData = map(elementsData, function(elementData2) {
    elementData2.descriptor = {};
    self2._eventBus.fire("copyPaste.copyElement", {
      descriptor: elementData2.descriptor,
      element: elementData2.element,
      elements
    });
    return elementData2;
  });
  elementsData = sortBy(elementsData, function(elementData2) {
    return elementData2.descriptor.priority;
  });
  elements = map(elementsData, function(elementData2) {
    return elementData2.element;
  });
  forEach(elementsData, function(elementData2) {
    var depth = elementData2.depth;
    if (!self2.hasRelations(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!canCopy2(elementData2.element, elements)) {
      removeElement(elementData2.element, elements);
      return;
    }
    if (!tree[depth]) {
      tree[depth] = [];
    }
    tree[depth].push(elementData2.descriptor);
  });
  return tree;
};
function isAttacher(element) {
  return !!element.host;
}
function copyWaypoints(element) {
  return map(element.waypoints, function(waypoint) {
    waypoint = copyWaypoint(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint(waypoint.original);
    }
    return waypoint;
  });
}
function copyWaypoint(waypoint) {
  return assign({}, waypoint);
}
function removeElement(element, elements) {
  var index5 = elements.indexOf(element);
  if (index5 === -1) {
    return elements;
  }
  return elements.splice(index5, 1);
}

// node_modules/diagram-js/lib/features/copy-paste/index.js
var copy_paste_default = {
  __depends__: [
    clipboard_default,
    create_default,
    mouse_default,
    rules_default
  ],
  __init__: ["copyPaste"],
  copyPaste: ["type", CopyPaste]
};

// node_modules/bpmn-js/lib/features/copy-paste/BpmnCopyPaste.js
function copyProperties(source, target, properties) {
  if (!isArray(properties)) {
    properties = [properties];
  }
  forEach(properties, function(property) {
    if (!isUndefined(source[property])) {
      target[property] = source[property];
    }
  });
}
var LOW_PRIORITY16 = 750;
function BpmnCopyPaste(bpmnFactory, eventBus, moddleCopy) {
  function copy2(bo, clone4) {
    var targetBo = bpmnFactory.create(bo.$type);
    return moddleCopy.copyElement(bo, targetBo, null, clone4);
  }
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY16, function(context) {
    var descriptor = context.descriptor, element = context.element, businessObject = getBusinessObject(element);
    if (isLabel(element)) {
      return descriptor;
    }
    var businessObjectCopy = descriptor.businessObject = copy2(businessObject, true);
    var diCopy = descriptor.di = copy2(getDi(element), true);
    diCopy.bpmnElement = businessObjectCopy;
    copyProperties(businessObjectCopy, descriptor, "name");
    copyProperties(diCopy, descriptor, "isExpanded");
    if (businessObject.default) {
      descriptor.default = businessObject.default.id;
    }
  });
  var referencesKey = "-bpmn-js-refs";
  function getReferences(cache) {
    return cache[referencesKey] = cache[referencesKey] || {};
  }
  function setReferences(cache, references) {
    cache[referencesKey] = references;
  }
  function resolveReferences(descriptor, cache, references) {
    var businessObject = getBusinessObject(descriptor);
    if (descriptor.default) {
      references[descriptor.default] = {
        element: businessObject,
        property: "default"
      };
    }
    if (descriptor.host) {
      getBusinessObject(descriptor).attachedToRef = getBusinessObject(cache[descriptor.host]);
    }
    return omit(references, reduce(references, function(array, reference, key) {
      var element = reference.element, property = reference.property;
      if (key === descriptor.id) {
        element.set(property, businessObject);
        array.push(descriptor.id);
      }
      return array;
    }, []));
  }
  eventBus.on("copyPaste.pasteElement", function(context) {
    var cache = context.cache, descriptor = context.descriptor, businessObject = descriptor.businessObject, di = descriptor.di;
    if (isLabel(descriptor)) {
      descriptor.businessObject = getBusinessObject(cache[descriptor.labelTarget]);
      descriptor.di = getDi(cache[descriptor.labelTarget]);
      return;
    }
    businessObject = descriptor.businessObject = copy2(businessObject);
    di = descriptor.di = copy2(di);
    di.bpmnElement = businessObject;
    copyProperties(descriptor, businessObject, [
      "isExpanded",
      "name"
    ]);
    descriptor.type = businessObject.$type;
  });
  eventBus.on("copyPaste.copyElement", LOW_PRIORITY16, function(context) {
    var descriptor = context.descriptor, element = context.element;
    if (!is(element, "bpmn:Participant")) {
      return;
    }
    var participantBo = getBusinessObject(element);
    if (participantBo.processRef) {
      descriptor.processRef = copy2(participantBo.processRef, true);
    }
  });
  eventBus.on("copyPaste.pasteElement", function(context) {
    var descriptor = context.descriptor, processRef = descriptor.processRef;
    if (processRef) {
      descriptor.processRef = copy2(processRef);
    }
  });
  eventBus.on("copyPaste.pasteElement", LOW_PRIORITY16, function(context) {
    var cache = context.cache, descriptor = context.descriptor;
    setReferences(
      cache,
      resolveReferences(descriptor, cache, getReferences(cache))
    );
  });
}
BpmnCopyPaste.$inject = [
  "bpmnFactory",
  "eventBus",
  "moddleCopy"
];

// node_modules/bpmn-js/lib/features/copy-paste/ModdleCopy.js
var DISALLOWED_PROPERTIES = [
  "artifacts",
  "dataInputAssociations",
  "dataOutputAssociations",
  "default",
  "flowElements",
  "lanes",
  "incoming",
  "outgoing",
  "categoryValue"
];
function ModdleCopy(eventBus, bpmnFactory, moddle) {
  this._bpmnFactory = bpmnFactory;
  this._eventBus = eventBus;
  this._moddle = moddle;
  eventBus.on("moddleCopy.canCopyProperties", function(context) {
    var propertyNames = context.propertyNames;
    if (!propertyNames || !propertyNames.length) {
      return;
    }
    return sortBy(propertyNames, function(propertyName) {
      return propertyName === "extensionElements";
    });
  });
  eventBus.on("moddleCopy.canCopyProperty", function(context) {
    var parent = context.parent, parentDescriptor = isObject(parent) && parent.$descriptor, propertyName = context.propertyName;
    if (propertyName && DISALLOWED_PROPERTIES.indexOf(propertyName) !== -1) {
      return false;
    }
    if (propertyName && parentDescriptor && !find(parentDescriptor.properties, matchPattern({ name: propertyName }))) {
      return false;
    }
  });
  eventBus.on("moddleCopy.canSetCopiedProperty", function(context) {
    var property = context.property;
    if (is4(property, "bpmn:ExtensionElements") && (!property.values || !property.values.length)) {
      return false;
    }
  });
}
ModdleCopy.$inject = [
  "eventBus",
  "bpmnFactory",
  "moddle"
];
ModdleCopy.prototype.copyElement = function(sourceElement, targetElement, propertyNames, clone4 = false) {
  var self2 = this;
  if (propertyNames && !isArray(propertyNames)) {
    propertyNames = [propertyNames];
  }
  propertyNames = propertyNames || getPropertyNames(sourceElement.$descriptor);
  var canCopyProperties = this._eventBus.fire("moddleCopy.canCopyProperties", {
    propertyNames,
    sourceElement,
    targetElement,
    clone: clone4
  });
  if (canCopyProperties === false) {
    return targetElement;
  }
  if (isArray(canCopyProperties)) {
    propertyNames = canCopyProperties;
  }
  forEach(propertyNames, function(propertyName) {
    var sourceProperty;
    if (has(sourceElement, propertyName)) {
      sourceProperty = sourceElement.get(propertyName);
    }
    var copiedProperty = self2.copyProperty(sourceProperty, targetElement, propertyName, clone4);
    if (!isDefined(copiedProperty)) {
      return;
    }
    var canSetProperty = self2._eventBus.fire("moddleCopy.canSetCopiedProperty", {
      parent: targetElement,
      property: copiedProperty,
      propertyName
    });
    if (canSetProperty === false) {
      return;
    }
    targetElement.set(propertyName, copiedProperty);
  });
  return targetElement;
};
ModdleCopy.prototype.copyProperty = function(property, parent, propertyName, clone4 = false) {
  var self2 = this;
  var copiedProperty = this._eventBus.fire("moddleCopy.canCopyProperty", {
    parent,
    property,
    propertyName,
    clone: clone4
  });
  if (copiedProperty === false) {
    return;
  }
  if (copiedProperty) {
    if (isObject(copiedProperty) && copiedProperty.$type && !copiedProperty.$parent) {
      copiedProperty.$parent = parent;
    }
    return copiedProperty;
  }
  var propertyDescriptor = this._moddle.getPropertyDescriptor(parent, propertyName);
  if (propertyDescriptor.isReference) {
    return;
  }
  if (propertyDescriptor.isId) {
    return property && this._copyId(property, parent, clone4);
  }
  if (isArray(property)) {
    return reduce(property, function(childProperties, childProperty) {
      copiedProperty = self2.copyProperty(childProperty, parent, propertyName, clone4);
      if (copiedProperty) {
        return childProperties.concat(copiedProperty);
      }
      return childProperties;
    }, []);
  }
  if (isObject(property) && property.$type) {
    if (this._moddle.getElementDescriptor(property).isGeneric) {
      return;
    }
    copiedProperty = self2._bpmnFactory.create(property.$type);
    copiedProperty.$parent = parent;
    copiedProperty = self2.copyElement(property, copiedProperty, null, clone4);
    return copiedProperty;
  }
  return property;
};
ModdleCopy.prototype._copyId = function(id, element, clone4 = false) {
  if (clone4) {
    return id;
  }
  if (this._moddle.ids.assigned(id)) {
    return;
  } else {
    this._moddle.ids.claim(id, element);
    return id;
  }
};
function getPropertyNames(descriptor, keepDefaultProperties) {
  return reduce(descriptor.properties, function(properties, property) {
    if (keepDefaultProperties && property.default) {
      return properties;
    }
    return properties.concat(property.name);
  }, []);
}
function is4(element, type) {
  return element && isFunction(element.$instanceOf) && element.$instanceOf(type);
}

// node_modules/bpmn-js/lib/features/copy-paste/index.js
var copy_paste_default2 = {
  __depends__: [
    copy_paste_default
  ],
  __init__: ["bpmnCopyPaste", "moddleCopy"],
  bpmnCopyPaste: ["type", BpmnCopyPaste],
  moddleCopy: ["type", ModdleCopy]
};

// node_modules/diagram-js/lib/features/replace/Replace.js
var round7 = Math.round;
function Replace(modeling, eventBus) {
  this._modeling = modeling;
  this._eventBus = eventBus;
}
Replace.$inject = ["modeling", "eventBus"];
Replace.prototype.replaceElement = function(oldElement, attrs, hints) {
  if (oldElement.waypoints) {
    return null;
  }
  var modeling = this._modeling;
  var eventBus = this._eventBus;
  eventBus.fire("replace.start", {
    element: oldElement,
    attrs,
    hints
  });
  var width = attrs.width || oldElement.width, height = attrs.height || oldElement.height, x6 = attrs.x || oldElement.x, y5 = attrs.y || oldElement.y, centerX = round7(x6 + width / 2), centerY = round7(y5 + height / 2);
  var newElement = modeling.replaceShape(
    oldElement,
    assign(
      {},
      attrs,
      {
        x: centerX,
        y: centerY,
        width,
        height
      }
    ),
    hints
  );
  eventBus.fire("replace.end", {
    element: oldElement,
    newElement,
    hints
  });
  return newElement;
};

// node_modules/diagram-js/lib/features/replace/ReplaceSelectionBehavior.js
function ReplaceSelectionBehavior(selection2, eventBus) {
  eventBus.on("replace.end", 500, function(event2) {
    const {
      newElement,
      hints = {}
    } = event2;
    if (hints.select === false) {
      return;
    }
    selection2.select(newElement);
  });
}
ReplaceSelectionBehavior.$inject = ["selection", "eventBus"];

// node_modules/diagram-js/lib/features/replace/index.js
var replace_default = {
  __init__: ["replace", "replaceSelectionBehavior"],
  replaceSelectionBehavior: ["type", ReplaceSelectionBehavior],
  replace: ["type", Replace]
};

// node_modules/bpmn-js/lib/features/replace/BpmnReplace.js
function copyProperties2(source, target, properties) {
  if (!isArray(properties)) {
    properties = [properties];
  }
  forEach(properties, function(property) {
    if (!isUndefined(source[property])) {
      target[property] = source[property];
    }
  });
}
var CUSTOM_PROPERTIES = [
  "cancelActivity",
  "instantiate",
  "eventGatewayType",
  "triggeredByEvent",
  "isInterrupting"
];
function shouldToggleCollapsed(element, targetElement) {
  var oldCollapsed = element && has(element, "collapsed") ? element.collapsed : !isExpanded(element);
  var targetCollapsed;
  if (targetElement && (has(targetElement, "collapsed") || has(targetElement, "isExpanded"))) {
    targetCollapsed = has(targetElement, "collapsed") ? targetElement.collapsed : !targetElement.isExpanded;
  } else {
    targetCollapsed = oldCollapsed;
  }
  if (oldCollapsed !== targetCollapsed) {
    return true;
  }
  return false;
}
function BpmnReplace(bpmnFactory, elementFactory, moddleCopy, modeling, replace, rules) {
  function replaceElement(element, targetElement, hints) {
    hints = hints || {};
    var type = targetElement.type, oldBusinessObject = element.businessObject;
    if (isSubProcess(oldBusinessObject) && (type === "bpmn:SubProcess" || type === "bpmn:AdHocSubProcess")) {
      if (shouldToggleCollapsed(element, targetElement)) {
        modeling.toggleCollapse(element);
        return element;
      }
    }
    var newBusinessObject = bpmnFactory.create(type);
    var newElement = {
      type,
      businessObject: newBusinessObject
    };
    newElement.di = {};
    if (type === "bpmn:ExclusiveGateway") {
      newElement.di.isMarkerVisible = true;
    }
    copyProperties2(element.di, newElement.di, [
      "fill",
      "stroke",
      "background-color",
      "border-color",
      "color"
    ]);
    var elementProps = getPropertyNames(oldBusinessObject.$descriptor), newElementProps = getPropertyNames(newBusinessObject.$descriptor, true), copyProps = intersection(elementProps, newElementProps);
    assign(newBusinessObject, pick(targetElement, CUSTOM_PROPERTIES));
    var properties = filter(copyProps, function(propertyName) {
      if (propertyName === "eventDefinitions") {
        return hasEventDefinition3(element, targetElement.eventDefinitionType);
      }
      if (propertyName === "loopCharacteristics") {
        return !isEventSubProcess(newBusinessObject);
      }
      if (has(newBusinessObject, propertyName)) {
        return false;
      }
      if (propertyName === "processRef" && targetElement.isExpanded === false) {
        return false;
      }
      if (propertyName === "triggeredByEvent") {
        return false;
      }
      if (propertyName === "isForCompensation") {
        return !isEventSubProcess(newBusinessObject);
      }
      return true;
    });
    newBusinessObject = moddleCopy.copyElement(
      oldBusinessObject,
      newBusinessObject,
      properties
    );
    if (targetElement.eventDefinitionType) {
      if (!hasEventDefinition3(newBusinessObject, targetElement.eventDefinitionType)) {
        newElement.eventDefinitionType = targetElement.eventDefinitionType;
        newElement.eventDefinitionAttrs = targetElement.eventDefinitionAttrs;
      }
    }
    if (is(oldBusinessObject, "bpmn:Activity")) {
      if (isSubProcess(oldBusinessObject)) {
        newElement.isExpanded = isExpanded(element);
      } else if (targetElement && has(targetElement, "isExpanded")) {
        newElement.isExpanded = targetElement.isExpanded;
        var defaultSize = elementFactory.getDefaultSize(newBusinessObject, {
          isExpanded: newElement.isExpanded
        });
        newElement.width = defaultSize.width;
        newElement.height = defaultSize.height;
        newElement.x = element.x - (newElement.width - element.width) / 2;
        newElement.y = element.y - (newElement.height - element.height) / 2;
      }
      if (isExpanded(element) && !is(oldBusinessObject, "bpmn:Task") && newElement.isExpanded) {
        newElement.width = element.width;
        newElement.height = element.height;
      }
    }
    if (isSubProcess(oldBusinessObject) && !isSubProcess(newBusinessObject)) {
      hints.moveChildren = false;
    }
    if (is(oldBusinessObject, "bpmn:Participant")) {
      if (targetElement.isExpanded === true) {
        newBusinessObject.processRef = bpmnFactory.create("bpmn:Process");
      } else {
        hints.moveChildren = false;
      }
      var isHorizontalPool = isHorizontal(element);
      if (!getDi(element).isHorizontal) {
        getDi(newElement).isHorizontal = isHorizontalPool;
      }
      newElement.width = isHorizontalPool ? element.width : elementFactory.getDefaultSize(newElement).width;
      newElement.height = isHorizontalPool ? elementFactory.getDefaultSize(newElement).height : element.height;
    }
    if (!rules.allowed("shape.resize", { shape: newBusinessObject })) {
      newElement.height = elementFactory.getDefaultSize(newElement).height;
      newElement.width = elementFactory.getDefaultSize(newElement).width;
    }
    newBusinessObject.name = oldBusinessObject.name;
    if (isAny(oldBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ]) && isAny(newBusinessObject, [
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway",
      "bpmn:Activity"
    ])) {
      newBusinessObject.default = oldBusinessObject.default;
    }
    if (targetElement.host && !is(oldBusinessObject, "bpmn:BoundaryEvent") && is(newBusinessObject, "bpmn:BoundaryEvent")) {
      newElement.host = targetElement.host;
    }
    if (newElement.type === "bpmn:DataStoreReference" || newElement.type === "bpmn:DataObjectReference") {
      newElement.x = element.x + (element.width - newElement.width) / 2;
    }
    return replace.replaceElement(element, newElement, { ...hints, targetElement });
  }
  this.replaceElement = replaceElement;
}
BpmnReplace.$inject = [
  "bpmnFactory",
  "elementFactory",
  "moddleCopy",
  "modeling",
  "replace",
  "rules"
];
function isSubProcess(businessObject) {
  return is(businessObject, "bpmn:SubProcess");
}
function hasEventDefinition3(element, type) {
  var businessObject = getBusinessObject(element);
  return type && businessObject.get("eventDefinitions").some(function(definition) {
    return is(definition, type);
  });
}
function intersection(a6, b4) {
  return a6.filter(function(item) {
    return b4.includes(item);
  });
}

// node_modules/bpmn-js/lib/features/replace/index.js
var replace_default2 = {
  __depends__: [
    copy_paste_default2,
    replace_default,
    selection_default
  ],
  bpmnReplace: ["type", BpmnReplace]
};

// node_modules/diagram-js/lib/features/tool-manager/ToolManager.js
var LOW_PRIORITY17 = 250;
function ToolManager(eventBus) {
  this._eventBus = eventBus;
  this._tools = [];
  this._active = null;
}
ToolManager.$inject = ["eventBus"];
ToolManager.prototype.registerTool = function(name2, events) {
  var tools = this._tools;
  if (!events) {
    throw new Error(`A tool has to be registered with it's "events"`);
  }
  tools.push(name2);
  this.bindEvents(name2, events);
};
ToolManager.prototype.isActive = function(tool) {
  return tool && this._active === tool;
};
ToolManager.prototype.length = function(tool) {
  return this._tools.length;
};
ToolManager.prototype.setActive = function(tool) {
  var eventBus = this._eventBus;
  if (this._active !== tool) {
    this._active = tool;
    eventBus.fire("tool-manager.update", { tool });
  }
};
ToolManager.prototype.bindEvents = function(name2, events) {
  var eventBus = this._eventBus;
  var eventsToRegister = [];
  eventBus.on(events.tool + ".init", function(event2) {
    var context = event2.context;
    if (!context.reactivate && this.isActive(name2)) {
      this.setActive(null);
      return;
    }
    this.setActive(name2);
  }, this);
  forEach(events, function(event2) {
    eventsToRegister.push(event2 + ".ended");
    eventsToRegister.push(event2 + ".canceled");
  });
  eventBus.on(eventsToRegister, LOW_PRIORITY17, function(event2) {
    if (!this._active) {
      return;
    }
    if (isPaletteClick(event2)) {
      return;
    }
    this.setActive(null);
  }, this);
};
function isPaletteClick(event2) {
  var target = event2.originalEvent && event2.originalEvent.target;
  return target && closest(target, '.group[data-group="tools"]');
}

// node_modules/diagram-js/lib/features/tool-manager/index.js
var tool_manager_default = {
  __depends__: [
    dragging_default
  ],
  __init__: ["toolManager"],
  toolManager: ["type", ToolManager]
};

// node_modules/diagram-js/lib/features/space-tool/SpaceUtil.js
function getDirection(axis, delta2) {
  if (axis === "x") {
    if (delta2 > 0) {
      return "e";
    }
    if (delta2 < 0) {
      return "w";
    }
  }
  if (axis === "y") {
    if (delta2 > 0) {
      return "s";
    }
    if (delta2 < 0) {
      return "n";
    }
  }
  return null;
}
function getWaypointsUpdatingConnections(movingShapes, resizingShapes) {
  var waypointsUpdatingConnections = [];
  forEach(movingShapes.concat(resizingShapes), function(shape) {
    var incoming = shape.incoming, outgoing = shape.outgoing;
    forEach(incoming.concat(outgoing), function(connection) {
      var source = connection.source, target = connection.target;
      if (includes3(movingShapes, source) || includes3(movingShapes, target) || includes3(resizingShapes, source) || includes3(resizingShapes, target)) {
        if (!includes3(waypointsUpdatingConnections, connection)) {
          waypointsUpdatingConnections.push(connection);
        }
      }
    });
  });
  return waypointsUpdatingConnections;
}
function includes3(array, item) {
  return array.indexOf(item) !== -1;
}
function resizeBounds2(bounds, direction, delta2) {
  var x6 = bounds.x, y5 = bounds.y, width = bounds.width, height = bounds.height, dx = delta2.x, dy = delta2.y;
  switch (direction) {
    case "n":
      return {
        x: x6,
        y: y5 + dy,
        width,
        height: height - dy
      };
    case "s":
      return {
        x: x6,
        y: y5,
        width,
        height: height + dy
      };
    case "w":
      return {
        x: x6 + dx,
        y: y5,
        width: width - dx,
        height
      };
    case "e":
      return {
        x: x6,
        y: y5,
        width: width + dx,
        height
      };
    default:
      throw new Error("unknown direction: " + direction);
  }
}

// node_modules/diagram-js/lib/features/space-tool/SpaceTool.js
var abs7 = Math.abs;
var round8 = Math.round;
var AXIS_TO_DIMENSION = {
  x: "width",
  y: "height"
};
var CURSOR_CROSSHAIR = "crosshair";
var DIRECTION_TO_TRBL = {
  n: "top",
  w: "left",
  s: "bottom",
  e: "right"
};
var HIGH_PRIORITY11 = 1500;
var DIRECTION_TO_OPPOSITE = {
  n: "s",
  w: "e",
  s: "n",
  e: "w"
};
var PADDING = 20;
function SpaceTool(canvas, dragging, eventBus, modeling, rules, toolManager, mouse) {
  this._canvas = canvas;
  this._dragging = dragging;
  this._eventBus = eventBus;
  this._modeling = modeling;
  this._rules = rules;
  this._toolManager = toolManager;
  this._mouse = mouse;
  var self2 = this;
  toolManager.registerTool("space", {
    tool: "spaceTool.selection",
    dragging: "spaceTool"
  });
  eventBus.on("spaceTool.selection.end", function(event2) {
    eventBus.once("spaceTool.selection.ended", function() {
      self2.activateMakeSpace(event2.originalEvent);
    });
  });
  eventBus.on("spaceTool.move", HIGH_PRIORITY11, function(event2) {
    var context = event2.context, initialized = context.initialized;
    if (!initialized) {
      initialized = context.initialized = self2.init(event2, context);
    }
    if (initialized) {
      ensureConstraints3(event2);
    }
  });
  eventBus.on("spaceTool.end", function(event2) {
    var context = event2.context, axis = context.axis, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start;
    if (!context.initialized) {
      return;
    }
    ensureConstraints3(event2);
    var delta2 = {
      x: 0,
      y: 0
    };
    delta2[axis] = round8(event2["d" + axis]);
    self2.makeSpace(movingShapes, resizingShapes, delta2, direction, start);
    eventBus.once("spaceTool.ended", function(event3) {
      self2.activateSelection(event3.originalEvent, true, true);
    });
  });
}
SpaceTool.$inject = [
  "canvas",
  "dragging",
  "eventBus",
  "modeling",
  "rules",
  "toolManager",
  "mouse"
];
SpaceTool.prototype.activateSelection = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "spaceTool.selection", {
    autoActivate,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {
        reactivate
      }
    },
    trapClick: false
  });
};
SpaceTool.prototype.activateMakeSpace = function(event2) {
  this._dragging.init(event2, "spaceTool", {
    autoActivate: true,
    cursor: CURSOR_CROSSHAIR,
    data: {
      context: {}
    }
  });
};
SpaceTool.prototype.makeSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  return this._modeling.createSpace(movingShapes, resizingShapes, delta2, direction, start);
};
SpaceTool.prototype.init = function(event2, context) {
  var axis = abs7(event2.dx) > abs7(event2.dy) ? "x" : "y", delta2 = event2["d" + axis], start = event2[axis] - delta2;
  if (abs7(delta2) < 5) {
    return false;
  }
  if (delta2 < 0) {
    delta2 *= -1;
  }
  if (hasPrimaryModifier(event2)) {
    delta2 *= -1;
  }
  var direction = getDirection(axis, delta2);
  var root = this._canvas.getRootElement();
  if (!hasSecondaryModifier(event2) && event2.hover) {
    root = event2.hover;
  }
  var children = [
    ...selfAndAllChildren(root, true),
    ...root.attachers || []
  ];
  var elements = this.calculateAdjustments(children, axis, delta2, start);
  var minDimensions = this._eventBus.fire("spaceTool.getMinDimensions", {
    axis,
    direction,
    shapes: elements.resizingShapes,
    start
  });
  var spaceToolConstraints = getSpaceToolConstraints(elements, axis, direction, start, minDimensions);
  assign(
    context,
    elements,
    {
      axis,
      direction,
      spaceToolConstraints,
      start
    }
  );
  set3("resize-" + (axis === "x" ? "ew" : "ns"));
  return true;
};
SpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var rules = this._rules;
  var movingShapes = [], resizingShapes = [];
  var attachers = [], connections = [];
  function moveShape(shape) {
    if (!movingShapes.includes(shape)) {
      movingShapes.push(shape);
    }
    var label = shape.label;
    if (label && !movingShapes.includes(label)) {
      movingShapes.push(label);
    }
  }
  function resizeShape(shape) {
    if (!resizingShapes.includes(shape)) {
      resizingShapes.push(shape);
    }
  }
  forEach(elements, function(element) {
    if (!element.parent || isLabel(element)) {
      return;
    }
    if (isConnection(element)) {
      connections.push(element);
      return;
    }
    var shapeStart = element[axis], shapeEnd = shapeStart + element[AXIS_TO_DIMENSION[axis]];
    if (isAttacher2(element) && (delta2 > 0 && getMid(element)[axis] > start || delta2 < 0 && getMid(element)[axis] < start)) {
      attachers.push(element);
      return;
    }
    if (delta2 > 0 && shapeStart > start || delta2 < 0 && shapeEnd < start) {
      moveShape(element);
      return;
    }
    if (shapeStart < start && shapeEnd > start && rules.allowed("shape.resize", { shape: element })) {
      resizeShape(element);
      return;
    }
  });
  forEach(movingShapes, function(shape) {
    var attachers2 = shape.attachers;
    if (attachers2) {
      forEach(attachers2, function(attacher) {
        moveShape(attacher);
      });
    }
  });
  var allShapes = movingShapes.concat(resizingShapes);
  forEach(attachers, function(attacher) {
    var host = attacher.host;
    if (includes4(allShapes, host)) {
      moveShape(attacher);
    }
  });
  allShapes = movingShapes.concat(resizingShapes);
  forEach(connections, function(connection) {
    var source = connection.source, target = connection.target, label = connection.label;
    if (includes4(allShapes, source) && includes4(allShapes, target) && label) {
      moveShape(label);
    }
  });
  return {
    movingShapes,
    resizingShapes
  };
};
SpaceTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
SpaceTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^spaceTool/.test(context.prefix);
  }
  return false;
};
function addPadding2(trbl) {
  return {
    top: trbl.top - PADDING,
    right: trbl.right + PADDING,
    bottom: trbl.bottom + PADDING,
    left: trbl.left - PADDING
  };
}
function ensureConstraints3(event2) {
  var context = event2.context, spaceToolConstraints = context.spaceToolConstraints;
  if (!spaceToolConstraints) {
    return;
  }
  var x6, y5;
  if (isNumber(spaceToolConstraints.left)) {
    x6 = Math.max(event2.x, spaceToolConstraints.left);
    event2.dx = event2.dx + x6 - event2.x;
    event2.x = x6;
  }
  if (isNumber(spaceToolConstraints.right)) {
    x6 = Math.min(event2.x, spaceToolConstraints.right);
    event2.dx = event2.dx + x6 - event2.x;
    event2.x = x6;
  }
  if (isNumber(spaceToolConstraints.top)) {
    y5 = Math.max(event2.y, spaceToolConstraints.top);
    event2.dy = event2.dy + y5 - event2.y;
    event2.y = y5;
  }
  if (isNumber(spaceToolConstraints.bottom)) {
    y5 = Math.min(event2.y, spaceToolConstraints.bottom);
    event2.dy = event2.dy + y5 - event2.y;
    event2.y = y5;
  }
}
function getSpaceToolConstraints(elements, axis, direction, start, minDimensions) {
  var movingShapes = elements.movingShapes, resizingShapes = elements.resizingShapes;
  if (!resizingShapes.length) {
    return;
  }
  var spaceToolConstraints = {}, min5, max8;
  forEach(resizingShapes, function(resizingShape) {
    var attachers = resizingShape.attachers, children = resizingShape.children;
    var resizingShapeBBox = asTRBL(resizingShape);
    var nonMovingResizingChildren = filter(children, function(child) {
      return !isConnection(child) && !isLabel(child) && !includes4(movingShapes, child) && !includes4(resizingShapes, child);
    });
    var movingChildren = filter(children, function(child) {
      return !isConnection(child) && !isLabel(child) && includes4(movingShapes, child);
    });
    var minOrMax, nonMovingResizingChildrenBBox, movingChildrenBBox, movingAttachers = [], nonMovingAttachers = [], movingAttachersBBox, movingAttachersConstraint, nonMovingAttachersBBox, nonMovingAttachersConstraint;
    if (nonMovingResizingChildren.length) {
      nonMovingResizingChildrenBBox = addPadding2(asTRBL(getBBox(nonMovingResizingChildren)));
      minOrMax = start - resizingShapeBBox[DIRECTION_TO_TRBL[direction]] + nonMovingResizingChildrenBBox[DIRECTION_TO_TRBL[direction]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
    if (movingChildren.length) {
      movingChildrenBBox = addPadding2(asTRBL(getBBox(movingChildren)));
      minOrMax = start - movingChildrenBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] + resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]];
      if (direction === "n") {
        spaceToolConstraints.bottom = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        spaceToolConstraints.right = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        spaceToolConstraints.top = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        spaceToolConstraints.left = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
    if (attachers && attachers.length) {
      attachers.forEach(function(attacher) {
        if (includes4(movingShapes, attacher)) {
          movingAttachers.push(attacher);
        } else {
          nonMovingAttachers.push(attacher);
        }
      });
      if (movingAttachers.length) {
        movingAttachersBBox = asTRBL(getBBox(movingAttachers.map(getMid)));
        movingAttachersConstraint = resizingShapeBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - (movingAttachersBBox[DIRECTION_TO_TRBL[DIRECTION_TO_OPPOSITE[direction]]] - start);
      }
      if (nonMovingAttachers.length) {
        nonMovingAttachersBBox = asTRBL(getBBox(nonMovingAttachers.map(getMid)));
        nonMovingAttachersConstraint = nonMovingAttachersBBox[DIRECTION_TO_TRBL[direction]] - (resizingShapeBBox[DIRECTION_TO_TRBL[direction]] - start);
      }
      if (direction === "n") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.bottom = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = Math.min(movingAttachersConstraint || Infinity, nonMovingAttachersConstraint || Infinity);
        spaceToolConstraints.right = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.top = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = Math.max(movingAttachersConstraint || -Infinity, nonMovingAttachersConstraint || -Infinity);
        spaceToolConstraints.left = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
    var resizingShapeMinDimensions = minDimensions && minDimensions[resizingShape.id];
    if (resizingShapeMinDimensions) {
      if (direction === "n") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.bottom = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "w") {
        minOrMax = start + resizingShape[AXIS_TO_DIMENSION[axis]] - resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.right = max8 = isNumber(max8) ? Math.min(max8, minOrMax) : minOrMax;
      } else if (direction === "s") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.top = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      } else if (direction === "e") {
        minOrMax = start - resizingShape[AXIS_TO_DIMENSION[axis]] + resizingShapeMinDimensions[AXIS_TO_DIMENSION[axis]];
        spaceToolConstraints.left = min5 = isNumber(min5) ? Math.max(min5, minOrMax) : minOrMax;
      }
    }
  });
  return spaceToolConstraints;
}
function includes4(array, item) {
  return array.indexOf(item) !== -1;
}
function isAttacher2(element) {
  return !!element.host;
}

// node_modules/diagram-js/lib/features/space-tool/SpaceToolPreview.js
var MARKER_DRAGGING = "djs-dragging";
var MARKER_RESIZING = "djs-resizing";
var LOW_PRIORITY18 = 250;
var max6 = Math.max;
function SpaceToolPreview(eventBus, elementRegistry, canvas, styles, previewSupport) {
  function addPreviewGfx(collection, dragGroup) {
    forEach(collection, function(element) {
      previewSupport.addDragger(element, dragGroup);
      canvas.addMarker(element, MARKER_DRAGGING);
    });
  }
  eventBus.on("spaceTool.selection.start", function(event2) {
    var space2 = canvas.getLayer("space"), context = event2.context;
    var orientation = {
      x: "M 0,-10000 L 0,10000",
      y: "M -10000,0 L 10000,0"
    };
    var crosshairGroup = create("g");
    attr(crosshairGroup, styles.cls("djs-crosshair-group", ["no-events"]));
    append(space2, crosshairGroup);
    var pathX = create("path");
    attr(pathX, "d", orientation.x);
    classes(pathX).add("djs-crosshair");
    append(crosshairGroup, pathX);
    var pathY = create("path");
    attr(pathY, "d", orientation.y);
    classes(pathY).add("djs-crosshair");
    append(crosshairGroup, pathY);
    context.crosshairGroup = crosshairGroup;
  });
  eventBus.on("spaceTool.selection.move", function(event2) {
    var crosshairGroup = event2.context.crosshairGroup;
    translate(crosshairGroup, event2.x, event2.y);
  });
  eventBus.on("spaceTool.selection.cleanup", function(event2) {
    var context = event2.context, crosshairGroup = context.crosshairGroup;
    if (crosshairGroup) {
      remove(crosshairGroup);
    }
  });
  eventBus.on("spaceTool.move", LOW_PRIORITY18, function(event2) {
    var context = event2.context, line2 = context.line, axis = context.axis, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes;
    if (!context.initialized) {
      return;
    }
    if (!context.dragGroup) {
      var spaceLayer = canvas.getLayer("space");
      line2 = create("path");
      attr(line2, "d", "M0,0 L0,0");
      classes(line2).add("djs-crosshair");
      append(spaceLayer, line2);
      context.line = line2;
      var dragGroup = create("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      append(canvas.getActiveLayer(), dragGroup);
      addPreviewGfx(movingShapes, dragGroup);
      var movingConnections = context.movingConnections = elementRegistry.filter(function(element) {
        var sourceIsMoving = false;
        forEach(movingShapes, function(shape) {
          forEach(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsMoving = true;
            }
          });
        });
        var targetIsMoving = false;
        forEach(movingShapes, function(shape) {
          forEach(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsMoving = true;
            }
          });
        });
        var sourceIsResizing = false;
        forEach(resizingShapes, function(shape) {
          forEach(shape.outgoing, function(connection) {
            if (element === connection) {
              sourceIsResizing = true;
            }
          });
        });
        var targetIsResizing = false;
        forEach(resizingShapes, function(shape) {
          forEach(shape.incoming, function(connection) {
            if (element === connection) {
              targetIsResizing = true;
            }
          });
        });
        return isConnection(element) && (sourceIsMoving || sourceIsResizing) && (targetIsMoving || targetIsResizing);
      });
      addPreviewGfx(movingConnections, dragGroup);
      context.dragGroup = dragGroup;
    }
    if (!context.frameGroup) {
      var frameGroup = create("g");
      attr(frameGroup, styles.cls("djs-frame-group", ["no-events"]));
      append(canvas.getActiveLayer(), frameGroup);
      var frames = [];
      forEach(resizingShapes, function(shape) {
        var frame = previewSupport.addFrame(shape, frameGroup);
        var initialBounds = frame.getBBox();
        frames.push({
          element: frame,
          initialBounds
        });
        canvas.addMarker(shape, MARKER_RESIZING);
      });
      context.frameGroup = frameGroup;
      context.frames = frames;
    }
    var orientation = {
      x: "M" + event2.x + ", -10000 L" + event2.x + ", 10000",
      y: "M -10000, " + event2.y + " L 10000, " + event2.y
    };
    attr(line2, { d: orientation[axis] });
    var opposite = { x: "y", y: "x" };
    var delta2 = { x: event2.dx, y: event2.dy };
    delta2[opposite[context.axis]] = 0;
    translate(context.dragGroup, delta2.x, delta2.y);
    forEach(context.frames, function(frame) {
      var element = frame.element, initialBounds = frame.initialBounds, width, height;
      if (context.direction === "e") {
        attr(element, {
          width: max6(initialBounds.width + delta2.x, 5)
        });
      } else {
        width = max6(initialBounds.width - delta2.x, 5);
        attr(element, {
          width,
          x: initialBounds.x + initialBounds.width - width
        });
      }
      if (context.direction === "s") {
        attr(element, {
          height: max6(initialBounds.height + delta2.y, 5)
        });
      } else {
        height = max6(initialBounds.height - delta2.y, 5);
        attr(element, {
          height,
          y: initialBounds.y + initialBounds.height - height
        });
      }
    });
  });
  eventBus.on("spaceTool.cleanup", function(event2) {
    var context = event2.context, movingShapes = context.movingShapes, movingConnections = context.movingConnections, resizingShapes = context.resizingShapes, line2 = context.line, dragGroup = context.dragGroup, frameGroup = context.frameGroup;
    forEach(movingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_DRAGGING);
    });
    forEach(movingConnections, function(connection) {
      canvas.removeMarker(connection, MARKER_DRAGGING);
    });
    if (dragGroup) {
      remove(line2);
      remove(dragGroup);
    }
    forEach(resizingShapes, function(shape) {
      canvas.removeMarker(shape, MARKER_RESIZING);
    });
    if (frameGroup) {
      remove(frameGroup);
    }
  });
}
SpaceToolPreview.$inject = [
  "eventBus",
  "elementRegistry",
  "canvas",
  "styles",
  "previewSupport"
];

// node_modules/diagram-js/lib/features/space-tool/index.js
var space_tool_default = {
  __init__: ["spaceToolPreview"],
  __depends__: [
    dragging_default,
    rules_default,
    tool_manager_default,
    preview_support_default,
    mouse_default
  ],
  spaceTool: ["type", SpaceTool],
  spaceToolPreview: ["type", SpaceToolPreview]
};

// node_modules/bpmn-js/lib/features/space-tool/BpmnSpaceTool.js
function BpmnSpaceTool(injector, canvas) {
  injector.invoke(SpaceTool, this);
  this._canvas = canvas;
}
BpmnSpaceTool.$inject = [
  "injector",
  "canvas"
];
e(BpmnSpaceTool, SpaceTool);
BpmnSpaceTool.prototype.calculateAdjustments = function(elements, axis, delta2, start) {
  var canvasRoot = this._canvas.getRootElement(), spaceRoot = elements[0] === canvasRoot ? null : elements[0], enclosedArtifacts = [];
  if (spaceRoot) {
    enclosedArtifacts = values(
      getEnclosedElements(
        canvasRoot.children.filter(
          (child) => is(child, "bpmn:Artifact")
        ),
        getBBox(spaceRoot)
      )
    );
  }
  const elementsToMove = [...elements, ...enclosedArtifacts];
  var adjustments = SpaceTool.prototype.calculateAdjustments.call(this, elementsToMove, axis, delta2, start);
  adjustments.resizingShapes = adjustments.resizingShapes.filter(function(shape) {
    if (is(shape, "bpmn:TextAnnotation")) {
      return false;
    }
    if (isCollapsedPool(shape)) {
      if (axis === "y" && isHorizontal(shape) || axis === "x" && !isHorizontal(shape)) {
        return false;
      }
    }
    return true;
  });
  return adjustments;
};
function isCollapsedPool(shape) {
  return is(shape, "bpmn:Participant") && !getBusinessObject(shape).processRef;
}

// node_modules/bpmn-js/lib/features/space-tool/index.js
var space_tool_default2 = {
  __depends__: [space_tool_default],
  spaceTool: ["type", BpmnSpaceTool]
};

// node_modules/diagram-js/lib/command/CommandStack.js
function CommandStack(eventBus, injector) {
  this._handlerMap = {};
  this._stack = [];
  this._stackIdx = -1;
  this._currentExecution = {
    actions: [],
    dirty: [],
    trigger: null
  };
  this._injector = injector;
  this._eventBus = eventBus;
  this._uid = 1;
  eventBus.on([
    "diagram.destroy",
    "diagram.clear"
  ], function() {
    this.clear(false);
  }, this);
}
CommandStack.$inject = ["eventBus", "injector"];
CommandStack.prototype.execute = function(command, context) {
  if (!command) {
    throw new Error("command required");
  }
  this._currentExecution.trigger = "execute";
  const action = { command, context };
  this._pushAction(action);
  this._internalExecute(action);
  this._popAction();
};
CommandStack.prototype.canExecute = function(command, context) {
  const action = { command, context };
  const handler = this._getHandler(command);
  let result = this._fire(command, "canExecute", action);
  if (result === void 0) {
    if (!handler) {
      return false;
    }
    if (handler.canExecute) {
      result = handler.canExecute(context);
    }
  }
  return result;
};
CommandStack.prototype.clear = function(emit) {
  this._stack.length = 0;
  this._stackIdx = -1;
  if (emit !== false) {
    this._fire("changed", { trigger: "clear" });
  }
};
CommandStack.prototype.undo = function() {
  let action = this._getUndoAction(), next;
  if (action) {
    this._currentExecution.trigger = "undo";
    this._pushAction(action);
    while (action) {
      this._internalUndo(action);
      next = this._getUndoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.redo = function() {
  let action = this._getRedoAction(), next;
  if (action) {
    this._currentExecution.trigger = "redo";
    this._pushAction(action);
    while (action) {
      this._internalExecute(action, true);
      next = this._getRedoAction();
      if (!next || next.id !== action.id) {
        break;
      }
      action = next;
    }
    this._popAction();
  }
};
CommandStack.prototype.register = function(command, handler) {
  this._setHandler(command, handler);
};
CommandStack.prototype.registerHandler = function(command, handlerCls) {
  if (!command || !handlerCls) {
    throw new Error("command and handlerCls must be defined");
  }
  const handler = this._injector.instantiate(handlerCls);
  this.register(command, handler);
};
CommandStack.prototype.canUndo = function() {
  return !!this._getUndoAction();
};
CommandStack.prototype.canRedo = function() {
  return !!this._getRedoAction();
};
CommandStack.prototype._getRedoAction = function() {
  return this._stack[this._stackIdx + 1];
};
CommandStack.prototype._getUndoAction = function() {
  return this._stack[this._stackIdx];
};
CommandStack.prototype._internalUndo = function(action) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  this._atomicDo(() => {
    this._fire(command, "revert", action);
    if (handler.revert) {
      this._markDirty(handler.revert(context));
    }
    this._revertedAction(action);
    this._fire(command, "reverted", action);
  });
};
CommandStack.prototype._fire = function(command, qualifier, event2) {
  if (arguments.length < 3) {
    event2 = qualifier;
    qualifier = null;
  }
  const names = qualifier ? [command + "." + qualifier, qualifier] : [command];
  let result;
  event2 = this._eventBus.createEvent(event2);
  for (const name2 of names) {
    result = this._eventBus.fire("commandStack." + name2, event2);
    if (event2.cancelBubble) {
      break;
    }
  }
  return result;
};
CommandStack.prototype._createId = function() {
  return this._uid++;
};
CommandStack.prototype._atomicDo = function(fn2) {
  const execution = this._currentExecution;
  execution.atomic = true;
  try {
    fn2();
  } finally {
    execution.atomic = false;
  }
};
CommandStack.prototype._internalExecute = function(action, redo) {
  const command = action.command, context = action.context;
  const handler = this._getHandler(command);
  if (!handler) {
    throw new Error("no command handler registered for <" + command + ">");
  }
  this._pushAction(action);
  if (!redo) {
    this._fire(command, "preExecute", action);
    if (handler.preExecute) {
      handler.preExecute(context);
    }
    this._fire(command, "preExecuted", action);
  }
  this._atomicDo(() => {
    this._fire(command, "execute", action);
    if (handler.execute) {
      this._markDirty(handler.execute(context));
    }
    this._executedAction(action, redo);
    this._fire(command, "executed", action);
  });
  if (!redo) {
    this._fire(command, "postExecute", action);
    if (handler.postExecute) {
      handler.postExecute(context);
    }
    this._fire(command, "postExecuted", action);
  }
  this._popAction();
};
CommandStack.prototype._pushAction = function(action) {
  const execution = this._currentExecution, actions = execution.actions;
  const baseAction = actions[0];
  if (execution.atomic) {
    throw new Error("illegal invocation in <execute> or <revert> phase (action: " + action.command + ")");
  }
  if (!action.id) {
    action.id = baseAction && baseAction.id || this._createId();
  }
  actions.push(action);
};
CommandStack.prototype._popAction = function() {
  const execution = this._currentExecution, trigger = execution.trigger, actions = execution.actions, dirty = execution.dirty;
  actions.pop();
  if (!actions.length) {
    this._eventBus.fire("elements.changed", { elements: uniqueBy("id", dirty.reverse()) });
    dirty.length = 0;
    this._fire("changed", { trigger });
    execution.trigger = null;
  }
};
CommandStack.prototype._markDirty = function(elements) {
  const execution = this._currentExecution;
  if (!elements) {
    return;
  }
  elements = isArray(elements) ? elements : [elements];
  execution.dirty = execution.dirty.concat(elements);
};
CommandStack.prototype._executedAction = function(action, redo) {
  const stackIdx = ++this._stackIdx;
  if (!redo) {
    this._stack.splice(stackIdx, this._stack.length, action);
  }
};
CommandStack.prototype._revertedAction = function(action) {
  this._stackIdx--;
};
CommandStack.prototype._getHandler = function(command) {
  return this._handlerMap[command];
};
CommandStack.prototype._setHandler = function(command, handler) {
  if (!command || !handler) {
    throw new Error("command and handler required");
  }
  if (this._handlerMap[command]) {
    throw new Error("overriding handler for command <" + command + ">");
  }
  this._handlerMap[command] = handler;
};

// node_modules/diagram-js/lib/command/index.js
var command_default = {
  commandStack: ["type", CommandStack]
};

// node_modules/diagram-js/lib/util/Removal.js
function saveClear(collection, removeFn) {
  if (typeof removeFn !== "function") {
    throw new Error("removeFn iterator must be a function");
  }
  if (!collection) {
    return;
  }
  var e8;
  while (e8 = collection[0]) {
    removeFn(e8);
  }
  return collection;
}

// node_modules/diagram-js/lib/features/label-support/LabelSupport.js
var LOW_PRIORITY19 = 250;
var HIGH_PRIORITY12 = 1400;
function LabelSupport(injector, eventBus, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY12, function(e8) {
    var context = e8.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = removeLabels(shapes);
    context.validatedShapes = removeLabels(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY19, function(e8) {
    var context = e8.context, shapes = context.shapes;
    var labels = [];
    forEach(shapes, function(element) {
      forEach(element.labels, function(label) {
        if (!label.hidden && context.shapes.indexOf(label) === -1) {
          labels.push(label);
        }
        if (element.labelTarget) {
          labels.push(element);
        }
      });
    });
    forEach(labels, function(label) {
      movePreview.makeDraggable(context, label, true);
    });
  });
  this.preExecuted("elements.move", HIGH_PRIORITY12, function(e8) {
    var context = e8.context, closure = context.closure, enclosedElements = closure.enclosedElements;
    var enclosedLabels = [];
    forEach(enclosedElements, function(element) {
      forEach(element.labels, function(label) {
        if (!enclosedElements[label.id]) {
          enclosedLabels.push(label);
        }
      });
    });
    closure.addAll(enclosedLabels);
  });
  this.preExecute([
    "connection.delete",
    "shape.delete"
  ], function(e8) {
    var context = e8.context, element = context.connection || context.shape;
    saveClear(element.labels, function(label) {
      modeling.removeShape(label, { nested: true });
    });
  });
  this.execute("shape.delete", function(e8) {
    var context = e8.context, shape = context.shape, labelTarget = shape.labelTarget;
    if (labelTarget) {
      context.labelTargetIndex = indexOf(labelTarget.labels, shape);
      context.labelTarget = labelTarget;
      shape.labelTarget = null;
    }
  });
  this.revert("shape.delete", function(e8) {
    var context = e8.context, shape = context.shape, labelTarget = context.labelTarget, labelTargetIndex = context.labelTargetIndex;
    if (labelTarget) {
      add2(labelTarget.labels, shape, labelTargetIndex);
      shape.labelTarget = labelTarget;
    }
  });
}
e(LabelSupport, CommandInterceptor);
LabelSupport.$inject = [
  "injector",
  "eventBus",
  "modeling"
];
function removeLabels(elements) {
  return filter(elements, function(element) {
    return elements.indexOf(element.labelTarget) === -1;
  });
}

// node_modules/diagram-js/lib/features/label-support/index.js
var label_support_default = {
  __init__: ["labelSupport"],
  labelSupport: ["type", LabelSupport]
};

// node_modules/diagram-js/lib/features/attach-support/AttachSupport.js
var LOW_PRIORITY20 = 251;
var HIGH_PRIORITY13 = 1401;
var MARKER_ATTACH2 = "attach-ok";
function AttachSupport(injector, eventBus, canvas, rules, modeling) {
  CommandInterceptor.call(this, eventBus);
  var movePreview = injector.get("movePreview", false);
  eventBus.on("shape.move.start", HIGH_PRIORITY13, function(e8) {
    var context = e8.context, shapes = context.shapes, validatedShapes = context.validatedShapes;
    context.shapes = addAttached(shapes);
    context.validatedShapes = removeAttached(validatedShapes);
  });
  movePreview && eventBus.on("shape.move.start", LOW_PRIORITY20, function(e8) {
    var context = e8.context, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach(attachers, function(attacher) {
      movePreview.makeDraggable(context, attacher, true);
      forEach(attacher.labels, function(label) {
        movePreview.makeDraggable(context, label, true);
      });
    });
  });
  movePreview && eventBus.on("shape.move.start", function(event2) {
    var context = event2.context, shapes = context.shapes;
    if (shapes.length !== 1) {
      return;
    }
    var shape = shapes[0];
    var host = shape.host;
    if (host) {
      canvas.addMarker(host, MARKER_ATTACH2);
      eventBus.once([
        "shape.move.out",
        "shape.move.cleanup"
      ], function() {
        canvas.removeMarker(host, MARKER_ATTACH2);
      });
    }
  });
  this.preExecuted("elements.move", HIGH_PRIORITY13, function(e8) {
    var context = e8.context, closure = context.closure, shapes = context.shapes, attachers = getAttachers(shapes);
    forEach(attachers, function(attacher) {
      closure.add(attacher, closure.topLevel[attacher.host.id]);
    });
  });
  this.postExecuted("elements.move", function(e8) {
    var context = e8.context, shapes = context.shapes, newHost = context.newHost, attachers;
    if (newHost && shapes.length !== 1) {
      return;
    }
    if (newHost) {
      attachers = shapes;
    } else {
      attachers = filter(shapes, function(shape) {
        var host = shape.host;
        return isAttacher3(shape) && !includes5(shapes, host);
      });
    }
    forEach(attachers, function(attacher) {
      modeling.updateAttachment(attacher, newHost);
    });
  });
  this.postExecuted("elements.move", function(e8) {
    var shapes = e8.context.shapes;
    forEach(shapes, function(shape) {
      forEach(shape.attachers, function(attacher) {
        forEach(attacher.outgoing.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
        forEach(attacher.incoming.slice(), function(connection) {
          var allowed = rules.allowed("connection.reconnect", {
            connection,
            source: connection.source,
            target: connection.target
          });
          if (!allowed) {
            modeling.removeConnection(connection);
          }
        });
      });
    });
  });
  this.postExecute("shape.create", function(e8) {
    var context = e8.context, shape = context.shape, host = context.host;
    if (host) {
      modeling.updateAttachment(shape, host);
    }
  });
  this.postExecute("shape.replace", function(e8) {
    var context = e8.context, oldShape = context.oldShape, newShape = context.newShape;
    saveClear(oldShape.attachers, function(attacher) {
      var allowed = rules.allowed("elements.move", {
        target: newShape,
        shapes: [attacher]
      });
      if (allowed === "attach") {
        modeling.updateAttachment(attacher, newShape);
      } else {
        modeling.removeShape(attacher);
      }
    });
    if (newShape.attachers.length) {
      forEach(newShape.attachers, function(attacher) {
        var delta2 = getNewAttachShapeDelta(attacher, oldShape, newShape);
        modeling.moveShape(attacher, delta2, attacher.parent);
      });
    }
  });
  this.postExecute("shape.resize", function(event2) {
    var context = event2.context, shape = context.shape, oldBounds = context.oldBounds, newBounds = context.newBounds, attachers = shape.attachers, hints = context.hints || {};
    if (hints.attachSupport === false) {
      return;
    }
    forEach(attachers, function(attacher) {
      var delta2 = getNewAttachShapeDelta(attacher, oldBounds, newBounds);
      modeling.moveShape(attacher, delta2, attacher.parent);
      forEach(attacher.labels, function(label) {
        modeling.moveShape(label, delta2, label.parent);
      });
    });
  });
  this.preExecute("shape.delete", function(event2) {
    var shape = event2.context.shape;
    saveClear(shape.attachers, function(attacher) {
      modeling.removeShape(attacher);
    });
    if (shape.host) {
      modeling.updateAttachment(shape, null);
    }
  });
}
e(AttachSupport, CommandInterceptor);
AttachSupport.$inject = [
  "injector",
  "eventBus",
  "canvas",
  "rules",
  "modeling"
];
function getAttachers(shapes) {
  return flatten(map(shapes, function(s5) {
    return s5.attachers || [];
  }));
}
function addAttached(elements) {
  var attachers = getAttachers(elements);
  return unionBy("id", elements, attachers);
}
function removeAttached(elements) {
  var ids3 = groupBy(elements, "id");
  return filter(elements, function(element) {
    while (element) {
      if (element.host && ids3[element.host.id]) {
        return false;
      }
      element = element.parent;
    }
    return true;
  });
}
function isAttacher3(shape) {
  return !!shape.host;
}
function includes5(array, item) {
  return array.indexOf(item) !== -1;
}

// node_modules/diagram-js/lib/features/attach-support/index.js
var attach_support_default = {
  __depends__: [
    rules_default
  ],
  __init__: ["attachSupport"],
  attachSupport: ["type", AttachSupport]
};

// node_modules/bpmn-js/lib/features/modeling/BpmnFactory.js
function BpmnFactory(moddle) {
  this._model = moddle;
}
BpmnFactory.$inject = ["moddle"];
BpmnFactory.prototype._needsId = function(element) {
  return isAny(element, [
    "bpmn:RootElement",
    "bpmn:FlowElement",
    "bpmn:MessageFlow",
    "bpmn:DataAssociation",
    "bpmn:Artifact",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:LaneSet",
    "bpmn:Process",
    "bpmn:Collaboration",
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane",
    "bpmn:Property",
    "bpmn:CategoryValue"
  ]);
};
BpmnFactory.prototype._ensureId = function(element) {
  if (element.id) {
    this._model.ids.claim(element.id, element);
    return;
  }
  var prefix3;
  if (is(element, "bpmn:Activity")) {
    prefix3 = "Activity";
  } else if (is(element, "bpmn:Event")) {
    prefix3 = "Event";
  } else if (is(element, "bpmn:Gateway")) {
    prefix3 = "Gateway";
  } else if (isAny(element, ["bpmn:SequenceFlow", "bpmn:MessageFlow"])) {
    prefix3 = "Flow";
  } else {
    prefix3 = (element.$type || "").replace(/^[^:]*:/g, "");
  }
  prefix3 += "_";
  if (!element.id && this._needsId(element)) {
    element.id = this._model.ids.nextPrefixed(prefix3, element);
  }
};
BpmnFactory.prototype.create = function(type, attrs) {
  var element = this._model.create(type, attrs || {});
  this._ensureId(element);
  return element;
};
BpmnFactory.prototype.createDiLabel = function() {
  return this.create("bpmndi:BPMNLabel", {
    bounds: this.createDiBounds()
  });
};
BpmnFactory.prototype.createDiShape = function(semantic, attrs) {
  return this.create("bpmndi:BPMNShape", assign({
    bpmnElement: semantic,
    bounds: this.createDiBounds()
  }, attrs));
};
BpmnFactory.prototype.createDiBounds = function(bounds) {
  return this.create("dc:Bounds", bounds);
};
BpmnFactory.prototype.createDiWaypoints = function(waypoints) {
  var self2 = this;
  return map(waypoints, function(pos) {
    return self2.createDiWaypoint(pos);
  });
};
BpmnFactory.prototype.createDiWaypoint = function(point) {
  return this.create("dc:Point", pick(point, ["x", "y"]));
};
BpmnFactory.prototype.createDiEdge = function(semantic, attrs) {
  return this.create("bpmndi:BPMNEdge", assign({
    bpmnElement: semantic,
    waypoint: this.createDiWaypoints([])
  }, attrs));
};
BpmnFactory.prototype.createDiPlane = function(semantic, attrs) {
  return this.create("bpmndi:BPMNPlane", assign({
    bpmnElement: semantic
  }, attrs));
};

// node_modules/bpmn-js/lib/features/modeling/BpmnUpdater.js
function BpmnUpdater(eventBus, bpmnFactory, connectionDocking) {
  CommandInterceptor.call(this, eventBus);
  this._bpmnFactory = bpmnFactory;
  var self2 = this;
  function cropConnection(e8) {
    var context = e8.context, hints = context.hints || {}, connection;
    if (!context.cropped && hints.createElementsBehavior !== false) {
      connection = context.connection;
      connection.waypoints = connectionDocking.getCroppedWaypoints(connection);
      context.cropped = true;
    }
  }
  this.executed([
    "connection.layout",
    "connection.create"
  ], cropConnection);
  this.reverted(["connection.layout"], function(e8) {
    delete e8.context.cropped;
  });
  function updateParent(e8) {
    var context = e8.context;
    self2.updateParent(context.shape || context.connection, context.oldParent);
  }
  function reverseUpdateParent(e8) {
    var context = e8.context;
    var element = context.shape || context.connection, oldParent = context.parent || context.newParent;
    self2.updateParent(element, oldParent);
  }
  this.executed([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(updateParent));
  this.reverted([
    "shape.move",
    "shape.create",
    "shape.delete",
    "connection.create",
    "connection.move",
    "connection.delete"
  ], ifBpmn(reverseUpdateParent));
  function updateRoot(event2) {
    var context = event2.context, oldRoot = context.oldRoot, children = oldRoot.children;
    forEach(children, function(child) {
      if (is(child, "bpmn:BaseElement")) {
        self2.updateParent(child);
      }
    });
  }
  this.executed(["canvas.updateRoot"], updateRoot);
  this.reverted(["canvas.updateRoot"], updateRoot);
  function updateBounds(e8) {
    var shape = e8.context.shape;
    if (!is(shape, "bpmn:BaseElement")) {
      return;
    }
    self2.updateBounds(shape);
  }
  this.executed(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  this.reverted(["shape.move", "shape.create", "shape.resize"], ifBpmn(function(event2) {
    if (event2.context.shape.type === "label") {
      return;
    }
    updateBounds(event2);
  }));
  eventBus.on("shape.changed", function(event2) {
    if (event2.element.type === "label") {
      updateBounds({ context: { shape: event2.element } });
    }
  });
  function updateConnection(e8) {
    self2.updateConnection(e8.context);
  }
  this.executed([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  this.reverted([
    "connection.create",
    "connection.move",
    "connection.delete",
    "connection.reconnect"
  ], ifBpmn(updateConnection));
  function updateConnectionWaypoints(e8) {
    self2.updateConnectionWaypoints(e8.context.connection);
  }
  this.executed([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.reverted([
    "connection.layout",
    "connection.move",
    "connection.updateWaypoints"
  ], ifBpmn(updateConnectionWaypoints));
  this.executed("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (connectionBo.conditionExpression && !isAny(newSourceBo, [
      "bpmn:Activity",
      "bpmn:ExclusiveGateway",
      "bpmn:InclusiveGateway"
    ])) {
      context.oldConditionExpression = connectionBo.conditionExpression;
      delete connectionBo.conditionExpression;
    }
    if (oldSource !== newSource && oldSourceBo.default === connectionBo) {
      context.oldDefault = oldSourceBo.default;
      delete oldSourceBo.default;
    }
  }));
  this.reverted("connection.reconnect", ifBpmn(function(event2) {
    var context = event2.context, connection = context.connection, oldSource = context.oldSource, newSource = context.newSource, connectionBo = getBusinessObject(connection), oldSourceBo = getBusinessObject(oldSource), newSourceBo = getBusinessObject(newSource);
    if (context.oldConditionExpression) {
      connectionBo.conditionExpression = context.oldConditionExpression;
    }
    if (context.oldDefault) {
      oldSourceBo.default = context.oldDefault;
      delete newSourceBo.default;
    }
  }));
  function updateAttachment(e8) {
    self2.updateAttachment(e8.context);
  }
  this.executed(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.reverted(["element.updateAttachment"], ifBpmn(updateAttachment));
  this.executed("element.updateLabel", ifBpmn(updateBPMNLabel));
  this.reverted("element.updateLabel", ifBpmn(updateBPMNLabel));
  function updateBPMNLabel(event2) {
    const { element } = event2.context, label = getLabel(element);
    const di = getDi(element), diLabel = di && di.get("label");
    if (isLabelExternal(element) || isPlane(element)) {
      return;
    }
    if (label && !diLabel) {
      di.set("label", bpmnFactory.create("bpmndi:BPMNLabel"));
    } else if (!label && diLabel) {
      di.set("label", void 0);
    }
  }
}
e(BpmnUpdater, CommandInterceptor);
BpmnUpdater.$inject = [
  "eventBus",
  "bpmnFactory",
  "connectionDocking"
];
BpmnUpdater.prototype.updateAttachment = function(context) {
  var shape = context.shape, businessObject = shape.businessObject, host = shape.host;
  businessObject.attachedToRef = host && host.businessObject;
};
BpmnUpdater.prototype.updateParent = function(element, oldParent) {
  if (isLabel(element)) {
    return;
  }
  if (is(element, "bpmn:DataStoreReference") && element.parent && is(element.parent, "bpmn:Collaboration")) {
    return;
  }
  var parentShape = element.parent;
  var businessObject = element.businessObject, di = getDi(element), parentBusinessObject = parentShape && parentShape.businessObject, parentDi = getDi(parentShape);
  if (is(element, "bpmn:FlowNode")) {
    this.updateFlowNodeRefs(businessObject, parentBusinessObject, oldParent && oldParent.businessObject);
  }
  if (is(element, "bpmn:DataOutputAssociation")) {
    if (element.source) {
      parentBusinessObject = element.source.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  if (is(element, "bpmn:DataInputAssociation")) {
    if (element.target) {
      parentBusinessObject = element.target.businessObject;
    } else {
      parentBusinessObject = null;
    }
  }
  this.updateSemanticParent(businessObject, parentBusinessObject);
  if (is(element, "bpmn:DataObjectReference") && businessObject.dataObjectRef) {
    this.updateSemanticParent(businessObject.dataObjectRef, parentBusinessObject);
  }
  this.updateDiParent(di, parentDi);
};
BpmnUpdater.prototype.updateBounds = function(shape) {
  var di = getDi(shape), embeddedLabelBounds = getEmbeddedLabelBounds(shape);
  if (embeddedLabelBounds) {
    var embeddedLabelBoundsDelta = delta(embeddedLabelBounds, di.get("bounds"));
    assign(embeddedLabelBounds, {
      x: shape.x + embeddedLabelBoundsDelta.x,
      y: shape.y + embeddedLabelBoundsDelta.y
    });
  }
  var target = isLabel(shape) ? this._getLabel(di) : di;
  var bounds = target.bounds;
  if (!bounds) {
    bounds = this._bpmnFactory.createDiBounds();
    target.set("bounds", bounds);
  }
  assign(bounds, {
    x: shape.x,
    y: shape.y,
    width: shape.width,
    height: shape.height
  });
};
BpmnUpdater.prototype.updateFlowNodeRefs = function(businessObject, newContainment, oldContainment) {
  if (oldContainment === newContainment) {
    return;
  }
  var oldRefs, newRefs;
  if (is(oldContainment, "bpmn:Lane")) {
    oldRefs = oldContainment.get("flowNodeRef");
    remove3(oldRefs, businessObject);
  }
  if (is(newContainment, "bpmn:Lane")) {
    newRefs = newContainment.get("flowNodeRef");
    add2(newRefs, businessObject);
  }
};
BpmnUpdater.prototype.updateDiConnection = function(connection, newSource, newTarget) {
  var connectionDi = getDi(connection), newSourceDi = getDi(newSource), newTargetDi = getDi(newTarget);
  if (connectionDi.sourceElement && connectionDi.sourceElement.bpmnElement !== getBusinessObject(newSource)) {
    connectionDi.sourceElement = newSource && newSourceDi;
  }
  if (connectionDi.targetElement && connectionDi.targetElement.bpmnElement !== getBusinessObject(newTarget)) {
    connectionDi.targetElement = newTarget && newTargetDi;
  }
};
BpmnUpdater.prototype.updateDiParent = function(di, parentDi) {
  if (parentDi && !is(parentDi, "bpmndi:BPMNPlane")) {
    parentDi = parentDi.$parent;
  }
  if (di.$parent === parentDi) {
    return;
  }
  var planeElements = (parentDi || di.$parent).get("planeElement");
  if (parentDi) {
    planeElements.push(di);
    di.$parent = parentDi;
  } else {
    remove3(planeElements, di);
    di.$parent = null;
  }
};
function getDefinitions(element) {
  while (element && !is(element, "bpmn:Definitions")) {
    element = element.$parent;
  }
  return element;
}
BpmnUpdater.prototype.getLaneSet = function(container) {
  var laneSet, laneSets;
  if (is(container, "bpmn:Lane")) {
    laneSet = container.childLaneSet;
    if (!laneSet) {
      laneSet = this._bpmnFactory.create("bpmn:LaneSet");
      container.childLaneSet = laneSet;
      laneSet.$parent = container;
    }
    return laneSet;
  }
  if (is(container, "bpmn:Participant")) {
    container = container.processRef;
  }
  laneSets = container.get("laneSets");
  laneSet = laneSets[0];
  if (!laneSet) {
    laneSet = this._bpmnFactory.create("bpmn:LaneSet");
    laneSet.$parent = container;
    laneSets.push(laneSet);
  }
  return laneSet;
};
BpmnUpdater.prototype.updateSemanticParent = function(businessObject, newParent, visualParent) {
  var containment;
  if (businessObject.$parent === newParent) {
    return;
  }
  if (is(businessObject, "bpmn:DataInput") || is(businessObject, "bpmn:DataOutput")) {
    if (is(newParent, "bpmn:Participant") && "processRef" in newParent) {
      newParent = newParent.processRef;
    }
    if ("ioSpecification" in newParent && newParent.ioSpecification === businessObject.$parent) {
      return;
    }
  }
  if (is(businessObject, "bpmn:Lane")) {
    if (newParent) {
      newParent = this.getLaneSet(newParent);
    }
    containment = "lanes";
  } else if (is(businessObject, "bpmn:FlowElement")) {
    if (newParent) {
      if (is(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
      } else if (is(newParent, "bpmn:Lane")) {
        do {
          newParent = newParent.$parent.$parent;
        } while (is(newParent, "bpmn:Lane"));
      }
    }
    containment = "flowElements";
  } else if (is(businessObject, "bpmn:Artifact")) {
    while (newParent && !is(newParent, "bpmn:Process") && !is(newParent, "bpmn:SubProcess") && !is(newParent, "bpmn:Collaboration")) {
      if (is(newParent, "bpmn:Participant")) {
        newParent = newParent.processRef;
        break;
      } else {
        newParent = newParent.$parent;
      }
    }
    containment = "artifacts";
  } else if (is(businessObject, "bpmn:MessageFlow")) {
    containment = "messageFlows";
  } else if (is(businessObject, "bpmn:Participant")) {
    containment = "participants";
    var process2 = businessObject.processRef, definitions;
    if (process2) {
      definitions = getDefinitions(businessObject.$parent || newParent);
      if (businessObject.$parent) {
        remove3(definitions.get("rootElements"), process2);
        process2.$parent = null;
      }
      if (newParent) {
        add2(definitions.get("rootElements"), process2);
        process2.$parent = definitions;
      }
    }
  } else if (is(businessObject, "bpmn:DataOutputAssociation")) {
    containment = "dataOutputAssociations";
  } else if (is(businessObject, "bpmn:DataInputAssociation")) {
    containment = "dataInputAssociations";
  }
  if (!containment) {
    throw new Error(`no parent for <${businessObject.id}> in <${newParent.id}>`);
  }
  var children;
  if (businessObject.$parent) {
    children = businessObject.$parent.get(containment);
    remove3(children, businessObject);
  }
  if (!newParent) {
    businessObject.$parent = null;
  } else {
    children = newParent.get(containment);
    children.push(businessObject);
    businessObject.$parent = newParent;
  }
  if (visualParent) {
    var diChildren = visualParent.get(containment);
    remove3(children, businessObject);
    if (newParent) {
      if (!diChildren) {
        diChildren = [];
        newParent.set(containment, diChildren);
      }
      diChildren.push(businessObject);
    }
  }
};
BpmnUpdater.prototype.updateConnectionWaypoints = function(connection) {
  var di = getDi(connection);
  di.set("waypoint", this._bpmnFactory.createDiWaypoints(connection.waypoints));
};
BpmnUpdater.prototype.updateConnection = function(context) {
  var connection = context.connection, businessObject = getBusinessObject(connection), newSource = connection.source, newSourceBo = getBusinessObject(newSource), newTarget = connection.target, newTargetBo = getBusinessObject(connection.target), visualParent;
  if (!is(businessObject, "bpmn:DataAssociation")) {
    var inverseSet = is(businessObject, "bpmn:SequenceFlow");
    if (businessObject.sourceRef !== newSourceBo) {
      if (inverseSet) {
        remove3(businessObject.sourceRef && businessObject.sourceRef.get("outgoing"), businessObject);
        if (newSourceBo && newSourceBo.get("outgoing")) {
          newSourceBo.get("outgoing").push(businessObject);
        }
      }
      businessObject.sourceRef = newSourceBo;
    }
    if (businessObject.targetRef !== newTargetBo) {
      if (inverseSet) {
        remove3(businessObject.targetRef && businessObject.targetRef.get("incoming"), businessObject);
        if (newTargetBo && newTargetBo.get("incoming")) {
          newTargetBo.get("incoming").push(businessObject);
        }
      }
      businessObject.targetRef = newTargetBo;
    }
  } else if (is(businessObject, "bpmn:DataInputAssociation")) {
    businessObject.get("sourceRef")[0] = newSourceBo;
    visualParent = context.parent || context.newParent || newTargetBo;
    this.updateSemanticParent(businessObject, newTargetBo, visualParent);
  } else if (is(businessObject, "bpmn:DataOutputAssociation")) {
    visualParent = context.parent || context.newParent || newSourceBo;
    this.updateSemanticParent(businessObject, newSourceBo, visualParent);
    businessObject.targetRef = newTargetBo;
  }
  this.updateConnectionWaypoints(connection);
  this.updateDiConnection(connection, newSource, newTarget);
};
BpmnUpdater.prototype._getLabel = function(di) {
  if (!di.label) {
    di.label = this._bpmnFactory.createDiLabel();
  }
  return di.label;
};
function ifBpmn(fn2) {
  return function(event2) {
    var context = event2.context, element = context.shape || context.connection || context.element;
    if (is(element, "bpmn:BaseElement")) {
      fn2(event2);
    }
  };
}
function getEmbeddedLabelBounds(shape) {
  if (!is(shape, "bpmn:Activity")) {
    return;
  }
  var di = getDi(shape);
  if (!di) {
    return;
  }
  var label = di.get("label");
  if (!label) {
    return;
  }
  return label.get("bounds");
}

// node_modules/bpmn-js/lib/features/modeling/ElementFactory.js
function ElementFactory2(bpmnFactory, moddle) {
  ElementFactory.call(this);
  this._bpmnFactory = bpmnFactory;
  this._moddle = moddle;
}
e(ElementFactory2, ElementFactory);
ElementFactory2.$inject = [
  "bpmnFactory",
  "moddle"
];
ElementFactory2.prototype._baseCreate = ElementFactory.prototype.create;
ElementFactory2.prototype.create = function(elementType, attrs) {
  if (elementType === "label") {
    var di = attrs.di || this._bpmnFactory.createDiLabel();
    return this._baseCreate(elementType, assign({ type: "label", di }, DEFAULT_LABEL_SIZE, attrs));
  }
  return this.createElement(elementType, attrs);
};
ElementFactory2.prototype.createElement = function(elementType, attrs) {
  attrs = assign({}, attrs || {});
  var size2;
  var businessObject = attrs.businessObject, di = attrs.di;
  if (!businessObject) {
    if (!attrs.type) {
      throw new Error("no shape type specified");
    }
    businessObject = this._bpmnFactory.create(attrs.type);
    ensureCompatDiRef(businessObject);
  }
  if (!isModdleDi(di)) {
    var diAttrs = assign(
      {},
      di || {},
      { id: businessObject.id + "_di" }
    );
    if (elementType === "root") {
      di = this._bpmnFactory.createDiPlane(businessObject, diAttrs);
    } else if (elementType === "connection") {
      di = this._bpmnFactory.createDiEdge(businessObject, diAttrs);
    } else {
      di = this._bpmnFactory.createDiShape(businessObject, diAttrs);
    }
  }
  if (is(businessObject, "bpmn:Group")) {
    attrs = assign({
      isFrame: true
    }, attrs);
  }
  attrs = applyAttributes(businessObject, attrs, [
    "processRef",
    "isInterrupting",
    "associationDirection",
    "isForCompensation"
  ]);
  if (attrs.isExpanded) {
    attrs = applyAttribute(di, attrs, "isExpanded");
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"])) {
    attrs = applyAttribute(di, attrs, "isHorizontal");
  }
  if (is(businessObject, "bpmn:SubProcess")) {
    attrs.collapsed = !isExpanded(businessObject, di);
  }
  if (is(businessObject, "bpmn:ExclusiveGateway")) {
    if (has(di, "isMarkerVisible")) {
      if (di.isMarkerVisible === void 0) {
        di.isMarkerVisible = false;
      }
    } else {
      di.isMarkerVisible = true;
    }
  }
  if (isDefined(attrs.triggeredByEvent)) {
    businessObject.triggeredByEvent = attrs.triggeredByEvent;
    delete attrs.triggeredByEvent;
  }
  if (isDefined(attrs.cancelActivity)) {
    businessObject.cancelActivity = attrs.cancelActivity;
    delete attrs.cancelActivity;
  }
  var eventDefinitions, newEventDefinition;
  if (attrs.eventDefinitionType) {
    eventDefinitions = businessObject.get("eventDefinitions") || [];
    newEventDefinition = this._bpmnFactory.create(attrs.eventDefinitionType, attrs.eventDefinitionAttrs);
    if (attrs.eventDefinitionType === "bpmn:ConditionalEventDefinition") {
      newEventDefinition.condition = this._bpmnFactory.create("bpmn:FormalExpression");
    }
    eventDefinitions.push(newEventDefinition);
    newEventDefinition.$parent = businessObject;
    businessObject.eventDefinitions = eventDefinitions;
    delete attrs.eventDefinitionType;
  }
  size2 = this.getDefaultSize(businessObject, di);
  attrs = assign({
    id: businessObject.id
  }, size2, attrs, {
    businessObject,
    di
  });
  return this._baseCreate(elementType, attrs);
};
ElementFactory2.prototype.getDefaultSize = function(element, di) {
  var bo = getBusinessObject(element);
  di = di || getDi(element);
  if (is(bo, "bpmn:SubProcess")) {
    if (isExpanded(bo, di)) {
      return { width: 350, height: 200 };
    } else {
      return { width: 100, height: 80 };
    }
  }
  if (is(bo, "bpmn:Task")) {
    return { width: 100, height: 80 };
  }
  if (is(bo, "bpmn:Gateway")) {
    return { width: 50, height: 50 };
  }
  if (is(bo, "bpmn:Event")) {
    return { width: 36, height: 36 };
  }
  if (is(bo, "bpmn:Participant")) {
    var isHorizontalPool = di.isHorizontal === void 0 || di.isHorizontal === true;
    if (isExpanded(bo, di)) {
      if (isHorizontalPool) {
        return { width: 600, height: 250 };
      }
      return { width: 250, height: 600 };
    } else {
      if (isHorizontalPool) {
        return { width: 400, height: 60 };
      }
      return { width: 60, height: 400 };
    }
  }
  if (is(bo, "bpmn:Lane")) {
    return { width: 400, height: 100 };
  }
  if (is(bo, "bpmn:DataObjectReference")) {
    return { width: 36, height: 50 };
  }
  if (is(bo, "bpmn:DataStoreReference")) {
    return { width: 50, height: 50 };
  }
  if (is(bo, "bpmn:TextAnnotation")) {
    return { width: 100, height: 30 };
  }
  if (is(bo, "bpmn:Group")) {
    return { width: 300, height: 300 };
  }
  return { width: 100, height: 80 };
};
ElementFactory2.prototype.createParticipantShape = function(attrs) {
  if (!isObject(attrs)) {
    attrs = { isExpanded: attrs };
  }
  attrs = assign({ type: "bpmn:Participant" }, attrs || {});
  if (attrs.isExpanded !== false) {
    attrs.processRef = this._bpmnFactory.create("bpmn:Process");
  }
  return this.createShape(attrs);
};
function applyAttributes(element, attrs, attributeNames) {
  forEach(attributeNames, function(property) {
    attrs = applyAttribute(element, attrs, property);
  });
  return attrs;
}
function applyAttribute(element, attrs, attributeName) {
  if (attrs[attributeName] === void 0) {
    return attrs;
  }
  element[attributeName] = attrs[attributeName];
  return omit(attrs, [attributeName]);
}
function isModdleDi(element) {
  return isAny(element, [
    "bpmndi:BPMNShape",
    "bpmndi:BPMNEdge",
    "bpmndi:BPMNDiagram",
    "bpmndi:BPMNPlane"
  ]);
}

// node_modules/diagram-js/lib/features/modeling/cmd/AlignElementsHandler.js
function AlignElements2(modeling, canvas) {
  this._modeling = modeling;
  this._canvas = canvas;
}
AlignElements2.$inject = ["modeling", "canvas"];
AlignElements2.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var elements = context.elements, alignment = context.alignment;
  forEach(elements, function(element) {
    var delta2 = {
      x: 0,
      y: 0
    };
    if (isDefined(alignment.left)) {
      delta2.x = alignment.left - element.x;
    } else if (isDefined(alignment.right)) {
      delta2.x = alignment.right - element.width - element.x;
    } else if (isDefined(alignment.center)) {
      delta2.x = alignment.center - Math.round(element.width / 2) - element.x;
    } else if (isDefined(alignment.top)) {
      delta2.y = alignment.top - element.y;
    } else if (isDefined(alignment.bottom)) {
      delta2.y = alignment.bottom - element.height - element.y;
    } else if (isDefined(alignment.middle)) {
      delta2.y = alignment.middle - Math.round(element.height / 2) - element.y;
    }
    modeling.moveElements([element], delta2, element.parent);
  });
};
AlignElements2.prototype.postExecute = function(context) {
};

// node_modules/diagram-js/lib/features/modeling/cmd/AppendShapeHandler.js
function AppendShapeHandler(modeling) {
  this._modeling = modeling;
}
AppendShapeHandler.$inject = ["modeling"];
AppendShapeHandler.prototype.preExecute = function(context) {
  var source = context.source;
  if (!source) {
    throw new Error("source required");
  }
  var target = context.target || source.parent, shape = context.shape, hints = context.hints || {};
  shape = context.shape = this._modeling.createShape(
    shape,
    context.position,
    target,
    { attach: hints.attach }
  );
  context.shape = shape;
};
AppendShapeHandler.prototype.postExecute = function(context) {
  var hints = context.hints || {};
  if (!existsConnection(context.source, context.shape)) {
    if (hints.connectionTarget === context.source) {
      this._modeling.connect(context.shape, context.source, context.connection);
    } else {
      this._modeling.connect(context.source, context.shape, context.connection);
    }
  }
};
function existsConnection(source, target) {
  return some(source.outgoing, function(c5) {
    return c5.target === target;
  });
}

// node_modules/diagram-js/lib/features/modeling/cmd/CreateConnectionHandler.js
function CreateConnectionHandler(canvas, layouter) {
  this._canvas = canvas;
  this._layouter = layouter;
}
CreateConnectionHandler.$inject = ["canvas", "layouter"];
CreateConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, source = context.source, target = context.target, parent = context.parent, parentIndex = context.parentIndex, hints = context.hints;
  if (!source || !target) {
    throw new Error("source and target required");
  }
  if (!parent) {
    throw new Error("parent required");
  }
  connection.source = source;
  connection.target = target;
  if (!connection.waypoints) {
    connection.waypoints = this._layouter.layoutConnection(connection, hints);
  }
  this._canvas.addConnection(connection, parent, parentIndex);
  return connection;
};
CreateConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateElementsHandler.js
var round9 = Math.round;
function CreateElementsHandler(modeling) {
  this._modeling = modeling;
}
CreateElementsHandler.$inject = [
  "modeling"
];
CreateElementsHandler.prototype.preExecute = function(context) {
  var elements = context.elements, parent = context.parent, parentIndex = context.parentIndex, position = context.position, hints = context.hints;
  var modeling = this._modeling;
  forEach(elements, function(element) {
    if (!isNumber(element.x)) {
      element.x = 0;
    }
    if (!isNumber(element.y)) {
      element.y = 0;
    }
  });
  var visibleElements = filter(elements, function(element) {
    return !element.hidden;
  });
  var bbox = getBBox(visibleElements);
  forEach(elements, function(element) {
    if (isConnection(element)) {
      element.waypoints = map(element.waypoints, function(waypoint) {
        return {
          x: round9(waypoint.x - bbox.x - bbox.width / 2 + position.x),
          y: round9(waypoint.y - bbox.y - bbox.height / 2 + position.y)
        };
      });
    }
    assign(element, {
      x: round9(element.x - bbox.x - bbox.width / 2 + position.x),
      y: round9(element.y - bbox.y - bbox.height / 2 + position.y)
    });
  });
  var parents = getParents(elements);
  var cache = {};
  forEach(elements, function(element) {
    if (isConnection(element)) {
      cache[element.id] = isNumber(parentIndex) ? modeling.createConnection(
        cache[element.source.id],
        cache[element.target.id],
        parentIndex,
        element,
        element.parent || parent,
        hints
      ) : modeling.createConnection(
        cache[element.source.id],
        cache[element.target.id],
        element,
        element.parent || parent,
        hints
      );
      return;
    }
    var createShapeHints = assign({}, hints);
    if (parents.indexOf(element) === -1) {
      createShapeHints.autoResize = false;
    }
    if (isLabel(element)) {
      createShapeHints = omit(createShapeHints, ["attach"]);
    }
    cache[element.id] = isNumber(parentIndex) ? modeling.createShape(
      element,
      pick(element, ["x", "y", "width", "height"]),
      element.parent || parent,
      parentIndex,
      createShapeHints
    ) : modeling.createShape(
      element,
      pick(element, ["x", "y", "width", "height"]),
      element.parent || parent,
      createShapeHints
    );
  });
  context.elements = values(cache);
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateShapeHandler.js
var round10 = Math.round;
function CreateShapeHandler(canvas) {
  this._canvas = canvas;
}
CreateShapeHandler.$inject = ["canvas"];
CreateShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, positionOrBounds = context.position, parent = context.parent, parentIndex = context.parentIndex;
  if (!parent) {
    throw new Error("parent required");
  }
  if (!positionOrBounds) {
    throw new Error("position required");
  }
  if (positionOrBounds.width !== void 0) {
    assign(shape, positionOrBounds);
  } else {
    assign(shape, {
      x: positionOrBounds.x - round10(shape.width / 2),
      y: positionOrBounds.y - round10(shape.height / 2)
    });
  }
  this._canvas.addShape(shape, parent, parentIndex);
  return shape;
};
CreateShapeHandler.prototype.revert = function(context) {
  var shape = context.shape;
  this._canvas.removeShape(shape);
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/CreateLabelHandler.js
function CreateLabelHandler(canvas) {
  CreateShapeHandler.call(this, canvas);
}
e(CreateLabelHandler, CreateShapeHandler);
CreateLabelHandler.$inject = ["canvas"];
var originalExecute = CreateShapeHandler.prototype.execute;
CreateLabelHandler.prototype.execute = function(context) {
  var label = context.shape;
  ensureValidDimensions(label);
  label.labelTarget = context.labelTarget;
  return originalExecute.call(this, context);
};
var originalRevert = CreateShapeHandler.prototype.revert;
CreateLabelHandler.prototype.revert = function(context) {
  context.shape.labelTarget = null;
  return originalRevert.call(this, context);
};
function ensureValidDimensions(label) {
  ["width", "height"].forEach(function(prop) {
    if (typeof label[prop] === "undefined") {
      label[prop] = 0;
    }
  });
}

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteConnectionHandler.js
function DeleteConnectionHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteConnectionHandler.$inject = [
  "canvas",
  "modeling"
];
DeleteConnectionHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var connection = context.connection;
  saveClear(connection.incoming, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
  saveClear(connection.outgoing, function(connection2) {
    modeling.removeConnection(connection2, { nested: true });
  });
};
DeleteConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, parent = connection.parent;
  context.parent = parent;
  context.parentIndex = indexOf(parent.children, connection);
  context.source = connection.source;
  context.target = connection.target;
  this._canvas.removeConnection(connection);
  connection.source = null;
  connection.target = null;
  return connection;
};
DeleteConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, parent = context.parent, parentIndex = context.parentIndex;
  connection.source = context.source;
  connection.target = context.target;
  add2(parent.children, connection, parentIndex);
  this._canvas.addConnection(connection, parent);
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteElementsHandler.js
function DeleteElementsHandler(modeling, elementRegistry) {
  this._modeling = modeling;
  this._elementRegistry = elementRegistry;
}
DeleteElementsHandler.$inject = [
  "modeling",
  "elementRegistry"
];
DeleteElementsHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling, elementRegistry = this._elementRegistry, elements = context.elements;
  forEach(elements, function(element) {
    if (!elementRegistry.get(element.id)) {
      return;
    }
    if (element.waypoints) {
      modeling.removeConnection(element);
    } else {
      modeling.removeShape(element);
    }
  });
};

// node_modules/diagram-js/lib/features/modeling/cmd/DeleteShapeHandler.js
function DeleteShapeHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
DeleteShapeHandler.$inject = ["canvas", "modeling"];
DeleteShapeHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape;
  saveClear(shape.incoming, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.outgoing, function(connection) {
    modeling.removeConnection(connection, { nested: true });
  });
  saveClear(shape.children, function(child) {
    if (isConnection(child)) {
      modeling.removeConnection(child, { nested: true });
    } else {
      modeling.removeShape(child, { nested: true });
    }
  });
};
DeleteShapeHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = shape.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = indexOf(oldParent.children, shape);
  canvas.removeShape(shape);
  return shape;
};
DeleteShapeHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex;
  add2(oldParent.children, shape, oldParentIndex);
  canvas.addShape(shape, oldParent);
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/DistributeElementsHandler.js
function DistributeElements(modeling) {
  this._modeling = modeling;
}
DistributeElements.$inject = ["modeling"];
var OFF_AXIS = {
  x: "y",
  y: "x"
};
DistributeElements.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var groups = context.groups, axis = context.axis, dimension = context.dimension;
  function updateRange(group, element) {
    group.range.min = Math.min(element[axis], group.range.min);
    group.range.max = Math.max(element[axis] + element[dimension], group.range.max);
  }
  function center2(element) {
    return element[axis] + element[dimension] / 2;
  }
  function lastIdx(arr) {
    return arr.length - 1;
  }
  function rangeDiff(range) {
    return range.max - range.min;
  }
  function centerElement(refCenter, element) {
    var delta2 = { y: 0 };
    delta2[axis] = refCenter - center2(element);
    if (delta2[axis]) {
      delta2[OFF_AXIS[axis]] = 0;
      modeling.moveElements([element], delta2, element.parent);
    }
  }
  var firstGroup = groups[0], lastGroupIdx = lastIdx(groups), lastGroup = groups[lastGroupIdx];
  var margin, spaceInBetween, groupsSize = 0;
  forEach(groups, function(group, idx) {
    var sortedElements, refElem, refCenter;
    if (group.elements.length < 2) {
      if (idx && idx !== groups.length - 1) {
        updateRange(group, group.elements[0]);
        groupsSize += rangeDiff(group.range);
      }
      return;
    }
    sortedElements = sortBy(group.elements, axis);
    refElem = sortedElements[0];
    if (idx === lastGroupIdx) {
      refElem = sortedElements[lastIdx(sortedElements)];
    }
    refCenter = center2(refElem);
    group.range = null;
    forEach(sortedElements, function(element) {
      centerElement(refCenter, element);
      if (group.range === null) {
        group.range = {
          min: element[axis],
          max: element[axis] + element[dimension]
        };
        return;
      }
      updateRange(group, element);
    });
    if (idx && idx !== groups.length - 1) {
      groupsSize += rangeDiff(group.range);
    }
  });
  spaceInBetween = Math.abs(lastGroup.range.min - firstGroup.range.max);
  margin = Math.round((spaceInBetween - groupsSize) / (groups.length - 1));
  if (margin < groups.length - 1) {
    return;
  }
  forEach(groups, function(group, groupIdx) {
    var delta2 = {}, prevGroup;
    if (group === firstGroup || group === lastGroup) {
      return;
    }
    prevGroup = groups[groupIdx - 1];
    group.range.max = 0;
    forEach(group.elements, function(element, idx) {
      delta2[OFF_AXIS[axis]] = 0;
      delta2[axis] = prevGroup.range.max - element[axis] + margin;
      if (group.range.min !== element[axis]) {
        delta2[axis] += element[axis] - group.range.min;
      }
      if (delta2[axis]) {
        modeling.moveElements([element], delta2, element.parent);
      }
      group.range.max = Math.max(element[axis] + element[dimension], idx ? group.range.max : 0);
    });
  });
};
DistributeElements.prototype.postExecute = function(context) {
};

// node_modules/diagram-js/lib/features/modeling/cmd/LayoutConnectionHandler.js
function LayoutConnectionHandler(layouter, canvas) {
  this._layouter = layouter;
  this._canvas = canvas;
}
LayoutConnectionHandler.$inject = ["layouter", "canvas"];
LayoutConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection;
  var oldWaypoints = connection.waypoints;
  assign(context, {
    oldWaypoints
  });
  connection.waypoints = this._layouter.layoutConnection(connection, context.hints);
  return connection;
};
LayoutConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection;
  connection.waypoints = context.oldWaypoints;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveConnectionHandler.js
function MoveConnectionHandler() {
}
MoveConnectionHandler.prototype.execute = function(context) {
  var connection = context.connection, delta2 = context.delta;
  var newParent = context.newParent || connection.parent, newParentIndex = context.newParentIndex, oldParent = connection.parent;
  context.oldParent = oldParent;
  context.oldParentIndex = remove3(oldParent.children, connection);
  add2(newParent.children, connection, newParentIndex);
  connection.parent = newParent;
  forEach(connection.waypoints, function(p5) {
    p5.x += delta2.x;
    p5.y += delta2.y;
    if (p5.original) {
      p5.original.x += delta2.x;
      p5.original.y += delta2.y;
    }
  });
  return connection;
};
MoveConnectionHandler.prototype.revert = function(context) {
  var connection = context.connection, newParent = connection.parent, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  remove3(newParent.children, connection);
  add2(oldParent.children, connection, oldParentIndex);
  connection.parent = oldParent;
  forEach(connection.waypoints, function(p5) {
    p5.x -= delta2.x;
    p5.y -= delta2.y;
    if (p5.original) {
      p5.original.x -= delta2.x;
      p5.original.y -= delta2.y;
    }
  });
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveClosure.js
function MoveClosure() {
  this.allShapes = {};
  this.allConnections = {};
  this.enclosedElements = {};
  this.enclosedConnections = {};
  this.topLevel = {};
}
MoveClosure.prototype.add = function(element, isTopLevel) {
  return this.addAll([element], isTopLevel);
};
MoveClosure.prototype.addAll = function(elements, isTopLevel) {
  var newClosure = getClosure(elements, !!isTopLevel, this);
  assign(this, newClosure);
  return this;
};

// node_modules/diagram-js/lib/features/modeling/cmd/helper/MoveHelper.js
function MoveHelper(modeling) {
  this._modeling = modeling;
}
MoveHelper.prototype.moveRecursive = function(elements, delta2, newParent) {
  if (!elements) {
    return [];
  } else {
    return this.moveClosure(this.getClosure(elements), delta2, newParent);
  }
};
MoveHelper.prototype.moveClosure = function(closure, delta2, newParent, newHost, primaryShape) {
  var modeling = this._modeling;
  var allShapes = closure.allShapes, allConnections = closure.allConnections, enclosedConnections = closure.enclosedConnections, topLevel = closure.topLevel, keepParent = false;
  if (primaryShape && primaryShape.parent === newParent) {
    keepParent = true;
  }
  forEach(allShapes, function(shape) {
    modeling.moveShape(shape, delta2, topLevel[shape.id] && !keepParent && newParent, {
      recurse: false,
      layout: false
    });
  });
  forEach(allConnections, function(c5) {
    var sourceMoved = !!allShapes[c5.source.id], targetMoved = !!allShapes[c5.target.id];
    if (enclosedConnections[c5.id] && sourceMoved && targetMoved) {
      modeling.moveConnection(c5, delta2, topLevel[c5.id] && !keepParent && newParent);
    } else {
      modeling.layoutConnection(c5, {
        connectionStart: sourceMoved && getMovedSourceAnchor(c5, c5.source, delta2),
        connectionEnd: targetMoved && getMovedTargetAnchor(c5, c5.target, delta2)
      });
    }
  });
};
MoveHelper.prototype.getClosure = function(elements) {
  return new MoveClosure().addAll(elements, true);
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveElementsHandler.js
function MoveElementsHandler(modeling) {
  this._helper = new MoveHelper(modeling);
}
MoveElementsHandler.$inject = ["modeling"];
MoveElementsHandler.prototype.preExecute = function(context) {
  context.closure = this._helper.getClosure(context.shapes);
};
MoveElementsHandler.prototype.postExecute = function(context) {
  var hints = context.hints, primaryShape;
  if (hints && hints.primaryShape) {
    primaryShape = hints.primaryShape;
    hints.oldParent = primaryShape.parent;
  }
  this._helper.moveClosure(
    context.closure,
    context.delta,
    context.newParent,
    context.newHost,
    primaryShape
  );
};

// node_modules/diagram-js/lib/features/modeling/cmd/MoveShapeHandler.js
function MoveShapeHandler(modeling) {
  this._modeling = modeling;
  this._helper = new MoveHelper(modeling);
}
MoveShapeHandler.$inject = ["modeling"];
MoveShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, delta2 = context.delta, newParent = context.newParent || shape.parent, newParentIndex = context.newParentIndex, oldParent = shape.parent;
  context.oldBounds = pick(shape, ["x", "y", "width", "height"]);
  context.oldParent = oldParent;
  context.oldParentIndex = remove3(oldParent.children, shape);
  add2(newParent.children, shape, newParentIndex);
  assign(shape, {
    parent: newParent,
    x: shape.x + delta2.x,
    y: shape.y + delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.postExecute = function(context) {
  var shape = context.shape, delta2 = context.delta, hints = context.hints;
  var modeling = this._modeling;
  if (hints.layout !== false) {
    forEach(shape.incoming, function(c5) {
      modeling.layoutConnection(c5, {
        connectionEnd: getMovedTargetAnchor(c5, shape, delta2)
      });
    });
    forEach(shape.outgoing, function(c5) {
      modeling.layoutConnection(c5, {
        connectionStart: getMovedSourceAnchor(c5, shape, delta2)
      });
    });
  }
  if (hints.recurse !== false) {
    this.moveChildren(context);
  }
};
MoveShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldParent = context.oldParent, oldParentIndex = context.oldParentIndex, delta2 = context.delta;
  add2(oldParent.children, shape, oldParentIndex);
  assign(shape, {
    parent: oldParent,
    x: shape.x - delta2.x,
    y: shape.y - delta2.y
  });
  return shape;
};
MoveShapeHandler.prototype.moveChildren = function(context) {
  var delta2 = context.delta, shape = context.shape;
  this._helper.moveRecursive(shape.children, delta2, null);
};
MoveShapeHandler.prototype.getNewParent = function(context) {
  return context.newParent || context.shape.parent;
};

// node_modules/diagram-js/lib/features/modeling/cmd/ReconnectConnectionHandler.js
function ReconnectConnectionHandler(modeling) {
  this._modeling = modeling;
}
ReconnectConnectionHandler.$inject = ["modeling"];
ReconnectConnectionHandler.prototype.execute = function(context) {
  var newSource = context.newSource, newTarget = context.newTarget, connection = context.connection, dockingOrPoints = context.dockingOrPoints;
  if (!newSource && !newTarget) {
    throw new Error("newSource or newTarget required");
  }
  if (isArray(dockingOrPoints)) {
    context.oldWaypoints = connection.waypoints;
    connection.waypoints = dockingOrPoints;
  }
  if (newSource) {
    context.oldSource = connection.source;
    connection.source = newSource;
  }
  if (newTarget) {
    context.oldTarget = connection.target;
    connection.target = newTarget;
  }
  return connection;
};
ReconnectConnectionHandler.prototype.postExecute = function(context) {
  var connection = context.connection, newSource = context.newSource, newTarget = context.newTarget, dockingOrPoints = context.dockingOrPoints, hints = context.hints || {};
  var layoutConnectionHints = {};
  if (hints.connectionStart) {
    layoutConnectionHints.connectionStart = hints.connectionStart;
  }
  if (hints.connectionEnd) {
    layoutConnectionHints.connectionEnd = hints.connectionEnd;
  }
  if (hints.layoutConnection === false) {
    return;
  }
  if (newSource && (!newTarget || hints.docking === "source")) {
    layoutConnectionHints.connectionStart = layoutConnectionHints.connectionStart || getDocking3(isArray(dockingOrPoints) ? dockingOrPoints[0] : dockingOrPoints);
  }
  if (newTarget && (!newSource || hints.docking === "target")) {
    layoutConnectionHints.connectionEnd = layoutConnectionHints.connectionEnd || getDocking3(isArray(dockingOrPoints) ? dockingOrPoints[dockingOrPoints.length - 1] : dockingOrPoints);
  }
  if (hints.newWaypoints) {
    layoutConnectionHints.waypoints = hints.newWaypoints;
  }
  this._modeling.layoutConnection(connection, layoutConnectionHints);
};
ReconnectConnectionHandler.prototype.revert = function(context) {
  var oldSource = context.oldSource, oldTarget = context.oldTarget, oldWaypoints = context.oldWaypoints, connection = context.connection;
  if (oldSource) {
    connection.source = oldSource;
  }
  if (oldTarget) {
    connection.target = oldTarget;
  }
  if (oldWaypoints) {
    connection.waypoints = oldWaypoints;
  }
  return connection;
};
function getDocking3(point) {
  return point.original || point;
}

// node_modules/diagram-js/lib/features/modeling/cmd/ReplaceShapeHandler.js
function ReplaceShapeHandler(modeling, rules) {
  this._modeling = modeling;
  this._rules = rules;
}
ReplaceShapeHandler.$inject = ["modeling", "rules"];
ReplaceShapeHandler.prototype.preExecute = function(context) {
  var self2 = this, modeling = this._modeling, rules = this._rules;
  var oldShape = context.oldShape, newData = context.newData, hints = context.hints || {}, newShape;
  function canReconnect(source, target, connection) {
    return rules.allowed("connection.reconnect", {
      connection,
      source,
      target
    });
  }
  var position = {
    x: newData.x,
    y: newData.y
  };
  var oldBounds = {
    x: oldShape.x,
    y: oldShape.y,
    width: oldShape.width,
    height: oldShape.height
  };
  newShape = context.newShape = context.newShape || self2.createShape(newData, position, oldShape.parent, hints);
  if (oldShape.host) {
    modeling.updateAttachment(newShape, oldShape.host);
  }
  var children;
  if (hints.moveChildren !== false) {
    children = oldShape.children.slice();
    modeling.moveElements(children, { x: 0, y: 0 }, newShape, hints);
  }
  var incoming = oldShape.incoming.slice(), outgoing = oldShape.outgoing.slice();
  forEach(incoming, function(connection) {
    var source = connection.source, allowed = canReconnect(source, newShape, connection);
    if (allowed) {
      self2.reconnectEnd(
        connection,
        newShape,
        getResizedTargetAnchor(connection, newShape, oldBounds),
        hints
      );
    }
  });
  forEach(outgoing, function(connection) {
    var target = connection.target, allowed = canReconnect(newShape, target, connection);
    if (allowed) {
      self2.reconnectStart(
        connection,
        newShape,
        getResizedSourceAnchor(connection, newShape, oldBounds),
        hints
      );
    }
  });
};
ReplaceShapeHandler.prototype.postExecute = function(context) {
  var oldShape = context.oldShape;
  this._modeling.removeShape(oldShape);
};
ReplaceShapeHandler.prototype.execute = function(context) {
};
ReplaceShapeHandler.prototype.revert = function(context) {
};
ReplaceShapeHandler.prototype.createShape = function(shape, position, target, hints) {
  return this._modeling.createShape(shape, position, target, hints);
};
ReplaceShapeHandler.prototype.reconnectStart = function(connection, newSource, dockingPoint, hints) {
  this._modeling.reconnectStart(connection, newSource, dockingPoint, hints);
};
ReplaceShapeHandler.prototype.reconnectEnd = function(connection, newTarget, dockingPoint, hints) {
  this._modeling.reconnectEnd(connection, newTarget, dockingPoint, hints);
};

// node_modules/diagram-js/lib/features/modeling/cmd/ResizeShapeHandler.js
function ResizeShapeHandler(modeling) {
  this._modeling = modeling;
}
ResizeShapeHandler.$inject = ["modeling"];
ResizeShapeHandler.prototype.execute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, minBounds = context.minBounds;
  if (newBounds.x === void 0 || newBounds.y === void 0 || newBounds.width === void 0 || newBounds.height === void 0) {
    throw new Error("newBounds must have {x, y, width, height} properties");
  }
  if (minBounds && (newBounds.width < minBounds.width || newBounds.height < minBounds.height)) {
    throw new Error("width and height cannot be less than minimum height and width");
  } else if (!minBounds && newBounds.width < 10 || newBounds.height < 10) {
    throw new Error("width and height cannot be less than 10px");
  }
  context.oldBounds = {
    width: shape.width,
    height: shape.height,
    x: shape.x,
    y: shape.y
  };
  assign(shape, {
    width: newBounds.width,
    height: newBounds.height,
    x: newBounds.x,
    y: newBounds.y
  });
  return shape;
};
ResizeShapeHandler.prototype.postExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, oldBounds = context.oldBounds, hints = context.hints || {};
  if (hints.layout === false) {
    return;
  }
  forEach(shape.incoming, function(c5) {
    modeling.layoutConnection(c5, {
      connectionEnd: getResizedTargetAnchor(c5, shape, oldBounds)
    });
  });
  forEach(shape.outgoing, function(c5) {
    modeling.layoutConnection(c5, {
      connectionStart: getResizedSourceAnchor(c5, shape, oldBounds)
    });
  });
};
ResizeShapeHandler.prototype.revert = function(context) {
  var shape = context.shape, oldBounds = context.oldBounds;
  assign(shape, {
    width: oldBounds.width,
    height: oldBounds.height,
    x: oldBounds.x,
    y: oldBounds.y
  });
  return shape;
};

// node_modules/diagram-js/lib/features/modeling/cmd/SpaceToolHandler.js
function SpaceToolHandler(modeling) {
  this._modeling = modeling;
}
SpaceToolHandler.$inject = ["modeling"];
SpaceToolHandler.prototype.preExecute = function(context) {
  var delta2 = context.delta, direction = context.direction, movingShapes = context.movingShapes, resizingShapes = context.resizingShapes, start = context.start, oldBounds = {};
  this.moveShapes(movingShapes, delta2);
  forEach(resizingShapes, function(shape) {
    oldBounds[shape.id] = getBounds2(shape);
  });
  this.resizeShapes(resizingShapes, delta2, direction);
  this.updateConnectionWaypoints(
    getWaypointsUpdatingConnections(movingShapes, resizingShapes),
    delta2,
    direction,
    start,
    movingShapes,
    resizingShapes,
    oldBounds
  );
};
SpaceToolHandler.prototype.execute = function() {
};
SpaceToolHandler.prototype.revert = function() {
};
SpaceToolHandler.prototype.moveShapes = function(shapes, delta2) {
  var self2 = this;
  forEach(shapes, function(element) {
    self2._modeling.moveShape(element, delta2, null, {
      autoResize: false,
      layout: false,
      recurse: false
    });
  });
};
SpaceToolHandler.prototype.resizeShapes = function(shapes, delta2, direction) {
  var self2 = this;
  forEach(shapes, function(shape) {
    var newBounds = resizeBounds2(shape, direction, delta2);
    self2._modeling.resizeShape(shape, newBounds, null, {
      attachSupport: false,
      autoResize: false,
      layout: false
    });
  });
};
SpaceToolHandler.prototype.updateConnectionWaypoints = function(connections, delta2, direction, start, movingShapes, resizingShapes, oldBounds) {
  var self2 = this, affectedShapes = movingShapes.concat(resizingShapes);
  forEach(connections, function(connection) {
    var source = connection.source, target = connection.target, waypoints = copyWaypoints2(connection), axis = getAxisFromDirection(direction), layoutHints = {};
    if (includes6(affectedShapes, source) && includes6(affectedShapes, target)) {
      waypoints = map(waypoints, function(waypoint) {
        if (shouldMoveWaypoint(waypoint, start, direction)) {
          waypoint[axis] = waypoint[axis] + delta2[axis];
        }
        if (waypoint.original && shouldMoveWaypoint(waypoint.original, start, direction)) {
          waypoint.original[axis] = waypoint.original[axis] + delta2[axis];
        }
        return waypoint;
      });
      self2._modeling.updateWaypoints(connection, waypoints, {
        labelBehavior: false
      });
    } else if (includes6(affectedShapes, source) || includes6(affectedShapes, target)) {
      if (includes6(movingShapes, source)) {
        layoutHints.connectionStart = getMovedSourceAnchor(connection, source, delta2);
      } else if (includes6(movingShapes, target)) {
        layoutHints.connectionEnd = getMovedTargetAnchor(connection, target, delta2);
      } else if (includes6(resizingShapes, source)) {
        layoutHints.connectionStart = getResizedSourceAnchor(
          connection,
          source,
          oldBounds[source.id]
        );
      } else if (includes6(resizingShapes, target)) {
        layoutHints.connectionEnd = getResizedTargetAnchor(
          connection,
          target,
          oldBounds[target.id]
        );
      }
      self2._modeling.layoutConnection(connection, layoutHints);
    }
  });
};
function copyWaypoint2(waypoint) {
  return assign({}, waypoint);
}
function copyWaypoints2(connection) {
  return map(connection.waypoints, function(waypoint) {
    waypoint = copyWaypoint2(waypoint);
    if (waypoint.original) {
      waypoint.original = copyWaypoint2(waypoint.original);
    }
    return waypoint;
  });
}
function getAxisFromDirection(direction) {
  switch (direction) {
    case "n":
      return "y";
    case "w":
      return "x";
    case "s":
      return "y";
    case "e":
      return "x";
  }
}
function shouldMoveWaypoint(waypoint, start, direction) {
  var relevantAxis = getAxisFromDirection(direction);
  if (/e|s/.test(direction)) {
    return waypoint[relevantAxis] > start;
  } else if (/n|w/.test(direction)) {
    return waypoint[relevantAxis] < start;
  }
}
function includes6(array, item) {
  return array.indexOf(item) !== -1;
}
function getBounds2(shape) {
  return {
    x: shape.x,
    y: shape.y,
    height: shape.height,
    width: shape.width
  };
}

// node_modules/diagram-js/lib/features/modeling/cmd/ToggleShapeCollapseHandler.js
function ToggleShapeCollapseHandler(modeling) {
  this._modeling = modeling;
}
ToggleShapeCollapseHandler.$inject = ["modeling"];
ToggleShapeCollapseHandler.prototype.execute = function(context) {
  var shape = context.shape, children = shape.children;
  context.oldChildrenVisibility = getElementsVisibilityRecursive(children);
  shape.collapsed = !shape.collapsed;
  var result = setHiddenRecursive(children, shape.collapsed);
  return [shape].concat(result);
};
ToggleShapeCollapseHandler.prototype.revert = function(context) {
  var shape = context.shape, oldChildrenVisibility = context.oldChildrenVisibility;
  var children = shape.children;
  var result = restoreVisibilityRecursive(children, oldChildrenVisibility);
  shape.collapsed = !shape.collapsed;
  return [shape].concat(result);
};
function getElementsVisibilityRecursive(elements) {
  var result = {};
  forEach(elements, function(element) {
    result[element.id] = element.hidden;
    if (element.children) {
      result = assign({}, result, getElementsVisibilityRecursive(element.children));
    }
  });
  return result;
}
function setHiddenRecursive(elements, newHidden) {
  var result = [];
  forEach(elements, function(element) {
    element.hidden = newHidden;
    result = result.concat(element);
    if (element.children) {
      result = result.concat(setHiddenRecursive(element.children, element.collapsed || newHidden));
    }
  });
  return result;
}
function restoreVisibilityRecursive(elements, lastState) {
  var result = [];
  forEach(elements, function(element) {
    element.hidden = lastState[element.id];
    result = result.concat(element);
    if (element.children) {
      result = result.concat(restoreVisibilityRecursive(element.children, lastState));
    }
  });
  return result;
}

// node_modules/diagram-js/lib/features/modeling/cmd/UpdateAttachmentHandler.js
function UpdateAttachmentHandler(modeling) {
  this._modeling = modeling;
}
UpdateAttachmentHandler.$inject = ["modeling"];
UpdateAttachmentHandler.prototype.execute = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = shape.host;
  context.oldHost = oldHost;
  context.attacherIdx = removeAttacher(oldHost, shape);
  addAttacher(newHost, shape);
  shape.host = newHost;
  return shape;
};
UpdateAttachmentHandler.prototype.revert = function(context) {
  var shape = context.shape, newHost = context.newHost, oldHost = context.oldHost, attacherIdx = context.attacherIdx;
  shape.host = oldHost;
  removeAttacher(newHost, shape);
  addAttacher(oldHost, shape, attacherIdx);
  return shape;
};
function removeAttacher(host, attacher) {
  return remove3(host && host.attachers, attacher);
}
function addAttacher(host, attacher, idx) {
  if (!host) {
    return;
  }
  var attachers = host.attachers;
  if (!attachers) {
    host.attachers = attachers = [];
  }
  add2(attachers, attacher, idx);
}

// node_modules/diagram-js/lib/features/modeling/cmd/UpdateWaypointsHandler.js
function UpdateWaypointsHandler() {
}
UpdateWaypointsHandler.prototype.execute = function(context) {
  var connection = context.connection, newWaypoints = context.newWaypoints;
  context.oldWaypoints = connection.waypoints;
  connection.waypoints = newWaypoints;
  return connection;
};
UpdateWaypointsHandler.prototype.revert = function(context) {
  var connection = context.connection, oldWaypoints = context.oldWaypoints;
  connection.waypoints = oldWaypoints;
  return connection;
};

// node_modules/diagram-js/lib/features/modeling/Modeling.js
function Modeling(eventBus, elementFactory, commandStack) {
  this._eventBus = eventBus;
  this._elementFactory = elementFactory;
  this._commandStack = commandStack;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2.registerHandlers(commandStack);
  });
}
Modeling.$inject = ["eventBus", "elementFactory", "commandStack"];
Modeling.prototype.getHandlers = function() {
  return {
    "shape.append": AppendShapeHandler,
    "shape.create": CreateShapeHandler,
    "shape.delete": DeleteShapeHandler,
    "shape.move": MoveShapeHandler,
    "shape.resize": ResizeShapeHandler,
    "shape.replace": ReplaceShapeHandler,
    "shape.toggleCollapse": ToggleShapeCollapseHandler,
    "spaceTool": SpaceToolHandler,
    "label.create": CreateLabelHandler,
    "connection.create": CreateConnectionHandler,
    "connection.delete": DeleteConnectionHandler,
    "connection.move": MoveConnectionHandler,
    "connection.layout": LayoutConnectionHandler,
    "connection.updateWaypoints": UpdateWaypointsHandler,
    "connection.reconnect": ReconnectConnectionHandler,
    "elements.create": CreateElementsHandler,
    "elements.move": MoveElementsHandler,
    "elements.delete": DeleteElementsHandler,
    "elements.distribute": DistributeElements,
    "elements.align": AlignElements2,
    "element.updateAttachment": UpdateAttachmentHandler
  };
};
Modeling.prototype.registerHandlers = function(commandStack) {
  forEach(this.getHandlers(), function(handler, id) {
    commandStack.registerHandler(id, handler);
  });
};
Modeling.prototype.moveShape = function(shape, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = null;
  }
  var context = {
    shape,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("shape.move", context);
};
Modeling.prototype.updateAttachment = function(shape, newHost) {
  var context = {
    shape,
    newHost
  };
  this._commandStack.execute("element.updateAttachment", context);
};
Modeling.prototype.moveElements = function(shapes, delta2, target, hints) {
  hints = hints || {};
  var attach = hints.attach;
  var newParent = target, newHost;
  if (attach === true) {
    newHost = target;
    newParent = target.parent;
  } else if (attach === false) {
    newHost = null;
  }
  var context = {
    shapes,
    delta: delta2,
    newParent,
    newHost,
    hints
  };
  this._commandStack.execute("elements.move", context);
};
Modeling.prototype.moveConnection = function(connection, delta2, newParent, newParentIndex, hints) {
  if (typeof newParentIndex === "object") {
    hints = newParentIndex;
    newParentIndex = void 0;
  }
  var context = {
    connection,
    delta: delta2,
    newParent,
    newParentIndex,
    hints: hints || {}
  };
  this._commandStack.execute("connection.move", context);
};
Modeling.prototype.layoutConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.layout", context);
};
Modeling.prototype.createConnection = function(source, target, parentIndex, connection, parent, hints) {
  if (typeof parentIndex === "object") {
    hints = parent;
    parent = connection;
    connection = parentIndex;
    parentIndex = void 0;
  }
  connection = this._create("connection", connection);
  var context = {
    source,
    target,
    parent,
    parentIndex,
    connection,
    hints
  };
  this._commandStack.execute("connection.create", context);
  return context.connection;
};
Modeling.prototype.createShape = function(shape, position, target, parentIndex, hints) {
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var attach = hints.attach, parent, host;
  shape = this._create("shape", shape);
  if (attach) {
    parent = target.parent;
    host = target;
  } else {
    parent = target;
  }
  var context = {
    position,
    shape,
    parent,
    parentIndex,
    host,
    hints
  };
  this._commandStack.execute("shape.create", context);
  return context.shape;
};
Modeling.prototype.createElements = function(elements, position, parent, parentIndex, hints) {
  if (!isArray(elements)) {
    elements = [elements];
  }
  if (typeof parentIndex !== "number") {
    hints = parentIndex;
    parentIndex = void 0;
  }
  hints = hints || {};
  var context = {
    position,
    elements,
    parent,
    parentIndex,
    hints
  };
  this._commandStack.execute("elements.create", context);
  return context.elements;
};
Modeling.prototype.createLabel = function(labelTarget, position, label, parent) {
  label = this._create("label", label);
  var context = {
    labelTarget,
    position,
    parent: parent || labelTarget.parent,
    shape: label
  };
  this._commandStack.execute("label.create", context);
  return context.shape;
};
Modeling.prototype.appendShape = function(source, shape, position, target, hints) {
  hints = hints || {};
  shape = this._create("shape", shape);
  var context = {
    source,
    position,
    target,
    shape,
    connection: hints.connection,
    connectionParent: hints.connectionParent,
    hints
  };
  this._commandStack.execute("shape.append", context);
  return context.shape;
};
Modeling.prototype.removeElements = function(elements) {
  var context = {
    elements
  };
  this._commandStack.execute("elements.delete", context);
};
Modeling.prototype.distributeElements = function(groups, axis, dimension) {
  var context = {
    groups,
    axis,
    dimension
  };
  this._commandStack.execute("elements.distribute", context);
};
Modeling.prototype.removeShape = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.delete", context);
};
Modeling.prototype.removeConnection = function(connection, hints) {
  var context = {
    connection,
    hints: hints || {}
  };
  this._commandStack.execute("connection.delete", context);
};
Modeling.prototype.replaceShape = function(oldShape, newShape, hints) {
  var context = {
    oldShape,
    newData: newShape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.replace", context);
  return context.newShape;
};
Modeling.prototype.alignElements = function(elements, alignment) {
  var context = {
    elements,
    alignment
  };
  this._commandStack.execute("elements.align", context);
};
Modeling.prototype.resizeShape = function(shape, newBounds, minBounds, hints) {
  var context = {
    shape,
    newBounds,
    minBounds,
    hints
  };
  this._commandStack.execute("shape.resize", context);
};
Modeling.prototype.createSpace = function(movingShapes, resizingShapes, delta2, direction, start) {
  var context = {
    delta: delta2,
    direction,
    movingShapes,
    resizingShapes,
    start
  };
  this._commandStack.execute("spaceTool", context);
};
Modeling.prototype.updateWaypoints = function(connection, newWaypoints, hints) {
  var context = {
    connection,
    newWaypoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.updateWaypoints", context);
};
Modeling.prototype.reconnect = function(connection, source, target, dockingOrPoints, hints) {
  var context = {
    connection,
    newSource: source,
    newTarget: target,
    dockingOrPoints,
    hints: hints || {}
  };
  this._commandStack.execute("connection.reconnect", context);
};
Modeling.prototype.reconnectStart = function(connection, newSource, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, newSource, connection.target, dockingOrPoints, assign(hints, {
    docking: "source"
  }));
};
Modeling.prototype.reconnectEnd = function(connection, newTarget, dockingOrPoints, hints) {
  if (!hints) {
    hints = {};
  }
  this.reconnect(connection, connection.source, newTarget, dockingOrPoints, assign(hints, {
    docking: "target"
  }));
};
Modeling.prototype.connect = function(source, target, attrs, hints) {
  return this.createConnection(source, target, attrs || {}, source.parent, hints);
};
Modeling.prototype._create = function(type, attrs) {
  if (isModelElement(attrs)) {
    return attrs;
  } else {
    return this._elementFactory.create(type, attrs);
  }
};
Modeling.prototype.toggleCollapse = function(shape, hints) {
  var context = {
    shape,
    hints: hints || {}
  };
  this._commandStack.execute("shape.toggleCollapse", context);
};

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateModdlePropertiesHandler.js
function UpdateModdlePropertiesHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateModdlePropertiesHandler.$inject = ["elementRegistry"];
UpdateModdlePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, moddleElement = context.moddleElement, properties = context.properties;
  if (!moddleElement) {
    throw new Error("<moddleElement> required");
  }
  var changed = context.changed || this._getVisualReferences(moddleElement).concat(element);
  var oldProperties = context.oldProperties || getModdleProperties(moddleElement, keys(properties));
  setModdleProperties(moddleElement, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdateModdlePropertiesHandler.prototype.revert = function(context) {
  var oldProperties = context.oldProperties, moddleElement = context.moddleElement, changed = context.changed;
  setModdleProperties(moddleElement, oldProperties);
  return changed;
};
UpdateModdlePropertiesHandler.prototype._getVisualReferences = function(moddleElement) {
  var elementRegistry = this._elementRegistry;
  if (is(moddleElement, "bpmn:DataObject")) {
    return getAllDataObjectReferences(moddleElement, elementRegistry);
  }
  return [];
};
function getModdleProperties(moddleElement, propertyNames) {
  return reduce(propertyNames, function(result, key) {
    result[key] = moddleElement.get(key);
    return result;
  }, {});
}
function setModdleProperties(moddleElement, properties) {
  forEach(properties, function(value, key) {
    moddleElement.set(key, value);
  });
}
function getAllDataObjectReferences(dataObject, elementRegistry) {
  return elementRegistry.filter(function(element) {
    return is(element, "bpmn:DataObjectReference") && getBusinessObject(element).dataObjectRef === dataObject;
  });
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdatePropertiesHandler.js
var DEFAULT_FLOW = "default";
var ID = "id";
var DI = "di";
var NULL_DIMENSIONS = {
  width: 0,
  height: 0
};
function UpdatePropertiesHandler(elementRegistry, moddle, modeling, textRenderer) {
  this._elementRegistry = elementRegistry;
  this._moddle = moddle;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
}
UpdatePropertiesHandler.$inject = [
  "elementRegistry",
  "moddle",
  "modeling",
  "textRenderer"
];
UpdatePropertiesHandler.prototype.execute = function(context) {
  var element = context.element, changed = [element];
  if (!element) {
    throw new Error("element required");
  }
  var elementRegistry = this._elementRegistry, ids3 = this._moddle.ids;
  var businessObject = element.businessObject, properties = unwrapBusinessObjects(context.properties), oldProperties = context.oldProperties || getProperties(element, properties);
  if (isIdChange(properties, businessObject)) {
    ids3.unclaim(businessObject[ID]);
    elementRegistry.updateId(element, properties[ID]);
    ids3.claim(properties[ID], businessObject);
  }
  if (DEFAULT_FLOW in properties) {
    if (properties[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(properties[DEFAULT_FLOW].id));
    }
    if (businessObject[DEFAULT_FLOW]) {
      changed.push(elementRegistry.get(businessObject[DEFAULT_FLOW].id));
    }
  }
  setProperties(element, properties);
  context.oldProperties = oldProperties;
  context.changed = changed;
  return changed;
};
UpdatePropertiesHandler.prototype.postExecute = function(context) {
  var element = context.element, label = element.label;
  var text = label && getBusinessObject(label).name;
  if (!text) {
    return;
  }
  var newLabelBounds = this._textRenderer.getExternalLabelBounds(label, text);
  this._modeling.resizeShape(label, newLabelBounds, NULL_DIMENSIONS);
};
UpdatePropertiesHandler.prototype.revert = function(context) {
  var element = context.element, properties = context.properties, oldProperties = context.oldProperties, businessObject = element.businessObject, elementRegistry = this._elementRegistry, ids3 = this._moddle.ids;
  setProperties(element, oldProperties);
  if (isIdChange(properties, businessObject)) {
    ids3.unclaim(properties[ID]);
    elementRegistry.updateId(element, oldProperties[ID]);
    ids3.claim(oldProperties[ID], businessObject);
  }
  return context.changed;
};
function isIdChange(properties, businessObject) {
  return ID in properties && properties[ID] !== businessObject[ID];
}
function getProperties(element, properties) {
  var propertyNames = keys(properties), businessObject = element.businessObject, di = getDi(element);
  return reduce(propertyNames, function(result, key) {
    if (key !== DI) {
      result[key] = businessObject.get(key);
    } else {
      result[key] = getDiProperties(di, keys(properties.di));
    }
    return result;
  }, {});
}
function getDiProperties(di, propertyNames) {
  return reduce(propertyNames, function(result, key) {
    result[key] = di && di.get(key);
    return result;
  }, {});
}
function setProperties(element, properties) {
  var businessObject = element.businessObject, di = getDi(element);
  forEach(properties, function(value, key) {
    if (key !== DI) {
      businessObject.set(key, value);
    } else {
      if (di) {
        setDiProperties(di, value);
      }
    }
  });
}
function setDiProperties(di, properties) {
  forEach(properties, function(value, key) {
    di.set(key, value);
  });
}
var referencePropertyNames = ["default"];
function unwrapBusinessObjects(properties) {
  var unwrappedProps = assign({}, properties);
  referencePropertyNames.forEach(function(name2) {
    if (name2 in properties) {
      unwrappedProps[name2] = getBusinessObject(unwrappedProps[name2]);
    }
  });
  return unwrappedProps;
}

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateCanvasRootHandler.js
function UpdateCanvasRootHandler(canvas, modeling) {
  this._canvas = canvas;
  this._modeling = modeling;
}
UpdateCanvasRootHandler.$inject = [
  "canvas",
  "modeling"
];
UpdateCanvasRootHandler.prototype.execute = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = canvas.getRootElement(), oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = oldRootBusinessObject.$parent, diPlane = getDi(oldRoot);
  canvas.setRootElement(newRoot);
  canvas.removeRootElement(oldRoot);
  add2(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = bpmnDefinitions;
  remove3(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = null;
  oldRoot.di = null;
  diPlane.bpmnElement = newRootBusinessObject;
  newRoot.di = diPlane;
  context.oldRoot = oldRoot;
  return [];
};
UpdateCanvasRootHandler.prototype.revert = function(context) {
  var canvas = this._canvas;
  var newRoot = context.newRoot, newRootBusinessObject = newRoot.businessObject, oldRoot = context.oldRoot, oldRootBusinessObject = oldRoot.businessObject, bpmnDefinitions = newRootBusinessObject.$parent, diPlane = getDi(newRoot);
  canvas.setRootElement(oldRoot);
  canvas.removeRootElement(newRoot);
  remove3(bpmnDefinitions.rootElements, newRootBusinessObject);
  newRootBusinessObject.$parent = null;
  add2(bpmnDefinitions.rootElements, oldRootBusinessObject);
  oldRootBusinessObject.$parent = bpmnDefinitions;
  newRoot.di = null;
  diPlane.bpmnElement = oldRootBusinessObject;
  oldRoot.di = diPlane;
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/cmd/AddLaneHandler.js
function AddLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
AddLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
AddLaneHandler.prototype.preExecute = function(context) {
  var spaceTool = this._spaceTool, modeling = this._modeling;
  var shape = context.shape, location = context.location;
  var lanesRoot = getLanesRoot(shape);
  var isRoot = lanesRoot === shape, laneParent = isRoot ? shape : shape.parent;
  var existingChildLanes = getChildLanes(laneParent);
  var isHorizontalLane = isHorizontal(shape);
  if (isHorizontalLane) {
    if (location === "left") {
      location = "top";
    } else if (location === "right") {
      location = "bottom";
    }
  } else {
    if (location === "top") {
      location = "left";
    } else if (location === "bottom") {
      location = "right";
    }
  }
  if (!existingChildLanes.length) {
    var siblingPosition = isHorizontalLane ? {
      x: shape.x + LANE_INDENTATION,
      y: shape.y,
      width: shape.width - LANE_INDENTATION,
      height: shape.height
    } : {
      x: shape.x,
      y: shape.y + LANE_INDENTATION,
      width: shape.width,
      height: shape.height - LANE_INDENTATION
    };
    modeling.createShape(
      {
        type: "bpmn:Lane",
        isHorizontal: isHorizontalLane
      },
      siblingPosition,
      laneParent
    );
  }
  var allAffected = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (element.label) {
      allAffected.push(element.label);
    }
    if (element === shape) {
      return [];
    }
    return filter(element.children, function(c5) {
      return c5 !== shape;
    });
  });
  var offset, lanePosition, spacePos, direction, axis;
  if (location === "top") {
    offset = -120;
    lanePosition = shape.y;
    spacePos = lanePosition + 10;
    direction = "n";
    axis = "y";
  } else if (location === "left") {
    offset = -120;
    lanePosition = shape.x;
    spacePos = lanePosition + 10;
    direction = "w";
    axis = "x";
  } else if (location === "bottom") {
    offset = 120;
    lanePosition = shape.y + shape.height;
    spacePos = lanePosition - 10;
    direction = "s";
    axis = "y";
  } else if (location === "right") {
    offset = 120;
    lanePosition = shape.x + shape.width;
    spacePos = lanePosition - 10;
    direction = "e";
    axis = "x";
  }
  var adjustments = spaceTool.calculateAdjustments(allAffected, axis, offset, spacePos);
  var delta2 = isHorizontalLane ? { x: 0, y: offset } : { x: offset, y: 0 };
  spaceTool.makeSpace(
    adjustments.movingShapes,
    adjustments.resizingShapes,
    delta2,
    direction,
    spacePos
  );
  var newLanePosition = isHorizontalLane ? {
    x: shape.x + (isRoot ? LANE_INDENTATION : 0),
    y: lanePosition - (location === "top" ? 120 : 0),
    width: shape.width - (isRoot ? LANE_INDENTATION : 0),
    height: 120
  } : {
    x: lanePosition - (location === "left" ? 120 : 0),
    y: shape.y + (isRoot ? LANE_INDENTATION : 0),
    width: 120,
    height: shape.height - (isRoot ? LANE_INDENTATION : 0)
  };
  context.newLane = modeling.createShape(
    {
      type: "bpmn:Lane",
      isHorizontal: isHorizontalLane
    },
    newLanePosition,
    laneParent
  );
};

// node_modules/bpmn-js/lib/features/modeling/cmd/SplitLaneHandler.js
function SplitLaneHandler(modeling) {
  this._modeling = modeling;
}
SplitLaneHandler.$inject = [
  "modeling"
];
SplitLaneHandler.prototype.preExecute = function(context) {
  var modeling = this._modeling;
  var shape = context.shape, newLanesCount = context.count;
  var childLanes = getChildLanes(shape), existingLanesCount = childLanes.length;
  if (existingLanesCount > newLanesCount) {
    throw new Error(`more than <${newLanesCount}> child lanes`);
  }
  var isHorizontalLane = isHorizontal(shape);
  var laneBaseSize = isHorizontalLane ? shape.height : shape.width;
  var newLanesSize = Math.round(laneBaseSize / newLanesCount);
  var laneSize, laneBounds, newLaneAttrs, idx;
  for (idx = 0; idx < newLanesCount; idx++) {
    if (idx === newLanesCount - 1) {
      laneSize = laneBaseSize - newLanesSize * idx;
    } else {
      laneSize = newLanesSize;
    }
    laneBounds = isHorizontalLane ? {
      x: shape.x + LANE_INDENTATION,
      y: shape.y + idx * newLanesSize,
      width: shape.width - LANE_INDENTATION,
      height: laneSize
    } : {
      x: shape.x + idx * newLanesSize,
      y: shape.y + LANE_INDENTATION,
      width: laneSize,
      height: shape.height - LANE_INDENTATION
    };
    if (idx < existingLanesCount) {
      modeling.resizeShape(childLanes[idx], laneBounds);
    } else {
      newLaneAttrs = {
        type: "bpmn:Lane",
        isHorizontal: isHorizontalLane
      };
      modeling.createShape(newLaneAttrs, laneBounds, shape);
    }
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/ResizeLaneHandler.js
function ResizeLaneHandler(modeling, spaceTool) {
  this._modeling = modeling;
  this._spaceTool = spaceTool;
}
ResizeLaneHandler.$inject = [
  "modeling",
  "spaceTool"
];
ResizeLaneHandler.prototype.preExecute = function(context) {
  var shape = context.shape, newBounds = context.newBounds, balanced = context.balanced;
  if (balanced !== false) {
    this.resizeBalanced(shape, newBounds);
  } else {
    this.resizeSpace(shape, newBounds);
  }
};
ResizeLaneHandler.prototype.resizeBalanced = function(shape, newBounds) {
  var modeling = this._modeling;
  var resizeNeeded = computeLanesResize(shape, newBounds);
  modeling.resizeShape(shape, newBounds);
  resizeNeeded.forEach(function(r7) {
    modeling.resizeShape(r7.shape, r7.newBounds);
  });
};
ResizeLaneHandler.prototype.resizeSpace = function(shape, newBounds) {
  var spaceTool = this._spaceTool;
  var shapeTrbl = asTRBL(shape), newTrbl = asTRBL(newBounds);
  var trblDiff = substractTRBL(newTrbl, shapeTrbl);
  var lanesRoot = getLanesRoot(shape);
  var allAffected = [], allLanes = [];
  eachElement(lanesRoot, function(element) {
    allAffected.push(element);
    if (is(element, "bpmn:Lane") || is(element, "bpmn:Participant")) {
      allLanes.push(element);
    }
    return element.children;
  });
  var change, spacePos, direction, offset, adjustments;
  if (trblDiff.bottom || trblDiff.top) {
    change = trblDiff.bottom || trblDiff.top;
    spacePos = shape.y + (trblDiff.bottom ? shape.height : 0) + (trblDiff.bottom ? -10 : 10);
    direction = trblDiff.bottom ? "s" : "n";
    offset = trblDiff.top > 0 || trblDiff.bottom < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allAffected, "y", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: 0, y: change }, direction);
  }
  if (trblDiff.left || trblDiff.right) {
    change = trblDiff.right || trblDiff.left;
    spacePos = shape.x + (trblDiff.right ? shape.width : 0) + (trblDiff.right ? -10 : 100);
    direction = trblDiff.right ? "e" : "w";
    offset = trblDiff.left > 0 || trblDiff.right < 0 ? -change : change;
    adjustments = spaceTool.calculateAdjustments(allLanes, "x", offset, spacePos);
    spaceTool.makeSpace(adjustments.movingShapes, adjustments.resizingShapes, { x: change, y: 0 }, direction);
  }
};

// node_modules/bpmn-js/lib/features/modeling/cmd/UpdateFlowNodeRefsHandler.js
var FLOW_NODE_REFS_ATTR = "flowNodeRef";
var LANES_ATTR = "lanes";
function UpdateFlowNodeRefsHandler(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
UpdateFlowNodeRefsHandler.$inject = [
  "elementRegistry"
];
UpdateFlowNodeRefsHandler.prototype._computeUpdates = function(flowNodeShapes, laneShapes) {
  var handledNodes = [];
  var updates = [];
  var participantCache = {};
  var allFlowNodeShapes = [];
  function isInLaneShape(element, laneShape) {
    var laneTrbl = asTRBL(laneShape);
    var elementMid = {
      x: element.x + element.width / 2,
      y: element.y + element.height / 2
    };
    return elementMid.x > laneTrbl.left && elementMid.x < laneTrbl.right && elementMid.y > laneTrbl.top && elementMid.y < laneTrbl.bottom;
  }
  function addFlowNodeShape(flowNodeShape) {
    if (handledNodes.indexOf(flowNodeShape) === -1) {
      allFlowNodeShapes.push(flowNodeShape);
      handledNodes.push(flowNodeShape);
    }
  }
  function getAllLaneShapes(flowNodeShape) {
    var root = getLanesRoot(flowNodeShape);
    if (!participantCache[root.id]) {
      participantCache[root.id] = collectLanes(root);
    }
    return participantCache[root.id];
  }
  function getNewLanes(flowNodeShape) {
    if (!flowNodeShape.parent) {
      return [];
    }
    var allLaneShapes = getAllLaneShapes(flowNodeShape);
    return allLaneShapes.filter(function(l5) {
      return isInLaneShape(flowNodeShape, l5);
    }).map(function(shape) {
      return shape.businessObject;
    });
  }
  laneShapes.forEach(function(laneShape) {
    var root = getLanesRoot(laneShape);
    if (!root || handledNodes.indexOf(root) !== -1) {
      return;
    }
    var children = root.children.filter(function(c5) {
      return is(c5, "bpmn:FlowNode");
    });
    children.forEach(addFlowNodeShape);
    handledNodes.push(root);
  });
  flowNodeShapes.forEach(addFlowNodeShape);
  allFlowNodeShapes.forEach(function(flowNodeShape) {
    var flowNode = flowNodeShape.businessObject;
    var lanes = flowNode.get(LANES_ATTR), remove4 = lanes.slice(), add5 = getNewLanes(flowNodeShape);
    updates.push({ flowNode, remove: remove4, add: add5 });
  });
  laneShapes.forEach(function(laneShape) {
    var lane = laneShape.businessObject;
    if (!laneShape.parent) {
      lane.get(FLOW_NODE_REFS_ATTR).forEach(function(flowNode) {
        updates.push({ flowNode, remove: [lane], add: [] });
      });
    }
  });
  return updates;
};
UpdateFlowNodeRefsHandler.prototype.execute = function(context) {
  var updates = context.updates;
  if (!updates) {
    updates = context.updates = this._computeUpdates(context.flowNodeShapes, context.laneShapes);
  }
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.remove.forEach(function(oldLane) {
      remove3(lanes, oldLane);
      remove3(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.add.forEach(function(newLane) {
      add2(lanes, newLane);
      add2(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
  return [];
};
UpdateFlowNodeRefsHandler.prototype.revert = function(context) {
  var updates = context.updates;
  updates.forEach(function(update) {
    var flowNode = update.flowNode, lanes = flowNode.get(LANES_ATTR);
    update.add.forEach(function(newLane) {
      remove3(lanes, newLane);
      remove3(newLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
    update.remove.forEach(function(oldLane) {
      add2(lanes, oldLane);
      add2(oldLane.get(FLOW_NODE_REFS_ATTR), flowNode);
    });
  });
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/cmd/IdClaimHandler.js
function IdClaimHandler(moddle) {
  this._moddle = moddle;
}
IdClaimHandler.$inject = ["moddle"];
IdClaimHandler.prototype.execute = function(context) {
  var ids3 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids3.claim(id, element);
  } else {
    ids3.unclaim(id);
  }
  return [];
};
IdClaimHandler.prototype.revert = function(context) {
  var ids3 = this._moddle.ids, id = context.id, element = context.element, claiming = context.claiming;
  if (claiming) {
    ids3.unclaim(id);
  } else {
    ids3.claim(id, element);
  }
  return [];
};

// node_modules/bpmn-js/lib/features/modeling/cmd/SetColorHandler.js
var DEFAULT_COLORS = {
  fill: void 0,
  stroke: void 0
};
function SetColorHandler(commandStack) {
  this._commandStack = commandStack;
  this._normalizeColor = function(color) {
    if (!color) {
      return void 0;
    }
    if (isString(color)) {
      var hexColor = colorToHex(color);
      if (hexColor) {
        return hexColor;
      }
    }
    throw new Error(`invalid color value: ${color}`);
  };
}
SetColorHandler.$inject = [
  "commandStack"
];
SetColorHandler.prototype.postExecute = function(context) {
  var elements = context.elements, colors2 = context.colors || DEFAULT_COLORS;
  var self2 = this;
  var di = {};
  if ("fill" in colors2) {
    assign(di, {
      "background-color": this._normalizeColor(colors2.fill)
    });
  }
  if ("stroke" in colors2) {
    assign(di, {
      "border-color": this._normalizeColor(colors2.stroke)
    });
  }
  forEach(elements, function(element) {
    var assignedDi = isConnection(element) ? pick(di, ["border-color"]) : di, elementDi = getDi(element);
    ensureLegacySupport(assignedDi);
    if (isLabel(element)) {
      self2._commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: elementDi.label,
        properties: {
          color: di["border-color"]
        }
      });
    } else {
      if (!isAny(elementDi, ["bpmndi:BPMNEdge", "bpmndi:BPMNShape"])) {
        return;
      }
      self2._commandStack.execute("element.updateProperties", {
        element,
        properties: {
          di: assignedDi
        }
      });
    }
  });
};
function colorToHex(color) {
  var context = document.createElement("canvas").getContext("2d");
  context.fillStyle = "transparent";
  context.fillStyle = color;
  return /^#[0-9a-fA-F]{6}$/.test(context.fillStyle) ? context.fillStyle : null;
}
function ensureLegacySupport(di) {
  if ("border-color" in di) {
    di.stroke = di["border-color"];
  }
  if ("background-color" in di) {
    di.fill = di["background-color"];
  }
}

// node_modules/bpmn-js/lib/features/label-editing/cmd/UpdateLabelHandler.js
var NULL_DIMENSIONS2 = {
  width: 0,
  height: 0
};
function UpdateLabelHandler(modeling, textRenderer, bpmnFactory) {
  function setText(element, text) {
    var label = element.label || element;
    var labelTarget = element.labelTarget || element;
    setLabel(label, text, labelTarget !== label);
    return [label, labelTarget];
  }
  function preExecute(ctx) {
    var element = ctx.element, businessObject = element.businessObject, newLabel = ctx.newLabel;
    if (!isLabel(element) && isLabelExternal(element) && !hasExternalLabel(element) && !isEmptyText(newLabel)) {
      var paddingTop = 7;
      var labelCenter = getExternalLabelMid(element);
      labelCenter = {
        x: labelCenter.x,
        y: labelCenter.y + paddingTop
      };
      modeling.createLabel(element, labelCenter, {
        id: businessObject.id + "_label",
        businessObject,
        di: element.di
      });
    }
  }
  function execute(ctx) {
    ctx.oldLabel = getLabel(ctx.element);
    return setText(ctx.element, ctx.newLabel);
  }
  function revert(ctx) {
    return setText(ctx.element, ctx.oldLabel);
  }
  function postExecute(ctx) {
    var element = ctx.element, label = element.label || element, newLabel = ctx.newLabel, newBounds = ctx.newBounds, hints = ctx.hints || {};
    if (!isLabel(label) && !is(label, "bpmn:TextAnnotation")) {
      return;
    }
    if (isLabel(label) && isEmptyText(newLabel)) {
      if (hints.removeShape !== false) {
        modeling.removeShape(label, { unsetLabel: false });
      }
      return;
    }
    var text = getLabel(element);
    if (typeof newBounds === "undefined") {
      newBounds = textRenderer.getExternalLabelBounds(label, text);
    }
    if (newBounds) {
      modeling.resizeShape(label, newBounds, NULL_DIMENSIONS2);
    }
  }
  this.preExecute = preExecute;
  this.execute = execute;
  this.revert = revert;
  this.postExecute = postExecute;
}
UpdateLabelHandler.$inject = [
  "modeling",
  "textRenderer",
  "bpmnFactory"
];
function isEmptyText(label) {
  return !label || !label.trim();
}

// node_modules/bpmn-js/lib/features/modeling/Modeling.js
function Modeling2(eventBus, elementFactory, commandStack, bpmnRules) {
  Modeling.call(this, eventBus, elementFactory, commandStack);
  this._bpmnRules = bpmnRules;
}
e(Modeling2, Modeling);
Modeling2.$inject = [
  "eventBus",
  "elementFactory",
  "commandStack",
  "bpmnRules"
];
Modeling2.prototype.getHandlers = function() {
  var handlers = Modeling.prototype.getHandlers.call(this);
  handlers["element.updateModdleProperties"] = UpdateModdlePropertiesHandler;
  handlers["element.updateProperties"] = UpdatePropertiesHandler;
  handlers["canvas.updateRoot"] = UpdateCanvasRootHandler;
  handlers["lane.add"] = AddLaneHandler;
  handlers["lane.resize"] = ResizeLaneHandler;
  handlers["lane.split"] = SplitLaneHandler;
  handlers["lane.updateRefs"] = UpdateFlowNodeRefsHandler;
  handlers["id.updateClaim"] = IdClaimHandler;
  handlers["element.setColor"] = SetColorHandler;
  handlers["element.updateLabel"] = UpdateLabelHandler;
  return handlers;
};
Modeling2.prototype.updateLabel = function(element, newLabel, newBounds, hints) {
  this._commandStack.execute("element.updateLabel", {
    element,
    newLabel,
    newBounds,
    hints: hints || {}
  });
};
Modeling2.prototype.connect = function(source, target, attrs, hints) {
  var bpmnRules = this._bpmnRules;
  if (!attrs) {
    attrs = bpmnRules.canConnect(source, target);
  }
  if (!attrs) {
    return;
  }
  return this.createConnection(source, target, attrs, source.parent, hints);
};
Modeling2.prototype.updateModdleProperties = function(element, moddleElement, properties) {
  this._commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement,
    properties
  });
};
Modeling2.prototype.updateProperties = function(element, properties) {
  this._commandStack.execute("element.updateProperties", {
    element,
    properties
  });
};
Modeling2.prototype.resizeLane = function(laneShape, newBounds, balanced) {
  this._commandStack.execute("lane.resize", {
    shape: laneShape,
    newBounds,
    balanced
  });
};
Modeling2.prototype.addLane = function(targetLaneShape, location) {
  var context = {
    shape: targetLaneShape,
    location
  };
  this._commandStack.execute("lane.add", context);
  return context.newLane;
};
Modeling2.prototype.splitLane = function(targetLane, count) {
  this._commandStack.execute("lane.split", {
    shape: targetLane,
    count
  });
};
Modeling2.prototype.makeCollaboration = function() {
  var collaborationElement = this._create("root", {
    type: "bpmn:Collaboration"
  });
  var context = {
    newRoot: collaborationElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return collaborationElement;
};
Modeling2.prototype.makeProcess = function() {
  var processElement = this._create("root", {
    type: "bpmn:Process"
  });
  var context = {
    newRoot: processElement
  };
  this._commandStack.execute("canvas.updateRoot", context);
  return processElement;
};
Modeling2.prototype.updateLaneRefs = function(flowNodeShapes, laneShapes) {
  this._commandStack.execute("lane.updateRefs", {
    flowNodeShapes,
    laneShapes
  });
};
Modeling2.prototype.claimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement,
    claiming: true
  });
};
Modeling2.prototype.unclaimId = function(id, moddleElement) {
  this._commandStack.execute("id.updateClaim", {
    id,
    element: moddleElement
  });
};
Modeling2.prototype.setColor = function(elements, colors2) {
  if (!elements.length) {
    elements = [elements];
  }
  this._commandStack.execute("element.setColor", {
    elements,
    colors: colors2
  });
};

// node_modules/diagram-js/lib/layout/BaseLayouter.js
function BaseLayouter() {
}
BaseLayouter.prototype.layoutConnection = function(connection, hints) {
  hints = hints || {};
  return [
    hints.connectionStart || getMid(hints.source || connection.source),
    hints.connectionEnd || getMid(hints.target || connection.target)
  ];
};

// node_modules/diagram-js/lib/layout/ManhattanLayout.js
var MIN_SEGMENT_LENGTH = 20;
var POINT_ORIENTATION_PADDING = 5;
var round11 = Math.round;
var INTERSECTION_THRESHOLD2 = 20;
var ORIENTATION_THRESHOLD = {
  "h:h": 20,
  "v:v": 20,
  "h:v": -10,
  "v:h": -10
};
function needsTurn(orientation, startDirection) {
  return !{
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /./,
    v: /./
  }[startDirection].test(orientation);
}
function canLayoutStraight(direction, targetOrientation) {
  return {
    t: /top/,
    r: /right/,
    b: /bottom/,
    l: /left/,
    h: /left|right/,
    v: /top|bottom/
  }[direction].test(targetOrientation);
}
function getSegmentBendpoints(a6, b4, directions2) {
  var orientation = getOrientation(b4, a6, POINT_ORIENTATION_PADDING);
  var startDirection = directions2.split(":")[0];
  var xmid = round11((b4.x - a6.x) / 2 + a6.x), ymid = round11((b4.y - a6.y) / 2 + a6.y);
  var segmentEnd, segmentDirections;
  var layoutStraight = canLayoutStraight(startDirection, orientation), layoutHorizontal = /h|r|l/.test(startDirection), layoutTurn = false;
  var turnNextDirections = false;
  if (layoutStraight) {
    segmentEnd = layoutHorizontal ? { x: xmid, y: a6.y } : { x: a6.x, y: ymid };
    segmentDirections = layoutHorizontal ? "h:h" : "v:v";
  } else {
    layoutTurn = needsTurn(orientation, startDirection);
    segmentDirections = layoutHorizontal ? "h:v" : "v:h";
    if (layoutTurn) {
      if (layoutHorizontal) {
        turnNextDirections = ymid === a6.y;
        segmentEnd = {
          x: a6.x + MIN_SEGMENT_LENGTH * (/l/.test(startDirection) ? -1 : 1),
          y: turnNextDirections ? ymid + MIN_SEGMENT_LENGTH : ymid
        };
      } else {
        turnNextDirections = xmid === a6.x;
        segmentEnd = {
          x: turnNextDirections ? xmid + MIN_SEGMENT_LENGTH : xmid,
          y: a6.y + MIN_SEGMENT_LENGTH * (/t/.test(startDirection) ? -1 : 1)
        };
      }
    } else {
      segmentEnd = {
        x: xmid,
        y: ymid
      };
    }
  }
  return {
    waypoints: getBendpoints(a6, segmentEnd, segmentDirections).concat(segmentEnd),
    directions: segmentDirections,
    turnNextDirections
  };
}
function getStartSegment(a6, b4, directions2) {
  return getSegmentBendpoints(a6, b4, directions2);
}
function getEndSegment(a6, b4, directions2) {
  var invertedSegment = getSegmentBendpoints(b4, a6, invertDirections(directions2));
  return {
    waypoints: invertedSegment.waypoints.slice().reverse(),
    directions: invertDirections(invertedSegment.directions),
    turnNextDirections: invertedSegment.turnNextDirections
  };
}
function getMidSegment(startSegment, endSegment) {
  var startDirection = startSegment.directions.split(":")[1], endDirection = endSegment.directions.split(":")[0];
  if (startSegment.turnNextDirections) {
    startDirection = startDirection == "h" ? "v" : "h";
  }
  if (endSegment.turnNextDirections) {
    endDirection = endDirection == "h" ? "v" : "h";
  }
  var directions2 = startDirection + ":" + endDirection;
  var bendpoints = getBendpoints(
    startSegment.waypoints[startSegment.waypoints.length - 1],
    endSegment.waypoints[0],
    directions2
  );
  return {
    waypoints: bendpoints,
    directions: directions2
  };
}
function invertDirections(directions2) {
  return directions2.split(":").reverse().join(":");
}
function getSimpleBendpoints(a6, b4, directions2) {
  var xmid = round11((b4.x - a6.x) / 2 + a6.x), ymid = round11((b4.y - a6.y) / 2 + a6.y);
  if (directions2 === "h:v") {
    return [{ x: b4.x, y: a6.y }];
  }
  if (directions2 === "v:h") {
    return [{ x: a6.x, y: b4.y }];
  }
  if (directions2 === "h:h") {
    return [
      { x: xmid, y: a6.y },
      { x: xmid, y: b4.y }
    ];
  }
  if (directions2 === "v:v") {
    return [
      { x: a6.x, y: ymid },
      { x: b4.x, y: ymid }
    ];
  }
  throw new Error("invalid directions: can only handle varians of [hv]:[hv]");
}
function getBendpoints(a6, b4, directions2) {
  directions2 = directions2 || "h:h";
  if (!isValidDirections(directions2)) {
    throw new Error(
      "unknown directions: <" + directions2 + ">: must be specified as <start>:<end> with start/end in { h,v,t,r,b,l }"
    );
  }
  if (isExplicitDirections(directions2)) {
    var startSegment = getStartSegment(a6, b4, directions2), endSegment = getEndSegment(a6, b4, directions2), midSegment = getMidSegment(startSegment, endSegment);
    return [].concat(
      startSegment.waypoints,
      midSegment.waypoints,
      endSegment.waypoints
    );
  }
  return getSimpleBendpoints(a6, b4, directions2);
}
function connectPoints(a6, b4, directions2) {
  var points = getBendpoints(a6, b4, directions2);
  points.unshift(a6);
  points.push(b4);
  return withoutRedundantPoints(points);
}
function connectRectangles(source, target, start, end, hints) {
  var preferredLayouts = hints && hints.preferredLayouts || [];
  var preferredLayout = without(preferredLayouts, "straight")[0] || "h:h";
  var threshold = ORIENTATION_THRESHOLD[preferredLayout] || 0;
  var orientation = getOrientation(source, target, threshold);
  var directions2 = getDirections(orientation, preferredLayout);
  start = start || getMid(source);
  end = end || getMid(target);
  var directionSplit = directions2.split(":");
  var startDocking = getDockingPoint(start, source, directionSplit[0], invertOrientation(orientation)), endDocking = getDockingPoint(end, target, directionSplit[1], orientation);
  return connectPoints(startDocking, endDocking, directions2);
}
function repairConnection(source, target, start, end, waypoints, hints) {
  if (isArray(start)) {
    waypoints = start;
    hints = end;
    start = getMid(source);
    end = getMid(target);
  }
  hints = assign({ preferredLayouts: [] }, hints);
  waypoints = waypoints || [];
  var preferredLayouts = hints.preferredLayouts, preferStraight = preferredLayouts.indexOf("straight") !== -1, repairedWaypoints;
  repairedWaypoints = preferStraight && tryLayoutStraight(source, target, start, end, hints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionEnd && tryRepairConnectionEnd(target, source, end, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  repairedWaypoints = hints.connectionStart && tryRepairConnectionStart(source, target, start, waypoints);
  if (repairedWaypoints) {
    return repairedWaypoints;
  }
  if (!hints.connectionStart && !hints.connectionEnd && waypoints && waypoints.length) {
    return waypoints;
  }
  return connectRectangles(source, target, start, end, hints);
}
function inRange(a6, start, end) {
  return a6 >= start && a6 <= end;
}
function isInRange(axis, a6, b4) {
  var size2 = {
    x: "width",
    y: "height"
  };
  return inRange(a6[axis], b4[axis], b4[axis] + b4[size2[axis]]);
}
function tryLayoutStraight(source, target, start, end, hints) {
  var axis = {}, primaryAxis, orientation;
  orientation = getOrientation(source, target);
  if (!/^(top|bottom|left|right)$/.test(orientation)) {
    return null;
  }
  if (/top|bottom/.test(orientation)) {
    primaryAxis = "x";
  }
  if (/left|right/.test(orientation)) {
    primaryAxis = "y";
  }
  if (hints.preserveDocking === "target") {
    if (!isInRange(primaryAxis, end, source)) {
      return null;
    }
    axis[primaryAxis] = end[primaryAxis];
    return [
      {
        x: axis.x !== void 0 ? axis.x : start.x,
        y: axis.y !== void 0 ? axis.y : start.y,
        original: {
          x: axis.x !== void 0 ? axis.x : start.x,
          y: axis.y !== void 0 ? axis.y : start.y
        }
      },
      {
        x: end.x,
        y: end.y
      }
    ];
  } else {
    if (!isInRange(primaryAxis, start, target)) {
      return null;
    }
    axis[primaryAxis] = start[primaryAxis];
    return [
      {
        x: start.x,
        y: start.y
      },
      {
        x: axis.x !== void 0 ? axis.x : end.x,
        y: axis.y !== void 0 ? axis.y : end.y,
        original: {
          x: axis.x !== void 0 ? axis.x : end.x,
          y: axis.y !== void 0 ? axis.y : end.y
        }
      }
    ];
  }
}
function tryRepairConnectionStart(moved, other, newDocking, points) {
  return _tryRepairConnectionSide(moved, other, newDocking, points);
}
function tryRepairConnectionEnd(moved, other, newDocking, points) {
  var waypoints = points.slice().reverse();
  waypoints = _tryRepairConnectionSide(moved, other, newDocking, waypoints);
  return waypoints ? waypoints.reverse() : null;
}
function _tryRepairConnectionSide(moved, other, newDocking, points) {
  function needsRelayout(points2) {
    if (points2.length < 3) {
      return true;
    }
    if (points2.length > 4) {
      return false;
    }
    return !!find(points2, function(p5, idx) {
      var q6 = points2[idx - 1];
      return q6 && pointDistance(p5, q6) < 3;
    });
  }
  function repairBendpoint(candidate, oldPeer, newPeer) {
    var alignment = pointsAligned(oldPeer, candidate);
    switch (alignment) {
      case "v":
        return { x: newPeer.x, y: candidate.y };
      case "h":
        return { x: candidate.x, y: newPeer.y };
    }
    return { x: candidate.x, y: candidate.y };
  }
  function removeOverlapping(points2, a6, b4) {
    var i7;
    for (i7 = points2.length - 2; i7 !== 0; i7--) {
      if (pointInRect(points2[i7], a6, INTERSECTION_THRESHOLD2) || pointInRect(points2[i7], b4, INTERSECTION_THRESHOLD2)) {
        return points2.slice(i7);
      }
    }
    return points2;
  }
  if (needsRelayout(points)) {
    return null;
  }
  var oldDocking = points[0], newPoints = points.slice(), slicedPoints;
  newPoints[0] = newDocking;
  newPoints[1] = repairBendpoint(newPoints[1], oldDocking, newDocking);
  slicedPoints = removeOverlapping(newPoints, moved, other);
  if (slicedPoints !== newPoints) {
    newPoints = _tryRepairConnectionSide(moved, other, newDocking, slicedPoints);
  }
  if (newPoints && pointsAligned(newPoints)) {
    return null;
  }
  return newPoints;
}
function getDirections(orientation, defaultLayout) {
  if (isExplicitDirections(defaultLayout)) {
    return defaultLayout;
  }
  switch (orientation) {
    case "intersect":
      return "t:t";
    case "top":
    case "bottom":
      return "v:v";
    case "left":
    case "right":
      return "h:h";
    // 'top-left'
    // 'top-right'
    // 'bottom-left'
    // 'bottom-right'
    default:
      return defaultLayout;
  }
}
function isValidDirections(directions2) {
  return directions2 && /^h|v|t|r|b|l:h|v|t|r|b|l$/.test(directions2);
}
function isExplicitDirections(directions2) {
  return directions2 && /t|r|b|l/.test(directions2);
}
function invertOrientation(orientation) {
  return {
    "top": "bottom",
    "bottom": "top",
    "left": "right",
    "right": "left",
    "top-left": "bottom-right",
    "bottom-right": "top-left",
    "top-right": "bottom-left",
    "bottom-left": "top-right"
  }[orientation];
}
function getDockingPoint(point, rectangle2, dockingDirection, targetOrientation) {
  if (dockingDirection === "h") {
    dockingDirection = /left/.test(targetOrientation) ? "l" : "r";
  }
  if (dockingDirection === "v") {
    dockingDirection = /top/.test(targetOrientation) ? "t" : "b";
  }
  if (dockingDirection === "t") {
    return { original: point, x: point.x, y: rectangle2.y };
  }
  if (dockingDirection === "r") {
    return { original: point, x: rectangle2.x + rectangle2.width, y: point.y };
  }
  if (dockingDirection === "b") {
    return { original: point, x: point.x, y: rectangle2.y + rectangle2.height };
  }
  if (dockingDirection === "l") {
    return { original: point, x: rectangle2.x, y: point.y };
  }
  throw new Error("unexpected dockingDirection: <" + dockingDirection + ">");
}
function withoutRedundantPoints(waypoints) {
  return waypoints.reduce(function(points, p5, idx) {
    var previous = points[points.length - 1], next = waypoints[idx + 1];
    if (!pointsOnLine(previous, next, p5, 0)) {
      points.push(p5);
    }
    return points;
  }, []);
}

// node_modules/bpmn-js/lib/features/modeling/BpmnLayouter.js
var ATTACH_ORIENTATION_PADDING = -10;
var BOUNDARY_TO_HOST_THRESHOLD = 40;
var PREFERRED_LAYOUTS_HORIZONTAL = {
  default: ["h:h"],
  fromGateway: ["v:h"],
  toGateway: ["h:v"],
  loop: {
    fromTop: ["t:r"],
    fromRight: ["r:b"],
    fromLeft: ["l:t"],
    fromBottom: ["b:l"]
  },
  boundaryLoop: {
    alternateHorizontalSide: "b",
    alternateVerticalSide: "l",
    default: "v"
  },
  messageFlow: ["straight", "v:v"],
  subProcess: ["straight", "h:h"],
  isHorizontal: true
};
var PREFERRED_LAYOUTS_VERTICAL = {
  default: ["v:v"],
  fromGateway: ["h:v"],
  toGateway: ["v:h"],
  loop: {
    fromTop: ["t:l"],
    fromRight: ["r:t"],
    fromLeft: ["l:b"],
    fromBottom: ["b:r"]
  },
  boundaryLoop: {
    alternateHorizontalSide: "t",
    alternateVerticalSide: "r",
    default: "h"
  },
  messageFlow: ["straight", "h:h"],
  subProcess: ["straight", "v:v"],
  isHorizontal: false
};
var oppositeOrientationMapping = {
  "top": "bottom",
  "top-right": "bottom-left",
  "top-left": "bottom-right",
  "right": "left",
  "bottom": "top",
  "bottom-right": "top-left",
  "bottom-left": "top-right",
  "left": "right"
};
var orientationDirectionMapping = {
  top: "t",
  right: "r",
  bottom: "b",
  left: "l"
};
function BpmnLayouter(elementRegistry) {
  this._elementRegistry = elementRegistry;
}
e(BpmnLayouter, BaseLayouter);
BpmnLayouter.prototype.layoutConnection = function(connection, hints) {
  if (!hints) {
    hints = {};
  }
  var source = hints.source || connection.source, target = hints.target || connection.target, waypoints = hints.waypoints || connection.waypoints, connectionStart = hints.connectionStart, connectionEnd = hints.connectionEnd, elementRegistry = this._elementRegistry;
  var manhattanOptions, updatedWaypoints;
  if (!connectionStart) {
    connectionStart = getConnectionDocking(waypoints && waypoints[0], source);
  }
  if (!connectionEnd) {
    connectionEnd = getConnectionDocking(waypoints && waypoints[waypoints.length - 1], target);
  }
  if (is(connection, "bpmn:Association") || is(connection, "bpmn:DataAssociation")) {
    if (waypoints && !isCompensationAssociation(source, target)) {
      return [].concat([connectionStart], waypoints.slice(1, -1), [connectionEnd]);
    }
  }
  var layout = isDirectionHorizontal(source, elementRegistry) ? PREFERRED_LAYOUTS_HORIZONTAL : PREFERRED_LAYOUTS_VERTICAL;
  if (is(connection, "bpmn:MessageFlow")) {
    manhattanOptions = getMessageFlowManhattanOptions(source, target, layout);
  } else if (is(connection, "bpmn:SequenceFlow") || isCompensationAssociation(source, target)) {
    if (source === target) {
      manhattanOptions = {
        preferredLayouts: getLoopPreferredLayout(source, connection, layout)
      };
    } else if (is(source, "bpmn:BoundaryEvent")) {
      manhattanOptions = {
        preferredLayouts: getBoundaryEventPreferredLayouts(source, target, connectionEnd, layout)
      };
    } else if (isExpandedSubProcess(source) || isExpandedSubProcess(target)) {
      manhattanOptions = {
        preferredLayouts: layout.subProcess,
        preserveDocking: getSubProcessPreserveDocking(source)
      };
    } else if (is(source, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: layout.fromGateway
      };
    } else if (is(target, "bpmn:Gateway")) {
      manhattanOptions = {
        preferredLayouts: layout.toGateway
      };
    } else {
      manhattanOptions = {
        preferredLayouts: layout.default
      };
    }
  }
  if (manhattanOptions) {
    manhattanOptions = assign(manhattanOptions, hints);
    updatedWaypoints = withoutRedundantPoints(repairConnection(
      source,
      target,
      connectionStart,
      connectionEnd,
      waypoints,
      manhattanOptions
    ));
  }
  return updatedWaypoints || [connectionStart, connectionEnd];
};
function getAttachOrientation(attachedElement) {
  var hostElement = attachedElement.host;
  return getOrientation(getMid(attachedElement), hostElement, ATTACH_ORIENTATION_PADDING);
}
function getMessageFlowManhattanOptions(source, target, layout) {
  return {
    preferredLayouts: layout.messageFlow,
    preserveDocking: getMessageFlowPreserveDocking(source, target)
  };
}
function getMessageFlowPreserveDocking(source, target) {
  if (is(target, "bpmn:Participant")) {
    return "source";
  }
  if (is(source, "bpmn:Participant")) {
    return "target";
  }
  if (isExpandedSubProcess(target)) {
    return "source";
  }
  if (isExpandedSubProcess(source)) {
    return "target";
  }
  if (is(target, "bpmn:Event")) {
    return "target";
  }
  if (is(source, "bpmn:Event")) {
    return "source";
  }
  return null;
}
function getSubProcessPreserveDocking(source) {
  return isExpandedSubProcess(source) ? "target" : "source";
}
function getConnectionDocking(point, shape) {
  return point ? point.original || point : getMid(shape);
}
function isCompensationAssociation(source, target) {
  return is(target, "bpmn:Activity") && is(source, "bpmn:BoundaryEvent") && target.businessObject.isForCompensation;
}
function isExpandedSubProcess(element) {
  return is(element, "bpmn:SubProcess") && isExpanded(element);
}
function isSame2(a6, b4) {
  return a6 === b4;
}
function isAnyOrientation(orientation, orientations) {
  return orientations.indexOf(orientation) !== -1;
}
function getHorizontalOrientation(orientation) {
  var matches3 = /right|left/.exec(orientation);
  return matches3 && matches3[0];
}
function getVerticalOrientation(orientation) {
  var matches3 = /top|bottom/.exec(orientation);
  return matches3 && matches3[0];
}
function isOppositeOrientation(a6, b4) {
  return oppositeOrientationMapping[a6] === b4;
}
function isOppositeHorizontalOrientation(a6, b4) {
  var horizontalOrientation = getHorizontalOrientation(a6);
  var oppositeHorizontalOrientation = oppositeOrientationMapping[horizontalOrientation];
  return b4.indexOf(oppositeHorizontalOrientation) !== -1;
}
function isOppositeVerticalOrientation(a6, b4) {
  var verticalOrientation = getVerticalOrientation(a6);
  var oppositeVerticalOrientation = oppositeOrientationMapping[verticalOrientation];
  return b4.indexOf(oppositeVerticalOrientation) !== -1;
}
function isHorizontalOrientation(orientation) {
  return orientation === "right" || orientation === "left";
}
function getLoopPreferredLayout(source, connection, layout) {
  var waypoints = connection.waypoints;
  var orientation = waypoints && waypoints.length && getOrientation(waypoints[0], source);
  if (orientation === "top") {
    return layout.loop.fromTop;
  } else if (orientation === "right") {
    return layout.loop.fromRight;
  } else if (orientation === "left") {
    return layout.loop.fromLeft;
  }
  return layout.loop.fromBottom;
}
function getBoundaryEventPreferredLayouts(source, target, end, layout) {
  var sourceMid = getMid(source), targetMid = getMid(target), attachOrientation = getAttachOrientation(source), sourceLayout, targetLayout;
  var isLoop = isSame2(source.host, target);
  var attachedToSide = isAnyOrientation(attachOrientation, ["top", "right", "bottom", "left"]);
  var targetOrientation = getOrientation(targetMid, sourceMid, {
    x: source.width / 2 + target.width / 2,
    y: source.height / 2 + target.height / 2
  });
  if (isLoop) {
    return getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout);
  }
  sourceLayout = getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);
  targetLayout = getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, layout.isHorizontal);
  return [sourceLayout + ":" + targetLayout];
}
function getBoundaryEventLoopLayout(attachOrientation, attachedToSide, source, target, end, layout) {
  var orientation = attachedToSide ? attachOrientation : layout.isHorizontal ? getVerticalOrientation(attachOrientation) : getHorizontalOrientation(attachOrientation), sourceLayout = orientationDirectionMapping[orientation], targetLayout;
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      targetLayout = shouldConnectToSameSide("y", source, target, end) ? "h" : layout.boundaryLoop.alternateHorizontalSide;
    } else {
      targetLayout = shouldConnectToSameSide("x", source, target, end) ? "v" : layout.boundaryLoop.alternateVerticalSide;
    }
  } else {
    targetLayout = layout.boundaryLoop.default;
  }
  return [sourceLayout + ":" + targetLayout];
}
function shouldConnectToSameSide(axis, source, target, end) {
  var threshold = BOUNDARY_TO_HOST_THRESHOLD;
  return !(areCloseOnAxis(axis, end, target, threshold) || areCloseOnAxis(axis, end, {
    x: target.x + target.width,
    y: target.y + target.height
  }, threshold) || areCloseOnAxis(axis, end, getMid(source), threshold));
}
function areCloseOnAxis(axis, a6, b4, threshold) {
  return Math.abs(a6[axis] - b4[axis]) < threshold;
}
function getBoundaryEventSourceLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal5) {
  if (attachedToSide) {
    return orientationDirectionMapping[attachOrientation];
  }
  var verticalAttachOrientation = getVerticalOrientation(attachOrientation), horizontalAttachOrientation = getHorizontalOrientation(attachOrientation), verticalTargetOrientation = getVerticalOrientation(targetOrientation), horizontalTargetOrientation = getHorizontalOrientation(targetOrientation);
  if (isHorizontal5) {
    if (isSame2(verticalAttachOrientation, verticalTargetOrientation) || isOppositeOrientation(horizontalAttachOrientation, horizontalTargetOrientation)) {
      return orientationDirectionMapping[verticalAttachOrientation];
    }
  } else {
    if (isSame2(horizontalAttachOrientation, horizontalTargetOrientation) || isOppositeOrientation(verticalAttachOrientation, verticalTargetOrientation)) {
      return orientationDirectionMapping[horizontalAttachOrientation];
    }
  }
  return orientationDirectionMapping[isHorizontal5 ? horizontalAttachOrientation : verticalAttachOrientation];
}
function getBoundaryEventTargetLayout(attachOrientation, targetOrientation, attachedToSide, isHorizontal5) {
  if (attachedToSide) {
    if (isHorizontalOrientation(attachOrientation)) {
      if (isOppositeHorizontalOrientation(attachOrientation, targetOrientation) || isSame2(attachOrientation, targetOrientation)) {
        return "h";
      }
      return "v";
    } else {
      if (isOppositeVerticalOrientation(attachOrientation, targetOrientation) || isSame2(attachOrientation, targetOrientation)) {
        return "v";
      }
      return "h";
    }
  }
  if (isHorizontal5) {
    if (isSame2(getVerticalOrientation(attachOrientation), getVerticalOrientation(targetOrientation))) {
      return "h";
    } else {
      return "v";
    }
  } else {
    if (isSame2(getHorizontalOrientation(attachOrientation), getHorizontalOrientation(targetOrientation))) {
      return "v";
    } else {
      return "h";
    }
  }
}
BpmnLayouter.$inject = ["elementRegistry"];

// node_modules/diagram-js/lib/layout/CroppingConnectionDocking.js
function dockingToPoint(docking) {
  return assign({ original: docking.point.original || docking.point }, docking.actual);
}
function CroppingConnectionDocking(elementRegistry, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._graphicsFactory = graphicsFactory;
}
CroppingConnectionDocking.$inject = ["elementRegistry", "graphicsFactory"];
CroppingConnectionDocking.prototype.getCroppedWaypoints = function(connection, source, target) {
  source = source || connection.source;
  target = target || connection.target;
  var sourceDocking = this.getDockingPoint(connection, source, true), targetDocking = this.getDockingPoint(connection, target);
  var croppedWaypoints = connection.waypoints.slice(sourceDocking.idx + 1, targetDocking.idx);
  croppedWaypoints.unshift(dockingToPoint(sourceDocking));
  croppedWaypoints.push(dockingToPoint(targetDocking));
  return croppedWaypoints;
};
CroppingConnectionDocking.prototype.getDockingPoint = function(connection, shape, dockStart) {
  var waypoints = connection.waypoints, dockingIdx, dockingPoint, croppedPoint;
  dockingIdx = dockStart ? 0 : waypoints.length - 1;
  dockingPoint = waypoints[dockingIdx];
  croppedPoint = this._getIntersection(shape, connection, dockStart);
  return {
    point: dockingPoint,
    actual: croppedPoint || dockingPoint,
    idx: dockingIdx
  };
};
CroppingConnectionDocking.prototype._getIntersection = function(shape, connection, takeFirst) {
  var shapePath = this._getShapePath(shape), connectionPath = this._getConnectionPath(connection);
  return getElementLineIntersection(shapePath, connectionPath, takeFirst);
};
CroppingConnectionDocking.prototype._getConnectionPath = function(connection) {
  return this._graphicsFactory.getConnectionPath(connection);
};
CroppingConnectionDocking.prototype._getShapePath = function(shape) {
  return this._graphicsFactory.getShapePath(shape);
};
CroppingConnectionDocking.prototype._getGfx = function(element) {
  return this._elementRegistry.getGraphics(element);
};

// node_modules/bpmn-js/lib/features/modeling/index.js
var modeling_default = {
  __init__: [
    "modeling",
    "bpmnUpdater"
  ],
  __depends__: [
    behavior_default,
    rules_default2,
    di_ordering_default,
    ordering_default,
    replace_default2,
    command_default,
    label_support_default,
    attach_support_default,
    selection_default,
    change_support_default,
    space_tool_default2
  ],
  bpmnFactory: ["type", BpmnFactory],
  bpmnUpdater: ["type", BpmnUpdater],
  elementFactory: ["type", ElementFactory2],
  modeling: ["type", Modeling2],
  layouter: ["type", BpmnLayouter],
  connectionDocking: ["type", CroppingConnectionDocking]
};

// node_modules/bpmn-js/lib/features/append-preview/AppendPreview.js
var round12 = Math.round;
function AppendPreview(complexPreview, connectionDocking, elementFactory, eventBus, layouter, rules) {
  this._complexPreview = complexPreview;
  this._connectionDocking = connectionDocking;
  this._elementFactory = elementFactory;
  this._eventBus = eventBus;
  this._layouter = layouter;
  this._rules = rules;
}
AppendPreview.prototype.create = function(source, type, options) {
  const complexPreview = this._complexPreview, connectionDocking = this._connectionDocking, elementFactory = this._elementFactory, eventBus = this._eventBus, layouter = this._layouter, rules = this._rules;
  const shape = elementFactory.createShape(assign({ type }, options));
  const position = eventBus.fire("autoPlace", {
    source,
    shape
  });
  if (!position) {
    return;
  }
  assign(shape, {
    x: position.x - round12(shape.width / 2),
    y: position.y - round12(shape.height / 2)
  });
  const connectionCreateAllowed = rules.allowed("connection.create", {
    source,
    target: shape,
    hints: {
      targetParent: source.parent
    }
  });
  let connection = null;
  if (connectionCreateAllowed) {
    connection = elementFactory.createConnection(connectionCreateAllowed);
    connection.waypoints = layouter.layoutConnection(connection, {
      source,
      target: shape
    });
    connection.waypoints = connectionDocking.getCroppedWaypoints(connection, source, shape);
  }
  complexPreview.create({
    created: [
      shape,
      connection
    ].filter((element) => !isNil(element))
  });
};
AppendPreview.prototype.cleanUp = function() {
  this._complexPreview.cleanUp();
};
AppendPreview.$inject = [
  "complexPreview",
  "connectionDocking",
  "elementFactory",
  "eventBus",
  "layouter",
  "rules"
];

// node_modules/bpmn-js/lib/features/append-preview/index.js
var append_preview_default = {
  __depends__: [
    auto_place_default2,
    complex_preview_default,
    modeling_default
  ],
  __init__: ["appendPreview"],
  appendPreview: ["type", AppendPreview]
};

// node_modules/diagram-js-direct-editing/lib/TextBox.js
var min4 = Math.min;
var max7 = Math.max;
function preventDefault2(e8) {
  e8.preventDefault();
}
function stopPropagation2(e8) {
  e8.stopPropagation();
}
function isTextNode(node2) {
  return node2.nodeType === Node.TEXT_NODE;
}
function toArray(nodeList) {
  return [].slice.call(nodeList);
}
function TextBox(options) {
  this.container = options.container;
  this.parent = domify$1(
    '<div class="djs-direct-editing-parent"><div class="djs-direct-editing-content" contenteditable="true"></div></div>'
  );
  this.content = query("[contenteditable]", this.parent);
  this.keyHandler = options.keyHandler || function() {
  };
  this.resizeHandler = options.resizeHandler || function() {
  };
  this.autoResize = bind(this.autoResize, this);
  this.handlePaste = bind(this.handlePaste, this);
}
TextBox.prototype.create = function(bounds, style, value, options) {
  var self2 = this;
  var parent = this.parent, content = this.content, container = this.container;
  options = this.options = options || {};
  style = this.style = style || {};
  var parentStyle = pick(style, [
    "width",
    "height",
    "maxWidth",
    "maxHeight",
    "minWidth",
    "minHeight",
    "left",
    "top",
    "backgroundColor",
    "position",
    "overflow",
    "border",
    "wordWrap",
    "textAlign",
    "outline",
    "transform"
  ]);
  assign(parent.style, {
    width: bounds.width + "px",
    height: bounds.height + "px",
    maxWidth: bounds.maxWidth + "px",
    maxHeight: bounds.maxHeight + "px",
    minWidth: bounds.minWidth + "px",
    minHeight: bounds.minHeight + "px",
    left: bounds.x + "px",
    top: bounds.y + "px",
    backgroundColor: "#ffffff",
    position: "absolute",
    overflow: "visible",
    border: "1px solid #ccc",
    boxSizing: "border-box",
    wordWrap: "normal",
    textAlign: "center",
    outline: "none"
  }, parentStyle);
  var contentStyle = pick(style, [
    "fontFamily",
    "fontSize",
    "fontWeight",
    "lineHeight",
    "padding",
    "paddingTop",
    "paddingRight",
    "paddingBottom",
    "paddingLeft"
  ]);
  assign(content.style, {
    boxSizing: "border-box",
    width: "100%",
    outline: "none",
    wordWrap: "break-word"
  }, contentStyle);
  if (options.centerVertically) {
    assign(content.style, {
      position: "absolute",
      top: "50%",
      transform: "translate(0, -50%)"
    }, contentStyle);
  }
  content.innerText = value;
  event.bind(content, "keydown", this.keyHandler);
  event.bind(content, "mousedown", stopPropagation2);
  event.bind(content, "paste", self2.handlePaste);
  if (options.autoResize) {
    event.bind(content, "input", this.autoResize);
  }
  if (options.resizable) {
    this.resizable(style);
  }
  container.appendChild(parent);
  this.setSelection(content.lastChild, content.lastChild && content.lastChild.length);
  return parent;
};
TextBox.prototype.handlePaste = function(e8) {
  var options = this.options, style = this.style;
  e8.preventDefault();
  var text;
  if (e8.clipboardData) {
    text = e8.clipboardData.getData("text/plain");
  } else {
    text = window.clipboardData.getData("Text");
  }
  this.insertText(text);
  if (options.autoResize) {
    var hasResized = this.autoResize(style);
    if (hasResized) {
      this.resizeHandler(hasResized);
    }
  }
};
TextBox.prototype.insertText = function(text) {
  text = normalizeEndOfLineSequences(text);
  var success = document.execCommand("insertText", false, text);
  if (success) {
    return;
  }
  this._insertTextIE(text);
};
TextBox.prototype._insertTextIE = function(text) {
  var range = this.getSelection(), startContainer = range.startContainer, endContainer = range.endContainer, startOffset = range.startOffset, endOffset = range.endOffset, commonAncestorContainer = range.commonAncestorContainer;
  var childNodesArray = toArray(commonAncestorContainer.childNodes);
  var container, offset;
  if (isTextNode(commonAncestorContainer)) {
    var containerTextContent = startContainer.textContent;
    startContainer.textContent = containerTextContent.substring(0, startOffset) + text + containerTextContent.substring(endOffset);
    container = startContainer;
    offset = startOffset + text.length;
  } else if (startContainer === this.content && endContainer === this.content) {
    var textNode = document.createTextNode(text);
    this.content.insertBefore(textNode, childNodesArray[startOffset]);
    container = textNode;
    offset = textNode.textContent.length;
  } else {
    var startContainerChildIndex = childNodesArray.indexOf(startContainer), endContainerChildIndex = childNodesArray.indexOf(endContainer);
    childNodesArray.forEach(function(childNode, index5) {
      if (index5 === startContainerChildIndex) {
        childNode.textContent = startContainer.textContent.substring(0, startOffset) + text + endContainer.textContent.substring(endOffset);
      } else if (index5 > startContainerChildIndex && index5 <= endContainerChildIndex) {
        remove2(childNode);
      }
    });
    container = startContainer;
    offset = startOffset + text.length;
  }
  if (container && offset !== void 0) {
    setTimeout(function() {
      self.setSelection(container, offset);
    });
  }
};
TextBox.prototype.autoResize = function() {
  var parent = this.parent, content = this.content;
  var fontSize = parseInt(this.style.fontSize) || 12;
  if (content.scrollHeight > parent.offsetHeight || content.scrollHeight < parent.offsetHeight - fontSize) {
    var bounds = parent.getBoundingClientRect();
    var height = content.scrollHeight;
    parent.style.height = height + "px";
    this.resizeHandler({
      width: bounds.width,
      height: bounds.height,
      dx: 0,
      dy: height - bounds.height
    });
  }
};
TextBox.prototype.resizable = function() {
  var self2 = this;
  var parent = this.parent, resizeHandle = this.resizeHandle;
  var minWidth = parseInt(this.style.minWidth) || 0, minHeight = parseInt(this.style.minHeight) || 0, maxWidth = parseInt(this.style.maxWidth) || Infinity, maxHeight = parseInt(this.style.maxHeight) || Infinity;
  if (!resizeHandle) {
    resizeHandle = this.resizeHandle = domify$1(
      '<div class="djs-direct-editing-resize-handle"></div>'
    );
    var startX, startY, startWidth, startHeight;
    var onMouseDown = function(e8) {
      preventDefault2(e8);
      stopPropagation2(e8);
      startX = e8.clientX;
      startY = e8.clientY;
      var bounds = parent.getBoundingClientRect();
      startWidth = bounds.width;
      startHeight = bounds.height;
      event.bind(document, "mousemove", onMouseMove);
      event.bind(document, "mouseup", onMouseUp);
    };
    var onMouseMove = function(e8) {
      preventDefault2(e8);
      stopPropagation2(e8);
      var newWidth = min4(max7(startWidth + e8.clientX - startX, minWidth), maxWidth);
      var newHeight = min4(max7(startHeight + e8.clientY - startY, minHeight), maxHeight);
      parent.style.width = newWidth + "px";
      parent.style.height = newHeight + "px";
      self2.resizeHandler({
        width: startWidth,
        height: startHeight,
        dx: e8.clientX - startX,
        dy: e8.clientY - startY
      });
    };
    var onMouseUp = function(e8) {
      preventDefault2(e8);
      stopPropagation2(e8);
      event.unbind(document, "mousemove", onMouseMove, false);
      event.unbind(document, "mouseup", onMouseUp, false);
    };
    event.bind(resizeHandle, "mousedown", onMouseDown);
  }
  assign(resizeHandle.style, {
    position: "absolute",
    bottom: "0px",
    right: "0px",
    cursor: "nwse-resize",
    width: "0",
    height: "0",
    borderTop: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent",
    borderRight: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderBottom: (parseInt(this.style.fontSize) / 4 || 3) + "px solid #ccc",
    borderLeft: (parseInt(this.style.fontSize) / 4 || 3) + "px solid transparent"
  });
  parent.appendChild(resizeHandle);
};
TextBox.prototype.destroy = function() {
  var parent = this.parent, content = this.content, resizeHandle = this.resizeHandle;
  content.innerText = "";
  parent.removeAttribute("style");
  content.removeAttribute("style");
  event.unbind(content, "keydown", this.keyHandler);
  event.unbind(content, "mousedown", stopPropagation2);
  event.unbind(content, "input", this.autoResize);
  event.unbind(content, "paste", this.handlePaste);
  if (resizeHandle) {
    resizeHandle.removeAttribute("style");
    remove2(resizeHandle);
  }
  remove2(parent);
};
TextBox.prototype.getValue = function() {
  return this.content.innerText.trim();
};
TextBox.prototype.getSelection = function() {
  var selection2 = window.getSelection(), range = selection2.getRangeAt(0);
  return range;
};
TextBox.prototype.setSelection = function(container, offset) {
  var range = document.createRange();
  if (container === null) {
    range.selectNodeContents(this.content);
  } else {
    range.setStart(container, offset);
    range.setEnd(container, offset);
  }
  var selection2 = window.getSelection();
  selection2.removeAllRanges();
  selection2.addRange(range);
};
function normalizeEndOfLineSequences(string) {
  return string.replace(/\r\n|\r|\n/g, "\n");
}

// node_modules/diagram-js-direct-editing/lib/DirectEditing.js
function DirectEditing(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._providers = [];
  this._textbox = new TextBox({
    container: canvas.getContainer(),
    keyHandler: bind(this._handleKey, this),
    resizeHandler: bind(this._handleResize, this)
  });
}
DirectEditing.$inject = ["eventBus", "canvas"];
DirectEditing.prototype.registerProvider = function(provider) {
  this._providers.push(provider);
};
DirectEditing.prototype.isActive = function(element) {
  return !!(this._active && (!element || this._active.element === element));
};
DirectEditing.prototype.cancel = function() {
  if (!this._active) {
    return;
  }
  this._fire("cancel");
  this.close();
};
DirectEditing.prototype._fire = function(event2, context) {
  this._eventBus.fire("directEditing." + event2, context || { active: this._active });
};
DirectEditing.prototype.close = function() {
  this._textbox.destroy();
  this._fire("deactivate");
  this._active = null;
  this.resizable = void 0;
  this._canvas.restoreFocus && this._canvas.restoreFocus();
};
DirectEditing.prototype.complete = function() {
  var active = this._active;
  if (!active) {
    return;
  }
  var containerBounds, previousBounds = active.context.bounds, newBounds = this.$textbox.getBoundingClientRect(), newText = this.getValue(), previousText = active.context.text;
  if (newText !== previousText || newBounds.height !== previousBounds.height || newBounds.width !== previousBounds.width) {
    containerBounds = this._textbox.container.getBoundingClientRect();
    active.provider.update(active.element, newText, active.context.text, {
      x: newBounds.left - containerBounds.left,
      y: newBounds.top - containerBounds.top,
      width: newBounds.width,
      height: newBounds.height
    });
  }
  this._fire("complete");
  this.close();
};
DirectEditing.prototype.getValue = function() {
  return this._textbox.getValue();
};
DirectEditing.prototype._handleKey = function(e8) {
  e8.stopPropagation();
  var key = e8.keyCode || e8.charCode;
  if (key === 27) {
    e8.preventDefault();
    return this.cancel();
  }
  if (key === 13 && !e8.shiftKey) {
    e8.preventDefault();
    return this.complete();
  }
};
DirectEditing.prototype._handleResize = function(event2) {
  this._fire("resize", event2);
};
DirectEditing.prototype.activate = function(element) {
  if (this.isActive()) {
    this.cancel();
  }
  var context;
  var provider = find(this._providers, function(p5) {
    return (context = p5.activate(element)) ? p5 : null;
  });
  if (context) {
    this.$textbox = this._textbox.create(
      context.bounds,
      context.style,
      context.text,
      context.options
    );
    this._active = {
      element,
      context,
      provider
    };
    if (context.options && context.options.resizable) {
      this.resizable = true;
    }
    this._fire("activate");
  }
  return !!context;
};

// node_modules/diagram-js-direct-editing/lib/index.js
var lib_default = {
  __depends__: [
    interaction_events_default
  ],
  __init__: ["directEditing"],
  directEditing: ["type", DirectEditing]
};

// node_modules/bpmn-js/lib/features/popup-menu/util/TypeUtil.js
function isDifferentType(element) {
  return function(entry) {
    var target = entry.target;
    var businessObject = getBusinessObject(element), eventDefinition = businessObject.eventDefinitions && businessObject.eventDefinitions[0];
    var isTypeEqual = businessObject.$type === target.type;
    var isEventDefinitionEqual = (eventDefinition && eventDefinition.$type) === target.eventDefinitionType;
    var isTriggeredByEventEqual = (
      // coherse to <false>
      !!target.triggeredByEvent === !!businessObject.triggeredByEvent
    );
    var isExpandedEqual = target.isExpanded === void 0 || target.isExpanded === isExpanded(element);
    return !isTypeEqual || !isEventDefinitionEqual || !isTriggeredByEventEqual || !isExpandedEqual;
  };
}

// node_modules/bpmn-js/lib/features/replace/ReplaceOptions.js
var START_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var START_EVENT_SUB_PROCESS = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throwing",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  }
];
var INTERMEDIATE_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message intermediate catch event",
    actionName: "replace-with-message-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Message intermediate throw event",
    actionName: "replace-with-message-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-message",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Timer intermediate catch event",
    actionName: "replace-with-timer-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition"
    }
  },
  {
    label: "Escalation intermediate throw event",
    actionName: "replace-with-escalation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-escalation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Conditional intermediate catch event",
    actionName: "replace-with-conditional-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition"
    }
  },
  {
    label: "Link intermediate catch event",
    actionName: "replace-with-link-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-link",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Link intermediate throw event",
    actionName: "replace-with-link-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-link",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:LinkEventDefinition",
      eventDefinitionAttrs: {
        name: ""
      }
    }
  },
  {
    label: "Compensation intermediate throw event",
    actionName: "replace-with-compensation-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-compensation",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal intermediate catch event",
    actionName: "replace-with-signal-intermediate-catch",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:IntermediateCatchEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Signal intermediate throw event",
    actionName: "replace-with-signal-intermediate-throw",
    className: "bpmn-icon-intermediate-event-throw-signal",
    target: {
      type: "bpmn:IntermediateThrowEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  }
];
var END_EVENT = [
  {
    label: "Start event",
    actionName: "replace-with-none-start",
    className: "bpmn-icon-start-event-none",
    target: {
      type: "bpmn:StartEvent"
    }
  },
  {
    label: "Intermediate throw event",
    actionName: "replace-with-none-intermediate-throw",
    className: "bpmn-icon-intermediate-event-none",
    target: {
      type: "bpmn:IntermediateThrowEvent"
    }
  },
  {
    label: "End event",
    actionName: "replace-with-none-end",
    className: "bpmn-icon-end-event-none",
    target: {
      type: "bpmn:EndEvent"
    }
  },
  {
    label: "Message end event",
    actionName: "replace-with-message-end",
    className: "bpmn-icon-end-event-message",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition"
    }
  },
  {
    label: "Escalation end event",
    actionName: "replace-with-escalation-end",
    className: "bpmn-icon-end-event-escalation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition"
    }
  },
  {
    label: "Error end event",
    actionName: "replace-with-error-end",
    className: "bpmn-icon-end-event-error",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition"
    }
  },
  {
    label: "Cancel end event",
    actionName: "replace-with-cancel-end",
    className: "bpmn-icon-end-event-cancel",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition"
    }
  },
  {
    label: "Compensation end event",
    actionName: "replace-with-compensation-end",
    className: "bpmn-icon-end-event-compensation",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition"
    }
  },
  {
    label: "Signal end event",
    actionName: "replace-with-signal-end",
    className: "bpmn-icon-end-event-signal",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition"
    }
  },
  {
    label: "Terminate end event",
    actionName: "replace-with-terminate-end",
    className: "bpmn-icon-end-event-terminate",
    target: {
      type: "bpmn:EndEvent",
      eventDefinitionType: "bpmn:TerminateEventDefinition"
    }
  }
];
var GATEWAY = [
  {
    label: "Exclusive gateway",
    actionName: "replace-with-exclusive-gateway",
    className: "bpmn-icon-gateway-xor",
    target: {
      type: "bpmn:ExclusiveGateway"
    }
  },
  {
    label: "Parallel gateway",
    actionName: "replace-with-parallel-gateway",
    className: "bpmn-icon-gateway-parallel",
    target: {
      type: "bpmn:ParallelGateway"
    }
  },
  {
    label: "Inclusive gateway",
    actionName: "replace-with-inclusive-gateway",
    className: "bpmn-icon-gateway-or",
    target: {
      type: "bpmn:InclusiveGateway"
    }
  },
  {
    label: "Complex gateway",
    actionName: "replace-with-complex-gateway",
    className: "bpmn-icon-gateway-complex",
    target: {
      type: "bpmn:ComplexGateway"
    }
  },
  {
    label: "Event-based gateway",
    actionName: "replace-with-event-based-gateway",
    className: "bpmn-icon-gateway-eventbased",
    target: {
      type: "bpmn:EventBasedGateway",
      instantiate: false,
      eventGatewayType: "Exclusive"
    }
  }
  // Gateways deactivated until https://github.com/bpmn-io/bpmn-js/issues/194
  // {
  //   label: 'Event based instantiating Gateway',
  //   actionName: 'replace-with-exclusive-event-based-gateway',
  //   className: 'bpmn-icon-exclusive-event-based',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Exclusive' }
  //   }
  // },
  // {
  //   label: 'Parallel Event based instantiating Gateway',
  //   actionName: 'replace-with-parallel-event-based-instantiate-gateway',
  //   className: 'bpmn-icon-parallel-event-based-instantiate-gateway',
  //   target: {
  //     type: 'bpmn:EventBasedGateway'
  //   },
  //   options: {
  //     businessObject: { instantiate: true, eventGatewayType: 'Parallel' }
  //   }
  // }
];
var SUBPROCESS_EXPANDED = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  }
];
var AD_HOC_SUBPROCESS_EXPANDED = [
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    actionName: "replace-with-collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  }
];
var TRANSACTION = [
  {
    label: "Transaction",
    actionName: "replace-with-transaction",
    className: "bpmn-icon-transaction",
    target: {
      type: "bpmn:Transaction",
      isExpanded: true
    }
  },
  {
    label: "Sub-process",
    actionName: "replace-with-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  },
  {
    label: "Event sub-process",
    actionName: "replace-with-event-subprocess",
    className: "bpmn-icon-event-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      triggeredByEvent: true,
      isExpanded: true
    }
  }
];
var EVENT_SUB_PROCESS = TRANSACTION;
var TASK = [
  {
    label: "Task",
    actionName: "replace-with-task",
    className: "bpmn-icon-task",
    target: {
      type: "bpmn:Task"
    }
  },
  {
    label: "User task",
    actionName: "replace-with-user-task",
    className: "bpmn-icon-user",
    target: {
      type: "bpmn:UserTask"
    }
  },
  {
    label: "Service task",
    actionName: "replace-with-service-task",
    className: "bpmn-icon-service",
    target: {
      type: "bpmn:ServiceTask"
    }
  },
  {
    label: "Send task",
    actionName: "replace-with-send-task",
    className: "bpmn-icon-send",
    target: {
      type: "bpmn:SendTask"
    }
  },
  {
    label: "Receive task",
    actionName: "replace-with-receive-task",
    className: "bpmn-icon-receive",
    target: {
      type: "bpmn:ReceiveTask"
    }
  },
  {
    label: "Manual task",
    actionName: "replace-with-manual-task",
    className: "bpmn-icon-manual",
    target: {
      type: "bpmn:ManualTask"
    }
  },
  {
    label: "Business rule task",
    actionName: "replace-with-rule-task",
    className: "bpmn-icon-business-rule",
    target: {
      type: "bpmn:BusinessRuleTask"
    }
  },
  {
    label: "Script task",
    actionName: "replace-with-script-task",
    className: "bpmn-icon-script",
    target: {
      type: "bpmn:ScriptTask"
    }
  },
  {
    label: "Call activity",
    actionName: "replace-with-call-activity",
    className: "bpmn-icon-call-activity",
    target: {
      type: "bpmn:CallActivity"
    }
  },
  {
    label: "Sub-process (collapsed)",
    actionName: "replace-with-collapsed-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: false
    }
  },
  {
    label: "Sub-process (expanded)",
    actionName: "replace-with-expanded-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:SubProcess",
      isExpanded: true
    }
  },
  {
    label: "Ad-hoc sub-process (collapsed)",
    actionName: "replace-with-collapsed-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-collapsed",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: false
    }
  },
  {
    label: "Ad-hoc sub-process (expanded)",
    actionName: "replace-with-ad-hoc-subprocess",
    className: "bpmn-icon-subprocess-expanded",
    target: {
      type: "bpmn:AdHocSubProcess",
      isExpanded: true
    }
  }
];
var DATA_OBJECT_REFERENCE = [
  {
    label: "Data store reference",
    actionName: "replace-with-data-store-reference",
    className: "bpmn-icon-data-store",
    target: {
      type: "bpmn:DataStoreReference"
    }
  }
];
var DATA_STORE_REFERENCE = [
  {
    label: "Data object reference",
    actionName: "replace-with-data-object-reference",
    className: "bpmn-icon-data-object",
    target: {
      type: "bpmn:DataObjectReference"
    }
  }
];
var BOUNDARY_EVENT = [
  {
    label: "Message boundary event",
    actionName: "replace-with-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Timer boundary event",
    actionName: "replace-with-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Escalation boundary event",
    actionName: "replace-with-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Conditional boundary event",
    actionName: "replace-with-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Error boundary event",
    actionName: "replace-with-error-boundary",
    className: "bpmn-icon-intermediate-event-catch-error",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Cancel boundary event",
    actionName: "replace-with-cancel-boundary",
    className: "bpmn-icon-intermediate-event-catch-cancel",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CancelEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Signal boundary event",
    actionName: "replace-with-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Compensation boundary event",
    actionName: "replace-with-compensation-boundary",
    className: "bpmn-icon-intermediate-event-catch-compensation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      cancelActivity: true
    }
  },
  {
    label: "Message boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-message",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Timer boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-timer",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Escalation boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-escalation",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Conditional boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-condition",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      cancelActivity: false
    }
  },
  {
    label: "Signal boundary event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-boundary",
    className: "bpmn-icon-intermediate-event-catch-non-interrupting-signal",
    target: {
      type: "bpmn:BoundaryEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      cancelActivity: false
    }
  }
];
var EVENT_SUB_PROCESS_START_EVENT = [
  {
    label: "Message start event",
    actionName: "replace-with-message-start",
    className: "bpmn-icon-start-event-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Timer start event",
    actionName: "replace-with-timer-start",
    className: "bpmn-icon-start-event-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Conditional start event",
    actionName: "replace-with-conditional-start",
    className: "bpmn-icon-start-event-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Signal start event",
    actionName: "replace-with-signal-start",
    className: "bpmn-icon-start-event-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Error start event",
    actionName: "replace-with-error-start",
    className: "bpmn-icon-start-event-error",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ErrorEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Escalation start event",
    actionName: "replace-with-escalation-start",
    className: "bpmn-icon-start-event-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Compensation start event",
    actionName: "replace-with-compensation-start",
    className: "bpmn-icon-start-event-compensation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:CompensateEventDefinition",
      isInterrupting: true
    }
  },
  {
    label: "Message start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-message-start",
    className: "bpmn-icon-start-event-non-interrupting-message",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:MessageEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Timer start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-timer-start",
    className: "bpmn-icon-start-event-non-interrupting-timer",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:TimerEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Conditional start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-conditional-start",
    className: "bpmn-icon-start-event-non-interrupting-condition",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:ConditionalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Signal start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-signal-start",
    className: "bpmn-icon-start-event-non-interrupting-signal",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:SignalEventDefinition",
      isInterrupting: false
    }
  },
  {
    label: "Escalation start event (non-interrupting)",
    actionName: "replace-with-non-interrupting-escalation-start",
    className: "bpmn-icon-start-event-non-interrupting-escalation",
    target: {
      type: "bpmn:StartEvent",
      eventDefinitionType: "bpmn:EscalationEventDefinition",
      isInterrupting: false
    }
  }
];
var SEQUENCE_FLOW = [
  {
    label: "Sequence flow",
    actionName: "replace-with-sequence-flow",
    className: "bpmn-icon-connection"
  },
  {
    label: "Default flow",
    actionName: "replace-with-default-flow",
    className: "bpmn-icon-default-flow"
  },
  {
    label: "Conditional flow",
    actionName: "replace-with-conditional-flow",
    className: "bpmn-icon-conditional-flow"
  }
];
var PARTICIPANT = [
  {
    label: "Expanded pool/participant",
    actionName: "replace-with-expanded-pool",
    className: "bpmn-icon-participant",
    target: {
      type: "bpmn:Participant",
      isExpanded: true
    }
  },
  {
    label: function(element) {
      var label = "Empty pool/participant";
      if (element.children && element.children.length) {
        label += " (removes content)";
      }
      return label;
    },
    actionName: "replace-with-collapsed-pool",
    // TODO(@janstuemmel): maybe design new icon
    className: "bpmn-icon-lane",
    target: {
      type: "bpmn:Participant",
      isExpanded: false
    }
  }
];
var TYPED_EVENT = {
  "bpmn:MessageEventDefinition": [
    {
      label: "Message start event",
      actionName: "replace-with-message-start",
      className: "bpmn-icon-start-event-message",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    },
    {
      label: "Message intermediate catch event",
      actionName: "replace-with-message-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-message",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    },
    {
      label: "Message intermediate throw event",
      actionName: "replace-with-message-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-message",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    },
    {
      label: "Message end event",
      actionName: "replace-with-message-end",
      className: "bpmn-icon-end-event-message",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:MessageEventDefinition"
      }
    }
  ],
  "bpmn:TimerEventDefinition": [
    {
      label: "Timer start event",
      actionName: "replace-with-timer-start",
      className: "bpmn-icon-start-event-timer",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:TimerEventDefinition"
      }
    },
    {
      label: "Timer intermediate catch event",
      actionName: "replace-with-timer-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-timer",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:TimerEventDefinition"
      }
    }
  ],
  "bpmn:ConditionalEventDefinition": [
    {
      label: "Conditional start event",
      actionName: "replace-with-conditional-start",
      className: "bpmn-icon-start-event-condition",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:ConditionalEventDefinition"
      }
    },
    {
      label: "Conditional intermediate catch event",
      actionName: "replace-with-conditional-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-condition",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:ConditionalEventDefinition"
      }
    }
  ],
  "bpmn:SignalEventDefinition": [
    {
      label: "Signal start event",
      actionName: "replace-with-signal-start",
      className: "bpmn-icon-start-event-signal",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    },
    {
      label: "Signal intermediate catch event",
      actionName: "replace-with-signal-intermediate-catch",
      className: "bpmn-icon-intermediate-event-catch-signal",
      target: {
        type: "bpmn:IntermediateCatchEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    },
    {
      label: "Signal intermediate throw event",
      actionName: "replace-with-signal-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-signal",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    },
    {
      label: "Signal end event",
      actionName: "replace-with-signal-end",
      className: "bpmn-icon-end-event-signal",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:SignalEventDefinition"
      }
    }
  ],
  "bpmn:ErrorEventDefinition": [
    {
      label: "Error start event",
      actionName: "replace-with-error-start",
      className: "bpmn-icon-start-event-error",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:ErrorEventDefinition"
      }
    },
    {
      label: "Error end event",
      actionName: "replace-with-error-end",
      className: "bpmn-icon-end-event-error",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:ErrorEventDefinition"
      }
    }
  ],
  "bpmn:EscalationEventDefinition": [
    {
      label: "Escalation start event",
      actionName: "replace-with-escalation-start",
      className: "bpmn-icon-start-event-escalation",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:EscalationEventDefinition"
      }
    },
    {
      label: "Escalation intermediate throw event",
      actionName: "replace-with-escalation-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-escalation",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:EscalationEventDefinition"
      }
    },
    {
      label: "Escalation end event",
      actionName: "replace-with-escalation-end",
      className: "bpmn-icon-end-event-escalation",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:EscalationEventDefinition"
      }
    }
  ],
  "bpmn:CompensateEventDefinition": [
    {
      label: "Compensation start event",
      actionName: "replace-with-compensation-start",
      className: "bpmn-icon-start-event-compensation",
      target: {
        type: "bpmn:StartEvent",
        eventDefinitionType: "bpmn:CompensateEventDefinition"
      }
    },
    {
      label: "Compensation intermediate throw event",
      actionName: "replace-with-compensation-intermediate-throw",
      className: "bpmn-icon-intermediate-event-throw-compensation",
      target: {
        type: "bpmn:IntermediateThrowEvent",
        eventDefinitionType: "bpmn:CompensateEventDefinition"
      }
    },
    {
      label: "Compensation end event",
      actionName: "replace-with-compensation-end",
      className: "bpmn-icon-end-event-compensation",
      target: {
        type: "bpmn:EndEvent",
        eventDefinitionType: "bpmn:CompensateEventDefinition"
      }
    }
  ]
};

// node_modules/bpmn-js/lib/features/popup-menu/util/Icons.js
var Icons_default = {
  "start-event-non-interrupting": `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
    <g transform="translate(0 995.64)">
      <path d="m1899 28.357c21.545 567.43-598.38 1023.5-1133.6 835.92-548.09-147.21-801.57-873.95-463.59-1330 302.62-480.3 1071.7-507.54 1407.6-49.847 122.14 153.12 190.07 348.07 189.59 543.91z" fill="none" stroke="currentColor" stroke-dasharray="418.310422, 361.2328165" stroke-linecap="round" stroke-width="100"/>
    </g>
  </svg>`,
  "intermediate-event-non-interrupting": `
  <svg viewBox="0 0 2048 2048" xmlns="http://www.w3.org/2000/svg">
     <g transform="translate(0 995.64)" fill="none" stroke="currentColor" stroke-linecap="round">
        <circle cx="1024" cy="28.357" r="875" stroke-dasharray="418.310422, 361.2328165" stroke-width="100"/>
        <circle cx="1024" cy="28.357" r="685" stroke-dasharray="348.31044857,261.23283643" stroke-dashoffset="500" stroke-width="100"/>
     </g>
  </svg>`
};

// node_modules/bpmn-js/lib/features/popup-menu/ReplaceMenuProvider.js
function ReplaceMenuProvider(bpmnFactory, popupMenu, modeling, moddle, bpmnReplace, rules, translate4, moddleCopy) {
  this._bpmnFactory = bpmnFactory;
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._moddle = moddle;
  this._bpmnReplace = bpmnReplace;
  this._rules = rules;
  this._translate = translate4;
  this._moddleCopy = moddleCopy;
  this._register();
}
ReplaceMenuProvider.$inject = [
  "bpmnFactory",
  "popupMenu",
  "modeling",
  "moddle",
  "bpmnReplace",
  "rules",
  "translate",
  "moddleCopy"
];
ReplaceMenuProvider.prototype._register = function() {
  this._popupMenu.registerProvider("bpmn-replace", this);
};
ReplaceMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var _a;
  var businessObject = target.businessObject;
  var rules = this._rules;
  var sameTypeEventOptions = [], eventDefinitionType;
  var filteredReplaceOptions = [];
  if (isArray(target) || !rules.allowed("shape.replace", { element: target })) {
    return {};
  }
  var differentType = isDifferentType(target);
  if (is(businessObject, "bpmn:DataObjectReference")) {
    return this._createEntries(target, DATA_OBJECT_REFERENCE);
  }
  if (is(businessObject, "bpmn:DataStoreReference") && !is(target.parent, "bpmn:Collaboration")) {
    return this._createEntries(target, DATA_STORE_REFERENCE);
  }
  if (is(businessObject, "bpmn:Event") && !is(businessObject, "bpmn:BoundaryEvent")) {
    eventDefinitionType = (_a = businessObject.get("eventDefinitions")[0]) == null ? void 0 : _a.$type;
    sameTypeEventOptions = TYPED_EVENT[eventDefinitionType] || [];
    if (!isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, "bpmn:SubProcess")) {
      sameTypeEventOptions = filter(sameTypeEventOptions, function(option) {
        return option.target.type !== "bpmn:StartEvent";
      });
    }
  }
  if (is(businessObject, "bpmn:StartEvent") && !is(businessObject.$parent, "bpmn:SubProcess")) {
    filteredReplaceOptions = filter(
      START_EVENT.concat(sameTypeEventOptions),
      differentType
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:Participant")) {
    filteredReplaceOptions = filter(PARTICIPANT, function(replaceOption) {
      return isExpanded(target) !== replaceOption.target.isExpanded;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:StartEvent") && isEventSubProcess(businessObject.$parent)) {
    filteredReplaceOptions = filter(
      EVENT_SUB_PROCESS_START_EVENT.concat(sameTypeEventOptions),
      function(replaceOption) {
        var target2 = replaceOption.target;
        var isInterrupting4 = target2.isInterrupting !== false;
        var isInterruptingEqual = businessObject.isInterrupting === isInterrupting4;
        return differentType(replaceOption) || !differentType(replaceOption) && !isInterruptingEqual;
      }
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:StartEvent") && !isEventSubProcess(businessObject.$parent) && is(businessObject.$parent, "bpmn:SubProcess")) {
    filteredReplaceOptions = filter(
      START_EVENT_SUB_PROCESS.concat(sameTypeEventOptions),
      differentType
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:EndEvent")) {
    filteredReplaceOptions = filter(END_EVENT.concat(sameTypeEventOptions), function(replaceOption) {
      var target2 = replaceOption.target;
      if (target2.eventDefinitionType == "bpmn:CancelEventDefinition" && !is(businessObject.$parent, "bpmn:Transaction")) {
        return false;
      }
      return differentType(replaceOption);
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:BoundaryEvent")) {
    filteredReplaceOptions = filter(BOUNDARY_EVENT, function(replaceOption) {
      var target2 = replaceOption.target;
      if (target2.eventDefinitionType == "bpmn:CancelEventDefinition" && !is(businessObject.attachedToRef, "bpmn:Transaction")) {
        return false;
      }
      var cancelActivity = target2.cancelActivity !== false;
      var isCancelActivityEqual = businessObject.cancelActivity == cancelActivity;
      return differentType(replaceOption) || !differentType(replaceOption) && !isCancelActivityEqual;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:IntermediateCatchEvent") || is(businessObject, "bpmn:IntermediateThrowEvent")) {
    filteredReplaceOptions = filter(
      INTERMEDIATE_EVENT.concat(sameTypeEventOptions),
      differentType
    );
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:Gateway")) {
    filteredReplaceOptions = filter(GATEWAY, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:Transaction")) {
    filteredReplaceOptions = filter(TRANSACTION, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (isEventSubProcess(businessObject) && isExpanded(target)) {
    filteredReplaceOptions = filter(EVENT_SUB_PROCESS, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:AdHocSubProcess") && isExpanded(target)) {
    filteredReplaceOptions = filter(AD_HOC_SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:SubProcess") && isExpanded(target)) {
    filteredReplaceOptions = filter(SUBPROCESS_EXPANDED, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:SubProcess") && !isExpanded(target)) {
    filteredReplaceOptions = filter(TASK, function(replaceOption) {
      var isTargetSameType = replaceOption.target.type === target.type;
      var isTargetExpanded = replaceOption.target.isExpanded === true;
      return isTargetSameType === isTargetExpanded;
    });
    return this._createEntries(target, filteredReplaceOptions);
  }
  if (is(businessObject, "bpmn:SequenceFlow")) {
    return this._createSequenceFlowEntries(target, SEQUENCE_FLOW);
  }
  if (is(businessObject, "bpmn:FlowNode")) {
    filteredReplaceOptions = filter(TASK, differentType);
    return this._createEntries(target, filteredReplaceOptions);
  }
  return {};
};
ReplaceMenuProvider.prototype.getPopupMenuHeaderEntries = function(target) {
  var headerEntries = {};
  if (is(target, "bpmn:Activity") && !isEventSubProcess(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getLoopCharacteristicsHeaderEntries(target)
    };
  }
  if (is(target, "bpmn:DataObjectReference")) {
    headerEntries = {
      ...headerEntries,
      ...this._getCollectionHeaderEntries(target)
    };
  }
  if (is(target, "bpmn:Participant")) {
    headerEntries = {
      ...headerEntries,
      ...this._getParticipantMultiplicityHeaderEntries(target)
    };
  }
  if (canBeNonInterrupting(target)) {
    headerEntries = {
      ...headerEntries,
      ...this._getNonInterruptingHeaderEntries(target)
    };
  }
  return headerEntries;
};
ReplaceMenuProvider.prototype._createEntries = function(target, replaceOptions) {
  var entries = {};
  var self2 = this;
  forEach(replaceOptions, function(replaceOption) {
    entries[replaceOption.actionName] = self2._createEntry(replaceOption, target);
  });
  return entries;
};
ReplaceMenuProvider.prototype._createSequenceFlowEntries = function(target, replaceOptions) {
  var businessObject = getBusinessObject(target);
  var entries = {};
  var modeling = this._modeling, moddle = this._moddle;
  var self2 = this;
  forEach(replaceOptions, function(replaceOption) {
    switch (replaceOption.actionName) {
      case "replace-with-default-flow":
        if (businessObject.sourceRef.default !== businessObject && (is(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is(businessObject.sourceRef, "bpmn:InclusiveGateway") || is(businessObject.sourceRef, "bpmn:ComplexGateway") || is(businessObject.sourceRef, "bpmn:Activity"))) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target.source, { default: businessObject });
            })
          };
        }
        break;
      case "replace-with-conditional-flow":
        if (!businessObject.conditionExpression && is(businessObject.sourceRef, "bpmn:Activity")) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              var conditionExpression = moddle.create("bpmn:FormalExpression", { body: "" });
              modeling.updateProperties(target, { conditionExpression });
            })
          };
        }
        break;
      default:
        if (is(businessObject.sourceRef, "bpmn:Activity") && businessObject.conditionExpression) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target, { conditionExpression: void 0 });
            })
          };
        }
        if ((is(businessObject.sourceRef, "bpmn:ExclusiveGateway") || is(businessObject.sourceRef, "bpmn:InclusiveGateway") || is(businessObject.sourceRef, "bpmn:ComplexGateway") || is(businessObject.sourceRef, "bpmn:Activity")) && businessObject.sourceRef.default === businessObject) {
          entries = {
            ...entries,
            [replaceOption.actionName]: self2._createEntry(replaceOption, target, function() {
              modeling.updateProperties(target.source, { default: void 0 });
            })
          };
        }
    }
  });
  return entries;
};
ReplaceMenuProvider.prototype._createEntry = function(replaceOption, target, action) {
  var translate4 = this._translate;
  var replaceElement = this._bpmnReplace.replaceElement;
  var replaceAction = function() {
    return replaceElement(target, replaceOption.target);
  };
  var label = replaceOption.label;
  if (label && typeof label === "function") {
    label = label(target);
  }
  action = action || replaceAction;
  return {
    label: translate4(label),
    className: replaceOption.className,
    action
  };
};
ReplaceMenuProvider.prototype._getLoopCharacteristicsHeaderEntries = function(target) {
  var self2 = this;
  var translate4 = this._translate;
  function toggleLoopCharacteristics(event2, entry) {
    if (entry.active) {
      self2._modeling.updateProperties(target, { loopCharacteristics: void 0 });
      return;
    }
    var loopCharacteristics2 = target.businessObject.get("loopCharacteristics");
    if (loopCharacteristics2 && is(loopCharacteristics2, entry.options.loopCharacteristics)) {
      self2._modeling.updateModdleProperties(target, loopCharacteristics2, { isSequential: entry.options.isSequential });
    } else {
      loopCharacteristics2 = self2._moddle.create(entry.options.loopCharacteristics, {
        isSequential: entry.options.isSequential
      });
      self2._modeling.updateProperties(target, { loopCharacteristics: loopCharacteristics2 });
    }
  }
  var businessObject = getBusinessObject(target), loopCharacteristics = businessObject.loopCharacteristics;
  var isSequential, isLoop, isParallel;
  if (loopCharacteristics) {
    isSequential = loopCharacteristics.isSequential;
    isLoop = loopCharacteristics.isSequential === void 0;
    isParallel = loopCharacteristics.isSequential !== void 0 && !loopCharacteristics.isSequential;
  }
  return {
    "toggle-parallel-mi": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate4("Parallel multi-instance"),
      active: isParallel,
      action: toggleLoopCharacteristics,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: false
      }
    },
    "toggle-sequential-mi": {
      className: "bpmn-icon-sequential-mi-marker",
      title: translate4("Sequential multi-instance"),
      active: isSequential,
      action: toggleLoopCharacteristics,
      options: {
        loopCharacteristics: "bpmn:MultiInstanceLoopCharacteristics",
        isSequential: true
      }
    },
    "toggle-loop": {
      className: "bpmn-icon-loop-marker",
      title: translate4("Loop"),
      active: isLoop,
      action: toggleLoopCharacteristics,
      options: {
        loopCharacteristics: "bpmn:StandardLoopCharacteristics"
      }
    }
  };
};
ReplaceMenuProvider.prototype._getCollectionHeaderEntries = function(target) {
  var self2 = this;
  var translate4 = this._translate;
  var dataObject = target.businessObject.dataObjectRef;
  if (!dataObject) {
    return {};
  }
  function toggleIsCollection(event2, entry) {
    self2._modeling.updateModdleProperties(
      target,
      dataObject,
      { isCollection: !entry.active }
    );
  }
  var isCollection3 = dataObject.isCollection;
  return {
    "toggle-is-collection": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate4("Collection"),
      active: isCollection3,
      action: toggleIsCollection
    }
  };
};
ReplaceMenuProvider.prototype._getParticipantMultiplicityHeaderEntries = function(target) {
  var self2 = this;
  var bpmnFactory = this._bpmnFactory;
  var translate4 = this._translate;
  function toggleParticipantMultiplicity(event2, entry) {
    var isActive = entry.active;
    var participantMultiplicity2;
    if (!isActive) {
      participantMultiplicity2 = bpmnFactory.create("bpmn:ParticipantMultiplicity");
    }
    self2._modeling.updateProperties(
      target,
      { participantMultiplicity: participantMultiplicity2 }
    );
  }
  var participantMultiplicity = target.businessObject.participantMultiplicity;
  return {
    "toggle-participant-multiplicity": {
      className: "bpmn-icon-parallel-mi-marker",
      title: translate4("Participant multiplicity"),
      active: !!participantMultiplicity,
      action: toggleParticipantMultiplicity
    }
  };
};
ReplaceMenuProvider.prototype._getNonInterruptingHeaderEntries = function(element) {
  const translate4 = this._translate;
  const businessObject = getBusinessObject(element);
  const self2 = this;
  const interruptingProperty = getInterruptingProperty(element);
  const icon = is(element, "bpmn:BoundaryEvent") ? Icons_default["intermediate-event-non-interrupting"] : Icons_default["start-event-non-interrupting"];
  const isNonInterrupting = !businessObject[interruptingProperty];
  return {
    "toggle-non-interrupting": {
      imageHtml: icon,
      title: translate4("Toggle non-interrupting"),
      active: isNonInterrupting,
      action: function() {
        self2._modeling.updateProperties(element, {
          [interruptingProperty]: !!isNonInterrupting
        });
      }
    }
  };
};

// node_modules/bpmn-js/lib/features/popup-menu/index.js
var popup_menu_default2 = {
  __depends__: [
    popup_menu_default,
    replace_default2,
    auto_place_default2
  ],
  __init__: [
    "replaceMenuProvider"
  ],
  replaceMenuProvider: ["type", ReplaceMenuProvider]
};

// node_modules/bpmn-js/lib/features/context-pad/ContextPadProvider.js
function ContextPadProvider(config, injector, eventBus, contextPad, modeling, elementFactory, connect, create3, popupMenu, canvas, rules, translate4, appendPreview) {
  config = config || {};
  contextPad.registerProvider(this);
  this._contextPad = contextPad;
  this._modeling = modeling;
  this._elementFactory = elementFactory;
  this._connect = connect;
  this._create = create3;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._rules = rules;
  this._translate = translate4;
  this._eventBus = eventBus;
  this._appendPreview = appendPreview;
  if (config.autoPlace !== false) {
    this._autoPlace = injector.get("autoPlace", false);
  }
  eventBus.on("create.end", 250, function(event2) {
    var context = event2.context, shape = context.shape;
    if (!hasPrimaryModifier(event2) || !contextPad.isOpen(shape)) {
      return;
    }
    var entries = contextPad.getEntries(shape);
    if (entries.replace) {
      entries.replace.action.click(event2, shape);
    }
  });
  eventBus.on("contextPad.close", function() {
    appendPreview.cleanUp();
  });
}
ContextPadProvider.$inject = [
  "config.contextPad",
  "injector",
  "eventBus",
  "contextPad",
  "modeling",
  "elementFactory",
  "connect",
  "create",
  "popupMenu",
  "canvas",
  "rules",
  "translate",
  "appendPreview"
];
ContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  var modeling = this._modeling;
  var actions = {};
  if (this._isDeleteAllowed(elements)) {
    assign(actions, {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: this._translate("Delete"),
        action: {
          click: function(event2, elements2) {
            modeling.removeElements(elements2.slice());
          }
        }
      }
    });
  }
  return actions;
};
ContextPadProvider.prototype._isDeleteAllowed = function(elements) {
  var baseAllowed = this._rules.allowed("elements.delete", {
    elements
  });
  if (isArray(baseAllowed)) {
    return every(elements, (el) => baseAllowed.includes(el));
  }
  return baseAllowed;
};
ContextPadProvider.prototype.getContextPadEntries = function(element) {
  var contextPad = this._contextPad, modeling = this._modeling, elementFactory = this._elementFactory, connect = this._connect, create3 = this._create, popupMenu = this._popupMenu, autoPlace = this._autoPlace, translate4 = this._translate, appendPreview = this._appendPreview;
  var actions = {};
  if (element.type === "label") {
    if (this._isDeleteAllowed([element])) {
      assign(actions, deleteAction());
    }
    return actions;
  }
  var businessObject = element.businessObject;
  function startConnect(event2, element2) {
    connect.start(event2, element2);
  }
  function removeElement2(e8, element2) {
    modeling.removeElements([element2]);
  }
  function deleteAction() {
    return {
      "delete": {
        group: "edit",
        className: "bpmn-icon-trash",
        title: translate4("Delete"),
        action: {
          click: removeElement2
        }
      }
    };
  }
  function getReplaceMenuPosition(element2) {
    var Y_OFFSET = 5;
    var pad = contextPad.getPad(element2).html;
    var padRect = pad.getBoundingClientRect();
    var pos = {
      x: padRect.left,
      y: padRect.bottom + Y_OFFSET
    };
    return pos;
  }
  function appendAction(type, className, title, options) {
    function appendStart(event2, element2) {
      var shape = elementFactory.createShape(assign({ type }, options));
      create3.start(event2, shape, {
        source: element2
      });
    }
    var append2 = autoPlace ? function(_5, element2) {
      var shape = elementFactory.createShape(assign({ type }, options));
      autoPlace.append(element2, shape);
    } : appendStart;
    var previewAppend = autoPlace ? function(_5, element2) {
      appendPreview.create(element2, type, options);
      return () => {
        appendPreview.cleanUp();
      };
    } : null;
    return {
      group: "model",
      className,
      title,
      action: {
        dragstart: appendStart,
        click: append2,
        hover: previewAppend
      }
    };
  }
  function splitLaneHandler(count) {
    return function(_5, element2) {
      modeling.splitLane(element2, count);
      contextPad.open(element2, true);
    };
  }
  if (isAny(businessObject, ["bpmn:Lane", "bpmn:Participant"]) && isExpanded(element)) {
    var childLanes = getChildLanes(element);
    assign(actions, {
      "lane-insert-above": {
        group: "lane-insert-above",
        className: "bpmn-icon-lane-insert-above",
        title: translate4("Add lane above"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "top");
          }
        }
      }
    });
    if (childLanes.length < 2) {
      if (isHorizontal(element) ? element.height >= 120 : element.width >= 120) {
        assign(actions, {
          "lane-divide-two": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-two",
            title: translate4("Divide into two lanes"),
            action: {
              click: splitLaneHandler(2)
            }
          }
        });
      }
      if (isHorizontal(element) ? element.height >= 180 : element.width >= 180) {
        assign(actions, {
          "lane-divide-three": {
            group: "lane-divide",
            className: "bpmn-icon-lane-divide-three",
            title: translate4("Divide into three lanes"),
            action: {
              click: splitLaneHandler(3)
            }
          }
        });
      }
    }
    assign(actions, {
      "lane-insert-below": {
        group: "lane-insert-below",
        className: "bpmn-icon-lane-insert-below",
        title: translate4("Add lane below"),
        action: {
          click: function(event2, element2) {
            modeling.addLane(element2, "bottom");
          }
        }
      }
    });
  }
  if (is(businessObject, "bpmn:FlowNode")) {
    if (is(businessObject, "bpmn:EventBasedGateway")) {
      assign(actions, {
        "append.receive-task": appendAction(
          "bpmn:ReceiveTask",
          "bpmn-icon-receive-task",
          translate4("Append receive task")
        ),
        "append.message-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-message",
          translate4("Append message intermediate catch event"),
          { eventDefinitionType: "bpmn:MessageEventDefinition" }
        ),
        "append.timer-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-timer",
          translate4("Append timer intermediate catch event"),
          { eventDefinitionType: "bpmn:TimerEventDefinition" }
        ),
        "append.condition-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-condition",
          translate4("Append conditional intermediate catch event"),
          { eventDefinitionType: "bpmn:ConditionalEventDefinition" }
        ),
        "append.signal-intermediate-event": appendAction(
          "bpmn:IntermediateCatchEvent",
          "bpmn-icon-intermediate-event-catch-signal",
          translate4("Append signal intermediate catch event"),
          { eventDefinitionType: "bpmn:SignalEventDefinition" }
        )
      });
    } else if (isEventType(businessObject, "bpmn:BoundaryEvent", "bpmn:CompensateEventDefinition")) {
      assign(actions, {
        "append.compensation-activity": appendAction(
          "bpmn:Task",
          "bpmn-icon-task",
          translate4("Append compensation activity"),
          {
            isForCompensation: true
          }
        )
      });
    } else if (!is(businessObject, "bpmn:EndEvent") && !businessObject.isForCompensation && !isEventType(businessObject, "bpmn:IntermediateThrowEvent", "bpmn:LinkEventDefinition") && !isEventSubProcess(businessObject)) {
      assign(actions, {
        "append.end-event": appendAction(
          "bpmn:EndEvent",
          "bpmn-icon-end-event-none",
          translate4("Append end event")
        ),
        "append.gateway": appendAction(
          "bpmn:ExclusiveGateway",
          "bpmn-icon-gateway-none",
          translate4("Append gateway")
        ),
        "append.append-task": appendAction(
          "bpmn:Task",
          "bpmn-icon-task",
          translate4("Append task")
        ),
        "append.intermediate-event": appendAction(
          "bpmn:IntermediateThrowEvent",
          "bpmn-icon-intermediate-event-none",
          translate4("Append intermediate/boundary event")
        )
      });
    }
  }
  if (!popupMenu.isEmpty(element, "bpmn-replace")) {
    assign(actions, {
      "replace": {
        group: "edit",
        className: "bpmn-icon-screw-wrench",
        title: translate4("Change element"),
        action: {
          click: function(event2, element2) {
            var position = assign(getReplaceMenuPosition(element2), {
              cursor: { x: event2.x, y: event2.y }
            });
            popupMenu.open(element2, "bpmn-replace", position, {
              title: translate4("Change element"),
              width: 300,
              search: true
            });
          }
        }
      }
    });
  }
  if (is(businessObject, "bpmn:SequenceFlow")) {
    assign(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate4("Add text annotation")
      )
    });
  }
  if (isAny(businessObject, [
    "bpmn:FlowNode",
    "bpmn:InteractionNode",
    "bpmn:DataObjectReference",
    "bpmn:DataStoreReference"
  ])) {
    assign(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate4("Add text annotation")
      ),
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate4("Connect to other element"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is(businessObject, "bpmn:TextAnnotation")) {
    assign(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate4("Connect using association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (isAny(businessObject, ["bpmn:DataObjectReference", "bpmn:DataStoreReference"])) {
    assign(actions, {
      "connect": {
        group: "connect",
        className: "bpmn-icon-connection-multi",
        title: translate4("Connect using data input association"),
        action: {
          click: startConnect,
          dragstart: startConnect
        }
      }
    });
  }
  if (is(businessObject, "bpmn:Group")) {
    assign(actions, {
      "append.text-annotation": appendAction(
        "bpmn:TextAnnotation",
        "bpmn-icon-text-annotation",
        translate4("Add text annotation")
      )
    });
  }
  if (this._isDeleteAllowed([element])) {
    assign(actions, deleteAction());
  }
  return actions;
};
function isEventType(businessObject, type, eventDefinitionType) {
  var isType3 = businessObject.$instanceOf(type);
  var isDefinition = false;
  var definitions = businessObject.eventDefinitions || [];
  forEach(definitions, function(def) {
    if (def.$type === eventDefinitionType) {
      isDefinition = true;
    }
  });
  return isType3 && isDefinition;
}

// node_modules/bpmn-js/lib/features/context-pad/index.js
var context_pad_default2 = {
  __depends__: [
    append_preview_default,
    lib_default,
    context_pad_default,
    selection_default,
    connect_default,
    create_default,
    popup_menu_default2
  ],
  __init__: ["contextPadProvider"],
  contextPadProvider: ["type", ContextPadProvider]
};

// node_modules/diagram-js/lib/features/distribute-elements/DistributeElements.js
var AXIS_DIMENSIONS = {
  horizontal: ["x", "width"],
  vertical: ["y", "height"]
};
var THRESHOLD2 = 5;
function DistributeElements2(modeling, rules) {
  this._modeling = modeling;
  this._filters = [];
  this.registerFilter(function(elements) {
    var allowed = rules.allowed("elements.distribute", { elements });
    if (isArray(allowed)) {
      return allowed;
    }
    return allowed ? elements : [];
  });
}
DistributeElements2.$inject = ["modeling", "rules"];
DistributeElements2.prototype.registerFilter = function(filterFn) {
  if (typeof filterFn !== "function") {
    throw new Error("the filter has to be a function");
  }
  this._filters.push(filterFn);
};
DistributeElements2.prototype.trigger = function(elements, orientation) {
  var modeling = this._modeling;
  var groups, distributableElements;
  if (elements.length < 3) {
    return;
  }
  this._setOrientation(orientation);
  distributableElements = this._filterElements(elements);
  groups = this._createGroups(distributableElements);
  if (groups.length <= 2) {
    return;
  }
  modeling.distributeElements(groups, this._axis, this._dimension);
  return groups;
};
DistributeElements2.prototype._filterElements = function(elements) {
  var filters = this._filters, axis = this._axis, dimension = this._dimension, distributableElements = [].concat(elements);
  if (!filters.length) {
    return elements;
  }
  forEach(filters, function(filterFn) {
    distributableElements = filterFn(distributableElements, axis, dimension);
  });
  return distributableElements;
};
DistributeElements2.prototype._createGroups = function(elements) {
  var rangeGroups = [], self2 = this, axis = this._axis, dimension = this._dimension;
  if (!axis) {
    throw new Error('must have a defined "axis" and "dimension"');
  }
  var sortedElements = sortBy(elements, axis);
  forEach(sortedElements, function(element, idx) {
    var elementRange = self2._findRange(element, axis, dimension), range;
    var previous = rangeGroups[rangeGroups.length - 1];
    if (previous && self2._hasIntersection(previous.range, elementRange)) {
      rangeGroups[rangeGroups.length - 1].elements.push(element);
    } else {
      range = { range: elementRange, elements: [element] };
      rangeGroups.push(range);
    }
  });
  return rangeGroups;
};
DistributeElements2.prototype._setOrientation = function(direction) {
  var orientation = AXIS_DIMENSIONS[direction];
  this._axis = orientation[0];
  this._dimension = orientation[1];
};
DistributeElements2.prototype._hasIntersection = function(rangeA, rangeB) {
  return Math.max(rangeA.min, rangeA.max) >= Math.min(rangeB.min, rangeB.max) && Math.min(rangeA.min, rangeA.max) <= Math.max(rangeB.min, rangeB.max);
};
DistributeElements2.prototype._findRange = function(element) {
  var axis = element[this._axis], dimension = element[this._dimension];
  return {
    min: axis + THRESHOLD2,
    max: axis + dimension - THRESHOLD2
  };
};

// node_modules/diagram-js/lib/features/distribute-elements/index.js
var distribute_elements_default = {
  __init__: ["distributeElements"],
  distributeElements: ["type", DistributeElements2]
};

// node_modules/bpmn-js/lib/features/distribute-elements/BpmnDistributeElements.js
function BpmnDistributeElements(eventBus) {
  RuleProvider.call(this, eventBus);
}
BpmnDistributeElements.$inject = ["eventBus"];
e(BpmnDistributeElements, RuleProvider);
BpmnDistributeElements.prototype.init = function() {
  this.addRule("elements.distribute", function(context) {
    var elements = context.elements;
    elements = filter(elements, function(element) {
      var cannotDistribute = isAny(element, [
        "bpmn:Association",
        "bpmn:BoundaryEvent",
        "bpmn:DataInputAssociation",
        "bpmn:DataOutputAssociation",
        "bpmn:Lane",
        "bpmn:MessageFlow",
        "bpmn:SequenceFlow",
        "bpmn:TextAnnotation"
      ]);
      return !(element.labelTarget || cannotDistribute);
    });
    elements = getParents(elements);
    if (elements.length < 3) {
      return false;
    }
    return elements;
  });
};

// node_modules/bpmn-js/lib/features/distribute-elements/DistributeElementsIcons.js
var icons2 = {
  horizontal: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
                <polyline points="450 400 450 150 1350 150 1350 400" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
                <rect x="150" y="450" width="600" height="1200" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
                <rect x="1050" y="450" width="600" height="800" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
              </svg>`,
  vertical: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1800 1800">
              <polyline points="400 1350 150 1350 150 450 400 450" style="fill:none;stroke:currentColor;stroke-width:100;stroke-linejoin:round;"/>
              <rect x="450" y="150" width="1200" height="600" rx="1" style="fill:none;stroke:currentColor;stroke-width:100;"></rect>
              <rect x="450" y="1050" width="800" height="600" rx="1" style="fill:currentColor;stroke:currentColor;stroke-width:100;opacity:.5;"></rect>
            </svg>`
};
var DistributeElementsIcons_default = icons2;

// node_modules/bpmn-js/lib/features/distribute-elements/DistributeElementsMenuProvider.js
var LOW_PRIORITY21 = 900;
function DistributeElementsMenuProvider(popupMenu, distributeElements, translate4, rules) {
  this._distributeElements = distributeElements;
  this._translate = translate4;
  this._popupMenu = popupMenu;
  this._rules = rules;
  popupMenu.registerProvider("align-elements", LOW_PRIORITY21, this);
}
DistributeElementsMenuProvider.$inject = [
  "popupMenu",
  "distributeElements",
  "translate",
  "rules"
];
DistributeElementsMenuProvider.prototype.getPopupMenuEntries = function(target) {
  var entries = {};
  if (this._isAllowed(target)) {
    assign(entries, this._getEntries(target));
  }
  return entries;
};
DistributeElementsMenuProvider.prototype._isAllowed = function(elements) {
  return this._rules.allowed("elements.distribute", { elements });
};
DistributeElementsMenuProvider.prototype._getEntries = function(elements) {
  var distributeElements = this._distributeElements, translate4 = this._translate, popupMenu = this._popupMenu;
  var entries = {
    "distribute-elements-horizontal": {
      group: "distribute",
      title: translate4("Distribute elements horizontally"),
      className: "bjs-align-elements-menu-entry",
      imageHtml: DistributeElementsIcons_default["horizontal"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "horizontal");
        popupMenu.close();
      }
    },
    "distribute-elements-vertical": {
      group: "distribute",
      title: translate4("Distribute elements vertically"),
      imageHtml: DistributeElementsIcons_default["vertical"],
      action: function(event2, entry) {
        distributeElements.trigger(elements, "vertical");
        popupMenu.close();
      }
    }
  };
  return entries;
};

// node_modules/bpmn-js/lib/features/distribute-elements/index.js
var distribute_elements_default2 = {
  __depends__: [
    popup_menu_default,
    distribute_elements_default
  ],
  __init__: [
    "bpmnDistributeElements",
    "distributeElementsMenuProvider"
  ],
  bpmnDistributeElements: ["type", BpmnDistributeElements],
  distributeElementsMenuProvider: ["type", DistributeElementsMenuProvider]
};

// node_modules/diagram-js/lib/features/editor-actions/EditorActions.js
var NOT_REGISTERED_ERROR = "is not a registered action";
var IS_REGISTERED_ERROR = "is already registered";
function EditorActions(eventBus, injector) {
  this._actions = {};
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2._registerDefaultActions(injector);
    eventBus.fire("editorActions.init", {
      editorActions: self2
    });
  });
}
EditorActions.$inject = [
  "eventBus",
  "injector"
];
EditorActions.prototype._registerDefaultActions = function(injector) {
  var commandStack = injector.get("commandStack", false);
  var modeling = injector.get("modeling", false);
  var selection2 = injector.get("selection", false);
  var zoomScroll = injector.get("zoomScroll", false);
  var copyPaste = injector.get("copyPaste", false);
  var canvas = injector.get("canvas", false);
  var rules = injector.get("rules", false);
  var keyboardMove = injector.get("keyboardMove", false);
  var keyboardMoveSelection = injector.get("keyboardMoveSelection", false);
  if (commandStack) {
    this.register("undo", function() {
      commandStack.undo();
    });
    this.register("redo", function() {
      commandStack.redo();
    });
  }
  if (copyPaste && selection2) {
    this.register("copy", function() {
      var selectedElements = selection2.get();
      if (selectedElements.length) {
        return copyPaste.copy(selectedElements);
      }
    });
  }
  if (copyPaste) {
    this.register("paste", function() {
      copyPaste.paste();
    });
  }
  if (zoomScroll) {
    this.register("stepZoom", function(opts) {
      zoomScroll.stepZoom(opts.value);
    });
  }
  if (canvas) {
    this.register("zoom", function(opts) {
      canvas.zoom(opts.value);
    });
  }
  if (modeling && selection2 && rules) {
    this.register("removeSelection", function() {
      var selectedElements = selection2.get();
      if (!selectedElements.length) {
        return;
      }
      var allowed = rules.allowed("elements.delete", { elements: selectedElements }), removableElements;
      if (allowed === false) {
        return;
      } else if (isArray(allowed)) {
        removableElements = allowed;
      } else {
        removableElements = selectedElements;
      }
      if (removableElements.length) {
        modeling.removeElements(removableElements.slice());
      }
    });
  }
  if (keyboardMove) {
    this.register("moveCanvas", function(opts) {
      keyboardMove.moveCanvas(opts);
    });
  }
  if (keyboardMoveSelection) {
    this.register("moveSelection", function(opts) {
      keyboardMoveSelection.moveSelection(opts.direction, opts.accelerated);
    });
  }
};
EditorActions.prototype.trigger = function(action, opts) {
  if (!this._actions[action]) {
    throw error3(action, NOT_REGISTERED_ERROR);
  }
  return this._actions[action](opts);
};
EditorActions.prototype.register = function(actions, listener) {
  var self2 = this;
  if (typeof actions === "string") {
    return this._registerAction(actions, listener);
  }
  forEach(actions, function(listener2, action) {
    self2._registerAction(action, listener2);
  });
};
EditorActions.prototype._registerAction = function(action, listener) {
  if (this.isRegistered(action)) {
    throw error3(action, IS_REGISTERED_ERROR);
  }
  this._actions[action] = listener;
};
EditorActions.prototype.unregister = function(action) {
  if (!this.isRegistered(action)) {
    throw error3(action, NOT_REGISTERED_ERROR);
  }
  this._actions[action] = void 0;
};
EditorActions.prototype.getActions = function() {
  return Object.keys(this._actions);
};
EditorActions.prototype.isRegistered = function(action) {
  return !!this._actions[action];
};
function error3(action, message) {
  return new Error(action + " " + message);
}

// node_modules/diagram-js/lib/features/editor-actions/index.js
var editor_actions_default = {
  __init__: ["editorActions"],
  editorActions: ["type", EditorActions]
};

// node_modules/bpmn-js/lib/features/editor-actions/BpmnEditorActions.js
function BpmnEditorActions(injector) {
  injector.invoke(EditorActions, this);
}
e(BpmnEditorActions, EditorActions);
BpmnEditorActions.$inject = [
  "injector"
];
BpmnEditorActions.prototype._registerDefaultActions = function(injector) {
  EditorActions.prototype._registerDefaultActions.call(this, injector);
  var canvas = injector.get("canvas", false);
  var elementRegistry = injector.get("elementRegistry", false);
  var selection2 = injector.get("selection", false);
  var spaceTool = injector.get("spaceTool", false);
  var lassoTool = injector.get("lassoTool", false);
  var handTool = injector.get("handTool", false);
  var globalConnect = injector.get("globalConnect", false);
  var distributeElements = injector.get("distributeElements", false);
  var alignElements = injector.get("alignElements", false);
  var directEditing = injector.get("directEditing", false);
  var searchPad = injector.get("searchPad", false);
  var modeling = injector.get("modeling", false);
  var contextPad = injector.get("contextPad", false);
  if (canvas && elementRegistry && selection2) {
    this._registerAction("selectElements", function() {
      var rootElement = canvas.getRootElement();
      var elements = elementRegistry.filter(function(element) {
        return element !== rootElement;
      });
      selection2.select(elements);
      return elements;
    });
  }
  if (spaceTool) {
    this._registerAction("spaceTool", function() {
      spaceTool.toggle();
    });
  }
  if (lassoTool) {
    this._registerAction("lassoTool", function() {
      lassoTool.toggle();
    });
  }
  if (handTool) {
    this._registerAction("handTool", function() {
      handTool.toggle();
    });
  }
  if (globalConnect) {
    this._registerAction("globalConnectTool", function() {
      globalConnect.toggle();
    });
  }
  if (selection2 && distributeElements) {
    this._registerAction("distributeElements", function(opts) {
      var currentSelection = selection2.get(), type = opts.type;
      if (currentSelection.length) {
        distributeElements.trigger(currentSelection, type);
      }
    });
  }
  if (selection2 && alignElements) {
    this._registerAction("alignElements", function(opts) {
      var currentSelection = selection2.get(), aligneableElements = [], type = opts.type;
      if (currentSelection.length) {
        aligneableElements = filter(currentSelection, function(element) {
          return !is(element, "bpmn:Lane");
        });
        alignElements.trigger(aligneableElements, type);
      }
    });
  }
  if (selection2 && modeling) {
    this._registerAction("setColor", function(opts) {
      var currentSelection = selection2.get();
      if (currentSelection.length) {
        modeling.setColor(currentSelection, opts);
      }
    });
  }
  if (selection2 && directEditing) {
    this._registerAction("directEditing", function() {
      var currentSelection = selection2.get();
      if (currentSelection.length) {
        directEditing.activate(currentSelection[0]);
      }
    });
  }
  if (searchPad) {
    this._registerAction("find", function() {
      searchPad.toggle();
    });
  }
  if (canvas && modeling) {
    this._registerAction("moveToOrigin", function() {
      var rootElement = canvas.getRootElement(), boundingBox, elements;
      if (is(rootElement, "bpmn:Collaboration")) {
        elements = elementRegistry.filter(function(element) {
          return is(element.parent, "bpmn:Collaboration");
        });
      } else {
        elements = elementRegistry.filter(function(element) {
          return element !== rootElement && !is(element.parent, "bpmn:SubProcess");
        });
      }
      boundingBox = getBBox(elements);
      modeling.moveElements(
        elements,
        { x: -boundingBox.x, y: -boundingBox.y },
        rootElement
      );
    });
  }
  if (selection2 && contextPad) {
    this._registerAction("replaceElement", function(event2) {
      contextPad.triggerEntry("replace", "click", event2);
    });
  }
};

// node_modules/bpmn-js/lib/features/editor-actions/index.js
var editor_actions_default2 = {
  __depends__: [
    editor_actions_default
  ],
  editorActions: ["type", BpmnEditorActions]
};

// node_modules/bpmn-js/lib/features/grid-snapping/BpmnGridSnapping.js
function BpmnGridSnapping(eventBus) {
  eventBus.on([
    "create.init",
    "shape.move.init"
  ], function(event2) {
    var context = event2.context, shape = event2.shape;
    if (isAny(shape, [
      "bpmn:Participant",
      "bpmn:SubProcess",
      "bpmn:TextAnnotation"
    ])) {
      if (!context.gridSnappingContext) {
        context.gridSnappingContext = {};
      }
      context.gridSnappingContext.snapLocation = "top-left";
    }
  });
}
BpmnGridSnapping.$inject = ["eventBus"];

// node_modules/diagram-js/lib/features/grid-snapping/GridUtil.js
var SPACING = 10;
function quantize(value, quantum, fn2) {
  if (!fn2) {
    fn2 = "round";
  }
  return Math[fn2](value / quantum) * quantum;
}

// node_modules/diagram-js/lib/features/grid-snapping/GridSnapping.js
var LOWER_PRIORITY2 = 1200;
var LOW_PRIORITY22 = 800;
function GridSnapping(elementRegistry, eventBus, config) {
  var active = !config || config.active !== false;
  this._eventBus = eventBus;
  var self2 = this;
  eventBus.on("diagram.init", LOW_PRIORITY22, function() {
    self2.setActive(active);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "bendpoint.move.move",
    "bendpoint.move.end",
    "connect.move",
    "connect.end",
    "connectionSegment.move.move",
    "connectionSegment.move.end",
    "resize.move",
    "resize.end",
    "shape.move.move",
    "shape.move.end"
  ], LOWER_PRIORITY2, function(event2) {
    var originalEvent = event2.originalEvent;
    if (!self2.active || originalEvent && isCmd(originalEvent)) {
      return;
    }
    var context = event2.context, gridSnappingContext = context.gridSnappingContext;
    if (!gridSnappingContext) {
      gridSnappingContext = context.gridSnappingContext = {};
    }
    ["x", "y"].forEach(function(axis) {
      var options = {};
      var snapOffset = getSnapOffset(event2, axis, elementRegistry);
      if (snapOffset) {
        options.offset = snapOffset;
      }
      var snapConstraints = getSnapConstraints(event2, axis);
      if (snapConstraints) {
        assign(options, snapConstraints);
      }
      if (!isSnapped(event2, axis)) {
        self2.snapEvent(event2, axis, options);
      }
    });
  });
}
GridSnapping.prototype.snapEvent = function(event2, axis, options) {
  var snappedValue = this.snapValue(event2[axis], options);
  setSnapped(event2, axis, snappedValue);
};
GridSnapping.prototype.getGridSpacing = function() {
  return SPACING;
};
GridSnapping.prototype.snapValue = function(value, options) {
  var offset = 0;
  if (options && options.offset) {
    offset = options.offset;
  }
  value += offset;
  value = quantize(value, SPACING);
  var min5, max8;
  if (options && options.min) {
    min5 = options.min;
    if (isNumber(min5)) {
      min5 = quantize(min5 + offset, SPACING, "ceil");
      value = Math.max(value, min5);
    }
  }
  if (options && options.max) {
    max8 = options.max;
    if (isNumber(max8)) {
      max8 = quantize(max8 + offset, SPACING, "floor");
      value = Math.min(value, max8);
    }
  }
  value -= offset;
  return value;
};
GridSnapping.prototype.isActive = function() {
  return this.active;
};
GridSnapping.prototype.setActive = function(active) {
  this.active = active;
  this._eventBus.fire("gridSnapping.toggle", { active });
};
GridSnapping.prototype.toggleActive = function() {
  this.setActive(!this.active);
};
GridSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "config.gridSnapping"
];
function getSnapConstraints(event2, axis) {
  var context = event2.context, createConstraints = context.createConstraints, resizeConstraints = context.resizeConstraints || {}, gridSnappingContext = context.gridSnappingContext, snapConstraints = gridSnappingContext.snapConstraints;
  if (snapConstraints && snapConstraints[axis]) {
    return snapConstraints[axis];
  }
  if (!snapConstraints) {
    snapConstraints = gridSnappingContext.snapConstraints = {};
  }
  if (!snapConstraints[axis]) {
    snapConstraints[axis] = {};
  }
  var direction = context.direction;
  if (createConstraints) {
    if (isHorizontal2(axis)) {
      snapConstraints.x.min = createConstraints.left;
      snapConstraints.x.max = createConstraints.right;
    } else {
      snapConstraints.y.min = createConstraints.top;
      snapConstraints.y.max = createConstraints.bottom;
    }
  }
  var minResizeConstraints = resizeConstraints.min, maxResizeConstraints = resizeConstraints.max;
  if (minResizeConstraints) {
    if (isHorizontal2(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.max = minResizeConstraints.left;
      } else {
        snapConstraints.x.min = minResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.max = minResizeConstraints.top;
      } else {
        snapConstraints.y.min = minResizeConstraints.bottom;
      }
    }
  }
  if (maxResizeConstraints) {
    if (isHorizontal2(axis)) {
      if (isWest(direction)) {
        snapConstraints.x.min = maxResizeConstraints.left;
      } else {
        snapConstraints.x.max = maxResizeConstraints.right;
      }
    } else {
      if (isNorth(direction)) {
        snapConstraints.y.min = maxResizeConstraints.top;
      } else {
        snapConstraints.y.max = maxResizeConstraints.bottom;
      }
    }
  }
  return snapConstraints[axis];
}
function getSnapOffset(event2, axis, elementRegistry) {
  var context = event2.context, shape = event2.shape, gridSnappingContext = context.gridSnappingContext, snapLocation = gridSnappingContext.snapLocation, snapOffset = gridSnappingContext.snapOffset;
  if (snapOffset && isNumber(snapOffset[axis])) {
    return snapOffset[axis];
  }
  if (!snapOffset) {
    snapOffset = gridSnappingContext.snapOffset = {};
  }
  if (!isNumber(snapOffset[axis])) {
    snapOffset[axis] = 0;
  }
  if (!shape) {
    return snapOffset[axis];
  }
  if (!elementRegistry.get(shape.id)) {
    if (isHorizontal2(axis)) {
      snapOffset[axis] += shape[axis] + shape.width / 2;
    } else {
      snapOffset[axis] += shape[axis] + shape.height / 2;
    }
  }
  if (!snapLocation) {
    return snapOffset[axis];
  }
  if (axis === "x") {
    if (/left/.test(snapLocation)) {
      snapOffset[axis] -= shape.width / 2;
    } else if (/right/.test(snapLocation)) {
      snapOffset[axis] += shape.width / 2;
    }
  } else {
    if (/top/.test(snapLocation)) {
      snapOffset[axis] -= shape.height / 2;
    } else if (/bottom/.test(snapLocation)) {
      snapOffset[axis] += shape.height / 2;
    }
  }
  return snapOffset[axis];
}
function isHorizontal2(axis) {
  return axis === "x";
}
function isNorth(direction) {
  return direction.indexOf("n") !== -1;
}
function isWest(direction) {
  return direction.indexOf("w") !== -1;
}

// node_modules/diagram-js/lib/features/grid-snapping/behavior/ResizeBehavior.js
function ResizeBehavior2(eventBus, gridSnapping) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.preExecute("shape.resize", function(event2) {
    var context = event2.context, hints = context.hints || {}, autoResize = hints.autoResize;
    if (!autoResize) {
      return;
    }
    var shape = context.shape, newBounds = context.newBounds;
    if (isString(autoResize)) {
      context.newBounds = self2.snapComplex(newBounds, autoResize);
    } else {
      context.newBounds = self2.snapSimple(shape, newBounds);
    }
  });
}
ResizeBehavior2.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e(ResizeBehavior2, CommandInterceptor);
ResizeBehavior2.prototype.snapSimple = function(shape, newBounds) {
  var gridSnapping = this._gridSnapping;
  newBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  newBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  newBounds.x = shape.x + shape.width / 2 - newBounds.width / 2;
  newBounds.y = shape.y + shape.height / 2 - newBounds.height / 2;
  return newBounds;
};
ResizeBehavior2.prototype.snapComplex = function(newBounds, directions2) {
  if (/w|e/.test(directions2)) {
    newBounds = this.snapHorizontally(newBounds, directions2);
  }
  if (/n|s/.test(directions2)) {
    newBounds = this.snapVertically(newBounds, directions2);
  }
  return newBounds;
};
ResizeBehavior2.prototype.snapHorizontally = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, west = /w/.test(directions2), east = /e/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.width = gridSnapping.snapValue(newBounds.width, {
    min: newBounds.width
  });
  if (east) {
    if (west) {
      snappedNewBounds.x = gridSnapping.snapValue(newBounds.x, {
        max: newBounds.x
      });
      snappedNewBounds.width += gridSnapping.snapValue(newBounds.x - snappedNewBounds.x, {
        min: newBounds.x - snappedNewBounds.x
      });
    } else {
      newBounds.x = newBounds.x + newBounds.width - snappedNewBounds.width;
    }
  }
  assign(newBounds, snappedNewBounds);
  return newBounds;
};
ResizeBehavior2.prototype.snapVertically = function(newBounds, directions2) {
  var gridSnapping = this._gridSnapping, north = /n/.test(directions2), south = /s/.test(directions2);
  var snappedNewBounds = {};
  snappedNewBounds.height = gridSnapping.snapValue(newBounds.height, {
    min: newBounds.height
  });
  if (north) {
    if (south) {
      snappedNewBounds.y = gridSnapping.snapValue(newBounds.y, {
        max: newBounds.y
      });
      snappedNewBounds.height += gridSnapping.snapValue(newBounds.y - snappedNewBounds.y, {
        min: newBounds.y - snappedNewBounds.y
      });
    } else {
      newBounds.y = newBounds.y + newBounds.height - snappedNewBounds.height;
    }
  }
  assign(newBounds, snappedNewBounds);
  return newBounds;
};

// node_modules/diagram-js/lib/features/grid-snapping/behavior/SpaceToolBehavior.js
var HIGH_PRIORITY14 = 2e3;
function SpaceToolBehavior2(eventBus, gridSnapping) {
  eventBus.on([
    "spaceTool.move",
    "spaceTool.end"
  ], HIGH_PRIORITY14, function(event2) {
    var context = event2.context;
    if (!context.initialized) {
      return;
    }
    var axis = context.axis;
    var snapped;
    if (axis === "x") {
      snapped = gridSnapping.snapValue(event2.dx);
      event2.x = event2.x + snapped - event2.dx;
      event2.dx = snapped;
    } else {
      snapped = gridSnapping.snapValue(event2.dy);
      event2.y = event2.y + snapped - event2.dy;
      event2.dy = snapped;
    }
  });
}
SpaceToolBehavior2.$inject = [
  "eventBus",
  "gridSnapping"
];

// node_modules/diagram-js/lib/features/grid-snapping/behavior/index.js
var behavior_default2 = {
  __init__: [
    "gridSnappingResizeBehavior",
    "gridSnappingSpaceToolBehavior"
  ],
  gridSnappingResizeBehavior: ["type", ResizeBehavior2],
  gridSnappingSpaceToolBehavior: ["type", SpaceToolBehavior2]
};

// node_modules/diagram-js/lib/features/grid-snapping/index.js
var grid_snapping_default = {
  __depends__: [behavior_default2],
  __init__: ["gridSnapping"],
  gridSnapping: ["type", GridSnapping]
};

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingAutoPlaceBehavior.js
var HIGH_PRIORITY15 = 2e3;
function GridSnappingAutoPlaceBehavior(eventBus, gridSnapping, elementRegistry) {
  eventBus.on("autoPlace", HIGH_PRIORITY15, function(context) {
    var source = context.source, sourceMid = getMid(source), shape = context.shape;
    var position = getNewShapePosition2(source, shape, elementRegistry);
    ["x", "y"].forEach(function(axis) {
      var options = {};
      if (position[axis] === sourceMid[axis]) {
        return;
      }
      if (position[axis] > sourceMid[axis]) {
        options.min = position[axis];
      } else {
        options.max = position[axis];
      }
      if (is(shape, "bpmn:TextAnnotation")) {
        if (isHorizontal3(axis)) {
          options.offset = -shape.width / 2;
        } else {
          options.offset = -shape.height / 2;
        }
      }
      position[axis] = gridSnapping.snapValue(position[axis], options);
    });
    return position;
  });
}
GridSnappingAutoPlaceBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "elementRegistry"
];
function isHorizontal3(axis) {
  return axis === "x";
}

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingParticipantBehavior.js
var HIGHER_PRIORITY = 1750;
function GridSnappingParticipantBehavior(canvas, eventBus, gridSnapping) {
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], HIGHER_PRIORITY, function(event2) {
    var context = event2.context, shape = context.shape, rootElement = canvas.getRootElement();
    if (!is(shape, "bpmn:Participant") || !is(rootElement, "bpmn:Process") || !rootElement.children.length) {
      return;
    }
    var createConstraints = context.createConstraints;
    if (!createConstraints) {
      return;
    }
    shape.width = gridSnapping.snapValue(shape.width, { min: shape.width });
    shape.height = gridSnapping.snapValue(shape.height, { min: shape.height });
  });
}
GridSnappingParticipantBehavior.$inject = [
  "canvas",
  "eventBus",
  "gridSnapping"
];

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/GridSnappingLayoutConnectionBehavior.js
var HIGH_PRIORITY16 = 3e3;
function GridSnappingLayoutConnectionBehavior(eventBus, gridSnapping, modeling) {
  CommandInterceptor.call(this, eventBus);
  this._gridSnapping = gridSnapping;
  var self2 = this;
  this.postExecuted([
    "connection.create",
    "connection.layout"
  ], HIGH_PRIORITY16, function(event2) {
    var context = event2.context, connection = context.connection, hints = context.hints || {}, waypoints = connection.waypoints;
    if (hints.connectionStart || hints.connectionEnd || hints.createElementsBehavior === false) {
      return;
    }
    if (!hasMiddleSegments(waypoints)) {
      return;
    }
    modeling.updateWaypoints(connection, self2.snapMiddleSegments(waypoints));
  });
}
GridSnappingLayoutConnectionBehavior.$inject = [
  "eventBus",
  "gridSnapping",
  "modeling"
];
e(GridSnappingLayoutConnectionBehavior, CommandInterceptor);
GridSnappingLayoutConnectionBehavior.prototype.snapMiddleSegments = function(waypoints) {
  var gridSnapping = this._gridSnapping, snapped;
  waypoints = waypoints.slice();
  for (var i7 = 1; i7 < waypoints.length - 2; i7++) {
    snapped = snapSegment(gridSnapping, waypoints[i7], waypoints[i7 + 1]);
    waypoints[i7] = snapped[0];
    waypoints[i7 + 1] = snapped[1];
  }
  return waypoints;
};
function hasMiddleSegments(waypoints) {
  return waypoints.length > 3;
}
function horizontallyAligned(aligned) {
  return aligned === "h";
}
function verticallyAligned(aligned) {
  return aligned === "v";
}
function snapSegment(gridSnapping, segmentStart, segmentEnd) {
  var aligned = pointsAligned(segmentStart, segmentEnd);
  var snapped = {};
  if (horizontallyAligned(aligned)) {
    snapped.y = gridSnapping.snapValue(segmentStart.y);
  }
  if (verticallyAligned(aligned)) {
    snapped.x = gridSnapping.snapValue(segmentStart.x);
  }
  if ("x" in snapped || "y" in snapped) {
    segmentStart = assign({}, segmentStart, snapped);
    segmentEnd = assign({}, segmentEnd, snapped);
  }
  return [segmentStart, segmentEnd];
}

// node_modules/bpmn-js/lib/features/grid-snapping/behavior/index.js
var behavior_default3 = {
  __init__: [
    "gridSnappingAutoPlaceBehavior",
    "gridSnappingParticipantBehavior",
    "gridSnappingLayoutConnectionBehavior"
  ],
  gridSnappingAutoPlaceBehavior: ["type", GridSnappingAutoPlaceBehavior],
  gridSnappingParticipantBehavior: ["type", GridSnappingParticipantBehavior],
  gridSnappingLayoutConnectionBehavior: ["type", GridSnappingLayoutConnectionBehavior]
};

// node_modules/bpmn-js/lib/features/grid-snapping/index.js
var grid_snapping_default2 = {
  __depends__: [
    grid_snapping_default,
    behavior_default3
  ],
  __init__: ["bpmnGridSnapping"],
  bpmnGridSnapping: ["type", BpmnGridSnapping]
};

// node_modules/bpmn-js/lib/features/interaction-events/BpmnInteractionEvents.js
var LABEL_WIDTH = 30;
var LABEL_HEIGHT = 30;
function BpmnInteractionEvents(eventBus, interactionEvents) {
  this._interactionEvents = interactionEvents;
  var self2 = this;
  eventBus.on([
    "interactionEvents.createHit",
    "interactionEvents.updateHit"
  ], function(context) {
    var element = context.element, gfx = context.gfx;
    if (is(element, "bpmn:Lane")) {
      return self2._createParticipantHit(element, gfx);
    } else if (is(element, "bpmn:Participant")) {
      if (isExpanded(element)) {
        return self2._createParticipantHit(element, gfx);
      } else {
        return self2._createDefaultHit(element, gfx);
      }
    } else if (is(element, "bpmn:SubProcess")) {
      if (isExpanded(element)) {
        return self2._createSubProcessHit(element, gfx);
      } else {
        return self2._createDefaultHit(element, gfx);
      }
    }
  });
}
BpmnInteractionEvents.$inject = [
  "eventBus",
  "interactionEvents"
];
BpmnInteractionEvents.prototype._createDefaultHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createDefaultHit(element, gfx);
  return true;
};
BpmnInteractionEvents.prototype._createParticipantHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  var box = isHorizontal(element) ? {
    width: LABEL_WIDTH,
    height: element.height
  } : {
    width: element.width,
    height: LABEL_HEIGHT
  };
  this._interactionEvents.createBoxHit(gfx, "all", box);
  return true;
};
BpmnInteractionEvents.prototype._createSubProcessHit = function(element, gfx) {
  this._interactionEvents.removeHits(gfx);
  this._interactionEvents.createBoxHit(gfx, "no-move", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "click-stroke", {
    width: element.width,
    height: element.height
  });
  this._interactionEvents.createBoxHit(gfx, "all", {
    width: element.width,
    height: LABEL_HEIGHT
  });
  return true;
};

// node_modules/bpmn-js/lib/features/interaction-events/index.js
var interaction_events_default2 = {
  __init__: ["bpmnInteractionEvents"],
  bpmnInteractionEvents: ["type", BpmnInteractionEvents]
};

// node_modules/bpmn-js/lib/features/keyboard/BpmnKeyboardBindings.js
function BpmnKeyboardBindings(injector) {
  injector.invoke(KeyboardBindings, this);
}
e(BpmnKeyboardBindings, KeyboardBindings);
BpmnKeyboardBindings.$inject = [
  "injector"
];
BpmnKeyboardBindings.prototype.registerBindings = function(keyboard, editorActions) {
  KeyboardBindings.prototype.registerBindings.call(this, keyboard, editorActions);
  function addListener(action, fn2) {
    if (editorActions.isRegistered(action)) {
      keyboard.addListener(fn2);
    }
  }
  addListener("selectElements", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["a", "A"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("selectElements");
      return true;
    }
  });
  addListener("find", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.isKey(["f", "F"], event2) && keyboard.isCmd(event2)) {
      editorActions.trigger("find");
      return true;
    }
  });
  addListener("spaceTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["s", "S"], event2)) {
      editorActions.trigger("spaceTool");
      return true;
    }
  });
  addListener("lassoTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["l", "L"], event2)) {
      editorActions.trigger("lassoTool");
      return true;
    }
  });
  addListener("handTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["h", "H"], event2)) {
      editorActions.trigger("handTool");
      return true;
    }
  });
  addListener("globalConnectTool", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["c", "C"], event2)) {
      editorActions.trigger("globalConnectTool");
      return true;
    }
  });
  addListener("directEditing", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["e", "E"], event2)) {
      editorActions.trigger("directEditing");
      return true;
    }
  });
  addListener("replaceElement", function(context) {
    var event2 = context.keyEvent;
    if (keyboard.hasModifier(event2)) {
      return;
    }
    if (keyboard.isKey(["r", "R"], event2)) {
      editorActions.trigger("replaceElement", event2);
      return true;
    }
  });
};

// node_modules/bpmn-js/lib/features/keyboard/index.js
var keyboard_default2 = {
  __depends__: [
    keyboard_default
  ],
  __init__: ["keyboardBindings"],
  keyboardBindings: ["type", BpmnKeyboardBindings]
};

// node_modules/diagram-js/lib/features/keyboard-move-selection/KeyboardMoveSelection.js
var DEFAULT_CONFIG2 = {
  moveSpeed: 1,
  moveSpeedAccelerated: 10
};
var HIGHER_PRIORITY2 = 1500;
var LEFT = "left";
var UP = "up";
var RIGHT = "right";
var DOWN = "down";
var KEY_TO_DIRECTION = {
  ArrowLeft: LEFT,
  Left: LEFT,
  ArrowUp: UP,
  Up: UP,
  ArrowRight: RIGHT,
  Right: RIGHT,
  ArrowDown: DOWN,
  Down: DOWN
};
var DIRECTIONS_DELTA = {
  left: function(speed) {
    return {
      x: -speed,
      y: 0
    };
  },
  up: function(speed) {
    return {
      x: 0,
      y: -speed
    };
  },
  right: function(speed) {
    return {
      x: speed,
      y: 0
    };
  },
  down: function(speed) {
    return {
      x: 0,
      y: speed
    };
  }
};
function KeyboardMoveSelection(config, keyboard, modeling, rules, selection2) {
  var self2 = this;
  this._config = assign({}, DEFAULT_CONFIG2, config || {});
  keyboard.addListener(HIGHER_PRIORITY2, function(event2) {
    var keyEvent = event2.keyEvent;
    var direction = KEY_TO_DIRECTION[keyEvent.key];
    if (!direction) {
      return;
    }
    if (keyboard.isCmd(keyEvent)) {
      return;
    }
    var accelerated = keyboard.isShift(keyEvent);
    self2.moveSelection(direction, accelerated);
    return true;
  });
  this.moveSelection = function(direction, accelerated) {
    var selectedElements = selection2.get();
    if (!selectedElements.length) {
      return;
    }
    var speed = this._config[accelerated ? "moveSpeedAccelerated" : "moveSpeed"];
    var delta2 = DIRECTIONS_DELTA[direction](speed);
    var canMove2 = rules.allowed("elements.move", {
      shapes: selectedElements
    });
    if (canMove2) {
      modeling.moveElements(selectedElements, delta2);
    }
  };
}
KeyboardMoveSelection.$inject = [
  "config.keyboardMoveSelection",
  "keyboard",
  "modeling",
  "rules",
  "selection"
];

// node_modules/diagram-js/lib/features/keyboard-move-selection/index.js
var keyboard_move_selection_default = {
  __depends__: [
    keyboard_default,
    selection_default
  ],
  __init__: [
    "keyboardMoveSelection"
  ],
  keyboardMoveSelection: ["type", KeyboardMoveSelection]
};

// node_modules/diagram-js/lib/features/resize/Resize.js
var DEFAULT_MIN_WIDTH = 10;
function Resize(eventBus, rules, modeling, dragging) {
  this._dragging = dragging;
  this._rules = rules;
  var self2 = this;
  function handleMove(context, delta2) {
    var shape = context.shape, direction = context.direction, resizeConstraints = context.resizeConstraints, newBounds;
    context.delta = delta2;
    newBounds = resizeBounds(shape, direction, delta2);
    context.newBounds = ensureConstraints(newBounds, resizeConstraints);
    context.canExecute = self2.canResize(context);
  }
  function handleStart(context) {
    var resizeConstraints = context.resizeConstraints, minBounds = context.minBounds;
    if (resizeConstraints !== void 0) {
      return;
    }
    if (minBounds === void 0) {
      minBounds = self2.computeMinResizeBox(context);
    }
    context.resizeConstraints = {
      min: asTRBL(minBounds)
    };
  }
  function handleEnd(context) {
    var shape = context.shape, canExecute = context.canExecute, newBounds = context.newBounds;
    if (canExecute) {
      newBounds = roundBounds(newBounds);
      if (!boundsChanged2(shape, newBounds)) {
        return;
      }
      modeling.resizeShape(shape, newBounds);
    }
  }
  eventBus.on("resize.start", function(event2) {
    handleStart(event2.context);
  });
  eventBus.on("resize.move", function(event2) {
    var delta2 = {
      x: event2.dx,
      y: event2.dy
    };
    handleMove(event2.context, delta2);
  });
  eventBus.on("resize.end", function(event2) {
    handleEnd(event2.context);
  });
}
Resize.prototype.canResize = function(context) {
  var rules = this._rules;
  var ctx = pick(context, ["newBounds", "shape", "delta", "direction"]);
  return rules.allowed("shape.resize", ctx);
};
Resize.prototype.activate = function(event2, shape, contextOrDirection) {
  var dragging = this._dragging, context, direction;
  if (typeof contextOrDirection === "string") {
    contextOrDirection = {
      direction: contextOrDirection
    };
  }
  context = assign({ shape }, contextOrDirection);
  direction = context.direction;
  if (!direction) {
    throw new Error("must provide a direction (n|w|s|e|nw|se|ne|sw)");
  }
  dragging.init(event2, getReferencePoint2(shape, direction), "resize", {
    autoActivate: true,
    cursor: getCursor(direction),
    data: {
      shape,
      context
    }
  });
};
Resize.prototype.computeMinResizeBox = function(context) {
  var shape = context.shape, direction = context.direction, minDimensions, childrenBounds;
  minDimensions = context.minDimensions || {
    width: DEFAULT_MIN_WIDTH,
    height: DEFAULT_MIN_WIDTH
  };
  childrenBounds = computeChildrenBBox(shape, context.childrenBoxPadding);
  return getMinResizeBounds(direction, shape, minDimensions, childrenBounds);
};
Resize.$inject = [
  "eventBus",
  "rules",
  "modeling",
  "dragging"
];
function boundsChanged2(shape, newBounds) {
  return shape.x !== newBounds.x || shape.y !== newBounds.y || shape.width !== newBounds.width || shape.height !== newBounds.height;
}
function getReferencePoint2(shape, direction) {
  var mid4 = getMid(shape), trbl = asTRBL(shape);
  var referencePoint = {
    x: mid4.x,
    y: mid4.y
  };
  if (direction.indexOf("n") !== -1) {
    referencePoint.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    referencePoint.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    referencePoint.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    referencePoint.x = trbl.left;
  }
  return referencePoint;
}
function getCursor(direction) {
  var prefix3 = "resize-";
  if (direction === "n" || direction === "s") {
    return prefix3 + "ns";
  } else if (direction === "e" || direction === "w") {
    return prefix3 + "ew";
  } else if (direction === "nw" || direction === "se") {
    return prefix3 + "nwse";
  } else {
    return prefix3 + "nesw";
  }
}

// node_modules/diagram-js/lib/features/resize/ResizePreview.js
var MARKER_RESIZING2 = "djs-resizing";
var MARKER_RESIZE_NOT_OK = "resize-not-ok";
var LOW_PRIORITY23 = 500;
function ResizePreview(eventBus, canvas, previewSupport) {
  function updateFrame(context) {
    var shape = context.shape, bounds = context.newBounds, frame = context.frame;
    if (!frame) {
      frame = context.frame = previewSupport.addFrame(shape, canvas.getActiveLayer());
      canvas.addMarker(shape, MARKER_RESIZING2);
    }
    if (bounds.width > 5) {
      attr(frame, { x: bounds.x, width: bounds.width });
    }
    if (bounds.height > 5) {
      attr(frame, { y: bounds.y, height: bounds.height });
    }
    if (context.canExecute) {
      classes(frame).remove(MARKER_RESIZE_NOT_OK);
    } else {
      classes(frame).add(MARKER_RESIZE_NOT_OK);
    }
  }
  function removeFrame(context) {
    var shape = context.shape, frame = context.frame;
    if (frame) {
      remove(context.frame);
    }
    canvas.removeMarker(shape, MARKER_RESIZING2);
  }
  eventBus.on("resize.move", LOW_PRIORITY23, function(event2) {
    updateFrame(event2.context);
  });
  eventBus.on("resize.cleanup", function(event2) {
    removeFrame(event2.context);
  });
}
ResizePreview.$inject = [
  "eventBus",
  "canvas",
  "previewSupport"
];

// node_modules/diagram-js/lib/features/resize/ResizeHandles.js
var HANDLE_OFFSET = -6;
var HANDLE_SIZE = 8;
var HANDLE_HIT_SIZE = 20;
var CLS_RESIZER = "djs-resizer";
var directions = ["n", "w", "s", "e", "nw", "ne", "se", "sw"];
function ResizeHandles(eventBus, canvas, selection2, resize) {
  this._resize = resize;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("selection.changed", function(e8) {
    var newSelection = e8.newSelection;
    self2.removeResizers();
    if (newSelection.length === 1) {
      forEach(newSelection, bind(self2.addResizer, self2));
    }
  });
  eventBus.on("shape.changed", function(e8) {
    var shape = e8.element;
    if (selection2.isSelected(shape)) {
      self2.removeResizers();
      self2.addResizer(shape);
    }
  });
}
ResizeHandles.prototype.makeDraggable = function(element, gfx, direction) {
  var resize = this._resize;
  function startResize(event2) {
    if (isPrimaryButton(event2)) {
      resize.activate(event2, element, direction);
    }
  }
  event.bind(gfx, "mousedown", startResize);
  event.bind(gfx, "touchstart", startResize);
};
ResizeHandles.prototype._createResizer = function(element, x6, y5, direction) {
  var resizersParent = this._getResizersParent();
  var offset = getHandleOffset(direction);
  var group = create("g");
  classes(group).add(CLS_RESIZER);
  classes(group).add(CLS_RESIZER + "-" + element.id);
  classes(group).add(CLS_RESIZER + "-" + direction);
  append(resizersParent, group);
  var visual = create("rect");
  attr(visual, {
    x: -HANDLE_SIZE / 2 + offset.x,
    y: -HANDLE_SIZE / 2 + offset.y,
    width: HANDLE_SIZE,
    height: HANDLE_SIZE
  });
  classes(visual).add(CLS_RESIZER + "-visual");
  append(group, visual);
  var hit = create("rect");
  attr(hit, {
    x: -HANDLE_HIT_SIZE / 2 + offset.x,
    y: -HANDLE_HIT_SIZE / 2 + offset.y,
    width: HANDLE_HIT_SIZE,
    height: HANDLE_HIT_SIZE
  });
  classes(hit).add(CLS_RESIZER + "-hit");
  append(group, hit);
  transform2(group, x6, y5);
  return group;
};
ResizeHandles.prototype.createResizer = function(element, direction) {
  var point = getReferencePoint2(element, direction);
  var resizer = this._createResizer(element, point.x, point.y, direction);
  this.makeDraggable(element, resizer, direction);
};
ResizeHandles.prototype.addResizer = function(element) {
  var self2 = this;
  if (isConnection(element) || !this._resize.canResize({ shape: element })) {
    return;
  }
  forEach(directions, function(direction) {
    self2.createResizer(element, direction);
  });
};
ResizeHandles.prototype.removeResizers = function() {
  var resizersParent = this._getResizersParent();
  clear(resizersParent);
};
ResizeHandles.prototype._getResizersParent = function() {
  return this._canvas.getLayer("resizers");
};
ResizeHandles.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "resize"
];
function getHandleOffset(direction) {
  var offset = {
    x: 0,
    y: 0
  };
  if (direction.indexOf("e") !== -1) {
    offset.x = -HANDLE_OFFSET;
  } else if (direction.indexOf("w") !== -1) {
    offset.x = HANDLE_OFFSET;
  }
  if (direction.indexOf("s") !== -1) {
    offset.y = -HANDLE_OFFSET;
  } else if (direction.indexOf("n") !== -1) {
    offset.y = HANDLE_OFFSET;
  }
  return offset;
}

// node_modules/diagram-js/lib/features/resize/index.js
var resize_default = {
  __depends__: [
    rules_default,
    dragging_default,
    preview_support_default
  ],
  __init__: [
    "resize",
    "resizePreview",
    "resizeHandles"
  ],
  resize: ["type", Resize],
  resizePreview: ["type", ResizePreview],
  resizeHandles: ["type", ResizeHandles]
};

// node_modules/bpmn-js/lib/features/label-editing/LabelEditingProvider.js
var HIGH_PRIORITY17 = 2e3;
function LabelEditingProvider(eventBus, bpmnFactory, canvas, directEditing, modeling, resizeHandles, textRenderer) {
  this._bpmnFactory = bpmnFactory;
  this._canvas = canvas;
  this._modeling = modeling;
  this._textRenderer = textRenderer;
  directEditing.registerProvider(this);
  eventBus.on("element.dblclick", function(event2) {
    activateDirectEdit(event2.element, true);
  });
  eventBus.on([
    "autoPlace.start",
    "canvas.viewbox.changing",
    "drag.init",
    "element.mousedown",
    "popupMenu.open",
    "root.set",
    "selection.changed"
  ], function() {
    if (directEditing.isActive()) {
      directEditing.complete();
    }
  });
  eventBus.on([
    "shape.remove",
    "connection.remove"
  ], HIGH_PRIORITY17, function(event2) {
    if (directEditing.isActive(event2.element)) {
      directEditing.cancel();
    }
  });
  eventBus.on(["commandStack.changed"], function(e8) {
    if (directEditing.isActive()) {
      directEditing.cancel();
    }
  });
  eventBus.on("directEditing.activate", function(event2) {
    resizeHandles.removeResizers();
  });
  eventBus.on("create.end", 500, function(event2) {
    var context = event2.context, element = context.shape, canExecute = event2.context.canExecute, isTouch = event2.isTouch;
    if (isTouch) {
      return;
    }
    if (!canExecute) {
      return;
    }
    if (context.hints && context.hints.createElementsBehavior === false) {
      return;
    }
    activateDirectEdit(element);
  });
  eventBus.on("autoPlace.end", 500, function(event2) {
    activateDirectEdit(event2.shape);
  });
  function activateDirectEdit(element, force) {
    if (force || isAny(element, ["bpmn:Task", "bpmn:TextAnnotation", "bpmn:Participant"]) || isCollapsedSubProcess(element)) {
      directEditing.activate(element);
    }
  }
}
LabelEditingProvider.$inject = [
  "eventBus",
  "bpmnFactory",
  "canvas",
  "directEditing",
  "modeling",
  "resizeHandles",
  "textRenderer"
];
LabelEditingProvider.prototype.activate = function(element) {
  var text = getLabel(element);
  if (text === void 0) {
    return;
  }
  var context = {
    text
  };
  var bounds = this.getEditingBBox(element);
  assign(context, bounds);
  var options = {};
  var style = context.style || {};
  assign(style, {
    backgroundColor: null,
    border: null
  });
  if (isAny(element, [
    "bpmn:Task",
    "bpmn:Participant",
    "bpmn:Lane",
    "bpmn:CallActivity"
  ]) || isCollapsedSubProcess(element)) {
    assign(options, {
      centerVertically: true
    });
  }
  if (isLabelExternal(element)) {
    assign(options, {
      autoResize: true
    });
    assign(style, {
      backgroundColor: "#ffffff",
      border: "1px solid #ccc"
    });
  }
  if (is(element, "bpmn:TextAnnotation")) {
    assign(options, {
      resizable: true,
      autoResize: true
    });
    assign(style, {
      backgroundColor: "#ffffff",
      border: "1px solid #ccc"
    });
  }
  assign(context, {
    options,
    style
  });
  return context;
};
LabelEditingProvider.prototype.getEditingBBox = function(element) {
  var canvas = this._canvas;
  var target = element.label || element;
  var bbox = canvas.getAbsoluteBBox(target);
  var mid4 = {
    x: bbox.x + bbox.width / 2,
    y: bbox.y + bbox.height / 2
  };
  var bounds = { x: bbox.x, y: bbox.y };
  var zoom2 = canvas.zoom();
  var defaultStyle = this._textRenderer.getDefaultStyle(), externalStyle = this._textRenderer.getExternalStyle();
  var externalFontSize = externalStyle.fontSize * zoom2, externalLineHeight = externalStyle.lineHeight, defaultFontSize = defaultStyle.fontSize * zoom2, defaultLineHeight = defaultStyle.lineHeight;
  var style = {
    fontFamily: this._textRenderer.getDefaultStyle().fontFamily,
    fontWeight: this._textRenderer.getDefaultStyle().fontWeight
  };
  if (is(element, "bpmn:Lane") || isExpandedPool(element)) {
    var isHorizontalLane = isHorizontal(element);
    var laneBounds = isHorizontalLane ? {
      width: bbox.height,
      height: 30 * zoom2,
      x: bbox.x - bbox.height / 2 + 15 * zoom2,
      y: mid4.y - 30 * zoom2 / 2
    } : {
      width: bbox.width,
      height: 30 * zoom2
    };
    assign(bounds, laneBounds);
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: isHorizontalLane ? "rotate(-90deg)" : null
    });
  }
  if (isCollapsedPool2(element)) {
    var isHorizontalPool = isHorizontal(element);
    var poolBounds = isHorizontalPool ? {
      width: bbox.width,
      height: bbox.height
    } : {
      width: bbox.height,
      height: bbox.width,
      x: mid4.x - bbox.height / 2,
      y: mid4.y - bbox.width / 2
    };
    assign(bounds, poolBounds);
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      transform: isHorizontalPool ? null : "rotate(-90deg)"
    });
  }
  if (isAny(element, ["bpmn:Task", "bpmn:CallActivity"]) || isCollapsedSubProcess(element)) {
    assign(bounds, {
      width: bbox.width,
      height: bbox.height
    });
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  if (isExpandedSubProcess2(element)) {
    assign(bounds, {
      width: bbox.width,
      x: bbox.x
    });
    assign(style, {
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight,
      paddingTop: 7 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 5 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px"
    });
  }
  var width = 90 * zoom2, paddingTop = 7 * zoom2, paddingBottom = 4 * zoom2;
  if (target.labelTarget) {
    assign(bounds, {
      width,
      height: bbox.height + paddingTop + paddingBottom,
      x: mid4.x - width / 2,
      y: bbox.y - paddingTop
    });
    assign(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (isLabelExternal(target) && !hasExternalLabel(target) && !isLabel(target)) {
    var externalLabelMid = getExternalLabelMid(element);
    var absoluteBBox = canvas.getAbsoluteBBox({
      x: externalLabelMid.x,
      y: externalLabelMid.y,
      width: 0,
      height: 0
    });
    var height = externalFontSize + paddingTop + paddingBottom;
    assign(bounds, {
      width,
      height,
      x: absoluteBBox.x - width / 2,
      y: absoluteBBox.y - height / 2
    });
    assign(style, {
      fontSize: externalFontSize + "px",
      lineHeight: externalLineHeight,
      paddingTop: paddingTop + "px",
      paddingBottom: paddingBottom + "px"
    });
  }
  if (is(element, "bpmn:TextAnnotation")) {
    assign(bounds, {
      width: bbox.width,
      height: bbox.height,
      minWidth: 30 * zoom2,
      minHeight: 10 * zoom2
    });
    assign(style, {
      textAlign: "left",
      paddingTop: 5 * zoom2 + "px",
      paddingBottom: 7 * zoom2 + "px",
      paddingLeft: 7 * zoom2 + "px",
      paddingRight: 5 * zoom2 + "px",
      fontSize: defaultFontSize + "px",
      lineHeight: defaultLineHeight
    });
  }
  return { bounds, style };
};
LabelEditingProvider.prototype.update = function(element, newLabel, activeContextText, bounds) {
  var newBounds, bbox;
  if (is(element, "bpmn:TextAnnotation")) {
    bbox = this._canvas.getAbsoluteBBox(element);
    newBounds = {
      x: element.x,
      y: element.y,
      width: element.width / bbox.width * bounds.width,
      height: element.height / bbox.height * bounds.height
    };
  }
  if (isEmptyText2(newLabel)) {
    newLabel = null;
  }
  this._modeling.updateLabel(element, newLabel, newBounds);
};
function isCollapsedSubProcess(element) {
  return is(element, "bpmn:SubProcess") && !isExpanded(element);
}
function isExpandedSubProcess2(element) {
  return is(element, "bpmn:SubProcess") && isExpanded(element);
}
function isCollapsedPool2(element) {
  return is(element, "bpmn:Participant") && !isExpanded(element);
}
function isExpandedPool(element) {
  return is(element, "bpmn:Participant") && isExpanded(element);
}
function isEmptyText2(label) {
  return !label || !label.trim();
}

// node_modules/bpmn-js/lib/features/label-editing/LabelEditingPreview.js
var MARKER_HIDDEN2 = "djs-element-hidden";
var MARKER_LABEL_HIDDEN = "djs-label-hidden";
function LabelEditingPreview(eventBus, canvas, pathMap) {
  var self2 = this;
  var defaultLayer = canvas.getDefaultLayer();
  var element, absoluteElementBBox, gfx;
  eventBus.on("directEditing.activate", function(context) {
    var activeProvider = context.active;
    element = activeProvider.element.label || activeProvider.element;
    if (is(element, "bpmn:TextAnnotation")) {
      absoluteElementBBox = canvas.getAbsoluteBBox(element);
      gfx = create("g");
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: element.height,
        position: {
          mx: 0,
          my: 0
        }
      });
      var path = self2.path = create("path");
      attr(path, {
        d: textPathData,
        strokeWidth: 2,
        stroke: getStrokeColor3(element)
      });
      append(gfx, path);
      append(defaultLayer, gfx);
      translate(gfx, element.x, element.y);
    }
    if (is(element, "bpmn:TextAnnotation") || element.labelTarget) {
      canvas.addMarker(element, MARKER_HIDDEN2);
    } else if (is(element, "bpmn:Task") || is(element, "bpmn:CallActivity") || is(element, "bpmn:SubProcess") || is(element, "bpmn:Participant") || is(element, "bpmn:Lane")) {
      canvas.addMarker(element, MARKER_LABEL_HIDDEN);
    }
  });
  eventBus.on("directEditing.resize", function(context) {
    if (is(element, "bpmn:TextAnnotation")) {
      var height = context.height, dy = context.dy;
      var newElementHeight = Math.max(element.height / absoluteElementBBox.height * (height + dy), 0);
      var textPathData = pathMap.getScaledPath("TEXT_ANNOTATION", {
        xScaleFactor: 1,
        yScaleFactor: 1,
        containerWidth: element.width,
        containerHeight: newElementHeight,
        position: {
          mx: 0,
          my: 0
        }
      });
      attr(self2.path, {
        d: textPathData
      });
    }
  });
  eventBus.on(["directEditing.complete", "directEditing.cancel"], function(context) {
    var activeProvider = context.active;
    if (activeProvider) {
      canvas.removeMarker(activeProvider.element.label || activeProvider.element, MARKER_HIDDEN2);
      canvas.removeMarker(element, MARKER_LABEL_HIDDEN);
    }
    element = void 0;
    absoluteElementBBox = void 0;
    if (gfx) {
      remove(gfx);
      gfx = void 0;
    }
  });
}
LabelEditingPreview.$inject = [
  "eventBus",
  "canvas",
  "pathMap"
];
function getStrokeColor3(element, defaultColor) {
  var di = getDi(element);
  return di.get("stroke") || defaultColor || "black";
}

// node_modules/bpmn-js/lib/features/label-editing/index.js
var label_editing_default = {
  __depends__: [
    change_support_default,
    resize_default,
    lib_default
  ],
  __init__: [
    "labelEditingProvider",
    "labelEditingPreview"
  ],
  labelEditingProvider: ["type", LabelEditingProvider],
  labelEditingPreview: ["type", LabelEditingPreview]
};

// node_modules/diagram-js/lib/features/tooltips/Tooltips.js
var ids2 = new IdGenerator("tt");
function createRoot2(parentNode) {
  var root = domify$1(
    '<div class="djs-tooltip-container" />'
  );
  assign2(root, {
    position: "absolute",
    width: "0",
    height: "0"
  });
  parentNode.insertBefore(root, parentNode.firstChild);
  return root;
}
function setPosition2(el, x6, y5) {
  assign2(el, { left: x6 + "px", top: y5 + "px" });
}
function setVisible2(el, visible) {
  el.style.display = visible === false ? "none" : "";
}
var tooltipClass = "djs-tooltip";
var tooltipSelector = "." + tooltipClass;
function Tooltips(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._ids = ids2;
  this._tooltipDefaults = {
    show: {
      minZoom: 0.7,
      maxZoom: 5
    }
  };
  this._tooltips = {};
  this._tooltipRoot = createRoot2(canvas.getContainer());
  var self2 = this;
  delegate.bind(this._tooltipRoot, tooltipSelector, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseover", function(event2) {
    self2.trigger("mouseover", event2);
  });
  delegate.bind(this._tooltipRoot, tooltipSelector, "mouseout", function(event2) {
    self2.trigger("mouseout", event2);
  });
  this._init();
}
Tooltips.$inject = ["eventBus", "canvas"];
Tooltips.prototype.add = function(tooltip) {
  if (!tooltip.position) {
    throw new Error("must specifiy tooltip position");
  }
  if (!tooltip.html) {
    throw new Error("must specifiy tooltip html");
  }
  var id = this._ids.next();
  tooltip = assign({}, this._tooltipDefaults, tooltip, {
    id
  });
  this._addTooltip(tooltip);
  if (tooltip.timeout) {
    this.setTimeout(tooltip);
  }
  return id;
};
Tooltips.prototype.trigger = function(action, event2) {
  var node2 = event2.delegateTarget || event2.target;
  var tooltip = this.get(attr2(node2, "data-tooltip-id"));
  if (!tooltip) {
    return;
  }
  if (action === "mouseover" && tooltip.timeout) {
    this.clearTimeout(tooltip);
  }
  if (action === "mouseout" && tooltip.timeout) {
    tooltip.timeout = 1e3;
    this.setTimeout(tooltip);
  }
};
Tooltips.prototype.get = function(id) {
  if (typeof id !== "string") {
    id = id.id;
  }
  return this._tooltips[id];
};
Tooltips.prototype.clearTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  var removeTimer = tooltip.removeTimer;
  if (removeTimer) {
    clearTimeout(removeTimer);
    tooltip.removeTimer = null;
  }
};
Tooltips.prototype.setTimeout = function(tooltip) {
  tooltip = this.get(tooltip);
  if (!tooltip) {
    return;
  }
  this.clearTimeout(tooltip);
  var self2 = this;
  tooltip.removeTimer = setTimeout(function() {
    self2.remove(tooltip);
  }, tooltip.timeout);
};
Tooltips.prototype.remove = function(id) {
  var tooltip = this.get(id);
  if (tooltip) {
    remove2(tooltip.html);
    remove2(tooltip.htmlContainer);
    delete tooltip.htmlContainer;
    delete this._tooltips[tooltip.id];
  }
};
Tooltips.prototype.show = function() {
  setVisible2(this._tooltipRoot);
};
Tooltips.prototype.hide = function() {
  setVisible2(this._tooltipRoot, false);
};
Tooltips.prototype._updateRoot = function(viewbox) {
  var a6 = viewbox.scale || 1;
  var d5 = viewbox.scale || 1;
  var matrix = "matrix(" + a6 + ",0,0," + d5 + "," + -1 * viewbox.x * a6 + "," + -1 * viewbox.y * d5 + ")";
  this._tooltipRoot.style.transform = matrix;
  this._tooltipRoot.style["-ms-transform"] = matrix;
};
Tooltips.prototype._addTooltip = function(tooltip) {
  var id = tooltip.id, html = tooltip.html, htmlContainer, tooltipRoot = this._tooltipRoot;
  if (html.get && html.constructor.prototype.jquery) {
    html = html.get(0);
  }
  if (isString(html)) {
    html = domify$1(html);
  }
  htmlContainer = domify$1('<div data-tooltip-id="' + id + '" class="' + tooltipClass + '">');
  assign2(htmlContainer, { position: "absolute" });
  htmlContainer.appendChild(html);
  if (tooltip.type) {
    classes2(htmlContainer).add("djs-tooltip-" + tooltip.type);
  }
  if (tooltip.className) {
    classes2(htmlContainer).add(tooltip.className);
  }
  tooltip.htmlContainer = htmlContainer;
  tooltipRoot.appendChild(htmlContainer);
  this._tooltips[id] = tooltip;
  this._updateTooltip(tooltip);
};
Tooltips.prototype._updateTooltip = function(tooltip) {
  var position = tooltip.position, htmlContainer = tooltip.htmlContainer;
  setPosition2(htmlContainer, position.x, position.y);
};
Tooltips.prototype._updateTooltipVisibilty = function(viewbox) {
  forEach(this._tooltips, function(tooltip) {
    var show = tooltip.show, htmlContainer = tooltip.htmlContainer, visible = true;
    if (show) {
      if (show.minZoom > viewbox.scale || show.maxZoom < viewbox.scale) {
        visible = false;
      }
      setVisible2(htmlContainer, visible);
    }
  });
};
Tooltips.prototype._init = function() {
  var self2 = this;
  function updateViewbox(viewbox) {
    self2._updateRoot(viewbox);
    self2._updateTooltipVisibilty(viewbox);
    self2.show();
  }
  this._eventBus.on("canvas.viewbox.changing", function(event2) {
    self2.hide();
  });
  this._eventBus.on("canvas.viewbox.changed", function(event2) {
    updateViewbox(event2.viewbox);
  });
};

// node_modules/diagram-js/lib/features/tooltips/index.js
var tooltips_default = {
  __init__: ["tooltips"],
  tooltips: ["type", Tooltips]
};

// node_modules/bpmn-js/lib/features/modeling-feedback/ModelingFeedback.js
var COLLAB_ERR_MSG = "flow elements must be children of pools/participants";
function ModelingFeedback(eventBus, tooltips3, translate4) {
  function showError(position, message, timeout) {
    tooltips3.add({
      position: {
        x: position.x + 5,
        y: position.y + 5
      },
      type: "error",
      timeout: timeout || 2e3,
      html: "<div>" + message + "</div>"
    });
  }
  eventBus.on(["shape.move.rejected", "create.rejected"], function(event2) {
    var context = event2.context, shape = context.shape, target = context.target;
    if (is(target, "bpmn:Collaboration") && is(shape, "bpmn:FlowNode")) {
      showError(event2, translate4(COLLAB_ERR_MSG));
    }
  });
}
ModelingFeedback.$inject = [
  "eventBus",
  "tooltips",
  "translate"
];

// node_modules/bpmn-js/lib/features/modeling-feedback/index.js
var modeling_feedback_default = {
  __depends__: [
    tooltips_default
  ],
  __init__: [
    "modelingFeedback"
  ],
  modelingFeedback: ["type", ModelingFeedback]
};

// node_modules/diagram-js/lib/features/outline/Outline.js
var LOW_PRIORITY24 = 500;
var DEFAULT_PRIORITY6 = 1e3;
function Outline(eventBus, styles) {
  this._eventBus = eventBus;
  this.offset = 5;
  var OUTLINE_STYLE = styles.cls("djs-outline", ["no-fill"]);
  var self2 = this;
  function createOutline(gfx) {
    var outline = create("rect");
    attr(outline, assign({
      x: 0,
      y: 0,
      rx: 4,
      width: 100,
      height: 100
    }, OUTLINE_STYLE));
    return outline;
  }
  eventBus.on(["shape.added", "shape.changed"], LOW_PRIORITY24, function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = self2.getOutline(element) || createOutline(gfx);
      append(gfx, outline);
    }
    self2.updateShapeOutline(outline, element);
  });
  eventBus.on(["connection.added", "connection.changed"], function(event2) {
    var element = event2.element, gfx = event2.gfx;
    var outline = query(".djs-outline", gfx);
    if (!outline) {
      outline = createOutline(gfx);
      append(gfx, outline);
    }
    self2.updateConnectionOutline(outline, element);
  });
}
Outline.prototype.updateShapeOutline = function(outline, element) {
  var updated = false;
  var providers = this._getProviders();
  if (providers.length) {
    forEach(providers, function(provider) {
      updated = updated || provider.updateOutline(element, outline);
    });
  }
  if (!updated) {
    attr(outline, {
      x: -this.offset,
      y: -this.offset,
      width: element.width + this.offset * 2,
      height: element.height + this.offset * 2
    });
  }
};
Outline.prototype.updateConnectionOutline = function(outline, connection) {
  var bbox = getBBox(connection);
  attr(outline, {
    x: bbox.x - this.offset,
    y: bbox.y - this.offset,
    width: bbox.width + this.offset * 2,
    height: bbox.height + this.offset * 2
  });
};
Outline.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY6;
  }
  this._eventBus.on("outline.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
};
Outline.prototype._getProviders = function() {
  var event2 = this._eventBus.createEvent({
    type: "outline.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Outline.prototype.getOutline = function(element) {
  var outline;
  var providers = this._getProviders();
  forEach(providers, function(provider) {
    if (!isFunction(provider.getOutline)) {
      return;
    }
    outline = outline || provider.getOutline(element);
  });
  return outline;
};
Outline.$inject = ["eventBus", "styles", "elementRegistry"];

// node_modules/diagram-js/lib/features/outline/MultiSelectionOutline.js
var SELECTION_OUTLINE_PADDING = 6;
function MultiSelectionOutline(eventBus, canvas, selection2) {
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("element.changed", function(event2) {
    if (selection2.isSelected(event2.element)) {
      self2._updateMultiSelectionOutline(selection2.get());
    }
  });
  eventBus.on("selection.changed", function(event2) {
    var newSelection = event2.newSelection;
    self2._updateMultiSelectionOutline(newSelection);
  });
}
MultiSelectionOutline.prototype._updateMultiSelectionOutline = function(selection2) {
  var layer = this._canvas.getLayer("selectionOutline");
  clear(layer);
  var enabled = selection2.length > 1;
  var container = this._canvas.getContainer();
  classes(container)[enabled ? "add" : "remove"]("djs-multi-select");
  if (!enabled) {
    return;
  }
  var bBox = addSelectionOutlinePadding(getBBox(selection2));
  var rect = create("rect");
  attr(rect, assign({
    rx: 3
  }, bBox));
  classes(rect).add("djs-selection-outline");
  append(layer, rect);
};
MultiSelectionOutline.$inject = ["eventBus", "canvas", "selection"];
function addSelectionOutlinePadding(bBox) {
  return {
    x: bBox.x - SELECTION_OUTLINE_PADDING,
    y: bBox.y - SELECTION_OUTLINE_PADDING,
    width: bBox.width + SELECTION_OUTLINE_PADDING * 2,
    height: bBox.height + SELECTION_OUTLINE_PADDING * 2
  };
}

// node_modules/diagram-js/lib/features/outline/index.js
var outline_default = {
  __depends__: [
    selection_default
  ],
  __init__: ["outline", "multiSelectionOutline"],
  outline: ["type", Outline],
  multiSelectionOutline: ["type", MultiSelectionOutline]
};

// node_modules/diagram-js/lib/features/move/Move.js
var LOW_PRIORITY25 = 500;
var MEDIUM_PRIORITY = 1250;
var HIGH_PRIORITY18 = 1500;
var round13 = Math.round;
function mid3(element) {
  return {
    x: element.x + round13(element.width / 2),
    y: element.y + round13(element.height / 2)
  };
}
function MoveEvents(eventBus, dragging, modeling, selection2, rules) {
  function canMove2(shapes, delta2, position, target) {
    return rules.allowed("elements.move", {
      shapes,
      delta: delta2,
      position,
      target
    });
  }
  eventBus.on("shape.move.start", HIGH_PRIORITY18, function(event2) {
    var context = event2.context, shape = event2.shape, shapes = selection2.get().slice();
    if (shapes.indexOf(shape) === -1) {
      shapes = [shape];
    }
    shapes = removeNested(shapes);
    assign(context, {
      shapes,
      validatedShapes: shapes,
      shape
    });
  });
  eventBus.on("shape.move.start", MEDIUM_PRIORITY, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, canExecute;
    canExecute = context.canExecute = canMove2(validatedShapes);
    if (!canExecute) {
      return false;
    }
  });
  eventBus.on("shape.move.move", LOW_PRIORITY25, function(event2) {
    var context = event2.context, validatedShapes = context.validatedShapes, hover = event2.hover, delta2 = { x: event2.dx, y: event2.dy }, position = { x: event2.x, y: event2.y }, canExecute;
    canExecute = canMove2(validatedShapes, delta2, position, hover);
    context.delta = delta2;
    context.canExecute = canExecute;
    if (canExecute === null) {
      context.target = null;
      return;
    }
    context.target = hover;
  });
  eventBus.on("shape.move.end", function(event2) {
    var context = event2.context;
    var delta2 = context.delta, canExecute = context.canExecute, isAttach = canExecute === "attach", shapes = context.shapes;
    if (canExecute === false) {
      return false;
    }
    delta2.x = round13(delta2.x);
    delta2.y = round13(delta2.y);
    if (delta2.x === 0 && delta2.y === 0) {
      return;
    }
    modeling.moveElements(shapes, delta2, context.target, {
      primaryShape: context.shape,
      attach: isAttach
    });
  });
  eventBus.on("element.mousedown", function(event2) {
    if (!isPrimaryButton(event2)) {
      return;
    }
    var originalEvent = getOriginal(event2);
    if (!originalEvent) {
      throw new Error("must supply DOM mousedown event");
    }
    return start(originalEvent, event2.element);
  });
  function start(event2, element, activate, context) {
    if (isObject(activate)) {
      context = activate;
      activate = false;
    }
    if (element.waypoints || !element.parent) {
      return;
    }
    if (classes(event2.target).has("djs-hit-no-move")) {
      return;
    }
    var referencePoint = mid3(element);
    dragging.init(event2, referencePoint, "shape.move", {
      cursor: "grabbing",
      autoActivate: activate,
      data: {
        shape: element,
        context: context || {}
      }
    });
    return true;
  }
  this.start = start;
}
MoveEvents.$inject = [
  "eventBus",
  "dragging",
  "modeling",
  "selection",
  "rules"
];
function removeNested(elements) {
  var ids3 = groupBy(elements, "id");
  return filter(elements, function(element) {
    while (element = element.parent) {
      if (ids3[element.id]) {
        return false;
      }
    }
    return true;
  });
}

// node_modules/diagram-js/lib/features/move/MovePreview.js
var LOW_PRIORITY26 = 499;
var MARKER_DRAGGING2 = "djs-dragging";
var MARKER_OK4 = "drop-ok";
var MARKER_NOT_OK4 = "drop-not-ok";
var MARKER_NEW_PARENT2 = "new-parent";
var MARKER_ATTACH3 = "attach-ok";
function MovePreview(eventBus, canvas, styles, previewSupport) {
  function getVisualDragShapes(shapes) {
    var elements = getAllDraggedElements(shapes);
    var filteredElements = removeEdges(elements);
    return filteredElements;
  }
  function getAllDraggedElements(shapes) {
    var allShapes = selfAndAllChildren(shapes, true);
    var allConnections = allShapes.flatMap(
      (shape) => (shape.incoming || []).concat(shape.outgoing || [])
    );
    var allElements = allShapes.concat(allConnections);
    var uniqueElements = [...new Set(allElements)];
    return uniqueElements;
  }
  function setMarker(element, marker) {
    [MARKER_ATTACH3, MARKER_OK4, MARKER_NOT_OK4, MARKER_NEW_PARENT2].forEach(function(m6) {
      if (m6 === marker) {
        canvas.addMarker(element, m6);
      } else {
        canvas.removeMarker(element, m6);
      }
    });
  }
  function makeDraggable(context, element, addMarker) {
    previewSupport.addDragger(element, context.dragGroup);
    if (addMarker) {
      canvas.addMarker(element, MARKER_DRAGGING2);
    }
    if (context.allDraggedElements) {
      context.allDraggedElements.push(element);
    } else {
      context.allDraggedElements = [element];
    }
  }
  eventBus.on("shape.move.start", LOW_PRIORITY26, function(event2) {
    var context = event2.context, dragShapes = context.shapes, allDraggedElements = context.allDraggedElements;
    var visuallyDraggedShapes = getVisualDragShapes(dragShapes);
    if (!context.dragGroup) {
      var dragGroup = create("g");
      attr(dragGroup, styles.cls("djs-drag-group", ["no-events"]));
      var activeLayer = canvas.getActiveLayer();
      append(activeLayer, dragGroup);
      context.dragGroup = dragGroup;
    }
    visuallyDraggedShapes.forEach(function(shape) {
      previewSupport.addDragger(shape, context.dragGroup);
    });
    if (!allDraggedElements) {
      allDraggedElements = getAllDraggedElements(dragShapes);
    } else {
      allDraggedElements = flatten([
        allDraggedElements,
        getAllDraggedElements(dragShapes)
      ]);
    }
    forEach(allDraggedElements, function(e8) {
      canvas.addMarker(e8, MARKER_DRAGGING2);
    });
    context.allDraggedElements = allDraggedElements;
    context.differentParents = haveDifferentParents(dragShapes);
  });
  eventBus.on("shape.move.move", LOW_PRIORITY26, function(event2) {
    var context = event2.context, dragGroup = context.dragGroup, target = context.target, parent = context.shape.parent, canExecute = context.canExecute;
    if (target) {
      if (canExecute === "attach") {
        setMarker(target, MARKER_ATTACH3);
      } else if (context.canExecute && parent && target.id !== parent.id) {
        setMarker(target, MARKER_NEW_PARENT2);
      } else {
        setMarker(target, context.canExecute ? MARKER_OK4 : MARKER_NOT_OK4);
      }
    }
    translate(dragGroup, event2.dx, event2.dy);
  });
  eventBus.on(["shape.move.out", "shape.move.cleanup"], function(event2) {
    var context = event2.context, target = context.target;
    if (target) {
      setMarker(target, null);
    }
  });
  eventBus.on("shape.move.cleanup", function(event2) {
    var context = event2.context, allDraggedElements = context.allDraggedElements, dragGroup = context.dragGroup;
    forEach(allDraggedElements, function(e8) {
      canvas.removeMarker(e8, MARKER_DRAGGING2);
    });
    if (dragGroup) {
      remove(dragGroup);
    }
  });
  this.makeDraggable = makeDraggable;
}
MovePreview.$inject = [
  "eventBus",
  "canvas",
  "styles",
  "previewSupport"
];
function removeEdges(elements) {
  var filteredElements = filter(elements, function(element) {
    if (!isConnection(element)) {
      return true;
    } else {
      return find(elements, matchPattern({ id: element.source.id })) && find(elements, matchPattern({ id: element.target.id }));
    }
  });
  return filteredElements;
}
function haveDifferentParents(elements) {
  return size(groupBy(elements, function(e8) {
    return e8.parent && e8.parent.id;
  })) !== 1;
}

// node_modules/diagram-js/lib/features/move/index.js
var move_default = {
  __depends__: [
    interaction_events_default,
    selection_default,
    outline_default,
    rules_default,
    dragging_default,
    preview_support_default
  ],
  __init__: [
    "move",
    "movePreview"
  ],
  move: ["type", MoveEvents],
  movePreview: ["type", MovePreview]
};

// node_modules/diagram-js/lib/features/palette/Palette.js
var TOGGLE_SELECTOR = ".djs-palette-toggle";
var ENTRY_SELECTOR = ".entry";
var ELEMENT_SELECTOR = TOGGLE_SELECTOR + ", " + ENTRY_SELECTOR;
var PALETTE_PREFIX = "djs-palette-";
var PALETTE_SHOWN_CLS = "shown";
var PALETTE_OPEN_CLS = "open";
var PALETTE_TWO_COLUMN_CLS = "two-column";
var DEFAULT_PRIORITY7 = 1e3;
function Palette(eventBus, canvas) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("tool-manager.update", function(event2) {
    var tool = event2.tool;
    self2.updateToolHighlight(tool);
  });
  eventBus.on("i18n.changed", function() {
    self2._update();
  });
  eventBus.on("diagram.init", function() {
    self2._diagramInitialized = true;
    self2._rebuild();
  });
}
Palette.$inject = ["eventBus", "canvas"];
Palette.prototype.registerProvider = function(priority, provider) {
  if (!provider) {
    provider = priority;
    priority = DEFAULT_PRIORITY7;
  }
  this._eventBus.on("palette.getProviders", priority, function(event2) {
    event2.providers.push(provider);
  });
  this._rebuild();
};
Palette.prototype.getEntries = function() {
  var providers = this._getProviders();
  return providers.reduce(addPaletteEntries, {});
};
Palette.prototype._rebuild = function() {
  if (!this._diagramInitialized) {
    return;
  }
  var providers = this._getProviders();
  if (!providers.length) {
    return;
  }
  if (!this._container) {
    this._init();
  }
  this._update();
};
Palette.prototype._init = function() {
  var self2 = this;
  var eventBus = this._eventBus;
  var parentContainer = this._getParentContainer();
  var container = this._container = domify$1(Palette.HTML_MARKUP);
  parentContainer.appendChild(container);
  classes2(parentContainer).add(PALETTE_PREFIX + PALETTE_SHOWN_CLS);
  delegate.bind(container, ELEMENT_SELECTOR, "click", function(event2) {
    var target = event2.delegateTarget;
    if (matches(target, TOGGLE_SELECTOR)) {
      return self2.toggle();
    }
    self2.trigger("click", event2);
  });
  event.bind(container, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  delegate.bind(container, ENTRY_SELECTOR, "dragstart", function(event2) {
    self2.trigger("dragstart", event2);
  });
  eventBus.on("canvas.resized", this._layoutChanged, this);
  eventBus.fire("palette.create", {
    container
  });
};
Palette.prototype._getProviders = function(id) {
  var event2 = this._eventBus.createEvent({
    type: "palette.getProviders",
    providers: []
  });
  this._eventBus.fire(event2);
  return event2.providers;
};
Palette.prototype._toggleState = function(state) {
  state = state || {};
  var parent = this._getParentContainer(), container = this._container;
  var eventBus = this._eventBus;
  var twoColumn;
  var cls = classes2(container), parentCls = classes2(parent);
  if ("twoColumn" in state) {
    twoColumn = state.twoColumn;
  } else {
    twoColumn = this._needsCollapse(parent.clientHeight, this._entries || {});
  }
  cls.toggle(PALETTE_TWO_COLUMN_CLS, twoColumn);
  parentCls.toggle(PALETTE_PREFIX + PALETTE_TWO_COLUMN_CLS, twoColumn);
  if ("open" in state) {
    cls.toggle(PALETTE_OPEN_CLS, state.open);
    parentCls.toggle(PALETTE_PREFIX + PALETTE_OPEN_CLS, state.open);
  }
  eventBus.fire("palette.changed", {
    twoColumn,
    open: this.isOpen()
  });
};
Palette.prototype._update = function() {
  var entriesContainer = query(".djs-palette-entries", this._container), entries = this._entries = this.getEntries();
  clear2(entriesContainer);
  forEach(entries, function(entry, id) {
    var grouping = entry.group || "default";
    var container = query("[data-group=" + escapeCSS(grouping) + "]", entriesContainer);
    if (!container) {
      container = domify$1('<div class="group"></div>');
      attr2(container, "data-group", grouping);
      entriesContainer.appendChild(container);
    }
    var html = entry.html || (entry.separator ? '<hr class="separator" />' : '<div class="entry" draggable="true"></div>');
    var control = domify$1(html);
    container.appendChild(control);
    if (!entry.separator) {
      attr2(control, "data-action", id);
      if (entry.title) {
        attr2(control, "title", entry.title);
      }
      if (entry.className) {
        addClasses2(control, entry.className);
      }
      if (entry.imageUrl) {
        var image = domify$1("<img>");
        attr2(image, "src", entry.imageUrl);
        control.appendChild(image);
      }
    }
  });
  this.open();
};
Palette.prototype.trigger = function(action, event2, autoActivate) {
  var entry, originalEvent, button = event2.delegateTarget || event2.target;
  if (!button) {
    return event2.preventDefault();
  }
  entry = attr2(button, "data-action");
  originalEvent = event2.originalEvent || event2;
  return this.triggerEntry(entry, action, originalEvent, autoActivate);
};
Palette.prototype.triggerEntry = function(entryId, action, event2, autoActivate) {
  var entries = this._entries, entry, handler;
  entry = entries[entryId];
  if (!entry) {
    return;
  }
  handler = entry.action;
  if (this._eventBus.fire("palette.trigger", { entry, event: event2 }) === false) {
    return;
  }
  if (isFunction(handler)) {
    if (action === "click") {
      return handler(event2, autoActivate);
    }
  } else {
    if (handler[action]) {
      return handler[action](event2, autoActivate);
    }
  }
  event2.preventDefault();
};
Palette.prototype._layoutChanged = function() {
  this._toggleState({});
};
Palette.prototype._needsCollapse = function(availableHeight, entries) {
  var margin = 20 + 10 + 20;
  var entriesHeight = Object.keys(entries).length * 46;
  return availableHeight < entriesHeight + margin;
};
Palette.prototype.close = function() {
  this._toggleState({
    open: false,
    twoColumn: false
  });
};
Palette.prototype.open = function() {
  this._toggleState({ open: true });
};
Palette.prototype.toggle = function() {
  if (this.isOpen()) {
    this.close();
  } else {
    this.open();
  }
};
Palette.prototype.isActiveTool = function(tool) {
  return tool && this._activeTool === tool;
};
Palette.prototype.updateToolHighlight = function(name2) {
  var entriesContainer, toolsContainer;
  if (!this._toolsContainer) {
    entriesContainer = query(".djs-palette-entries", this._container);
    this._toolsContainer = query("[data-group=tools]", entriesContainer);
  }
  toolsContainer = this._toolsContainer;
  forEach(toolsContainer.children, function(tool) {
    var actionName = tool.getAttribute("data-action");
    if (!actionName) {
      return;
    }
    var toolClasses = classes2(tool);
    actionName = actionName.replace("-tool", "");
    if (toolClasses.contains("entry") && actionName === name2) {
      toolClasses.add("highlighted-entry");
    } else {
      toolClasses.remove("highlighted-entry");
    }
  });
};
Palette.prototype.isOpen = function() {
  return classes2(this._container).has(PALETTE_OPEN_CLS);
};
Palette.prototype._getParentContainer = function() {
  return this._canvas.getContainer();
};
Palette.HTML_MARKUP = '<div class="djs-palette"><div class="djs-palette-entries"></div><div class="djs-palette-toggle"></div></div>';
function addClasses2(element, classNames) {
  var classes3 = classes2(element);
  var actualClassNames = isArray(classNames) ? classNames : classNames.split(/\s+/g);
  actualClassNames.forEach(function(cls) {
    classes3.add(cls);
  });
}
function addPaletteEntries(entries, provider) {
  var entriesOrUpdater = provider.getPaletteEntries();
  if (isFunction(entriesOrUpdater)) {
    return entriesOrUpdater(entries);
  }
  forEach(entriesOrUpdater, function(entry, id) {
    entries[id] = entry;
  });
  return entries;
}

// node_modules/diagram-js/lib/features/palette/index.js
var palette_default = {
  __init__: ["palette"],
  palette: ["type", Palette]
};

// node_modules/diagram-js/lib/features/lasso-tool/LassoTool.js
var LASSO_TOOL_CURSOR = "crosshair";
function LassoTool(eventBus, canvas, dragging, elementRegistry, selection2, toolManager, mouse) {
  this._selection = selection2;
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this;
  var visuals = {
    create: function(context) {
      var container = canvas.getActiveLayer(), frame;
      frame = context.frame = create("rect");
      attr(frame, {
        class: "djs-lasso-overlay",
        width: 1,
        height: 1,
        x: 0,
        y: 0
      });
      append(container, frame);
    },
    update: function(context) {
      var frame = context.frame, bbox = context.bbox;
      attr(frame, {
        x: bbox.x,
        y: bbox.y,
        width: bbox.width,
        height: bbox.height
      });
    },
    remove: function(context) {
      if (context.frame) {
        remove(context.frame);
      }
    }
  };
  toolManager.registerTool("lasso", {
    tool: "lasso.selection",
    dragging: "lasso"
  });
  eventBus.on("lasso.selection.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return;
    }
    eventBus.once("lasso.selection.ended", function() {
      self2.activateLasso(event2.originalEvent, true);
    });
  });
  eventBus.on("lasso.end", 0, function(event2) {
    var context = event2.context;
    var bbox = toBBox(event2);
    var elements = elementRegistry.filter(function(element) {
      return element;
    });
    var add5 = hasSecondaryModifier(event2);
    self2.select(elements, bbox, add5 ? context.selection : []);
  });
  eventBus.on("lasso.start", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.create(context);
    context.selection = selection2.get();
  });
  eventBus.on("lasso.move", function(event2) {
    var context = event2.context;
    context.bbox = toBBox(event2);
    visuals.update(context);
  });
  eventBus.on("lasso.cleanup", function(event2) {
    var context = event2.context;
    visuals.remove(context);
  });
  eventBus.on("element.mousedown", 1500, function(event2) {
    if (!hasSecondaryModifier(event2)) {
      return;
    }
    self2.activateLasso(event2.originalEvent);
    return true;
  });
}
LassoTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "elementRegistry",
  "selection",
  "toolManager",
  "mouse"
];
LassoTool.prototype.activateLasso = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso", {
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    }
  });
};
LassoTool.prototype.activateSelection = function(event2, autoActivate) {
  this._dragging.init(event2, "lasso.selection", {
    trapClick: false,
    autoActivate,
    cursor: LASSO_TOOL_CURSOR,
    data: {
      context: {}
    },
    keepSelection: true
  });
};
LassoTool.prototype.select = function(elements, bbox, previousSelection = []) {
  var selectedElements = getEnclosedElements(elements, bbox);
  this._selection.select([
    ...previousSelection,
    ...values(selectedElements)
  ]);
};
LassoTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateSelection(mouseEvent, !!mouseEvent);
};
LassoTool.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^lasso/.test(context.prefix);
};
function toBBox(event2) {
  var start = {
    x: event2.x - event2.dx,
    y: event2.y - event2.dy
  };
  var end = {
    x: event2.x,
    y: event2.y
  };
  var bbox;
  if (start.x <= end.x && start.y < end.y || start.x < end.x && start.y <= end.y) {
    bbox = {
      x: start.x,
      y: start.y,
      width: end.x - start.x,
      height: end.y - start.y
    };
  } else if (start.x >= end.x && start.y < end.y || start.x > end.x && start.y <= end.y) {
    bbox = {
      x: end.x,
      y: start.y,
      width: start.x - end.x,
      height: end.y - start.y
    };
  } else if (start.x <= end.x && start.y > end.y || start.x < end.x && start.y >= end.y) {
    bbox = {
      x: start.x,
      y: end.y,
      width: end.x - start.x,
      height: start.y - end.y
    };
  } else if (start.x >= end.x && start.y > end.y || start.x > end.x && start.y >= end.y) {
    bbox = {
      x: end.x,
      y: end.y,
      width: start.x - end.x,
      height: start.y - end.y
    };
  } else {
    bbox = {
      x: end.x,
      y: end.y,
      width: 0,
      height: 0
    };
  }
  return bbox;
}

// node_modules/diagram-js/lib/features/lasso-tool/index.js
var lasso_tool_default = {
  __depends__: [
    tool_manager_default,
    mouse_default
  ],
  __init__: ["lassoTool"],
  lassoTool: ["type", LassoTool]
};

// node_modules/diagram-js/lib/features/hand-tool/HandTool.js
var HIGH_PRIORITY19 = 1500;
var HAND_CURSOR = "grab";
function HandTool(eventBus, canvas, dragging, injector, toolManager, mouse) {
  this._dragging = dragging;
  this._mouse = mouse;
  var self2 = this, keyboard = injector.get("keyboard", false);
  toolManager.registerTool("hand", {
    tool: "hand",
    dragging: "hand.move"
  });
  eventBus.on("element.mousedown", HIGH_PRIORITY19, function(event2) {
    if (!hasPrimaryModifier(event2)) {
      return;
    }
    self2.activateMove(event2.originalEvent, true);
    return false;
  });
  keyboard && keyboard.addListener(HIGH_PRIORITY19, function(e8) {
    if (!isSpace(e8.keyEvent) || self2.isActive()) {
      return;
    }
    var mouseEvent = self2._mouse.getLastMoveEvent();
    self2.activateMove(mouseEvent, !!mouseEvent);
  }, "keyboard.keydown");
  keyboard && keyboard.addListener(HIGH_PRIORITY19, function(e8) {
    if (!isSpace(e8.keyEvent) || !self2.isActive()) {
      return;
    }
    self2.toggle();
  }, "keyboard.keyup");
  eventBus.on("hand.end", function(event2) {
    var target = event2.originalEvent.target;
    if (!event2.hover && !(target instanceof SVGElement)) {
      return false;
    }
    eventBus.once("hand.ended", function() {
      self2.activateMove(event2.originalEvent, { reactivate: true });
    });
  });
  eventBus.on("hand.move.move", function(event2) {
    var scale = canvas.viewbox().scale;
    canvas.scroll({
      dx: event2.dx * scale,
      dy: event2.dy * scale
    });
  });
  eventBus.on("hand.move.end", function(event2) {
    var context = event2.context, reactivate = context.reactivate;
    if (!hasPrimaryModifier(event2) && reactivate) {
      eventBus.once("hand.move.ended", function(event3) {
        self2.activateHand(event3.originalEvent, true, true);
      });
    }
    return false;
  });
}
HandTool.$inject = [
  "eventBus",
  "canvas",
  "dragging",
  "injector",
  "toolManager",
  "mouse"
];
HandTool.prototype.activateMove = function(event2, autoActivate, context) {
  if (typeof autoActivate === "object") {
    context = autoActivate;
    autoActivate = false;
  }
  this._dragging.init(event2, "hand.move", {
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: context || {}
    }
  });
};
HandTool.prototype.activateHand = function(event2, autoActivate, reactivate) {
  this._dragging.init(event2, "hand", {
    trapClick: false,
    autoActivate,
    cursor: HAND_CURSOR,
    data: {
      context: {
        reactivate
      }
    }
  });
};
HandTool.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  this.activateHand(mouseEvent, !!mouseEvent);
};
HandTool.prototype.isActive = function() {
  var context = this._dragging.context();
  if (context) {
    return /^(hand|hand\.move)$/.test(context.prefix);
  }
  return false;
};
function isSpace(keyEvent) {
  return isKey("Space", keyEvent);
}

// node_modules/diagram-js/lib/features/hand-tool/index.js
var hand_tool_default = {
  __depends__: [
    tool_manager_default,
    mouse_default
  ],
  __init__: ["handTool"],
  handTool: ["type", HandTool]
};

// node_modules/diagram-js/lib/features/global-connect/GlobalConnect.js
var MARKER_OK5 = "connect-ok";
var MARKER_NOT_OK5 = "connect-not-ok";
function GlobalConnect(eventBus, dragging, connect, canvas, toolManager, rules, mouse) {
  var self2 = this;
  this._dragging = dragging;
  this._rules = rules;
  this._mouse = mouse;
  toolManager.registerTool("global-connect", {
    tool: "global-connect",
    dragging: "global-connect.drag"
  });
  eventBus.on("global-connect.hover", function(event2) {
    var context = event2.context, startTarget = event2.hover;
    var canStartConnect = context.canStartConnect = self2.canStartConnect(startTarget);
    if (canStartConnect === null) {
      return;
    }
    context.startTarget = startTarget;
    canvas.addMarker(startTarget, canStartConnect ? MARKER_OK5 : MARKER_NOT_OK5);
  });
  eventBus.on(["global-connect.out", "global-connect.cleanup"], function(event2) {
    var startTarget = event2.context.startTarget, canStartConnect = event2.context.canStartConnect;
    if (startTarget) {
      canvas.removeMarker(startTarget, canStartConnect ? MARKER_OK5 : MARKER_NOT_OK5);
    }
  });
  eventBus.on(["global-connect.ended"], function(event2) {
    var context = event2.context, startTarget = context.startTarget, startPosition = {
      x: event2.x,
      y: event2.y
    };
    var canStartConnect = self2.canStartConnect(startTarget);
    if (!canStartConnect) {
      return;
    }
    eventBus.once("element.out", function() {
      eventBus.once(["connect.ended", "connect.canceled"], function() {
        eventBus.fire("global-connect.drag.ended");
      });
      connect.start(null, startTarget, startPosition);
    });
    return false;
  });
}
GlobalConnect.$inject = [
  "eventBus",
  "dragging",
  "connect",
  "canvas",
  "toolManager",
  "rules",
  "mouse"
];
GlobalConnect.prototype.start = function(event2, autoActivate) {
  this._dragging.init(event2, "global-connect", {
    autoActivate,
    trapClick: false,
    data: {
      context: {}
    }
  });
};
GlobalConnect.prototype.toggle = function() {
  if (this.isActive()) {
    return this._dragging.cancel();
  }
  var mouseEvent = this._mouse.getLastMoveEvent();
  return this.start(mouseEvent, !!mouseEvent);
};
GlobalConnect.prototype.isActive = function() {
  var context = this._dragging.context();
  return context && /^global-connect/.test(context.prefix);
};
GlobalConnect.prototype.canStartConnect = function(startTarget) {
  return this._rules.allowed("connection.start", { source: startTarget });
};

// node_modules/diagram-js/lib/features/global-connect/index.js
var global_connect_default = {
  __depends__: [
    connect_default,
    rules_default,
    dragging_default,
    tool_manager_default,
    mouse_default
  ],
  globalConnect: ["type", GlobalConnect]
};

// node_modules/bpmn-js/lib/features/palette/PaletteProvider.js
function PaletteProvider(palette, create3, elementFactory, spaceTool, lassoTool, handTool, globalConnect, translate4) {
  this._palette = palette;
  this._create = create3;
  this._elementFactory = elementFactory;
  this._spaceTool = spaceTool;
  this._lassoTool = lassoTool;
  this._handTool = handTool;
  this._globalConnect = globalConnect;
  this._translate = translate4;
  palette.registerProvider(this);
}
PaletteProvider.$inject = [
  "palette",
  "create",
  "elementFactory",
  "spaceTool",
  "lassoTool",
  "handTool",
  "globalConnect",
  "translate"
];
PaletteProvider.prototype.getPaletteEntries = function() {
  var actions = {}, create3 = this._create, elementFactory = this._elementFactory, spaceTool = this._spaceTool, lassoTool = this._lassoTool, handTool = this._handTool, globalConnect = this._globalConnect, translate4 = this._translate;
  function createAction2(type, group, className, title, options) {
    function createListener(event2) {
      var shape = elementFactory.createShape(assign({ type }, options));
      create3.start(event2, shape);
    }
    return {
      group,
      className,
      title,
      action: {
        dragstart: createListener,
        click: createListener
      }
    };
  }
  function createSubprocess(event2) {
    var subProcess = elementFactory.createShape({
      type: "bpmn:SubProcess",
      x: 0,
      y: 0,
      isExpanded: true
    });
    var startEvent = elementFactory.createShape({
      type: "bpmn:StartEvent",
      x: 40,
      y: 82,
      parent: subProcess
    });
    create3.start(event2, [subProcess, startEvent], {
      hints: {
        autoSelect: [subProcess]
      }
    });
  }
  function createParticipant(event2) {
    create3.start(event2, elementFactory.createParticipantShape());
  }
  assign(actions, {
    "hand-tool": {
      group: "tools",
      className: "bpmn-icon-hand-tool",
      title: translate4("Activate hand tool"),
      action: {
        click: function(event2) {
          handTool.activateHand(event2);
        }
      }
    },
    "lasso-tool": {
      group: "tools",
      className: "bpmn-icon-lasso-tool",
      title: translate4("Activate lasso tool"),
      action: {
        click: function(event2) {
          lassoTool.activateSelection(event2);
        }
      }
    },
    "space-tool": {
      group: "tools",
      className: "bpmn-icon-space-tool",
      title: translate4("Activate create/remove space tool"),
      action: {
        click: function(event2) {
          spaceTool.activateSelection(event2);
        }
      }
    },
    "global-connect-tool": {
      group: "tools",
      className: "bpmn-icon-connection-multi",
      title: translate4("Activate global connect tool"),
      action: {
        click: function(event2) {
          globalConnect.start(event2);
        }
      }
    },
    "tool-separator": {
      group: "tools",
      separator: true
    },
    "create.start-event": createAction2(
      "bpmn:StartEvent",
      "event",
      "bpmn-icon-start-event-none",
      translate4("Create start event")
    ),
    "create.intermediate-event": createAction2(
      "bpmn:IntermediateThrowEvent",
      "event",
      "bpmn-icon-intermediate-event-none",
      translate4("Create intermediate/boundary event")
    ),
    "create.end-event": createAction2(
      "bpmn:EndEvent",
      "event",
      "bpmn-icon-end-event-none",
      translate4("Create end event")
    ),
    "create.exclusive-gateway": createAction2(
      "bpmn:ExclusiveGateway",
      "gateway",
      "bpmn-icon-gateway-none",
      translate4("Create gateway")
    ),
    "create.task": createAction2(
      "bpmn:Task",
      "activity",
      "bpmn-icon-task",
      translate4("Create task")
    ),
    "create.data-object": createAction2(
      "bpmn:DataObjectReference",
      "data-object",
      "bpmn-icon-data-object",
      translate4("Create data object reference")
    ),
    "create.data-store": createAction2(
      "bpmn:DataStoreReference",
      "data-store",
      "bpmn-icon-data-store",
      translate4("Create data store reference")
    ),
    "create.subprocess-expanded": {
      group: "activity",
      className: "bpmn-icon-subprocess-expanded",
      title: translate4("Create expanded sub-process"),
      action: {
        dragstart: createSubprocess,
        click: createSubprocess
      }
    },
    "create.participant-expanded": {
      group: "collaboration",
      className: "bpmn-icon-participant",
      title: translate4("Create pool/participant"),
      action: {
        dragstart: createParticipant,
        click: createParticipant
      }
    },
    "create.group": createAction2(
      "bpmn:Group",
      "artifact",
      "bpmn-icon-group",
      translate4("Create group")
    )
  });
  return actions;
};

// node_modules/bpmn-js/lib/features/palette/index.js
var palette_default2 = {
  __depends__: [
    palette_default,
    create_default,
    space_tool_default2,
    lasso_tool_default,
    hand_tool_default,
    global_connect_default,
    translate_default
  ],
  __init__: ["paletteProvider"],
  paletteProvider: ["type", PaletteProvider]
};

// node_modules/bpmn-js/lib/features/replace-preview/BpmnReplacePreview.js
var LOW_PRIORITY27 = 250;
function BpmnReplacePreview(eventBus, elementRegistry, elementFactory, canvas, previewSupport) {
  CommandInterceptor.call(this, eventBus);
  function replaceVisual(context) {
    var replacements = context.canExecute.replacements;
    forEach(replacements, function(replacement) {
      var id = replacement.oldElementId;
      var newElement = {
        type: replacement.newElementType
      };
      if (context.visualReplacements[id]) {
        return;
      }
      var element = elementRegistry.get(id);
      assign(newElement, { x: element.x, y: element.y });
      var tempShape = elementFactory.createShape(newElement);
      canvas.addShape(tempShape, element.parent);
      var gfx = query('[data-element-id="' + escapeCSS(element.id) + '"]', context.dragGroup);
      if (gfx) {
        attr(gfx, { display: "none" });
      }
      var dragger = previewSupport.addDragger(tempShape, context.dragGroup);
      context.visualReplacements[id] = dragger;
      canvas.removeShape(tempShape);
    });
  }
  function restoreVisual(context) {
    var visualReplacements = context.visualReplacements;
    forEach(visualReplacements, function(dragger, id) {
      var originalGfx = query('[data-element-id="' + escapeCSS(id) + '"]', context.dragGroup);
      if (originalGfx) {
        attr(originalGfx, { display: "inline" });
      }
      dragger.remove();
      if (visualReplacements[id]) {
        delete visualReplacements[id];
      }
    });
  }
  eventBus.on("shape.move.move", LOW_PRIORITY27, function(event2) {
    var context = event2.context, canExecute = context.canExecute;
    if (!context.visualReplacements) {
      context.visualReplacements = {};
    }
    if (canExecute && canExecute.replacements) {
      replaceVisual(context);
    } else {
      restoreVisual(context);
    }
  });
}
BpmnReplacePreview.$inject = [
  "eventBus",
  "elementRegistry",
  "elementFactory",
  "canvas",
  "previewSupport"
];
e(BpmnReplacePreview, CommandInterceptor);

// node_modules/bpmn-js/lib/features/replace-preview/index.js
var replace_preview_default = {
  __depends__: [
    preview_support_default
  ],
  __init__: ["bpmnReplacePreview"],
  bpmnReplacePreview: ["type", BpmnReplacePreview]
};

// node_modules/bpmn-js/lib/features/snapping/BpmnConnectSnapping.js
var HIGHER_PRIORITY3 = 1250;
var BOUNDARY_TO_HOST_THRESHOLD2 = 40;
var TARGET_BOUNDS_PADDING = 20;
var TASK_BOUNDS_PADDING = 10;
var TARGET_CENTER_PADDING = 20;
var AXES = ["x", "y"];
var abs8 = Math.abs;
function BpmnConnectSnapping(eventBus) {
  eventBus.on([
    "connect.hover",
    "connect.move",
    "connect.end"
  ], HIGHER_PRIORITY3, function(event2) {
    var context = event2.context, canExecute = context.canExecute, start = context.start, hover = context.hover, source = context.source, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (!context.initialConnectionStart) {
      context.initialConnectionStart = context.connectionStart;
    }
    if (canExecute && hover) {
      snapToShape(event2, hover, getTargetBoundsPadding(hover));
    }
    if (hover && isAnyType(canExecute, [
      "bpmn:Association",
      "bpmn:DataInputAssociation",
      "bpmn:DataOutputAssociation",
      "bpmn:SequenceFlow"
    ])) {
      context.connectionStart = mid(start);
      if (isAny(hover, ["bpmn:Event", "bpmn:Gateway"])) {
        snapToPosition(event2, mid(hover));
      }
      if (isAny(hover, ["bpmn:Task", "bpmn:SubProcess"])) {
        snapToTargetMid(event2, hover);
      }
      if (is(source, "bpmn:BoundaryEvent") && target === source.host) {
        snapBoundaryEventLoop(event2);
      }
    } else if (isType2(canExecute, "bpmn:MessageFlow")) {
      if (is(start, "bpmn:Event")) {
        context.connectionStart = mid(start);
      }
      if (is(hover, "bpmn:Event")) {
        snapToPosition(event2, mid(hover));
      }
    } else {
      context.connectionStart = context.initialConnectionStart;
    }
  });
}
BpmnConnectSnapping.$inject = ["eventBus"];
function snapToShape(event2, target, padding) {
  AXES.forEach(function(axis) {
    var dimensionForAxis = getDimensionForAxis(axis, target);
    if (event2[axis] < target[axis] + padding) {
      setSnapped(event2, axis, target[axis] + padding);
    } else if (event2[axis] > target[axis] + dimensionForAxis - padding) {
      setSnapped(event2, axis, target[axis] + dimensionForAxis - padding);
    }
  });
}
function snapToTargetMid(event2, target) {
  var targetMid = mid(target);
  AXES.forEach(function(axis) {
    if (isMid(event2, target, axis)) {
      setSnapped(event2, axis, targetMid[axis]);
    }
  });
}
function snapBoundaryEventLoop(event2) {
  var context = event2.context, source = context.source, target = context.target;
  if (isReverse3(context)) {
    return;
  }
  var sourceMid = mid(source), orientation = getOrientation(sourceMid, target, -10), axes = [];
  if (/top|bottom/.test(orientation)) {
    axes.push("x");
  }
  if (/left|right/.test(orientation)) {
    axes.push("y");
  }
  axes.forEach(function(axis) {
    var coordinate = event2[axis], newCoordinate;
    if (abs8(coordinate - sourceMid[axis]) < BOUNDARY_TO_HOST_THRESHOLD2) {
      if (coordinate > sourceMid[axis]) {
        newCoordinate = sourceMid[axis] + BOUNDARY_TO_HOST_THRESHOLD2;
      } else {
        newCoordinate = sourceMid[axis] - BOUNDARY_TO_HOST_THRESHOLD2;
      }
      setSnapped(event2, axis, newCoordinate);
    }
  });
}
function snapToPosition(event2, position) {
  setSnapped(event2, "x", position.x);
  setSnapped(event2, "y", position.y);
}
function isType2(attrs, type) {
  return attrs && attrs.type === type;
}
function isAnyType(attrs, types3) {
  return some(types3, function(type) {
    return isType2(attrs, type);
  });
}
function getDimensionForAxis(axis, element) {
  return axis === "x" ? element.width : element.height;
}
function getTargetBoundsPadding(target) {
  if (is(target, "bpmn:Task")) {
    return TASK_BOUNDS_PADDING;
  } else {
    return TARGET_BOUNDS_PADDING;
  }
}
function isMid(event2, target, axis) {
  return event2[axis] > target[axis] + TARGET_CENTER_PADDING && event2[axis] < target[axis] + getDimensionForAxis(axis, target) - TARGET_CENTER_PADDING;
}
function isReverse3(context) {
  var hover = context.hover, source = context.source;
  return hover && source && hover === source;
}

// node_modules/diagram-js/lib/features/snapping/SnapContext.js
function SnapContext() {
  this._targets = {};
  this._snapOrigins = {};
  this._snapLocations = [];
  this._defaultSnaps = {};
}
SnapContext.prototype.getSnapOrigin = function(snapLocation) {
  return this._snapOrigins[snapLocation];
};
SnapContext.prototype.setSnapOrigin = function(snapLocation, snapOrigin) {
  this._snapOrigins[snapLocation] = snapOrigin;
  if (this._snapLocations.indexOf(snapLocation) === -1) {
    this._snapLocations.push(snapLocation);
  }
};
SnapContext.prototype.addDefaultSnap = function(snapLocation, point) {
  var snapValues = this._defaultSnaps[snapLocation];
  if (!snapValues) {
    snapValues = this._defaultSnaps[snapLocation] = [];
  }
  snapValues.push(point);
};
SnapContext.prototype.getSnapLocations = function() {
  return this._snapLocations;
};
SnapContext.prototype.setSnapLocations = function(snapLocations) {
  this._snapLocations = snapLocations;
};
SnapContext.prototype.pointsForTarget = function(target) {
  var targetId = target.id || target;
  var snapPoints = this._targets[targetId];
  if (!snapPoints) {
    snapPoints = this._targets[targetId] = new SnapPoints();
    snapPoints.initDefaults(this._defaultSnaps);
  }
  return snapPoints;
};
function SnapPoints() {
  this._snapValues = {};
}
SnapPoints.prototype.add = function(snapLocation, point) {
  var snapValues = this._snapValues[snapLocation];
  if (!snapValues) {
    snapValues = this._snapValues[snapLocation] = { x: [], y: [] };
  }
  if (snapValues.x.indexOf(point.x) === -1) {
    snapValues.x.push(point.x);
  }
  if (snapValues.y.indexOf(point.y) === -1) {
    snapValues.y.push(point.y);
  }
};
SnapPoints.prototype.snap = function(point, snapLocation, axis, tolerance) {
  var snappingValues = this._snapValues[snapLocation];
  return snappingValues && snapTo(point[axis], snappingValues[axis], tolerance);
};
SnapPoints.prototype.initDefaults = function(defaultSnaps) {
  var self2 = this;
  forEach(defaultSnaps || {}, function(snapPoints, snapLocation) {
    forEach(snapPoints, function(point) {
      self2.add(snapLocation, point);
    });
  });
};

// node_modules/diagram-js/lib/features/snapping/CreateMoveSnapping.js
var HIGHER_PRIORITY4 = 1250;
function CreateMoveSnapping(elementRegistry, eventBus, snapping) {
  var self2 = this;
  this._elementRegistry = elementRegistry;
  eventBus.on([
    "create.start",
    "shape.move.start"
  ], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGHER_PRIORITY4, function(event2) {
    var context = event2.context, shape = context.shape, snapContext = context.snapContext, target = context.target;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2) || !target) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(target);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, target);
      snapPoints.initialized = true;
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on([
    "create.cleanup",
    "shape.move.cleanup"
  ], function() {
    snapping.hide();
  });
}
CreateMoveSnapping.$inject = [
  "elementRegistry",
  "eventBus",
  "snapping"
];
CreateMoveSnapping.prototype.initSnap = function(event2) {
  var elementRegistry = this._elementRegistry;
  var context = event2.context, shape = context.shape, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var shapeMid;
  if (elementRegistry.get(shape.id)) {
    shapeMid = mid(shape, event2);
  } else {
    shapeMid = {
      x: event2.x + mid(shape).x,
      y: event2.y + mid(shape).y
    };
  }
  var shapeTopLeft = {
    x: shapeMid.x - shape.width / 2,
    y: shapeMid.y - shape.height / 2
  }, shapeBottomRight = {
    x: shapeMid.x + shape.width / 2,
    y: shapeMid.y + shape.height / 2
  };
  snapContext.setSnapOrigin("mid", {
    x: shapeMid.x - event2.x,
    y: shapeMid.y - event2.y
  });
  if (isLabel(shape)) {
    return snapContext;
  }
  snapContext.setSnapOrigin("top-left", {
    x: shapeTopLeft.x - event2.x,
    y: shapeTopLeft.y - event2.y
  });
  snapContext.setSnapOrigin("bottom-right", {
    x: shapeBottomRight.x - event2.x,
    y: shapeBottomRight.y - event2.y
  });
  return snapContext;
};
CreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach(snapTargets, function(snapTarget) {
    if (isLabel(snapTarget)) {
      if (isLabel(shape)) {
        snapPoints.add("mid", mid(snapTarget));
      }
      return;
    }
    if (isConnection(snapTarget)) {
      if (snapTarget.waypoints.length < 3) {
        return;
      }
      var waypoints = snapTarget.waypoints.slice(1, -1);
      forEach(waypoints, function(waypoint) {
        snapPoints.add("mid", waypoint);
      });
      return;
    }
    snapPoints.add("mid", mid(snapTarget));
  });
  if (!isNumber(shape.x) || !isNumber(shape.y)) {
    return snapPoints;
  }
  if (this._elementRegistry.get(shape.id)) {
    snapPoints.add("mid", mid(shape));
  }
  return snapPoints;
};
CreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren2(target).filter(function(child) {
    return !isHidden2(child);
  });
};
function isHidden2(element) {
  return !!element.hidden;
}

// node_modules/bpmn-js/lib/features/snapping/BpmnCreateMoveSnapping.js
var HIGH_PRIORITY20 = 1500;
function BpmnCreateMoveSnapping(eventBus, injector) {
  injector.invoke(CreateMoveSnapping, this);
  eventBus.on(["create.move", "create.end"], HIGH_PRIORITY20, setSnappedIfConstrained);
  eventBus.on([
    "create.move",
    "create.end",
    "shape.move.move",
    "shape.move.end"
  ], HIGH_PRIORITY20, function(event2) {
    var context = event2.context, canExecute = context.canExecute, target = context.target;
    var canAttach2 = canExecute && (canExecute === "attach" || canExecute.attach);
    if (canAttach2 && !isSnapped(event2)) {
      snapBoundaryEvent(event2, target);
    }
  });
}
e(BpmnCreateMoveSnapping, CreateMoveSnapping);
BpmnCreateMoveSnapping.$inject = [
  "eventBus",
  "injector"
];
BpmnCreateMoveSnapping.prototype.initSnap = function(event2) {
  var snapContext = CreateMoveSnapping.prototype.initSnap.call(this, event2);
  var shape = event2.shape;
  var isMove = !!this._elementRegistry.get(shape.id);
  forEach(shape.outgoing, function(connection) {
    var docking = connection.waypoints[0];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  forEach(shape.incoming, function(connection) {
    var docking = connection.waypoints[connection.waypoints.length - 1];
    docking = docking.original || docking;
    snapContext.setSnapOrigin(connection.id + "-docking", getDockingSnapOrigin(docking, isMove, event2));
  });
  if (is(shape, "bpmn:Participant")) {
    snapContext.setSnapLocations(["top-left", "bottom-right", "mid"]);
  }
  return snapContext;
};
BpmnCreateMoveSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target) {
  CreateMoveSnapping.prototype.addSnapTargetPoints.call(this, snapPoints, shape, target);
  var snapTargets = this.getSnapTargets(shape, target);
  forEach(snapTargets, function(snapTarget) {
    if (isContainer(snapTarget) || areAll([shape, snapTarget], "bpmn:TextAnnotation")) {
      snapPoints.add("top-left", topLeft(snapTarget));
      snapPoints.add("bottom-right", bottomRight(snapTarget));
    }
  });
  var elementRegistry = this._elementRegistry;
  forEach(shape.incoming, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes7(snapTargets, connection.source)) {
        snapPoints.add("mid", getMid(connection.source));
      }
      var docking = connection.waypoints[0];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  forEach(shape.outgoing, function(connection) {
    if (elementRegistry.get(shape.id)) {
      if (!includes7(snapTargets, connection.target)) {
        snapPoints.add("mid", getMid(connection.target));
      }
      var docking = connection.waypoints[connection.waypoints.length - 1];
      snapPoints.add(connection.id + "-docking", docking.original || docking);
    }
  });
  if (is(target, "bpmn:SequenceFlow")) {
    snapPoints = this.addSnapTargetPoints(snapPoints, shape, target.parent);
  }
  return snapPoints;
};
BpmnCreateMoveSnapping.prototype.getSnapTargets = function(shape, target) {
  return CreateMoveSnapping.prototype.getSnapTargets.call(this, shape, target).filter(function(snapTarget) {
    return !is(snapTarget, "bpmn:Lane");
  });
};
function snapBoundaryEvent(event2, target) {
  var targetTRBL = asTRBL(target);
  var direction = getBoundaryAttachment(event2, target);
  var context = event2.context, shape = context.shape;
  var offset;
  if (shape.parent) {
    offset = { x: 0, y: 0 };
  } else {
    offset = getMid(shape);
  }
  if (/top/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.top - offset.y);
  } else if (/bottom/.test(direction)) {
    setSnapped(event2, "y", targetTRBL.bottom - offset.y);
  }
  if (/left/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.left - offset.x);
  } else if (/right/.test(direction)) {
    setSnapped(event2, "x", targetTRBL.right - offset.x);
  }
}
function areAll(elements, type) {
  return elements.every(function(el) {
    return is(el, type);
  });
}
function isContainer(element) {
  if (is(element, "bpmn:SubProcess") && isExpanded(element)) {
    return true;
  }
  return is(element, "bpmn:Participant");
}
function setSnappedIfConstrained(event2) {
  var context = event2.context, createConstraints = context.createConstraints;
  if (!createConstraints) {
    return;
  }
  var top = createConstraints.top, right = createConstraints.right, bottom = createConstraints.bottom, left = createConstraints.left;
  if (left && left >= event2.x || right && right <= event2.x) {
    setSnapped(event2, "x", event2.x);
  }
  if (top && top >= event2.y || bottom && bottom <= event2.y) {
    setSnapped(event2, "y", event2.y);
  }
}
function includes7(array, value) {
  return array.indexOf(value) !== -1;
}
function getDockingSnapOrigin(docking, isMove, event2) {
  return isMove ? {
    x: docking.x - event2.x,
    y: docking.y - event2.y
  } : {
    x: docking.x,
    y: docking.y
  };
}

// node_modules/diagram-js/lib/features/snapping/ResizeSnapping.js
var HIGHER_PRIORITY5 = 1250;
function ResizeSnapping(eventBus, snapping) {
  var self2 = this;
  eventBus.on(["resize.start"], function(event2) {
    self2.initSnap(event2);
  });
  eventBus.on([
    "resize.move",
    "resize.end"
  ], HIGHER_PRIORITY5, function(event2) {
    var context = event2.context, shape = context.shape, parent = shape.parent, direction = context.direction, snapContext = context.snapContext;
    if (event2.originalEvent && isCmd(event2.originalEvent)) {
      return;
    }
    if (isSnapped(event2)) {
      return;
    }
    var snapPoints = snapContext.pointsForTarget(parent);
    if (!snapPoints.initialized) {
      snapPoints = self2.addSnapTargetPoints(snapPoints, shape, parent, direction);
      snapPoints.initialized = true;
    }
    if (isHorizontal4(direction)) {
      setSnapped(event2, "x", event2.x);
    }
    if (isVertical(direction)) {
      setSnapped(event2, "y", event2.y);
    }
    snapping.snap(event2, snapPoints);
  });
  eventBus.on(["resize.cleanup"], function() {
    snapping.hide();
  });
}
ResizeSnapping.prototype.initSnap = function(event2) {
  var context = event2.context, shape = context.shape, direction = context.direction, snapContext = context.snapContext;
  if (!snapContext) {
    snapContext = context.snapContext = new SnapContext();
  }
  var snapOrigin = getSnapOrigin(shape, direction);
  snapContext.setSnapOrigin("corner", {
    x: snapOrigin.x - event2.x,
    y: snapOrigin.y - event2.y
  });
  return snapContext;
};
ResizeSnapping.prototype.addSnapTargetPoints = function(snapPoints, shape, target, direction) {
  var snapTargets = this.getSnapTargets(shape, target);
  forEach(snapTargets, function(snapTarget) {
    snapPoints.add("corner", bottomRight(snapTarget));
    snapPoints.add("corner", topLeft(snapTarget));
  });
  snapPoints.add("corner", getSnapOrigin(shape, direction));
  return snapPoints;
};
ResizeSnapping.$inject = [
  "eventBus",
  "snapping"
];
ResizeSnapping.prototype.getSnapTargets = function(shape, target) {
  return getChildren2(target).filter(function(child) {
    return !isAttached(child, shape) && !isConnection(child) && !isHidden3(child) && !isLabel(child);
  });
};
function getSnapOrigin(shape, direction) {
  var mid4 = getMid(shape), trbl = asTRBL(shape);
  var snapOrigin = {
    x: mid4.x,
    y: mid4.y
  };
  if (direction.indexOf("n") !== -1) {
    snapOrigin.y = trbl.top;
  } else if (direction.indexOf("s") !== -1) {
    snapOrigin.y = trbl.bottom;
  }
  if (direction.indexOf("e") !== -1) {
    snapOrigin.x = trbl.right;
  } else if (direction.indexOf("w") !== -1) {
    snapOrigin.x = trbl.left;
  }
  return snapOrigin;
}
function isAttached(element, host) {
  return element.host === host;
}
function isHidden3(element) {
  return !!element.hidden;
}
function isHorizontal4(direction) {
  return direction === "n" || direction === "s";
}
function isVertical(direction) {
  return direction === "e" || direction === "w";
}

// node_modules/diagram-js/lib/features/snapping/Snapping.js
var SNAP_TOLERANCE = 7;
var SNAP_LINE_HIDE_DELAY = 1e3;
function Snapping(canvas) {
  this._canvas = canvas;
  this._asyncHide = debounce(bind(this.hide, this), SNAP_LINE_HIDE_DELAY);
}
Snapping.$inject = ["canvas"];
Snapping.prototype.snap = function(event2, snapPoints) {
  var context = event2.context, snapContext = context.snapContext, snapLocations = snapContext.getSnapLocations();
  var snapping = {
    x: isSnapped(event2, "x"),
    y: isSnapped(event2, "y")
  };
  forEach(snapLocations, function(location) {
    var snapOrigin = snapContext.getSnapOrigin(location);
    var snapCurrent = {
      x: event2.x + snapOrigin.x,
      y: event2.y + snapOrigin.y
    };
    forEach(["x", "y"], function(axis) {
      var locationSnapping;
      if (!snapping[axis]) {
        locationSnapping = snapPoints.snap(snapCurrent, location, axis, SNAP_TOLERANCE);
        if (locationSnapping !== void 0) {
          snapping[axis] = {
            value: locationSnapping,
            originValue: locationSnapping - snapOrigin[axis]
          };
        }
      }
    });
    if (snapping.x && snapping.y) {
      return false;
    }
  });
  this.showSnapLine("vertical", snapping.x && snapping.x.value);
  this.showSnapLine("horizontal", snapping.y && snapping.y.value);
  forEach(["x", "y"], function(axis) {
    var axisSnapping = snapping[axis];
    if (isObject(axisSnapping)) {
      setSnapped(event2, axis, axisSnapping.originValue);
    }
  });
};
Snapping.prototype._createLine = function(orientation) {
  var root = this._canvas.getLayer("snap");
  var line2 = create("path");
  attr(line2, { d: "M0,0 L0,0" });
  classes(line2).add("djs-snap-line");
  append(root, line2);
  return {
    update: function(position) {
      if (!isNumber(position)) {
        attr(line2, { display: "none" });
      } else {
        if (orientation === "horizontal") {
          attr(line2, {
            d: "M-100000," + position + " L+100000," + position,
            display: ""
          });
        } else {
          attr(line2, {
            d: "M " + position + ",-100000 L " + position + ", +100000",
            display: ""
          });
        }
      }
    }
  };
};
Snapping.prototype._createSnapLines = function() {
  this._snapLines = {
    horizontal: this._createLine("horizontal"),
    vertical: this._createLine("vertical")
  };
};
Snapping.prototype.showSnapLine = function(orientation, position) {
  var line2 = this.getSnapLine(orientation);
  if (line2) {
    line2.update(position);
  }
  this._asyncHide();
};
Snapping.prototype.getSnapLine = function(orientation) {
  if (!this._snapLines) {
    this._createSnapLines();
  }
  return this._snapLines[orientation];
};
Snapping.prototype.hide = function() {
  forEach(this._snapLines, function(snapLine) {
    snapLine.update();
  });
};

// node_modules/diagram-js/lib/features/snapping/index.js
var snapping_default = {
  __init__: [
    "createMoveSnapping",
    "resizeSnapping",
    "snapping"
  ],
  createMoveSnapping: ["type", CreateMoveSnapping],
  resizeSnapping: ["type", ResizeSnapping],
  snapping: ["type", Snapping]
};

// node_modules/bpmn-js/lib/features/snapping/index.js
var snapping_default2 = {
  __depends__: [snapping_default],
  __init__: [
    "connectSnapping",
    "createMoveSnapping"
  ],
  connectSnapping: ["type", BpmnConnectSnapping],
  createMoveSnapping: ["type", BpmnCreateMoveSnapping]
};

// node_modules/diagram-js/lib/features/search-pad/SearchPad.js
var SCROLL_TO_ELEMENT_PADDING = 300;
function SearchPad(canvas, eventBus, selection2, translate4) {
  this._open = false;
  this._results = {};
  this._eventMaps = [];
  this._cachedRootElement = null;
  this._cachedSelection = null;
  this._cachedViewbox = null;
  this._canvas = canvas;
  this._eventBus = eventBus;
  this._selection = selection2;
  this._translate = translate4;
  this._container = this._getBoxHtml();
  this._searchInput = query(SearchPad.INPUT_SELECTOR, this._container);
  this._resultsContainer = query(SearchPad.RESULTS_CONTAINER_SELECTOR, this._container);
  this._canvas.getContainer().appendChild(this._container);
  eventBus.on([
    "canvas.destroy",
    "diagram.destroy",
    "drag.init",
    "elements.changed"
  ], this.close, this);
}
SearchPad.$inject = [
  "canvas",
  "eventBus",
  "selection",
  "translate"
];
SearchPad.prototype._bindEvents = function() {
  var self2 = this;
  function listen(el, selector, type, fn2) {
    self2._eventMaps.push({
      el,
      type,
      listener: delegate.bind(el, selector, type, fn2)
    });
  }
  listen(document, "html", "click", function(e8) {
    self2.close(false);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "click", function(e8) {
    e8.stopPropagation();
    e8.delegateTarget.focus();
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "mouseover", function(e8) {
    e8.stopPropagation();
    self2._scrollToNode(e8.delegateTarget);
    self2._preselect(e8.delegateTarget);
  });
  listen(this._container, SearchPad.RESULT_SELECTOR, "click", function(e8) {
    e8.stopPropagation();
    self2._select(e8.delegateTarget);
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keydown", function(e8) {
    if (isKey("ArrowUp", e8)) {
      e8.preventDefault();
    }
    if (isKey("ArrowDown", e8)) {
      e8.preventDefault();
    }
  });
  listen(this._container, SearchPad.INPUT_SELECTOR, "keyup", function(e8) {
    if (isKey("Escape", e8)) {
      return self2.close();
    }
    if (isKey("Enter", e8)) {
      var selected = self2._getCurrentResult();
      return selected ? self2._select(selected) : self2.close(false);
    }
    if (isKey("ArrowUp", e8)) {
      return self2._scrollToDirection(true);
    }
    if (isKey("ArrowDown", e8)) {
      return self2._scrollToDirection();
    }
    if (isKey(["ArrowLeft", "ArrowRight"], e8)) {
      return;
    }
    self2._search(e8.delegateTarget.value);
  });
};
SearchPad.prototype._unbindEvents = function() {
  this._eventMaps.forEach(function(m6) {
    delegate.unbind(m6.el, m6.type, m6.listener);
  });
};
SearchPad.prototype._search = function(pattern) {
  var self2 = this;
  this._clearResults();
  if (!pattern.trim()) {
    return;
  }
  var searchResults = this._searchProvider.find(pattern);
  searchResults = searchResults.filter(function(searchResult) {
    return !self2._canvas.getRootElements().includes(searchResult.element);
  });
  if (!searchResults.length) {
    this._selection.select(null);
    return;
  }
  searchResults.forEach(function(result) {
    var id = result.element.id;
    var node3 = self2._createResultNode(result, id);
    self2._results[id] = {
      element: result.element,
      node: node3
    };
  });
  var node2 = query(SearchPad.RESULT_SELECTOR, this._resultsContainer);
  this._scrollToNode(node2);
  this._preselect(node2);
};
SearchPad.prototype._scrollToDirection = function(previous) {
  var selected = this._getCurrentResult();
  if (!selected) {
    return;
  }
  var node2 = previous ? selected.previousElementSibling : selected.nextElementSibling;
  if (node2) {
    this._scrollToNode(node2);
    this._preselect(node2);
  }
};
SearchPad.prototype._scrollToNode = function(node2) {
  if (!node2 || node2 === this._getCurrentResult()) {
    return;
  }
  var nodeOffset = node2.offsetTop;
  var containerScroll = this._resultsContainer.scrollTop;
  var bottomScroll = nodeOffset - this._resultsContainer.clientHeight + node2.clientHeight;
  if (nodeOffset < containerScroll) {
    this._resultsContainer.scrollTop = nodeOffset;
  } else if (containerScroll < bottomScroll) {
    this._resultsContainer.scrollTop = bottomScroll;
  }
};
SearchPad.prototype._clearResults = function() {
  clear2(this._resultsContainer);
  this._results = {};
  this._eventBus.fire("searchPad.cleared");
};
SearchPad.prototype._getCurrentResult = function() {
  return query(SearchPad.RESULT_SELECTED_SELECTOR, this._resultsContainer);
};
SearchPad.prototype._createResultNode = function(result, id) {
  var node2 = domify$1(SearchPad.RESULT_HTML);
  if (result.primaryTokens.length > 0) {
    createInnerTextNode(node2, result.primaryTokens, SearchPad.RESULT_PRIMARY_HTML);
  }
  createInnerTextNode(node2, result.secondaryTokens, SearchPad.RESULT_SECONDARY_HTML);
  attr2(node2, SearchPad.RESULT_ID_ATTRIBUTE, id);
  this._resultsContainer.appendChild(node2);
  return node2;
};
SearchPad.prototype.registerProvider = function(provider) {
  this._searchProvider = provider;
};
SearchPad.prototype.open = function() {
  if (!this._searchProvider) {
    throw new Error("no search provider registered");
  }
  if (this.isOpen()) {
    return;
  }
  this._cachedRootElement = this._canvas.getRootElement();
  this._cachedSelection = this._selection.get();
  this._cachedViewbox = this._canvas.viewbox();
  this._selection.select(null);
  this._bindEvents();
  this._open = true;
  classes2(this._canvas.getContainer()).add("djs-search-open");
  classes2(this._container).add("open");
  this._searchInput.focus();
  this._eventBus.fire("searchPad.opened");
};
SearchPad.prototype.close = function(restoreCached = true) {
  if (!this.isOpen()) {
    return;
  }
  if (restoreCached) {
    if (this._cachedRootElement) {
      this._canvas.setRootElement(this._cachedRootElement);
    }
    if (this._cachedSelection) {
      this._selection.select(this._cachedSelection);
    }
    if (this._cachedViewbox) {
      this._canvas.viewbox(this._cachedViewbox);
    }
    this._eventBus.fire("searchPad.restored");
  }
  this._cachedRootElement = null;
  this._cachedSelection = null;
  this._cachedViewbox = null;
  this._unbindEvents();
  this._open = false;
  classes2(this._canvas.getContainer()).remove("djs-search-open");
  classes2(this._container).remove("open");
  this._clearResults();
  this._searchInput.value = "";
  this._searchInput.blur();
  this._eventBus.fire("searchPad.closed");
  this._canvas.restoreFocus();
};
SearchPad.prototype.toggle = function() {
  this.isOpen() ? this.close() : this.open();
};
SearchPad.prototype.isOpen = function() {
  return this._open;
};
SearchPad.prototype._preselect = function(node2) {
  var selectedNode = this._getCurrentResult();
  if (node2 === selectedNode) {
    return;
  }
  if (selectedNode) {
    classes2(selectedNode).remove(SearchPad.RESULT_SELECTED_CLASS);
  }
  var id = attr2(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  classes2(node2).add(SearchPad.RESULT_SELECTED_CLASS);
  this._canvas.scrollToElement(element, {
    top: SCROLL_TO_ELEMENT_PADDING
  });
  this._selection.select(element);
  this._eventBus.fire("searchPad.preselected", element);
};
SearchPad.prototype._select = function(node2) {
  var id = attr2(node2, SearchPad.RESULT_ID_ATTRIBUTE);
  var element = this._results[id].element;
  this._cachedSelection = null;
  this._cachedViewbox = null;
  this.close(false);
  this._canvas.scrollToElement(element, {
    top: SCROLL_TO_ELEMENT_PADDING
  });
  this._selection.select(element);
  this._eventBus.fire("searchPad.selected", element);
};
SearchPad.prototype._getBoxHtml = function() {
  const box = domify$1(SearchPad.BOX_HTML);
  const input = query(SearchPad.INPUT_SELECTOR, box);
  if (input) {
    input.setAttribute("aria-label", this._translate("Search in diagram"));
  }
  return box;
};
function createInnerTextNode(parentNode, tokens, template) {
  var text = createHtmlText(tokens);
  var childNode = domify$1(template);
  childNode.innerHTML = text;
  parentNode.appendChild(childNode);
}
function createHtmlText(tokens) {
  var htmlText = "";
  tokens.forEach(function(t7) {
    var text = escapeHTML(t7.value || t7.matched || t7.normal);
    var match = t7.match || t7.matched;
    if (match) {
      htmlText += '<b class="' + SearchPad.RESULT_HIGHLIGHT_CLASS + '">' + text + "</b>";
    } else {
      htmlText += text;
    }
  });
  return htmlText !== "" ? htmlText : null;
}
SearchPad.CONTAINER_SELECTOR = ".djs-search-container";
SearchPad.INPUT_SELECTOR = ".djs-search-input input";
SearchPad.RESULTS_CONTAINER_SELECTOR = ".djs-search-results";
SearchPad.RESULT_SELECTOR = ".djs-search-result";
SearchPad.RESULT_SELECTED_CLASS = "djs-search-result-selected";
SearchPad.RESULT_SELECTED_SELECTOR = "." + SearchPad.RESULT_SELECTED_CLASS;
SearchPad.RESULT_ID_ATTRIBUTE = "data-result-id";
SearchPad.RESULT_HIGHLIGHT_CLASS = "djs-search-highlight";
SearchPad.BOX_HTML = `<div class="djs-search-container djs-scrollable">
  <div class="djs-search-input">
    <svg class="djs-search-icon" width="14" height="14" viewBox="0 0 14 14" fill="none" xmlns="http://www.w3.org/2000/svg">
      <path fill-rule="evenodd" clip-rule="evenodd" d="M9.0325 8.5H9.625L13.3675 12.25L12.25 13.3675L8.5 9.625V9.0325L8.2975 8.8225C7.4425 9.5575 6.3325 10 5.125 10C2.4325 10 0.25 7.8175 0.25 5.125C0.25 2.4325 2.4325 0.25 5.125 0.25C7.8175 0.25 10 2.4325 10 5.125C10 6.3325 9.5575 7.4425 8.8225 8.2975L9.0325 8.5ZM1.75 5.125C1.75 6.9925 3.2575 8.5 5.125 8.5C6.9925 8.5 8.5 6.9925 8.5 5.125C8.5 3.2575 6.9925 1.75 5.125 1.75C3.2575 1.75 1.75 3.2575 1.75 5.125Z" fill="#22242A"/>
    </svg>
    <input type="text" spellcheck="false" />
  </div>
  <div class="djs-search-results" />
</div>`;
SearchPad.RESULT_HTML = '<div class="djs-search-result"></div>';
SearchPad.RESULT_PRIMARY_HTML = '<div class="djs-search-result-primary"></div>';
SearchPad.RESULT_SECONDARY_HTML = '<p class="djs-search-result-secondary"></p>';

// node_modules/diagram-js/lib/features/search-pad/index.js
var search_pad_default = {
  __depends__: [
    translate_default,
    overlays_default,
    selection_default
  ],
  searchPad: ["type", SearchPad]
};

// node_modules/bpmn-js/lib/features/search/BpmnSearchProvider.js
function BpmnSearchProvider(elementRegistry, searchPad, canvas, search2) {
  this._elementRegistry = elementRegistry;
  this._canvas = canvas;
  this._search = search2;
  searchPad.registerProvider(this);
}
BpmnSearchProvider.$inject = [
  "elementRegistry",
  "searchPad",
  "canvas",
  "search"
];
BpmnSearchProvider.prototype.find = function(pattern) {
  var rootElements = this._canvas.getRootElements();
  var elements = this._elementRegistry.filter(function(element) {
    return !isLabel(element) && !rootElements.includes(element);
  });
  return this._search(
    elements.map((element) => {
      return {
        element,
        label: getLabel(element),
        id: element.id
      };
    }),
    pattern,
    {
      keys: [
        "label",
        "id"
      ]
    }
  ).map(toSearchPadResult);
};
function toSearchPadResult(result) {
  const {
    item: {
      element
    },
    tokens
  } = result;
  return {
    element,
    primaryTokens: tokens.label,
    secondaryTokens: tokens.id
  };
}

// node_modules/bpmn-js/lib/features/search/index.js
var search_default2 = {
  __depends__: [
    search_pad_default,
    search_default
  ],
  __init__: ["bpmnSearch"],
  bpmnSearch: ["type", BpmnSearchProvider]
};

// node_modules/bpmn-js/lib/features/outline/OutlineUtil.js
var DATA_OBJECT_REFERENCE_OUTLINE_PATH = "M44.7648 11.3263L36.9892 2.64074C36.0451 1.58628 34.5651 0.988708 33.1904 0.988708H5.98667C3.22688 0.988708 0.989624 3.34892 0.989624 6.26039V55.0235C0.989624 57.9349 3.22688 60.2952 5.98667 60.2952H40.966C43.7257 60.2952 45.963 57.9349 45.963 55.0235V14.9459C45.963 13.5998 45.6407 12.3048 44.7648 11.3263Z";
var DATA_STORE_REFERENCE_OUTLINE_PATH = "M1.03845 48.1347C1.03845 49.3511 1.07295 50.758 1.38342 52.064C1.69949 53.3938 2.32428 54.7154 3.56383 55.6428C6.02533 57.4841 10.1161 58.7685 14.8212 59.6067C19.5772 60.4538 25.1388 60.8738 30.6831 60.8738C36.2276 60.8738 41.7891 60.4538 46.545 59.6067C51.2504 58.7687 55.3412 57.4842 57.8028 55.6429C59.0424 54.7156 59.6673 53.3938 59.9834 52.064C60.2938 50.7579 60.3285 49.351 60.3285 48.1344V13.8415C60.3285 12.6249 60.2938 11.218 59.9834 9.91171C59.6673 8.58194 59.0423 7.2602 57.8027 6.33294C55.341 4.49168 51.2503 3.20723 46.545 2.36914C41.7891 1.522 36.2276 1.10204 30.6831 1.10205C25.1388 1.10206 19.5772 1.52206 14.8213 2.36923C10.1162 3.20734 6.02543 4.49183 3.5639 6.33314C2.32433 7.26038 1.69951 8.58206 1.38343 9.91181C1.07295 11.2179 1.03845 12.6247 1.03845 13.8411V48.1347Z";
var DATA_OBJECT_REFERENCE_STANDARD_SIZE = { width: 36, height: 50 };
var DATA_STORE_REFERENCE_STANDARD_SIZE = { width: 50, height: 50 };
function createPath(path, attrs, OUTLINE_STYLE) {
  return create("path", {
    d: path,
    strokeWidth: 2,
    transform: `translate(${attrs.x}, ${attrs.y})`,
    ...OUTLINE_STYLE
  });
}

// node_modules/bpmn-js/lib/features/outline/OutlineProvider.js
var DEFAULT_OFFSET = 5;
function OutlineProvider(outline, styles) {
  this._styles = styles;
  outline.registerProvider(this);
}
OutlineProvider.$inject = [
  "outline",
  "styles"
];
OutlineProvider.prototype.getOutline = function(element) {
  const OUTLINE_STYLE = this._styles.cls("djs-outline", ["no-fill"]);
  var outline;
  if (isLabel(element)) {
    return;
  }
  if (is(element, "bpmn:Gateway")) {
    outline = create("rect");
    assign(outline.style, {
      "transform-box": "fill-box",
      "transform": "rotate(45deg)",
      "transform-origin": "center"
    });
    attr(outline, assign({
      x: 2,
      y: 2,
      rx: 4,
      width: element.width - 4,
      height: element.height - 4
    }, OUTLINE_STYLE));
  } else if (isAny(element, ["bpmn:Task", "bpmn:SubProcess", "bpmn:Group", "bpmn:CallActivity"])) {
    outline = create("rect");
    attr(outline, assign({
      x: -DEFAULT_OFFSET,
      y: -DEFAULT_OFFSET,
      rx: 14,
      width: element.width + DEFAULT_OFFSET * 2,
      height: element.height + DEFAULT_OFFSET * 2
    }, OUTLINE_STYLE));
  } else if (is(element, "bpmn:EndEvent")) {
    outline = create("circle");
    attr(outline, assign({
      cx: element.width / 2,
      cy: element.height / 2,
      r: element.width / 2 + DEFAULT_OFFSET + 1
    }, OUTLINE_STYLE));
  } else if (is(element, "bpmn:Event")) {
    outline = create("circle");
    attr(outline, assign({
      cx: element.width / 2,
      cy: element.height / 2,
      r: element.width / 2 + DEFAULT_OFFSET
    }, OUTLINE_STYLE));
  } else if (is(element, "bpmn:DataObjectReference") && isStandardSize(element, "bpmn:DataObjectReference")) {
    outline = createPath(
      DATA_OBJECT_REFERENCE_OUTLINE_PATH,
      { x: -6, y: -6 },
      OUTLINE_STYLE
    );
  } else if (is(element, "bpmn:DataStoreReference") && isStandardSize(element, "bpmn:DataStoreReference")) {
    outline = createPath(
      DATA_STORE_REFERENCE_OUTLINE_PATH,
      { x: -6, y: -6 },
      OUTLINE_STYLE
    );
  }
  return outline;
};
OutlineProvider.prototype.updateOutline = function(element, outline) {
  if (isLabel(element)) {
    return;
  }
  if (isAny(element, ["bpmn:SubProcess", "bpmn:Group"])) {
    attr(outline, {
      width: element.width + DEFAULT_OFFSET * 2,
      height: element.height + DEFAULT_OFFSET * 2
    });
    return true;
  } else if (isAny(element, [
    "bpmn:Event",
    "bpmn:Gateway",
    "bpmn:DataStoreReference",
    "bpmn:DataObjectReference"
  ])) {
    return true;
  }
  return false;
};
function isStandardSize(element, type) {
  var standardSize;
  if (type === "bpmn:DataObjectReference") {
    standardSize = DATA_OBJECT_REFERENCE_STANDARD_SIZE;
  } else if (type === "bpmn:DataStoreReference") {
    standardSize = DATA_STORE_REFERENCE_STANDARD_SIZE;
  }
  return element.width === standardSize.width && element.height === standardSize.height;
}

// node_modules/bpmn-js/lib/features/outline/index.js
var outline_default2 = {
  __depends__: [
    outline_default
  ],
  __init__: ["outlineProvider"],
  outlineProvider: ["type", OutlineProvider]
};

// node_modules/bpmn-js/lib/Modeler.js
var initialDiagram = '<?xml version="1.0" encoding="UTF-8"?><bpmn:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" targetNamespace="http://bpmn.io/schema/bpmn" id="Definitions_1"><bpmn:process id="Process_1" isExecutable="false"><bpmn:startEvent id="StartEvent_1"/></bpmn:process><bpmndi:BPMNDiagram id="BPMNDiagram_1"><bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1"><bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1"><dc:Bounds height="36.0" width="36.0" x="173.0" y="102.0"/></bpmndi:BPMNShape></bpmndi:BPMNPlane></bpmndi:BPMNDiagram></bpmn:definitions>';
function Modeler(options) {
  BaseModeler.call(this, options);
}
e(Modeler, BaseModeler);
Modeler.Viewer = Viewer;
Modeler.NavigatedViewer = NavigatedViewer;
Modeler.prototype.createDiagram = function createDiagram() {
  return this.importXML(initialDiagram);
};
Modeler.prototype._interactionModules = [
  // non-modeling components
  keyboard_move_default,
  movecanvas_default,
  zoomscroll_default
];
Modeler.prototype._modelingModules = [
  // modeling components
  align_elements_default2,
  auto_place_default2,
  auto_scroll_default,
  auto_resize_default,
  bendpoints_default,
  connect_default,
  connection_preview_default,
  context_pad_default2,
  copy_paste_default2,
  create_default,
  distribute_elements_default2,
  editor_actions_default2,
  grid_snapping_default2,
  interaction_events_default2,
  keyboard_default2,
  keyboard_move_selection_default,
  label_editing_default,
  modeling_default,
  modeling_feedback_default,
  move_default,
  palette_default2,
  replace_preview_default,
  resize_default,
  snapping_default2,
  search_default2,
  outline_default2
];
Modeler.prototype._modules = [].concat(
  Viewer.prototype._modules,
  Modeler.prototype._interactionModules,
  Modeler.prototype._modelingModules
);

// node_modules/@bpmn-io/properties-panel/preact/dist/preact.module.js
var n3;
var l3;
var u3;
var t4;
var i3;
var o3;
var r4;
var f3;
var e5;
var c3 = {};
var s3 = [];
var a3 = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i;
var h3 = Array.isArray;
function v3(n4, l5) {
  for (var u6 in l5) n4[u6] = l5[u6];
  return n4;
}
function p3(n4) {
  var l5 = n4.parentNode;
  l5 && l5.removeChild(n4);
}
function y3(l5, u6, t7) {
  var i7, o5, r7, f6 = {};
  for (r7 in u6) "key" == r7 ? i7 = u6[r7] : "ref" == r7 ? o5 = u6[r7] : f6[r7] = u6[r7];
  if (arguments.length > 2 && (f6.children = arguments.length > 3 ? n3.call(arguments, 2) : t7), "function" == typeof l5 && null != l5.defaultProps) for (r7 in l5.defaultProps) void 0 === f6[r7] && (f6[r7] = l5.defaultProps[r7]);
  return d3(l5, f6, i7, o5, null);
}
function d3(n4, t7, i7, o5, r7) {
  var f6 = { type: n4, props: t7, key: i7, ref: o5, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: null == r7 ? ++u3 : r7, __i: -1, __u: 0 };
  return null == r7 && null != l3.vnode && l3.vnode(f6), f6;
}
function _3() {
  return { current: null };
}
function g3(n4) {
  return n4.children;
}
function b2(n4, l5) {
  this.props = n4, this.context = l5;
}
function m4(n4, l5) {
  if (null == l5) return n4.__ ? m4(n4.__, n4.__i + 1) : null;
  for (var u6; l5 < n4.__k.length; l5++) if (null != (u6 = n4.__k[l5]) && null != u6.__e) return u6.__e;
  return "function" == typeof n4.type ? m4(n4) : null;
}
function k3(n4) {
  var l5, u6;
  if (null != (n4 = n4.__) && null != n4.__c) {
    for (n4.__e = n4.__c.base = null, l5 = 0; l5 < n4.__k.length; l5++) if (null != (u6 = n4.__k[l5]) && null != u6.__e) {
      n4.__e = n4.__c.base = u6.__e;
      break;
    }
    return k3(n4);
  }
}
function w3(n4) {
  (!n4.__d && (n4.__d = true) && i3.push(n4) && !x3.__r++ || o3 !== l3.debounceRendering) && ((o3 = l3.debounceRendering) || r4)(x3);
}
function x3() {
  var n4, u6, t7, o5, r7, e8, c5, s5, a6;
  for (i3.sort(f3); n4 = i3.shift(); ) n4.__d && (u6 = i3.length, o5 = void 0, e8 = (r7 = (t7 = n4).__v).__e, s5 = [], a6 = [], (c5 = t7.__P) && ((o5 = v3({}, r7)).__v = r7.__v + 1, l3.vnode && l3.vnode(o5), L2(c5, o5, r7, t7.__n, void 0 !== c5.ownerSVGElement, 32 & r7.__u ? [e8] : null, s5, null == e8 ? m4(r7) : e8, !!(32 & r7.__u), a6), o5.__.__k[o5.__i] = o5, M2(s5, o5, a6), o5.__e != e8 && k3(o5)), i3.length > u6 && i3.sort(f3));
  x3.__r = 0;
}
function C3(n4, l5, u6, t7, i7, o5, r7, f6, e8, a6, h5) {
  var v5, p5, y5, d5, _5, g6 = t7 && t7.__k || s3, b4 = l5.length;
  for (u6.__d = e8, P3(u6, l5, g6), e8 = u6.__d, v5 = 0; v5 < b4; v5++) null != (y5 = u6.__k[v5]) && "boolean" != typeof y5 && "function" != typeof y5 && (p5 = -1 === y5.__i ? c3 : g6[y5.__i] || c3, y5.__i = v5, L2(n4, y5, p5, i7, o5, r7, f6, e8, a6, h5), d5 = y5.__e, y5.ref && p5.ref != y5.ref && (p5.ref && z3(p5.ref, null, y5), h5.push(y5.ref, y5.__c || d5, y5)), null == _5 && null != d5 && (_5 = d5), 65536 & y5.__u || p5.__k === y5.__k ? e8 = S2(y5, e8, n4) : "function" == typeof y5.type && void 0 !== y5.__d ? e8 = y5.__d : d5 && (e8 = d5.nextSibling), y5.__d = void 0, y5.__u &= -196609);
  u6.__d = e8, u6.__e = _5;
}
function P3(n4, l5, u6) {
  var t7, i7, o5, r7, f6, e8 = l5.length, c5 = u6.length, s5 = c5, a6 = 0;
  for (n4.__k = [], t7 = 0; t7 < e8; t7++) null != (i7 = n4.__k[t7] = null == (i7 = l5[t7]) || "boolean" == typeof i7 || "function" == typeof i7 ? null : "string" == typeof i7 || "number" == typeof i7 || "bigint" == typeof i7 || i7.constructor == String ? d3(null, i7, null, null, i7) : h3(i7) ? d3(g3, { children: i7 }, null, null, null) : void 0 === i7.constructor && i7.__b > 0 ? d3(i7.type, i7.props, i7.key, i7.ref ? i7.ref : null, i7.__v) : i7) ? (i7.__ = n4, i7.__b = n4.__b + 1, f6 = H(i7, u6, r7 = t7 + a6, s5), i7.__i = f6, o5 = null, -1 !== f6 && (s5--, (o5 = u6[f6]) && (o5.__u |= 131072)), null == o5 || null === o5.__v ? (-1 == f6 && a6--, "function" != typeof i7.type && (i7.__u |= 65536)) : f6 !== r7 && (f6 === r7 + 1 ? a6++ : f6 > r7 ? s5 > e8 - r7 ? a6 += f6 - r7 : a6-- : a6 = f6 < r7 && f6 == r7 - 1 ? f6 - r7 : 0, f6 !== t7 + a6 && (i7.__u |= 65536))) : (o5 = u6[t7]) && null == o5.key && o5.__e && (o5.__e == n4.__d && (n4.__d = m4(o5)), N2(o5, o5, false), u6[t7] = null, s5--);
  if (s5) for (t7 = 0; t7 < c5; t7++) null != (o5 = u6[t7]) && 0 == (131072 & o5.__u) && (o5.__e == n4.__d && (n4.__d = m4(o5)), N2(o5, o5));
}
function S2(n4, l5, u6) {
  var t7, i7;
  if ("function" == typeof n4.type) {
    for (t7 = n4.__k, i7 = 0; t7 && i7 < t7.length; i7++) t7[i7] && (t7[i7].__ = n4, l5 = S2(t7[i7], l5, u6));
    return l5;
  }
  return n4.__e != l5 && (u6.insertBefore(n4.__e, l5 || null), l5 = n4.__e), l5 && l5.nextSibling;
}
function $2(n4, l5) {
  return l5 = l5 || [], null == n4 || "boolean" == typeof n4 || (h3(n4) ? n4.some(function(n5) {
    $2(n5, l5);
  }) : l5.push(n4)), l5;
}
function H(n4, l5, u6, t7) {
  var i7 = n4.key, o5 = n4.type, r7 = u6 - 1, f6 = u6 + 1, e8 = l5[u6];
  if (null === e8 || e8 && i7 == e8.key && o5 === e8.type) return u6;
  if (t7 > (null != e8 && 0 == (131072 & e8.__u) ? 1 : 0)) for (; r7 >= 0 || f6 < l5.length; ) {
    if (r7 >= 0) {
      if ((e8 = l5[r7]) && 0 == (131072 & e8.__u) && i7 == e8.key && o5 === e8.type) return r7;
      r7--;
    }
    if (f6 < l5.length) {
      if ((e8 = l5[f6]) && 0 == (131072 & e8.__u) && i7 == e8.key && o5 === e8.type) return f6;
      f6++;
    }
  }
  return -1;
}
function I2(n4, l5, u6) {
  "-" === l5[0] ? n4.setProperty(l5, null == u6 ? "" : u6) : n4[l5] = null == u6 ? "" : "number" != typeof u6 || a3.test(l5) ? u6 : u6 + "px";
}
function T3(n4, l5, u6, t7, i7) {
  var o5;
  n: if ("style" === l5) if ("string" == typeof u6) n4.style.cssText = u6;
  else {
    if ("string" == typeof t7 && (n4.style.cssText = t7 = ""), t7) for (l5 in t7) u6 && l5 in u6 || I2(n4.style, l5, "");
    if (u6) for (l5 in u6) t7 && u6[l5] === t7[l5] || I2(n4.style, l5, u6[l5]);
  }
  else if ("o" === l5[0] && "n" === l5[1]) o5 = l5 !== (l5 = l5.replace(/(PointerCapture)$|Capture$/, "$1")), l5 = l5.toLowerCase() in n4 ? l5.toLowerCase().slice(2) : l5.slice(2), n4.l || (n4.l = {}), n4.l[l5 + o5] = u6, u6 ? t7 ? u6.u = t7.u : (u6.u = Date.now(), n4.addEventListener(l5, o5 ? D3 : A3, o5)) : n4.removeEventListener(l5, o5 ? D3 : A3, o5);
  else {
    if (i7) l5 = l5.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
    else if ("width" !== l5 && "height" !== l5 && "href" !== l5 && "list" !== l5 && "form" !== l5 && "tabIndex" !== l5 && "download" !== l5 && "rowSpan" !== l5 && "colSpan" !== l5 && "role" !== l5 && l5 in n4) try {
      n4[l5] = null == u6 ? "" : u6;
      break n;
    } catch (n5) {
    }
    "function" == typeof u6 || (null == u6 || false === u6 && "-" !== l5[4] ? n4.removeAttribute(l5) : n4.setAttribute(l5, u6));
  }
}
function A3(n4) {
  var u6 = this.l[n4.type + false];
  if (n4.t) {
    if (n4.t <= u6.u) return;
  } else n4.t = Date.now();
  return u6(l3.event ? l3.event(n4) : n4);
}
function D3(n4) {
  return this.l[n4.type + true](l3.event ? l3.event(n4) : n4);
}
function L2(n4, u6, t7, i7, o5, r7, f6, e8, c5, s5) {
  var a6, p5, y5, d5, _5, m6, k6, w6, x6, P5, S3, $4, H3, I4, T6, A6 = u6.type;
  if (void 0 !== u6.constructor) return null;
  128 & t7.__u && (c5 = !!(32 & t7.__u), r7 = [e8 = u6.__e = t7.__e]), (a6 = l3.__b) && a6(u6);
  n: if ("function" == typeof A6) try {
    if (w6 = u6.props, x6 = (a6 = A6.contextType) && i7[a6.__c], P5 = a6 ? x6 ? x6.props.value : a6.__ : i7, t7.__c ? k6 = (p5 = u6.__c = t7.__c).__ = p5.__E : ("prototype" in A6 && A6.prototype.render ? u6.__c = p5 = new A6(w6, P5) : (u6.__c = p5 = new b2(w6, P5), p5.constructor = A6, p5.render = O2), x6 && x6.sub(p5), p5.props = w6, p5.state || (p5.state = {}), p5.context = P5, p5.__n = i7, y5 = p5.__d = true, p5.__h = [], p5._sb = []), null == p5.__s && (p5.__s = p5.state), null != A6.getDerivedStateFromProps && (p5.__s == p5.state && (p5.__s = v3({}, p5.__s)), v3(p5.__s, A6.getDerivedStateFromProps(w6, p5.__s))), d5 = p5.props, _5 = p5.state, p5.__v = u6, y5) null == A6.getDerivedStateFromProps && null != p5.componentWillMount && p5.componentWillMount(), null != p5.componentDidMount && p5.__h.push(p5.componentDidMount);
    else {
      if (null == A6.getDerivedStateFromProps && w6 !== d5 && null != p5.componentWillReceiveProps && p5.componentWillReceiveProps(w6, P5), !p5.__e && (null != p5.shouldComponentUpdate && false === p5.shouldComponentUpdate(w6, p5.__s, P5) || u6.__v === t7.__v)) {
        for (u6.__v !== t7.__v && (p5.props = w6, p5.state = p5.__s, p5.__d = false), u6.__e = t7.__e, u6.__k = t7.__k, u6.__k.forEach(function(n5) {
          n5 && (n5.__ = u6);
        }), S3 = 0; S3 < p5._sb.length; S3++) p5.__h.push(p5._sb[S3]);
        p5._sb = [], p5.__h.length && f6.push(p5);
        break n;
      }
      null != p5.componentWillUpdate && p5.componentWillUpdate(w6, p5.__s, P5), null != p5.componentDidUpdate && p5.__h.push(function() {
        p5.componentDidUpdate(d5, _5, m6);
      });
    }
    if (p5.context = P5, p5.props = w6, p5.__P = n4, p5.__e = false, $4 = l3.__r, H3 = 0, "prototype" in A6 && A6.prototype.render) {
      for (p5.state = p5.__s, p5.__d = false, $4 && $4(u6), a6 = p5.render(p5.props, p5.state, p5.context), I4 = 0; I4 < p5._sb.length; I4++) p5.__h.push(p5._sb[I4]);
      p5._sb = [];
    } else do {
      p5.__d = false, $4 && $4(u6), a6 = p5.render(p5.props, p5.state, p5.context), p5.state = p5.__s;
    } while (p5.__d && ++H3 < 25);
    p5.state = p5.__s, null != p5.getChildContext && (i7 = v3(v3({}, i7), p5.getChildContext())), y5 || null == p5.getSnapshotBeforeUpdate || (m6 = p5.getSnapshotBeforeUpdate(d5, _5)), C3(n4, h3(T6 = null != a6 && a6.type === g3 && null == a6.key ? a6.props.children : a6) ? T6 : [T6], u6, t7, i7, o5, r7, f6, e8, c5, s5), p5.base = u6.__e, u6.__u &= -161, p5.__h.length && f6.push(p5), k6 && (p5.__E = p5.__ = null);
  } catch (n5) {
    u6.__v = null, c5 || null != r7 ? (u6.__e = e8, u6.__u |= c5 ? 160 : 32, r7[r7.indexOf(e8)] = null) : (u6.__e = t7.__e, u6.__k = t7.__k), l3.__e(n5, u6, t7);
  }
  else null == r7 && u6.__v === t7.__v ? (u6.__k = t7.__k, u6.__e = t7.__e) : u6.__e = j3(t7.__e, u6, t7, i7, o5, r7, f6, c5, s5);
  (a6 = l3.diffed) && a6(u6);
}
function M2(n4, u6, t7) {
  u6.__d = void 0;
  for (var i7 = 0; i7 < t7.length; i7++) z3(t7[i7], t7[++i7], t7[++i7]);
  l3.__c && l3.__c(u6, n4), n4.some(function(u7) {
    try {
      n4 = u7.__h, u7.__h = [], n4.some(function(n5) {
        n5.call(u7);
      });
    } catch (n5) {
      l3.__e(n5, u7.__v);
    }
  });
}
function j3(l5, u6, t7, i7, o5, r7, f6, e8, s5) {
  var a6, v5, y5, d5, _5, g6, b4, k6 = t7.props, w6 = u6.props, x6 = u6.type;
  if ("svg" === x6 && (o5 = true), null != r7) {
    for (a6 = 0; a6 < r7.length; a6++) if ((_5 = r7[a6]) && "setAttribute" in _5 == !!x6 && (x6 ? _5.localName === x6 : 3 === _5.nodeType)) {
      l5 = _5, r7[a6] = null;
      break;
    }
  }
  if (null == l5) {
    if (null === x6) return document.createTextNode(w6);
    l5 = o5 ? document.createElementNS("http://www.w3.org/2000/svg", x6) : document.createElement(x6, w6.is && w6), r7 = null, e8 = false;
  }
  if (null === x6) k6 === w6 || e8 && l5.data === w6 || (l5.data = w6);
  else {
    if (r7 = r7 && n3.call(l5.childNodes), k6 = t7.props || c3, !e8 && null != r7) for (k6 = {}, a6 = 0; a6 < l5.attributes.length; a6++) k6[(_5 = l5.attributes[a6]).name] = _5.value;
    for (a6 in k6) _5 = k6[a6], "children" == a6 || ("dangerouslySetInnerHTML" == a6 ? y5 = _5 : "key" === a6 || a6 in w6 || T3(l5, a6, null, _5, o5));
    for (a6 in w6) _5 = w6[a6], "children" == a6 ? d5 = _5 : "dangerouslySetInnerHTML" == a6 ? v5 = _5 : "value" == a6 ? g6 = _5 : "checked" == a6 ? b4 = _5 : "key" === a6 || e8 && "function" != typeof _5 || k6[a6] === _5 || T3(l5, a6, _5, k6[a6], o5);
    if (v5) e8 || y5 && (v5.__html === y5.__html || v5.__html === l5.innerHTML) || (l5.innerHTML = v5.__html), u6.__k = [];
    else if (y5 && (l5.innerHTML = ""), C3(l5, h3(d5) ? d5 : [d5], u6, t7, i7, o5 && "foreignObject" !== x6, r7, f6, r7 ? r7[0] : t7.__k && m4(t7, 0), e8, s5), null != r7) for (a6 = r7.length; a6--; ) null != r7[a6] && p3(r7[a6]);
    e8 || (a6 = "value", void 0 !== g6 && (g6 !== l5[a6] || "progress" === x6 && !g6 || "option" === x6 && g6 !== k6[a6]) && T3(l5, a6, g6, k6[a6], false), a6 = "checked", void 0 !== b4 && b4 !== l5[a6] && T3(l5, a6, b4, k6[a6], false));
  }
  return l5;
}
function z3(n4, u6, t7) {
  try {
    "function" == typeof n4 ? n4(u6) : n4.current = u6;
  } catch (n5) {
    l3.__e(n5, t7);
  }
}
function N2(n4, u6, t7) {
  var i7, o5;
  if (l3.unmount && l3.unmount(n4), (i7 = n4.ref) && (i7.current && i7.current !== n4.__e || z3(i7, null, u6)), null != (i7 = n4.__c)) {
    if (i7.componentWillUnmount) try {
      i7.componentWillUnmount();
    } catch (n5) {
      l3.__e(n5, u6);
    }
    i7.base = i7.__P = null, n4.__c = void 0;
  }
  if (i7 = n4.__k) for (o5 = 0; o5 < i7.length; o5++) i7[o5] && N2(i7[o5], u6, t7 || "function" != typeof n4.type);
  t7 || null == n4.__e || p3(n4.__e), n4.__ = n4.__e = n4.__d = void 0;
}
function O2(n4, l5, u6) {
  return this.constructor(n4, u6);
}
function q3(u6, t7, i7) {
  var o5, r7, f6, e8;
  l3.__ && l3.__(u6, t7), r7 = (o5 = "function" == typeof i7) ? null : i7 && i7.__k || t7.__k, f6 = [], e8 = [], L2(t7, u6 = (!o5 && i7 || t7).__k = y3(g3, null, [u6]), r7 || c3, c3, void 0 !== t7.ownerSVGElement, !o5 && i7 ? [i7] : r7 ? null : t7.firstChild ? n3.call(t7.childNodes) : null, f6, !o5 && i7 ? i7 : r7 ? r7.__e : t7.firstChild, o5, e8), M2(f6, u6, e8);
}
function B3(n4, l5) {
  q3(n4, l5, B3);
}
function E(l5, u6, t7) {
  var i7, o5, r7, f6, e8 = v3({}, l5.props);
  for (r7 in l5.type && l5.type.defaultProps && (f6 = l5.type.defaultProps), u6) "key" == r7 ? i7 = u6[r7] : "ref" == r7 ? o5 = u6[r7] : e8[r7] = void 0 === u6[r7] && void 0 !== f6 ? f6[r7] : u6[r7];
  return arguments.length > 2 && (e8.children = arguments.length > 3 ? n3.call(arguments, 2) : t7), d3(l5.type, e8, i7 || l5.key, o5 || l5.ref, null);
}
function F3(n4, l5) {
  var u6 = { __c: l5 = "__cC" + e5++, __: n4, Consumer: function(n5, l6) {
    return n5.children(l6);
  }, Provider: function(n5) {
    var u7, t7;
    return this.getChildContext || (u7 = [], (t7 = {})[l5] = this, this.getChildContext = function() {
      return t7;
    }, this.shouldComponentUpdate = function(n6) {
      this.props.value !== n6.value && u7.some(function(n7) {
        n7.__e = true, w3(n7);
      });
    }, this.sub = function(n6) {
      u7.push(n6);
      var l6 = n6.componentWillUnmount;
      n6.componentWillUnmount = function() {
        u7.splice(u7.indexOf(n6), 1), l6 && l6.call(n6);
      };
    }), n5.children;
  } };
  return u6.Provider.__ = u6.Consumer.contextType = u6;
}
n3 = s3.slice, l3 = { __e: function(n4, l5, u6, t7) {
  for (var i7, o5, r7; l5 = l5.__; ) if ((i7 = l5.__c) && !i7.__) try {
    if ((o5 = i7.constructor) && null != o5.getDerivedStateFromError && (i7.setState(o5.getDerivedStateFromError(n4)), r7 = i7.__d), null != i7.componentDidCatch && (i7.componentDidCatch(n4, t7 || {}), r7 = i7.__d), r7) return i7.__E = i7;
  } catch (l6) {
    n4 = l6;
  }
  throw n4;
} }, u3 = 0, t4 = function(n4) {
  return null != n4 && null == n4.constructor;
}, b2.prototype.setState = function(n4, l5) {
  var u6;
  u6 = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v3({}, this.state), "function" == typeof n4 && (n4 = n4(v3({}, u6), this.props)), n4 && v3(u6, n4), null != n4 && this.__v && (l5 && this._sb.push(l5), w3(this));
}, b2.prototype.forceUpdate = function(n4) {
  this.__v && (this.__e = true, n4 && this.__h.push(n4), w3(this));
}, b2.prototype.render = g3, i3 = [], r4 = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f3 = function(n4, l5) {
  return n4.__v.__b - l5.__v.__b;
}, x3.__r = 0, e5 = 0;

// node_modules/@bpmn-io/properties-panel/preact/hooks/dist/hooks.module.js
var t5;
var r5;
var u4;
var i4;
var o4 = 0;
var f4 = [];
var c4 = [];
var e6 = l3.__b;
var a4 = l3.__r;
var v4 = l3.diffed;
var l4 = l3.__c;
var m5 = l3.unmount;
function d4(t7, u6) {
  l3.__h && l3.__h(r5, t7, o4 || u6), o4 = 0;
  var i7 = r5.__H || (r5.__H = { __: [], __h: [] });
  return t7 >= i7.__.length && i7.__.push({ __V: c4 }), i7.__[t7];
}
function h4(n4) {
  return o4 = 1, s4(B4, n4);
}
function s4(n4, u6, i7) {
  var o5 = d4(t5++, 2);
  if (o5.t = n4, !o5.__c && (o5.__ = [i7 ? i7(u6) : B4(void 0, u6), function(n5) {
    var t7 = o5.__N ? o5.__N[0] : o5.__[0], r7 = o5.t(t7, n5);
    t7 !== r7 && (o5.__N = [r7, o5.__[1]], o5.__c.setState({}));
  }], o5.__c = r5, !r5.u)) {
    var f6 = function(n5, t7, r7) {
      if (!o5.__c.__H) return true;
      var u7 = o5.__c.__H.__.filter(function(n6) {
        return n6.__c;
      });
      if (u7.every(function(n6) {
        return !n6.__N;
      })) return !c5 || c5.call(this, n5, t7, r7);
      var i8 = false;
      return u7.forEach(function(n6) {
        if (n6.__N) {
          var t8 = n6.__[0];
          n6.__ = n6.__N, n6.__N = void 0, t8 !== n6.__[0] && (i8 = true);
        }
      }), !(!i8 && o5.__c.props === n5) && (!c5 || c5.call(this, n5, t7, r7));
    };
    r5.u = true;
    var c5 = r5.shouldComponentUpdate, e8 = r5.componentWillUpdate;
    r5.componentWillUpdate = function(n5, t7, r7) {
      if (this.__e) {
        var u7 = c5;
        c5 = void 0, f6(n5, t7, r7), c5 = u7;
      }
      e8 && e8.call(this, n5, t7, r7);
    }, r5.shouldComponentUpdate = f6;
  }
  return o5.__N || o5.__;
}
function p4(u6, i7) {
  var o5 = d4(t5++, 3);
  !l3.__s && z4(o5.__H, i7) && (o5.__ = u6, o5.i = i7, r5.__H.__h.push(o5));
}
function y4(u6, i7) {
  var o5 = d4(t5++, 4);
  !l3.__s && z4(o5.__H, i7) && (o5.__ = u6, o5.i = i7, r5.__h.push(o5));
}
function _4(n4) {
  return o4 = 5, F4(function() {
    return { current: n4 };
  }, []);
}
function A4(n4, t7, r7) {
  o4 = 6, y4(function() {
    return "function" == typeof n4 ? (n4(t7()), function() {
      return n4(null);
    }) : n4 ? (n4.current = t7(), function() {
      return n4.current = null;
    }) : void 0;
  }, null == r7 ? r7 : r7.concat(n4));
}
function F4(n4, r7) {
  var u6 = d4(t5++, 7);
  return z4(u6.__H, r7) ? (u6.__V = n4(), u6.i = r7, u6.__h = n4, u6.__V) : u6.__;
}
function T4(n4, t7) {
  return o4 = 8, F4(function() {
    return n4;
  }, t7);
}
function q4(n4) {
  var u6 = r5.context[n4.__c], i7 = d4(t5++, 9);
  return i7.c = n4, u6 ? (null == i7.__ && (i7.__ = true, u6.sub(r5)), u6.props.value) : n4.__;
}
function x4(t7, r7) {
  l3.useDebugValue && l3.useDebugValue(r7 ? r7(t7) : t7);
}
function V2() {
  var n4 = d4(t5++, 11);
  if (!n4.__) {
    for (var u6 = r5.__v; null !== u6 && !u6.__m && null !== u6.__; ) u6 = u6.__;
    var i7 = u6.__m || (u6.__m = [0, 0]);
    n4.__ = "P" + i7[0] + "-" + i7[1]++;
  }
  return n4.__;
}
function b3() {
  for (var t7; t7 = f4.shift(); ) if (t7.__P && t7.__H) try {
    t7.__H.__h.forEach(k4), t7.__H.__h.forEach(w4), t7.__H.__h = [];
  } catch (r7) {
    t7.__H.__h = [], l3.__e(r7, t7.__v);
  }
}
l3.__b = function(n4) {
  r5 = null, e6 && e6(n4);
}, l3.__r = function(n4) {
  a4 && a4(n4), t5 = 0;
  var i7 = (r5 = n4.__c).__H;
  i7 && (u4 === r5 ? (i7.__h = [], r5.__h = [], i7.__.forEach(function(n5) {
    n5.__N && (n5.__ = n5.__N), n5.__V = c4, n5.__N = n5.i = void 0;
  })) : (i7.__h.forEach(k4), i7.__h.forEach(w4), i7.__h = [], t5 = 0)), u4 = r5;
}, l3.diffed = function(t7) {
  v4 && v4(t7);
  var o5 = t7.__c;
  o5 && o5.__H && (o5.__H.__h.length && (1 !== f4.push(o5) && i4 === l3.requestAnimationFrame || ((i4 = l3.requestAnimationFrame) || j4)(b3)), o5.__H.__.forEach(function(n4) {
    n4.i && (n4.__H = n4.i), n4.__V !== c4 && (n4.__ = n4.__V), n4.i = void 0, n4.__V = c4;
  })), u4 = r5 = null;
}, l3.__c = function(t7, r7) {
  r7.some(function(t8) {
    try {
      t8.__h.forEach(k4), t8.__h = t8.__h.filter(function(n4) {
        return !n4.__ || w4(n4);
      });
    } catch (u6) {
      r7.some(function(n4) {
        n4.__h && (n4.__h = []);
      }), r7 = [], l3.__e(u6, t8.__v);
    }
  }), l4 && l4(t7, r7);
}, l3.unmount = function(t7) {
  m5 && m5(t7);
  var r7, u6 = t7.__c;
  u6 && u6.__H && (u6.__H.__.forEach(function(n4) {
    try {
      k4(n4);
    } catch (n5) {
      r7 = n5;
    }
  }), u6.__H = void 0, r7 && l3.__e(r7, u6.__v));
};
var g4 = "function" == typeof requestAnimationFrame;
function j4(n4) {
  var t7, r7 = function() {
    clearTimeout(u6), g4 && cancelAnimationFrame(t7), setTimeout(n4);
  }, u6 = setTimeout(r7, 100);
  g4 && (t7 = requestAnimationFrame(r7));
}
function k4(n4) {
  var t7 = r5, u6 = n4.__c;
  "function" == typeof u6 && (n4.__c = void 0, u6()), r5 = t7;
}
function w4(n4) {
  var t7 = r5;
  n4.__c = n4.__(), r5 = t7;
}
function z4(n4, t7) {
  return !n4 || n4.length !== t7.length || t7.some(function(t8, r7) {
    return t8 !== n4[r7];
  });
}
function B4(n4, t7) {
  return "function" == typeof t7 ? t7(n4) : t7;
}

// node_modules/@bpmn-io/properties-panel/preact/compat/dist/compat.module.js
function g5(n4, t7) {
  for (var e8 in t7) n4[e8] = t7[e8];
  return n4;
}
function C4(n4, t7) {
  for (var e8 in n4) if ("__source" !== e8 && !(e8 in t7)) return true;
  for (var r7 in t7) if ("__source" !== r7 && n4[r7] !== t7[r7]) return true;
  return false;
}
function E2(n4) {
  this.props = n4;
}
function w5(n4, e8) {
  function r7(n5) {
    var t7 = this.props.ref, r8 = t7 == n5.ref;
    return !r8 && t7 && (t7.call ? t7(null) : t7.current = null), e8 ? !e8(this.props, n5) || !r8 : C4(this.props, n5);
  }
  function u6(e9) {
    return this.shouldComponentUpdate = r7, y3(n4, e9);
  }
  return u6.displayName = "Memo(" + (n4.displayName || n4.name) + ")", u6.prototype.isReactComponent = true, u6.__f = true, u6;
}
(E2.prototype = new b2()).isPureReactComponent = true, E2.prototype.shouldComponentUpdate = function(n4, t7) {
  return C4(this.props, n4) || C4(this.state, t7);
};
var x5 = l3.__b;
l3.__b = function(n4) {
  n4.type && n4.type.__f && n4.ref && (n4.props.ref = n4.ref, n4.ref = null), x5 && x5(n4);
};
var R = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function N3(n4) {
  function t7(t8) {
    var e8 = g5({}, t8);
    return delete e8.ref, n4(e8, t8.ref || null);
  }
  return t7.$$typeof = R, t7.render = t7, t7.prototype.isReactComponent = t7.__f = true, t7.displayName = "ForwardRef(" + (n4.displayName || n4.name) + ")", t7;
}
var k5 = function(n4, t7) {
  return null == n4 ? null : $2($2(n4).map(t7));
};
var A5 = { map: k5, forEach: k5, count: function(n4) {
  return n4 ? $2(n4).length : 0;
}, only: function(n4) {
  var t7 = $2(n4);
  if (1 !== t7.length) throw "Children.only";
  return t7[0];
}, toArray: $2 };
var O3 = l3.__e;
l3.__e = function(n4, t7, e8, r7) {
  if (n4.then) {
    for (var u6, o5 = t7; o5 = o5.__; ) if ((u6 = o5.__c) && u6.__c) return null == t7.__e && (t7.__e = e8.__e, t7.__k = e8.__k), u6.__c(n4, t7);
  }
  O3(n4, t7, e8, r7);
};
var T5 = l3.unmount;
function F5(n4, t7, e8) {
  return n4 && (n4.__c && n4.__c.__H && (n4.__c.__H.__.forEach(function(n5) {
    "function" == typeof n5.__c && n5.__c();
  }), n4.__c.__H = null), null != (n4 = g5({}, n4)).__c && (n4.__c.__P === e8 && (n4.__c.__P = t7), n4.__c = null), n4.__k = n4.__k && n4.__k.map(function(n5) {
    return F5(n5, t7, e8);
  })), n4;
}
function I3(n4, t7, e8) {
  return n4 && e8 && (n4.__v = null, n4.__k = n4.__k && n4.__k.map(function(n5) {
    return I3(n5, t7, e8);
  }), n4.__c && n4.__c.__P === t7 && (n4.__e && e8.appendChild(n4.__e), n4.__c.__e = true, n4.__c.__P = e8)), n4;
}
function L3() {
  this.__u = 0, this.t = null, this.__b = null;
}
function U(n4) {
  var t7 = n4.__.__c;
  return t7 && t7.__a && t7.__a(n4);
}
function D4(n4) {
  var e8, r7, u6;
  function o5(o6) {
    if (e8 || (e8 = n4()).then(function(n5) {
      r7 = n5.default || n5;
    }, function(n5) {
      u6 = n5;
    }), u6) throw u6;
    if (!r7) throw e8;
    return y3(r7, o6);
  }
  return o5.displayName = "Lazy", o5.__f = true, o5;
}
function M3() {
  this.u = null, this.o = null;
}
l3.unmount = function(n4) {
  var t7 = n4.__c;
  t7 && t7.__R && t7.__R(), t7 && 32 & n4.__u && (n4.type = null), T5 && T5(n4);
}, (L3.prototype = new b2()).__c = function(n4, t7) {
  var e8 = t7.__c, r7 = this;
  null == r7.t && (r7.t = []), r7.t.push(e8);
  var u6 = U(r7.__v), o5 = false, i7 = function() {
    o5 || (o5 = true, e8.__R = null, u6 ? u6(l5) : l5());
  };
  e8.__R = i7;
  var l5 = function() {
    if (!--r7.__u) {
      if (r7.state.__a) {
        var n5 = r7.state.__a;
        r7.__v.__k[0] = I3(n5, n5.__c.__P, n5.__c.__O);
      }
      var t8;
      for (r7.setState({ __a: r7.__b = null }); t8 = r7.t.pop(); ) t8.forceUpdate();
    }
  };
  r7.__u++ || 32 & t7.__u || r7.setState({ __a: r7.__b = r7.__v.__k[0] }), n4.then(i7, i7);
}, L3.prototype.componentWillUnmount = function() {
  this.t = [];
}, L3.prototype.render = function(n4, e8) {
  if (this.__b) {
    if (this.__v.__k) {
      var r7 = document.createElement("div"), o5 = this.__v.__k[0].__c;
      this.__v.__k[0] = F5(this.__b, r7, o5.__O = o5.__P);
    }
    this.__b = null;
  }
  var i7 = e8.__a && y3(g3, null, n4.fallback);
  return i7 && (i7.__u &= -33), [y3(g3, null, e8.__a ? null : n4.children), i7];
};
var V3 = function(n4, t7, e8) {
  if (++e8[1] === e8[0] && n4.o.delete(t7), n4.props.revealOrder && ("t" !== n4.props.revealOrder[0] || !n4.o.size)) for (e8 = n4.u; e8; ) {
    for (; e8.length > 3; ) e8.pop()();
    if (e8[1] < e8[0]) break;
    n4.u = e8 = e8[2];
  }
};
function W(n4) {
  return this.getChildContext = function() {
    return n4.context;
  }, n4.children;
}
function P4(n4) {
  var e8 = this, r7 = n4.i;
  e8.componentWillUnmount = function() {
    q3(null, e8.l), e8.l = null, e8.i = null;
  }, e8.i && e8.i !== r7 && e8.componentWillUnmount(), e8.l || (e8.i = r7, e8.l = { nodeType: 1, parentNode: r7, childNodes: [], appendChild: function(n5) {
    this.childNodes.push(n5), e8.i.appendChild(n5);
  }, insertBefore: function(n5, t7) {
    this.childNodes.push(n5), e8.i.appendChild(n5);
  }, removeChild: function(n5) {
    this.childNodes.splice(this.childNodes.indexOf(n5) >>> 1, 1), e8.i.removeChild(n5);
  } }), q3(y3(W, { context: e8.context }, n4.__v), e8.l);
}
function j5(n4, e8) {
  var r7 = y3(P4, { __v: n4, i: e8 });
  return r7.containerInfo = e8, r7;
}
(M3.prototype = new b2()).__a = function(n4) {
  var t7 = this, e8 = U(t7.__v), r7 = t7.o.get(n4);
  return r7[0]++, function(u6) {
    var o5 = function() {
      t7.props.revealOrder ? (r7.push(u6), V3(t7, n4, r7)) : u6();
    };
    e8 ? e8(o5) : o5();
  };
}, M3.prototype.render = function(n4) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t7 = $2(n4.children);
  n4.revealOrder && "b" === n4.revealOrder[0] && t7.reverse();
  for (var e8 = t7.length; e8--; ) this.o.set(t7[e8], this.u = [1, 0, this.u]);
  return n4.children;
}, M3.prototype.componentDidUpdate = M3.prototype.componentDidMount = function() {
  var n4 = this;
  this.o.forEach(function(t7, e8) {
    V3(n4, e8, t7);
  });
};
var z5 = "undefined" != typeof Symbol && Symbol.for && Symbol.for("react.element") || 60103;
var B5 = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/;
var H2 = /^on(Ani|Tra|Tou|BeforeInp|Compo)/;
var Z = /[A-Z0-9]/g;
var Y = "undefined" != typeof document;
var $3 = function(n4) {
  return ("undefined" != typeof Symbol && "symbol" == typeof Symbol() ? /fil|che|rad/ : /fil|che|ra/).test(n4);
};
function q5(n4, t7, e8) {
  return null == t7.__k && (t7.textContent = ""), q3(n4, t7), "function" == typeof e8 && e8(), n4 ? n4.__c : null;
}
function G(n4, t7, e8) {
  return B3(n4, t7), "function" == typeof e8 && e8(), n4 ? n4.__c : null;
}
b2.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(t7) {
  Object.defineProperty(b2.prototype, t7, { configurable: true, get: function() {
    return this["UNSAFE_" + t7];
  }, set: function(n4) {
    Object.defineProperty(this, t7, { configurable: true, writable: true, value: n4 });
  } });
});
var J = l3.event;
function K() {
}
function Q() {
  return this.cancelBubble;
}
function X() {
  return this.defaultPrevented;
}
l3.event = function(n4) {
  return J && (n4 = J(n4)), n4.persist = K, n4.isPropagationStopped = Q, n4.isDefaultPrevented = X, n4.nativeEvent = n4;
};
var nn;
var tn = { enumerable: false, configurable: true, get: function() {
  return this.class;
} };
var en = l3.vnode;
l3.vnode = function(n4) {
  "string" == typeof n4.type && function(n5) {
    var t7 = n5.props, e8 = n5.type, u6 = {};
    for (var o5 in t7) {
      var i7 = t7[o5];
      if (!("value" === o5 && "defaultValue" in t7 && null == i7 || Y && "children" === o5 && "noscript" === e8 || "class" === o5 || "className" === o5)) {
        var l5 = o5.toLowerCase();
        "defaultValue" === o5 && "value" in t7 && null == t7.value ? o5 = "value" : "download" === o5 && true === i7 ? i7 = "" : "ondoubleclick" === l5 ? o5 = "ondblclick" : "onchange" !== l5 || "input" !== e8 && "textarea" !== e8 || $3(t7.type) ? "onfocus" === l5 ? o5 = "onfocusin" : "onblur" === l5 ? o5 = "onfocusout" : H2.test(o5) ? o5 = l5 : -1 === e8.indexOf("-") && B5.test(o5) ? o5 = o5.replace(Z, "-$&").toLowerCase() : null === i7 && (i7 = void 0) : l5 = o5 = "oninput", "oninput" === l5 && u6[o5 = l5] && (o5 = "oninputCapture"), u6[o5] = i7;
      }
    }
    "select" == e8 && u6.multiple && Array.isArray(u6.value) && (u6.value = $2(t7.children).forEach(function(n6) {
      n6.props.selected = -1 != u6.value.indexOf(n6.props.value);
    })), "select" == e8 && null != u6.defaultValue && (u6.value = $2(t7.children).forEach(function(n6) {
      n6.props.selected = u6.multiple ? -1 != u6.defaultValue.indexOf(n6.props.value) : u6.defaultValue == n6.props.value;
    })), t7.class && !t7.className ? (u6.class = t7.class, Object.defineProperty(u6, "className", tn)) : (t7.className && !t7.class || t7.class && t7.className) && (u6.class = u6.className = t7.className), n5.props = u6;
  }(n4), n4.$$typeof = z5, en && en(n4);
};
var rn = l3.__r;
l3.__r = function(n4) {
  rn && rn(n4), nn = n4.__c;
};
var un = l3.diffed;
l3.diffed = function(n4) {
  un && un(n4);
  var t7 = n4.props, e8 = n4.__e;
  null != e8 && "textarea" === n4.type && "value" in t7 && t7.value !== e8.value && (e8.value = null == t7.value ? "" : t7.value), nn = null;
};
var on = { ReactCurrentDispatcher: { current: { readContext: function(n4) {
  return nn.__n[n4.__c].props.value;
} } } };
function cn(n4) {
  return y3.bind(null, n4);
}
function fn(n4) {
  return !!n4 && n4.$$typeof === z5;
}
function an(n4) {
  return fn(n4) && n4.type === g3;
}
function sn(n4) {
  return fn(n4) ? E.apply(null, arguments) : n4;
}
function hn(n4) {
  return !!n4.__k && (q3(null, n4), true);
}
function vn(n4) {
  return n4 && (n4.base || 1 === n4.nodeType && n4) || null;
}
var dn = function(n4, t7) {
  return n4(t7);
};
var pn = function(n4, t7) {
  return n4(t7);
};
var mn = g3;
function yn(n4) {
  n4();
}
function _n(n4) {
  return n4;
}
function bn() {
  return [false, yn];
}
var Sn = y4;
var gn = fn;
function Cn(n4, t7) {
  var e8 = t7(), r7 = h4({ h: { __: e8, v: t7 } }), u6 = r7[0].h, o5 = r7[1];
  return y4(function() {
    u6.__ = e8, u6.v = t7, En(u6) && o5({ h: u6 });
  }, [n4, e8, t7]), p4(function() {
    return En(u6) && o5({ h: u6 }), n4(function() {
      En(u6) && o5({ h: u6 });
    });
  }, [n4]), e8;
}
function En(n4) {
  var t7, e8, r7 = n4.v, u6 = n4.__;
  try {
    var o5 = r7();
    return !((t7 = u6) === (e8 = o5) && (0 !== t7 || 1 / t7 == 1 / e8) || t7 != t7 && e8 != e8);
  } catch (n5) {
    return true;
  }
}
var wn = { useState: h4, useId: V2, useReducer: s4, useEffect: p4, useLayoutEffect: y4, useInsertionEffect: Sn, useTransition: bn, useDeferredValue: _n, useSyncExternalStore: Cn, startTransition: yn, useRef: _4, useImperativeHandle: A4, useMemo: F4, useCallback: T4, useContext: q4, useDebugValue: x4, version: "17.0.2", Children: A5, render: q5, hydrate: G, unmountComponentAtNode: hn, createPortal: j5, createElement: y3, createContext: F3, createFactory: cn, cloneElement: sn, createRef: _3, Fragment: g3, isValidElement: fn, isElement: gn, isFragment: an, findDOMNode: vn, Component: b2, PureComponent: E2, memo: w5, forwardRef: N3, flushSync: pn, unstable_batchedUpdates: dn, StrictMode: mn, Suspense: L3, SuspenseList: M3, lazy: D4, __SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED: on };

// node_modules/@bpmn-io/properties-panel/preact/jsx-runtime/dist/jsxRuntime.module.js
var f5 = 0;
var i5 = Array.isArray;
function u5(e8, t7, n4, o5, i7, u6) {
  var a6, c5, p5 = {};
  for (c5 in t7) "ref" == c5 ? a6 = t7[c5] : p5[c5] = t7[c5];
  var l5 = { type: e8, props: p5, key: n4, ref: a6, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --f5, __i: -1, __u: 0, __source: i7, __self: u6 };
  if ("function" == typeof e8 && (a6 = e8.defaultProps)) for (c5 in a6) void 0 === p5[c5] && (p5[c5] = a6[c5]);
  return l3.vnode && l3.vnode(l5), l5;
}

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var import_classnames = __toESM(require_classnames());

// node_modules/feelers/dist/index.mjs
var import_lr2 = require("@lezer/lr");
var import_highlight4 = require("@lezer/highlight");

// node_modules/lezer-feel/dist/index.js
var import_lr = require("@lezer/lr");
var import_highlight = require("@lezer/highlight");
var propertyIdentifier = 121;
var identifier = 122;
var nameIdentifier = 123;
var insertSemi = 124;
var expression0 = 128;
var ForExpression = 4;
var forExpressionStart = 131;
var ForInExpression = 7;
var Name = 8;
var Identifier = 9;
var AdditionalIdentifier = 10;
var forExpressionBodyStart = 139;
var IfExpression = 19;
var ifExpressionStart = 140;
var QuantifiedExpression = 23;
var quantifiedExpressionStart = 141;
var QuantifiedInExpression = 27;
var PositiveUnaryTest = 37;
var ArithmeticExpression = 41;
var arithmeticPlusStart = 145;
var arithmeticTimesStart = 146;
var arithmeticExpStart = 147;
var arithmeticUnaryStart = 148;
var VariableName = 47;
var PathExpression = 68;
var pathExpressionStart = 154;
var FilterExpression = 70;
var filterExpressionStart = 155;
var FunctionInvocation = 72;
var functionInvocationStart = 156;
var ParameterName = 76;
var nil = 161;
var NumericLiteral = 79;
var StringLiteral = 80;
var BooleanLiteral = 81;
var listStart = 167;
var List = 89;
var FunctionDefinition = 90;
var functionDefinitionStart = 169;
var Context2 = 97;
var contextStart = 171;
var ContextEntry = 98;
var PropertyName = 100;
var PropertyIdentifier = 101;
var LOG_PARSE = typeof process != "undefined" && process.env && /\bfparse(:dbg)?\b/.test(process.env.LOG);
var LOG_PARSE_DEBUG = typeof process != "undefined" && process.env && /\bfparse:dbg\b/.test(process.env.LOG);
var LOG_VARS = typeof process != "undefined" && process.env && /\bcontext\b/.test(process.env.LOG);
var spaceChars = [
  9,
  11,
  12,
  32,
  133,
  160,
  5760,
  8192,
  8193,
  8194,
  8195,
  8196,
  8197,
  8198,
  8199,
  8200,
  8201,
  8202,
  8232,
  8233,
  8239,
  8287,
  12288
];
var newlineChars = chars("\n\r");
var asterix = "*".charCodeAt(0);
var additionalNameChars = chars("'./-+*^");
function chars(str) {
  return Array.from(str).map((s5) => s5.charCodeAt(0));
}
function isStartChar(ch) {
  return ch === 63 || ch >= 65 && ch <= 90 || ch === 95 || ch >= 97 && ch <= 122 || ch >= 192 && ch <= 214 || ch >= 216 && ch <= 246 || ch >= 248 && ch <= 767 || ch >= 880 && ch <= 893 || ch >= 895 && ch <= 8191 || ch >= 8204 && ch <= 8205 || ch >= 8304 && ch <= 8591 || ch >= 11264 && ch <= 12271 || ch >= 12289 && ch <= 55295 || ch >= 63744 && ch <= 64975 || ch >= 65008 && ch <= 65533 || ch >= 55296 && ch <= 56319 || ch >= 56320 && ch <= 57343;
}
function isAdditional(ch) {
  return additionalNameChars.includes(ch);
}
function isPartChar(ch) {
  return ch >= 48 && ch <= 57 || ch === 183 || ch >= 768 && ch <= 879 || ch >= 8255 && ch <= 8256;
}
function isSpace2(ch) {
  return spaceChars.includes(ch);
}
function indent(str, spaces) {
  return spaces.concat(
    str.split(/\n/g).join("\n" + spaces)
  );
}
function parseAdditionalSymbol(input, offset = 0) {
  const next = input.peek(offset);
  if (next === asterix && input.peek(offset + 1) === asterix) {
    return {
      offset: 2,
      token: "**"
    };
  }
  if (isAdditional(next)) {
    return {
      offset: 1,
      token: String.fromCharCode(next)
    };
  }
  return null;
}
function parseIdentifier(input, offset = 0, namePart = false) {
  for (let inside = false, chars2 = [], i7 = 0; ; i7++) {
    const next = input.peek(offset + i7);
    if (isStartChar(next) || (inside || namePart) && isPartChar(next)) {
      if (!inside) {
        inside = true;
      }
      chars2.push(next);
    } else {
      if (chars2.length) {
        return {
          token: String.fromCharCode(...chars2),
          offset: i7
        };
      }
      return null;
    }
  }
}
function parseSpaces(input, offset) {
  for (let inside = false, i7 = 0; ; i7++) {
    let next = input.peek(offset + i7);
    if (isSpace2(next)) {
      if (!inside) {
        inside = true;
      }
    } else {
      if (inside) {
        return {
          token: " ",
          offset: i7
        };
      }
      return null;
    }
  }
}
function parseName2(input, variables) {
  const contextKeys = variables.contextKeys();
  const start = variables.tokens;
  for (let i7 = 0, tokens = [], nextMatch = null; ; ) {
    const namePart = start.length + tokens.length > 0;
    const maybeSpace = tokens.length > 0;
    const match = parseIdentifier(input, i7, namePart) || namePart && parseAdditionalSymbol(input, i7) || maybeSpace && parseSpaces(input, i7);
    if (!match) {
      return nextMatch;
    }
    const {
      token,
      offset
    } = match;
    i7 += offset;
    if (token === " ") {
      continue;
    }
    tokens = [...tokens, token];
    const name2 = [...start, ...tokens].join(" ");
    if (contextKeys.some((el) => el === name2)) {
      const token2 = tokens[0];
      nextMatch = {
        token: token2,
        offset: token2.length,
        term: nameIdentifier
      };
    }
    if (contextKeys.some((el) => el.startsWith(name2))) {
      continue;
    }
    if (dateTimeIdentifiers.some((el) => el === name2)) {
      const token2 = tokens[0];
      nextMatch = {
        token: token2,
        offset: token2.length,
        term: identifier
      };
    }
    if (dateTimeIdentifiers.some((el) => el.startsWith(name2))) {
      continue;
    }
    return nextMatch;
  }
}
var identifiersMap = {
  [identifier]: "identifier",
  [nameIdentifier]: "nameIdentifier"
};
var identifiers = new import_lr.ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <identifier | nameIdentifier>", input.pos);
  const nameMatch = parseName2(input, stack.context);
  const start = stack.context.tokens;
  const match = nameMatch || parseIdentifier(input, 0, start.length > 0);
  if (match) {
    input.advance(match.offset);
    input.acceptToken(nameMatch ? nameMatch.term : identifier);
    LOG_PARSE && console.log("%s: MATCH <%s> <%s>", input.pos, nameMatch ? identifiersMap[nameMatch.term] : "identifier", match.token);
  }
}, { contextual: true });
var propertyIdentifiers = new import_lr.ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <propertyIdentifier>", input.pos);
  const start = stack.context.tokens;
  const match = parseIdentifier(input, 0, start.length > 0);
  if (match) {
    input.advance(match.offset);
    input.acceptToken(propertyIdentifier);
    LOG_PARSE && console.log("%s: MATCH <propertyIdentifier> <%s>", input.pos, match.token);
  }
});
var insertSemicolon = new import_lr.ExternalTokenizer((input, stack) => {
  LOG_PARSE_DEBUG && console.log("%s: T <insertSemi>", input.pos);
  let offset;
  let insert = false;
  for (offset = 0; ; offset++) {
    const char = input.peek(offset);
    if (spaceChars.includes(char)) {
      continue;
    }
    if (newlineChars.includes(char)) {
      insert = true;
    }
    break;
  }
  if (insert) {
    const identifier2 = parseIdentifier(input, offset + 1);
    const spaces = parseSpaces(input, offset + 1);
    if (spaces || identifier2 && /^(then|else|return|satisfies)$/.test(identifier2.token)) {
      return;
    }
    LOG_PARSE && console.log("%s: MATCH <insertSemi>", input.pos);
    input.acceptToken(insertSemi);
  }
});
var prefixedContextStarts = {
  [functionInvocationStart]: "FunctionInvocation",
  [filterExpressionStart]: "FilterExpression",
  [pathExpressionStart]: "PathExpression"
};
var contextStarts = {
  [contextStart]: "Context",
  [functionDefinitionStart]: "FunctionDefinition",
  [forExpressionStart]: "ForExpression",
  [listStart]: "List",
  [ifExpressionStart]: "IfExpression",
  [quantifiedExpressionStart]: "QuantifiedExpression"
};
var contextEnds = {
  [Context2]: "Context",
  [FunctionDefinition]: "FunctionDefinition",
  [ForExpression]: "ForExpression",
  [List]: "List",
  [IfExpression]: "IfExpression",
  [QuantifiedExpression]: "QuantifiedExpression",
  [PathExpression]: "PathExpression",
  [FunctionInvocation]: "FunctionInvocation",
  [FilterExpression]: "FilterExpression",
  [ArithmeticExpression]: "ArithmeticExpression"
};
var ValueProducer = class _ValueProducer {
  /**
   * @param { Function } fn
   */
  constructor(fn2) {
    this.fn = fn2;
  }
  get(variables) {
    return this.fn(variables);
  }
  /**
   * @param { Function } fn
   *
   * @return { ValueProducer }
   */
  static of(fn2) {
    return new _ValueProducer(fn2);
  }
};
var dateTimeLiterals = {
  "date and time": 1,
  "date": 1,
  "time": 1,
  "duration": 1
};
var dateTimeIdentifiers = Object.keys(dateTimeLiterals);
var VariableContext = class {
  /**
   * Creates a new context from a JavaScript object.
   *
   * @param {any} [value]
   */
  constructor(value = {}) {
    this.value = value;
  }
  /**
   * Return all defined keys of the context.
   *
   * @returns {Array<string>} the keys of the context
   */
  getKeys() {
    return Object.keys(this.value);
  }
  /**
   * Returns the value of the given key.
   *
   * If the value represents a context itself, it should be wrapped in a
   * context class.
   *
   * @param {String} key
   * @returns {VariableContext|ValueProducer|null}
   */
  get(key) {
    const result = this.value[key];
    const constructor = (
      /** @type { typeof VariableContext } */
      this.constructor
    );
    if (constructor.isAtomic(result)) {
      return result;
    }
    return constructor.of(result);
  }
  /**
   * Creates a new context with the given key added.
   *
   * @param {String} key
   * @param {any} value
   *
   * @returns {VariableContext} new context with the given key added
   */
  set(key, value) {
    const constructor = (
      /** @type { typeof VariableContext } */
      this.constructor
    );
    return constructor.of({
      ...this.value,
      [key]: value
    });
  }
  /**
   * Non-destructively merge another context into this one,
   * and return the result.
   *
   * @param {ContextValue} other
   *
   * @return {VariableContext}
   */
  merge(other) {
    const constructor = (
      /** @type { typeof VariableContext } */
      this.constructor
    );
    return new constructor(
      constructor.__merge(this.value, other)
    );
  }
  /**
   * Wether the given value is atomic. Non-atomic values need to be wrapped in a
   * context Class.
   *
   * @param {any} value
   * @returns {Boolean}
   */
  static isAtomic(value) {
    return !value || value instanceof this || value instanceof ValueProducer || typeof value !== "object";
  }
  /**
   * Takes any number of Contexts and merges them into a single context.
   *
   * @param { ...VariableContext } contexts
   * @returns { VariableContext }
   */
  static of(...contexts) {
    return contexts.reduce((context, otherContext) => {
      return context.merge(otherContext);
    }, new this({}));
  }
  /**
   * Returns the raw representation of the given context.
   *
   * @param {VariableContext | any} context
   *
   * @return {any}
   */
  static __unwrap(context) {
    if (!context) {
      return {};
    }
    if (context instanceof this) {
      return context.value;
    }
    if (typeof context !== "object") {
      return {};
    }
    return { ...context };
  }
  /**
   * Non-destructively merges two contexts (or their values)
   * with each other, returning the result.
   *
   * @param {ContextValue} context
   * @param {ContextValue} other
   *
   * @return {any}
   */
  static __merge(context, other) {
    return reduce(this.__unwrap(other), (merged, value, key) => {
      if (value instanceof ValueProducer) {
        return {
          ...merged,
          [key]: value
        };
      }
      value = this.__unwrap(value);
      if (has(merged, key)) {
        value = this.__merge(this.__unwrap(merged[key]), value);
      }
      return {
        ...merged,
        [key]: value
      };
    }, this.__unwrap(context));
  }
};
var Variables = class _Variables {
  /**
   * @param { {
   *   name?: string,
   *   tokens?: string[],
   *   children?: Variables[],
   *   parent: Variables | null
   *   context: VariableContext,
   *   value?: any,
   *   raw?: any
   * } } options
   */
  constructor({
    name: name2 = "Expressions",
    tokens = [],
    children = [],
    parent = null,
    context,
    value,
    raw
  }) {
    this.name = name2;
    this.tokens = tokens;
    this.children = children;
    this.parent = parent;
    this.context = context;
    this.value = value;
    this.raw = raw;
  }
  enterScope(name2) {
    const childScope = this.of({
      name: name2,
      parent: this
    });
    LOG_VARS && console.log("[%s] enter", childScope.path, childScope.context);
    return childScope;
  }
  exitScope(str) {
    if (!this.parent) {
      LOG_VARS && console.log("[%s] NO exit %o\n%s", this.path, this.context, indent(str, "  "));
      return this;
    }
    LOG_VARS && console.log("[%s] exit %o\n%s", this.path, this.context, indent(str, "  "));
    return this.parent.pushChild(this);
  }
  token(part) {
    LOG_VARS && console.log("[%s] token <%s> + <%s>", this.path, this.tokens.join(" "), part);
    return this.assign({
      tokens: [...this.tokens, part]
    });
  }
  literal(value) {
    LOG_VARS && console.log("[%s] literal %o", this.path, value);
    return this.pushChild(this.of({
      name: "Literal",
      value
    }));
  }
  /**
   * Return computed scope value
   *
   * @return {any}
   */
  computedValue() {
    for (let scope = this; ; scope = last2(scope.children)) {
      if (!scope) {
        return null;
      }
      if (scope.value) {
        return scope.value;
      }
    }
  }
  contextKeys() {
    return this.context.getKeys().map(normalizeContextKey);
  }
  get path() {
    var _a, _b;
    return ((_b = (_a = this.parent) == null ? void 0 : _a.path) == null ? void 0 : _b.concat(" > ", this.name)) || this.name;
  }
  /**
   * Return value of variable.
   *
   * @param { string } variable
   * @return { any } value
   */
  get(variable) {
    const names = [variable, variable && normalizeContextKey(variable)];
    const contextKey = this.context.getKeys().find(
      (key) => names.includes(normalizeContextKey(key))
    );
    if (typeof contextKey === "undefined") {
      return void 0;
    }
    const val = this.context.get(contextKey);
    if (val instanceof ValueProducer) {
      return val.get(this);
    } else {
      return val;
    }
  }
  resolveName() {
    const variable = this.tokens.join(" ");
    const tokens = [];
    const parentScope = this.assign({
      tokens
    });
    const variableScope = this.of({
      name: "VariableName",
      parent: parentScope,
      value: this.get(variable),
      raw: variable
    });
    LOG_VARS && console.log("[%s] resolve name <%s=%s>", variableScope.path, variable, this.get(variable));
    return parentScope.pushChild(variableScope);
  }
  pushChild(child) {
    if (!child) {
      return this;
    }
    const parent = this.assign({
      children: [...this.children, child]
    });
    child.parent = parent;
    return parent;
  }
  pushChildren(children) {
    let parent = this;
    for (const child of children) {
      parent = parent.pushChild(child);
    }
    return parent;
  }
  declareName() {
    if (this.tokens.length === 0) {
      throw Error("no tokens to declare name");
    }
    const variableName = this.tokens.join(" ");
    LOG_VARS && console.log("[%s] declareName <%s>", this.path, variableName);
    return this.assign({
      tokens: []
    }).pushChild(
      this.of({
        name: "Name",
        value: variableName
      })
    );
  }
  define(name2, value) {
    if (typeof name2 !== "string") {
      LOG_VARS && console.log("[%s] no define <%s=%s>", this.path, name2, value);
      return this;
    }
    LOG_VARS && console.log("[%s] define <%s=%s>", this.path, name2, value);
    const context = this.context.set(name2, value);
    return this.assign({
      context
    });
  }
  /**
   * @param { Record<string, any> } [options]
   *
   * @return { Variables }
   */
  assign(options = {}) {
    return _Variables.of({
      ...this,
      ...options
    });
  }
  /**
   * @param { Record<string, any> } [options]
   *
   * @return { Variables }
   */
  of(options = {}) {
    const defaultOptions = {
      context: this.context,
      parent: this.parent
    };
    return _Variables.of({
      ...defaultOptions,
      ...options
    });
  }
  /**
   * @param { {
   *   name?: string,
   *   tokens?: string[],
   *   children?: Variables[],
   *   parent?: Variables | null
   *   context: VariableContext,
   *   value?: any,
   *   raw?: any
   * } } options
   *
   * @return {Variables}
   */
  static of(options) {
    const {
      name: name2,
      tokens = [],
      children = [],
      parent = null,
      context,
      value,
      raw
    } = options;
    if (!context) {
      throw new Error("must provide <context>");
    }
    return new _Variables({
      name: name2,
      tokens: [...tokens],
      children: [...children],
      context,
      parent,
      value,
      raw
    });
  }
};
function normalizeContextKey(name2) {
  return name2.replace(/\s*([./\-'+]|\*\*?)\s*/g, " $1 ").replace(/\s{2,}/g, " ").trim();
}
function wrap(variables, scopeName, code) {
  const parts = variables.children.filter((c5) => c5.name !== scopeName);
  const children = variables.children.filter((c5) => c5.name === scopeName);
  const namePart = parts[0];
  const valuePart = parts[Math.max(1, parts.length - 1)];
  const name2 = namePart == null ? void 0 : namePart.computedValue();
  const value = (valuePart == null ? void 0 : valuePart.computedValue()) || null;
  return variables.assign({
    children
  }).enterScope(scopeName).pushChildren(parts).exitScope(code).define(name2, value);
}
function trackVariables(context = {}, Context3 = VariableContext) {
  const start = Variables.of({
    context: Context3.of(context)
  });
  return new import_lr.ContextTracker({
    start,
    reduce(variables, term, stack, input) {
      if (term === IfExpression) {
        const [thenPart, elsePart] = variables.children.slice(-2);
        variables = variables.assign({
          value: Context3.of(
            thenPart == null ? void 0 : thenPart.computedValue(),
            elsePart == null ? void 0 : elsePart.computedValue()
          )
        });
      }
      if (term === List) {
        variables = variables.assign({
          value: Context3.of(
            ...variables.children.map(
              (c5) => c5 == null ? void 0 : c5.computedValue()
            )
          )
        });
      }
      if (term === FilterExpression) {
        const [sourcePart, _5] = variables.children.slice(-2);
        variables = variables.assign({
          value: sourcePart == null ? void 0 : sourcePart.computedValue()
        });
      }
      if (term === FunctionInvocation) {
        const [
          name2,
          ...args
        ] = variables.children;
        if ((name2 == null ? void 0 : name2.raw) === "get value") {
          variables = getContextValue(variables, args);
        }
      }
      const start2 = contextStarts[term];
      if (start2) {
        return variables.enterScope(start2);
      }
      const prefixedStart = prefixedContextStarts[term];
      if (prefixedStart) {
        const {
          children: currentChildren,
          context: currentContext
        } = variables;
        const children = currentChildren.slice(0, -1);
        const lastChild = last2(currentChildren);
        let newContext = null;
        if (term === pathExpressionStart) {
          newContext = Context3.of(lastChild == null ? void 0 : lastChild.computedValue());
        }
        if (term === filterExpressionStart) {
          newContext = Context3.of(
            currentContext,
            lastChild == null ? void 0 : lastChild.computedValue()
          ).set("item", lastChild == null ? void 0 : lastChild.computedValue());
        }
        return variables.assign({ children }).enterScope(prefixedStart).pushChild(lastChild).assign({ context: newContext || currentContext });
      }
      const code = input.read(input.pos, stack.pos);
      const end = contextEnds[term];
      if (end) {
        return variables.exitScope(code);
      }
      if (term === ContextEntry) {
        const parts = variables.children.filter((c5) => c5.name !== "ContextEntry");
        const name2 = parts[0];
        const value = last2(parts);
        return wrap(variables, "ContextEntry", code).assign(
          {
            value: Context3.of(variables.value).set(name2 == null ? void 0 : name2.computedValue(), value == null ? void 0 : value.computedValue())
          }
        );
      }
      if (term === ForInExpression || term === QuantifiedInExpression) {
        return wrap(variables, "InExpression", code);
      }
      if (term === forExpressionBodyStart) {
        return variables.define(
          "partial",
          ValueProducer.of((variables2) => {
            var _a;
            return (_a = last2(variables2.children)) == null ? void 0 : _a.computedValue();
          })
        );
      }
      if (term === ParameterName) {
        const name2 = last2(variables.children).computedValue();
        return variables.define(name2, 1);
      }
      if (term === arithmeticPlusStart || term === arithmeticTimesStart || term === arithmeticExpStart) {
        const children = variables.children.slice(0, -1);
        const lastChild = last2(variables.children);
        return variables.assign({
          children
        }).enterScope("ArithmeticExpression").pushChild(lastChild);
      }
      if (term === arithmeticUnaryStart) {
        return variables.enterScope("ArithmeticExpression");
      }
      if (term === Identifier || term === AdditionalIdentifier || term === PropertyIdentifier) {
        return variables.token(code);
      }
      if (term === StringLiteral) {
        return variables.literal(code.replace(/^"|"$/g, ""));
      }
      if (term === BooleanLiteral) {
        return variables.literal(code === "true" ? true : false);
      }
      if (term === NumericLiteral) {
        return variables.literal(parseFloat(code));
      }
      if (term === nil) {
        return variables.literal(null);
      }
      if (term === VariableName) {
        return variables.resolveName();
      }
      if (term === Name || term === PropertyName) {
        return variables.declareName();
      }
      if (term === expression0 || term === PositiveUnaryTest) {
        if (variables.tokens.length > 0) {
          throw new Error("uncleared name");
        }
      }
      if (term === expression0) {
        let parent = variables;
        while (parent.parent) {
          parent = parent.exitScope(code);
        }
        return parent;
      }
      return variables;
    }
  });
}
var variableTracker = trackVariables({});
function getContextValue(variables, args) {
  if (!args.length) {
    return variables.assign({
      value: null
    });
  }
  if (args[0].name === "Name") {
    args = extractNamedArgs(args, ["m", "key"]);
  }
  if (args.length !== 2) {
    return variables.assign({
      value: null
    });
  }
  const [
    context,
    key
  ] = args;
  const keyValue = key == null ? void 0 : key.computedValue();
  const contextValue = context == null ? void 0 : context.computedValue();
  if (!contextValue || typeof contextValue !== "object" || typeof keyValue !== "string") {
    return variables.assign({
      value: null
    });
  }
  return variables.assign({
    value: [normalizeContextKey(keyValue), keyValue].reduce((value, keyValue2) => {
      return contextValue.get(keyValue2) || value;
    }, null)
  });
}
function extractNamedArgs(args, argNames) {
  const context = {};
  for (let i7 = 0; i7 < args.length; i7 += 2) {
    const [name2, value] = args.slice(i7, i7 + 2);
    context[name2.value] = value;
  }
  return argNames.map((name2) => context[name2]);
}
function last2(arr) {
  return arr[arr.length - 1];
}
var feelHighlighting = (0, import_highlight.styleTags)({
  StringLiteral: import_highlight.tags.string,
  NumericLiteral: import_highlight.tags.number,
  BooleanLiteral: import_highlight.tags.bool,
  "AtLiteral!": import_highlight.tags.special(import_highlight.tags.string),
  CompareOp: import_highlight.tags.compareOperator,
  ArithOp: import_highlight.tags.arithmeticOperator,
  "for if then else some every satisfies between return": import_highlight.tags.controlKeyword,
  "in instance of and or": import_highlight.tags.operatorKeyword,
  function: import_highlight.tags.definitionKeyword,
  as: import_highlight.tags.keyword,
  "Type/...": import_highlight.tags.typeName,
  Wildcard: import_highlight.tags.special(import_highlight.tags.variableName),
  null: import_highlight.tags.null,
  LineComment: import_highlight.tags.lineComment,
  BlockComment: import_highlight.tags.blockComment,
  'VariableName! "?"': import_highlight.tags.variableName,
  "DateTimeConstructor! SpecialFunctionName!": import_highlight.tags.function(import_highlight.tags.special(import_highlight.tags.variableName)),
  "List Interval": import_highlight.tags.list,
  Context: import_highlight.tags.definition(import_highlight.tags.literal),
  "Name!": import_highlight.tags.definition(import_highlight.tags.variableName),
  "Key/Name! ContextEntryType/Name!": import_highlight.tags.definition(import_highlight.tags.propertyName),
  "PathExpression/VariableName!": import_highlight.tags.function(import_highlight.tags.propertyName),
  "FormalParameter/ParameterName!": import_highlight.tags.function(import_highlight.tags.definition(import_highlight.tags.variableName)),
  "( )": import_highlight.tags.paren,
  "[ ]": import_highlight.tags.squareBracket,
  "{ }": import_highlight.tags.brace,
  ".": import_highlight.tags.derefOperator,
  ", ;": import_highlight.tags.separator,
  "..": import_highlight.tags.punctuation
});
var spec_identifier = { __proto__: null, for: 10, in: 32, return: 36, if: 40, then: 42, else: 44, some: 48, every: 50, satisfies: 56, or: 60, and: 64, between: 72, instance: 86, of: 89, days: 101, time: 103, duration: 105, years: 107, months: 109, date: 111, list: 117, context: 123, function: 130, null: 156, true: 330, false: 330, "?": 170, external: 186, not: 211 };
var parser = import_lr.LRParser.deserialize({
  version: 14,
  states: "C|O`QYOOO`QYOOO$sQYOOOOQU'#Ce'#CeO$}QYO'#C`O&WQYO'#FQOOQQ'#Ff'#FfO&bQYO'#FfO`QYO'#DVOOQU'#En'#EnO(UQ^O'#D]OOQU'#D^'#D^OOQU'#D]'#D]OOQO'#Fn'#FnO*RQWO'#DvOOQQ'#D}'#D}OOQQ'#EO'#EOOOQQ'#EP'#EPO*WOWO'#ESO*RQWO'#EQOOQQ'#EQ'#EQOOQQ'#Ft'#FtOOQQ'#Fr'#FrOOQQ'#Fy'#FyOOQQ'#EU'#EUO`QYO'#EWOOQQ'#FS'#FSO*]Q^O'#FSO,SQYO'#EXO,ZQWO'#EYOOQP'#F}'#F}O,`QXO'#EaOOQQ'#Fz'#FzOOQQ'#FR'#FRQOQWOOOOQQ'#FT'#FTOOQQ'#F^'#F^O`QYO'#CoOOQQ'#F_'#F_O$}QYO'#CsO,kQYO'#DwOOQQ'#Fs'#FsO,pQYO'#EROOQO'#ER'#ERO`QYO'#EVO`QYO'#EUOOQO'#F{'#F{Q,xQWOOO,}QYO'#DRO-tQWO'#FbOOQO'#DT'#DTO.PQYO'#FfO.WQWOOO.}QYO'#CdO/[QYO'#FVOOQQ'#Cc'#CcO/aQYO'#FUOOQQ'#Cb'#CbO/iQYO,58zO`QYO,59iOOQQ'#Fc'#FcOOQQ'#Fd'#FdOOQQ'#Fe'#FeO`QYO,59qO`QYO,59qO`QYO,59qOOQQ'#Fl'#FlO/nQYO,5:^OOQQ'#Fm'#FmO`QYO,5:`O`QYO,59eO`QYO,59gO`QYO,59iO1jQYO,59iO1qQYO,59rOOQQ,5:i,5:iO1vQYO,59qOOQU-E8l-E8lO3jQYO'#FoOOQQ,5:b,5:bOOQQ,5:n,5:nOOQQ,5:l,5:lO3qQYO,5:rOOQQ,5;n,5;nO3{QYO,5:qO4YQWO,5:sO4_QYO,5:tOOQP'#Ee'#EeO5UQXO'#EdOOQO'#Ec'#EcO5]QWO'#EbO5bQWO'#GOO5jQWO,5:{O5oQYO,59ZO/[QYO'#FaOOQQ'#Cw'#CwO5vQYO'#F`OOQQ'#Cv'#CvO6OQYO,59_O6TQYO,5:cO6YQYO,5:mO3tQYO,5:qO6_QYO,5:pO`QYO'#EwQ,xQWOOO`QYO'#EmO7UQWO,5;|O`QYOOOOQR'#Cf'#CfOOQQ'#Ej'#EjO8OQYO,59OO`QYO,5;qOOQQ'#FY'#FYO$}QYO'#EkO8`QYO,5;pO`QYO1G.fOOQQ'#F]'#F]O9VQYO1G/TO;|QYO1G/]O<WQYO1G/]O<bQYO1G/]OOQQ1G/x1G/xO>UQYO1G/zO>]QYO1G/PO?fQYO1G/RO@oQYO1G/TO`QYO1G/TOOQQ1G/T1G/TOAVQYO1G/^OAtQ^O'#CdOCWQYO'#FqOOQO'#Dz'#DzOCbQWO'#DyOCgQWO'#FpOOQO'#Dx'#DxOOQO'#D{'#D{OCoQWO,5<ZOOQQ1G0^1G0^O`QYO1G0]O`QYO'#EsOCtQWO,5<]OOQQ1G0_1G0_ODPQWO'#E[OD[QWO'#F|OOQO'#EZ'#EZODdQWO1G0`OOQP'#Eu'#EuODiQXO,5;OO`QYO,5:|ODpQXO'#EvODxQWO,5<jOOQQ1G0g1G0gO`QYO1G.uO`QYO,5;{O$}QYO'#ElOEQQYO,5;zO`QYO1G.yOEYQYO1G/}OOQO1G0X1G0XOOQO,5;c,5;cOOQO-E8u-E8uOOQO,5;X,5;XOOQO-E8k-E8kOE_QWOOOOQQ-E8h-E8hOEdQYO'#CmOOQQ1G1]1G1]OOQQ,5;V,5;VOOQQ-E8i-E8iOEqQYO7+$QOOQQ7+%f7+%fO`QYO7+$oOFhQYO,5:rOFuQWO7+$oOFzQYO'#D[OOQQ'#DZ'#DZOHnQYO'#D_OHsQYO'#D_OHxQYO'#D_OH}Q`O'#DgOISQ`O'#DjOIXQ`O'#DnOOQQ7+$x7+$xO`QYO,5:eO$}QYO'#ErOI^QWO,5<[OOQQ1G1u1G1uOJdQYO7+%wOJqQYO,5;_OOQO-E8q-E8qOAVQYO,5:vO$}QYO'#EtOKOQWO,5<hOKWQYO7+%zOOQP-E8s-E8sOK_QYO1G0hOOQO,5;b,5;bOOQO-E8t-E8tOKiQYO7+$aOKpQYO1G1gOOQQ,5;W,5;WOOQQ-E8j-E8jOKzQYO7+$eOOQO7+%i7+%iO`QYO,59XOLqQYO<<HZOOQQ<<HZ<<HZO/nQYO'#EoOMzQYO,59vO! nQYO,59yO! sQYO,59yO! xQYO,59yO! }QYO,5:RO$}QYO,5:UO!!lQbO,5:YO!!sQYO1G0POOQO,5;^,5;^OOQO-E8p-E8pO!!}QYO<<IcOOQQ<<Ic<<IcOOQO1G0b1G0bOOQO,5;`,5;`OOQO-E8r-E8rO!%|QYO'#E^OOQQ<<If<<IfO`QYO<<IfO`QYO<<G{O!&sQYO1G.sOOQQ,5;Z,5;ZOOQQ-E8m-E8mO!&}QYO1G/eOOQQ1G/e1G/eO!'SQbO'#D]O!'eQ`O'#D[O!'pQ`O1G/mO!'uQWO'#DmO!'zQ`O'#FhOOQO'#Dl'#DlO!(SQ`O1G/pOOQO'#Dq'#DqO!(XQ`O'#FjOOQO'#Dp'#DpO!(aQ`O1G/tOOQQAN?QAN?QO!(fQYOAN=gOOQQ7+%P7+%PO!)]Q`O,59vOOQQ7+%X7+%XO! }QYO,5:XO$}QYO'#EpO!)hQ`O,5<SOOQQ7+%[7+%[O! }QYO'#EqO!)pQ`O,5<UO!)xQ`O7+%`OOQO1G/s1G/sOOQO,5;[,5;[OOQO-E8n-E8nOOQO,5;],5;]OOQO-E8o-E8oOAVQYO<<HzOOQQAN>fAN>fO/nQYO'#EoO! }QYO<<HzO!)}Q`O7+%`O!*SQ`O1G/tO!!lQbO,5:YO!*XQ`O'#Dn",
  stateData: "!*h~O#rOS#sOSPOSQOS~OTsOZVO[UOdtOhvOivOr}Os}OviO!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~OTsO[UOdtOhvOivOr}Os}OviO!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~OZ!TO#]!UO~P#SO#nRO#oRO~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO!i!fO#z!dOv$bX~O#l#tX$s#tX~P%VO$i!mOT$YXZ$YX[$YXd$YXh$YXi$YXr$YXs$YXv$YX!T$YX!U$YX!V$YX!X$YX!c$YX!g$YX!i$YX!p$YX!w$YX#S$YX#n$YX#o$YX$Z$YX$j$YX$k$YX$l$YX~O#nRO#oROZ!PX[!PX]!PX^!PX_!PX`!PXn!PXp!PXr!PXs!PXt!PXv!PX{!PX!i!PX#l!PX#p!PX#z!PX$s!PX$O!PXx!PX#}!PX!g!PXe!PXb!PX#R!PXf!PXl!PX~Ov!pO~O$j`O~O#p!uOZ#vX[#vX]#vX^#vX_#vX`#vXn#vXp#vXr#vXs#vXt#vXv#vX{#vX!i#vX#l#vX#z#vX$s#vX$O#vXx#vX#}#vX!g#vXe#vXb#vX#R#vXf#vXl#vX~O!g$eP~P`Ov!xO~O#m!yO$j`O#R$rP~Op#VO~Op#WOv!uX~O$s#ZO~O#luX$OuX$suXxuX#}uX!guXeuXbuX#RuXfuXluX~P%VO$O#]O#l$UXx$UX~O#l#[X~P&bOv#_O~OZ#`O[#`O]#`O^#`O_#`O#nRO#oRO#z#`O#{#`O$]WX~O`WXxWX$OWX~P.]O`#dO~O$O#eOb#xX~Ob#hO~O#nRO#oRO$ZZO~OTsOZVO[UOdtOhvOivOr}Os}O!T{O!U{O!VxO!XzO!c!OO!g|O!igO!pyO!wjO#SnO#nRO#oRO$ZZO$i_O$j`O$kaO$lbO~Ov#rO~P/yO|#tO~O{!lO!i!fO#z!dOZya[ya]ya^ya_ya`yanyapyaryasyatyav$bX#lya$sya$Oyaxya#}ya!gyaeyabya#Ryafyalya~Ox$eP~P`Ox#}O#}$OO~P%VO#}$OO$O$PO!g$eX~P%VO!g$RO~O#nRO#oROx$pP~OZ#`O[#`O]#`O^#`O_#`O#m!yO#z#`O#{#`O~O$]#WX~P4jO$]$YO~O$O$ZO#R$rX~O#R$]O~Oe$^O~P%VO$O$`Ol$SX~Ol$bO~O!W$cO~O!T$dO~O#l!xa$s!xa$O!xax!xa#}!xa!g!xae!xab!xa#R!xaf!xal!xa~P%VO$O#]O#l$Uax$Ua~OZ#`O[#`O]#`O^#`O_#`O#nRO#oRO#z#`O#{#`O~O`Wa$]WaxWa$OWa~P7aO$O#eOb#xa~OZ!^O[!^O]!_O^!_O_!`O{!lO!i!fO#z!dOv$bX~O`qinqipqirqisqitqi#lqi$sqi$Oqixqi#}qi!gqieqibqi#Rqifqilqi~P8hO_!`O{!lO!i!fO#z!dOZyi[yi`yinyipyiryisyityiv$bX#lyi$syi$Oyixyi#}yi!gyieyibyi#Ryifyilyi~O]!_O^!_O~P:`O]yi^yi~P:`O{!lO!i!fO#z!dOZyi[yi]yi^yi_yi`yinyipyiryisyityiv$bX#lyi$syi$Oyixyi#}yi!gyieyibyi#Ryifyilyi~O!g$pO~P%VO`!kOp!iOr!]Os!]Ot!jOnmi#lmi$smi$Omixmi#}mi!gmiemibmi#Rmifmilmi~P8hO`!kOr!]Os!]Ot!jOnoipoi#loi$soi$Ooixoi#}oi!goieoiboi#Roifoiloi~P8hO`!kOn!hOp$qOr!]Os!]Ot!jO~P8hO!S$vO!V$wO!X$xO![$yO!_$zO!c${O#nRO#oRO$ZZO~OZ#bX[#bX]#bX^#bX_#bX`#bXn#bXp#bXr#bXs#bXt#bXv#bXx#bX{#bX!i#bX#n#bX#o#bX#p#bX#z#bX$O#bX~P.]O$O$POx$eX~P%VO$]$}O~O$O%OOx$dX~Ox%QO~O$O$PO!g$eax$ea~O$]%UOx#OX$O#OX~O$O%VOx$pX~Ox%XO~O$]#Wa~P4jO#m!yO$j`O~O$O$ZO#R$ra~O$O$`Ol$Sa~O!U%cO~OxrO~O#}%dObaX$OaX~P%VO#lSq$sSq$OSqxSq#}Sq!gSqeSqbSq#RSqfSqlSq~P%VOx#}O#}$OO$OuX~P%VOx%fO~O#z%gOZ!OX[!OX]!OX^!OX_!OX`!OXn!OXp!OXr!OXs!OXt!OXv!OX{!OX!i!OX#l!OX$s!OX$O!OXx!OX#}!OX!g!OXe!OXb!OX#R!OXf!OXl!OX~Op%iO~Op%jO~Op%kO~O!]%lO~O!]%mO~O!]%nO~O$O%OOx$da~OZ!^O[!^O]!_O^!_O_!`O`!kOn!hOp!iOr!]Os!]Ot!jO{!lO#z!dOv$bX~Ox%sO!g%sO!i%rO~PIfO!g#ga$O#gax#ga~P%VO$O%VOx$pa~O#P%yO~P`O#R#Ui$O#Ui~P%VOf%zO~P%VOl$Ti$O$Ti~P%VO#lgq$sgq$Ogqxgq#}gq!ggqegqbgq#Rgqfgqlgq~P%VO`qynqypqyrqysqytqy#lqy$sqy$Oqyxqy#}qy!gqyeqybqy#Rqyfqylqy~P8hO#z%gOZ!Oa[!Oa]!Oa^!Oa_!Oa`!Oan!Oap!Oar!Oas!Oat!Oav!Oa{!Oa!i!Oa#l!Oa$s!Oa$O!Oax!Oa#}!Oa!g!Oae!Oab!Oa#R!Oaf!Oal!Oa~O!T&OO~O!W&OO~O!T&PO~O!S$vO!V$wO!X$xO![$yO!_$zO!c&uO#nRO#oRO$ZZO~O!Y$^P~P! }Ox!mi$O!mi~P%VOT$aXZ$aX[$aX]!yy^!yy_!yy`!yyd$aXh$aXi$aXn!yyp!yyr$aXs$aXt!yyv$aX{!yy!T$aX!U$aX!V$aX!X$aX!c$aX!g$aX!i$aX!p$aX!w$aX#S$aX#l!yy#n$aX#o$aX#z!yy$Z$aX$i$aX$j$aX$k$aX$l$aX$s!yy$O!yyx!yy#}!yye!yyb!yy#R!yyf!yyl!yy~O#l#QX$s#QX$O#QXx#QX#}#QX!g#QXe#QXb#QX#R#QXf#QXl#QX~P%VObai$Oai~P%VO!U&_O~O#nRO#oRO!Y!PX#z!PX$O!PX~O#z&pO!Y!OX$O!OX~O!Y&aO~O$]&bO~O$O&cO!Y$[X~O!Y&eO~O$O&fO!Y$^X~O!Y&hO~O#lc!R$sc!R$Oc!Rxc!R#}c!R!gc!Rec!Rbc!R#Rc!Rfc!Rlc!R~P%VO#z&pO!Y!Oa$O!Oa~O$O&cO!Y$[a~O$O&fO!Y$^a~O$_&nO~O$_&qO~O!Y&rO~O!]&tO~O$Z~QP_^$i]#z~",
  goto: "E|$sPPPP$tP%m%p%v&Y'sPPPPPP'|P$tPPP$tPP(P(SP$tP$tP$tPPP(YP(eP$t$tPP(n)T)`*m)TPPPPPPP)TPP)TP+r+u)TP+{,R$tP$tP$t,Y-R-U-[-RP-d.]-d-d/]0UP$t0}$t1v1v2o2rP2xPP1v3O3U/X3YPP3bP3e3l3r3x4O5Z5e5k5q5w6O6U6[6bPPPPPPPP6h6q8x9q:j:mPP:qPP:w:z;s<l<o<s<x=g>V>vP?oP?rP?v@iA[BTBZB^$tBdBdPPPPC]8xDUD}EQEy!mjOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR![SQ!YSR$m#eS!WS#eS#Qw$`W#w!p!x%O%VT&T%m&c#WXOPQWYilu|}!]!a!b!c!e!g!h!i!j!k#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%l%n%y%z&Q&b&f&n&p&q&tb!VSw!x#e$`%O%V%m&cU#a!V#b#uR#u!pU#a!V#b#uT$W!z$XR$l#cR#UwQ#SwR%`$`U!RQ#_#rQ#s!kR$g#]QrQQ$i#_R$s#rQ$|#tQ%t%UQ&S%lU&X%n&f&tQ&i&bT&o&n&qc$u#t%U%l%n&b&f&n&q&t!lkOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ#m!eU$t#t%U&nS%|%g&p]&R%l%n&b&f&q&t#V[OPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%l%n%y%z&b&f&n&p&q&tR&W%mQ&U%mR&j&cQ&[%nR&s&tS&Y%n&tR&l&f!m]OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#|!pQ#y!pR%p%OS#x!p%OT$S!x%V!meOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!leOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ!rbT!{o$Z!mcOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mdOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mhOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mpOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR$V!xQ$T!xR%u%VQ%x%XR&]%yQ!}oR%[$ZT!|o$ZS!zo$ZT$W!z$XRrQS#b!V#uR$j#bQ#f!YR$n#fQ$a#SR%a$aQ#^!RR$h#^!vYOPQWilu|}!]!a!b!c!e!g!h!i!j!k!p#Z#]#_#c#g#r#t$O$P$Y$^$_$b$q$}%U%X%d%g%y%z&nS!oY&Q_&Q%l%n&b&f&p&q&tQ%h$tS%}%h&`R&`&RQ&d&UR&k&dQ&g&YR&m&gQ%P#yR%q%PS$Q!v#vR%T$QQ%W$TR%v%WQ$X!zR%Y$XQ$[!}R%]$[Q#[!PR$f#[QrOQ!PPR$e#ZUTOP#ZW!QQ!k#]#_Q!nWQ!tiQ!vlQ#PuQ#X|Q#Y}Q#i!]Q#j!aQ#k!bQ#l!cQ#n!gQ#o!hQ#p!iQ#q!jQ#v!pQ$k#cQ$o#gQ$r#rQ%R$OQ%S$PQ%Z$YQ%^$^Q%_$_Q%b$bQ%e$qQ%o$}S%w%X%yQ%{%dR&^%z!mqOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mSOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR!ZST!XS#eQ#c!WR$_#QR#g![!muOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mwOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#TwT#Rw$`V!SQ#_#r!X!aT!Q!t!v#P#X#Y#i#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!Z!bT!Q!t!v#P#X#Y#i#j#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!]!cT!Q!t!v#P#X#Y#i#j#k#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!mWOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR&V%mT&Z%n&t!a!eT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!a!gT!Q!n!t!v#P#X#Y#i#j#k#l#n#o#p#q#v$k$o$r%R%S%Z%^%_%b%e%o%w%{&^!m^OPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zQ!q^R!scR#z!pQ!wlR#{!p!mfOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mlOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%z!mmOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR$U!x!moOPQWilu|}!]!a!b!c!g!h!i!j!k!p#Z#]#_#c#g#r$O$P$Y$^$_$b$q$}%X%d%y%zR#Oo",
  nodeNames: "\u26A0 LineComment BlockComment Expression ForExpression for InExpressions InExpression Name Identifier Identifier ArithOp ArithOp ArithOp ArithOp ArithOp in IterationContext return IfExpression if then else QuantifiedExpression some every InExpressions InExpression satisfies Disjunction or Conjunction and Comparison CompareOp CompareOp between PositiveUnaryTest ( PositiveUnaryTests ) ArithmeticExpression InstanceOfExpression instance of Type QualifiedName VariableName BacktickIdentifier SpecialType days time duration years months date > ListType list < ContextType context ContextEntryTypes ContextEntryType FunctionType function ArgumentTypes ArgumentType PathExpression ] FilterExpression [ FunctionInvocation SpecialFunctionName NamedParameters NamedParameter ParameterName PositionalParameters null NumericLiteral StringLiteral BooleanLiteral DateTimeLiteral DateTimeConstructor AtLiteral ? SimplePositiveUnaryTest Interval ParenthesizedExpression List FunctionDefinition FormalParameters FormalParameter external FunctionBody } { Context ContextEntry Key Name Identifier Expressions UnaryTests Wildcard not",
  maxTerm: 173,
  context: variableTracker,
  nodeProps: [
    ["group", -17, 4, 19, 23, 29, 31, 33, 41, 42, 68, 70, 72, 85, 86, 88, 89, 90, 97, "Expr", 47, "Expr Expr", -5, 78, 79, 80, 81, 82, "Expr Literal"],
    ["closedBy", 38, ")", 71, "]", 96, "}"],
    ["openedBy", 40, "(", 69, "[", 95, "{"]
  ],
  propSources: [feelHighlighting],
  skippedNodes: [0, 1, 2],
  repeatNodeCount: 14,
  tokenData: ".Z~RvXY#iYZ$^Z[#i]^$^pq#iqr$crs$nwx&fxy&kyz&pz{&u{|'S|}'X}!O'^!O!P'k!P!Q(u!Q![*p![!]+X!]!^+^!^!_+c!_!`$i!`!a+r!b!c+|!}#O,R#P#Q,W#Q#R&}#S#T,]#o#p.P#q#r.U$f$g#i#BY#BZ#i$IS$I_#i$I|$I}$^$I}$JO$^$JT$JU#i$KV$KW#i&FU&FV#i?HT?HU#i~#nY#r~XY#iZ[#ipq#i$f$g#i#BY#BZ#i$IS$I_#i$JT$JU#i$KV$KW#i&FU&FV#i?HT?HU#i~$cO#s~~$fP!_!`$i~$nOr~~$sW$j~OY$nZr$nrs%]s#O$n#O#P%b#P;'S$n;'S;=`&`<%lO$n~%bO$j~~%eRO;'S$n;'S;=`%n;=`O$n~%sX$j~OY$nZr$nrs%]s#O$n#O#P%b#P;'S$n;'S;=`&`;=`<%l$n<%lO$n~&cP;=`<%l$n~&kO#{~~&pOv~~&uOx~~&zP^~z{&}~'SO_~~'XO[~~'^O$O~R'cPZP!`!a'fQ'kO$_Q~'pQ#z~!O!P'v!Q!['{~'{O#}~~(QR$i~!Q!['{!g!h(Z#X#Y(Z~(^R{|(g}!O(g!Q![(m~(jP!Q![(m~(rP$i~!Q![(m~(zQ]~z{)Q!P!Q*X~)TTOz)Qz{)d{;'S)Q;'S;=`*R<%lO)Q~)gVOz)Qz{)d{!P)Q!P!Q)|!Q;'S)Q;'S;=`*R<%lO)Q~*ROQ~~*UP;=`<%l)Q~*^SP~OY*XZ;'S*X;'S;=`*j<%lO*X~*mP;=`<%l*X~*uS$i~!O!P+R!Q![*p!g!h(Z#X#Y(Z~+UP!Q!['{~+^O$]~~+cO$s~R+jP!]QsP!_!`+mP+rOsPR+yP!YQsP!_!`+m~,RO$l~~,WO!i~~,]O!g~~,`WOY,]Z#O,]#O#P,x#P#S,]#S#T-t#T;'S,];'S;=`-y<%lO,]~,{RO;'S,];'S;=`-U;=`O,]~-XXOY,]Z#O,]#O#P,x#P#S,]#S#T-t#T;'S,];'S;=`-y;=`<%l,]<%lO,]~-yO$Z~~-|P;=`<%l,]~.UO#S~~.ZO#R~",
  tokenizers: [propertyIdentifiers, identifiers, insertSemicolon, 0, 1],
  topRules: { "Expression": [0, 3], "Expressions": [1, 102], "UnaryTests": [2, 103] },
  dialects: { camunda: 2544 },
  dynamicPrecedences: { "31": -1, "68": 1, "72": -1, "74": -1 },
  specialized: [{ term: 122, get: (value) => spec_identifier[value] || -1 }],
  tokenPrec: 2546
});

// node_modules/feelers/dist/index.mjs
var import_autocomplete = require("@codemirror/autocomplete");
var import_commands = require("@codemirror/commands");
var import_language3 = require("@codemirror/language");
var import_lint = require("@codemirror/lint");
var import_state = require("@codemirror/state");
var import_view2 = require("@codemirror/view");

// node_modules/@lezer/markdown/dist/index.js
var import_common = require("@lezer/common");
var import_highlight2 = require("@lezer/highlight");
var CompositeBlock = class _CompositeBlock {
  static create(type, value, from, parentHash, end) {
    let hash = parentHash + (parentHash << 8) + type + (value << 4) | 0;
    return new _CompositeBlock(type, value, from, hash, end, [], []);
  }
  constructor(type, value, from, hash, end, children, positions) {
    this.type = type;
    this.value = value;
    this.from = from;
    this.hash = hash;
    this.end = end;
    this.children = children;
    this.positions = positions;
    this.hashProp = [[import_common.NodeProp.contextHash, hash]];
  }
  addChild(child, pos) {
    if (child.prop(import_common.NodeProp.contextHash) != this.hash)
      child = new import_common.Tree(child.type, child.children, child.positions, child.length, this.hashProp);
    this.children.push(child);
    this.positions.push(pos);
  }
  toTree(nodeSet, end = this.end) {
    let last4 = this.children.length - 1;
    if (last4 >= 0)
      end = Math.max(end, this.positions[last4] + this.children[last4].length + this.from);
    return new import_common.Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({
      makeTree: (children, positions, length2) => new import_common.Tree(import_common.NodeType.none, children, positions, length2, this.hashProp)
    });
  }
};
var Type;
(function(Type3) {
  Type3[Type3["Document"] = 1] = "Document";
  Type3[Type3["CodeBlock"] = 2] = "CodeBlock";
  Type3[Type3["FencedCode"] = 3] = "FencedCode";
  Type3[Type3["Blockquote"] = 4] = "Blockquote";
  Type3[Type3["HorizontalRule"] = 5] = "HorizontalRule";
  Type3[Type3["BulletList"] = 6] = "BulletList";
  Type3[Type3["OrderedList"] = 7] = "OrderedList";
  Type3[Type3["ListItem"] = 8] = "ListItem";
  Type3[Type3["ATXHeading1"] = 9] = "ATXHeading1";
  Type3[Type3["ATXHeading2"] = 10] = "ATXHeading2";
  Type3[Type3["ATXHeading3"] = 11] = "ATXHeading3";
  Type3[Type3["ATXHeading4"] = 12] = "ATXHeading4";
  Type3[Type3["ATXHeading5"] = 13] = "ATXHeading5";
  Type3[Type3["ATXHeading6"] = 14] = "ATXHeading6";
  Type3[Type3["SetextHeading1"] = 15] = "SetextHeading1";
  Type3[Type3["SetextHeading2"] = 16] = "SetextHeading2";
  Type3[Type3["HTMLBlock"] = 17] = "HTMLBlock";
  Type3[Type3["LinkReference"] = 18] = "LinkReference";
  Type3[Type3["Paragraph"] = 19] = "Paragraph";
  Type3[Type3["CommentBlock"] = 20] = "CommentBlock";
  Type3[Type3["ProcessingInstructionBlock"] = 21] = "ProcessingInstructionBlock";
  Type3[Type3["Escape"] = 22] = "Escape";
  Type3[Type3["Entity"] = 23] = "Entity";
  Type3[Type3["HardBreak"] = 24] = "HardBreak";
  Type3[Type3["Emphasis"] = 25] = "Emphasis";
  Type3[Type3["StrongEmphasis"] = 26] = "StrongEmphasis";
  Type3[Type3["Link"] = 27] = "Link";
  Type3[Type3["Image"] = 28] = "Image";
  Type3[Type3["InlineCode"] = 29] = "InlineCode";
  Type3[Type3["HTMLTag"] = 30] = "HTMLTag";
  Type3[Type3["Comment"] = 31] = "Comment";
  Type3[Type3["ProcessingInstruction"] = 32] = "ProcessingInstruction";
  Type3[Type3["Autolink"] = 33] = "Autolink";
  Type3[Type3["HeaderMark"] = 34] = "HeaderMark";
  Type3[Type3["QuoteMark"] = 35] = "QuoteMark";
  Type3[Type3["ListMark"] = 36] = "ListMark";
  Type3[Type3["LinkMark"] = 37] = "LinkMark";
  Type3[Type3["EmphasisMark"] = 38] = "EmphasisMark";
  Type3[Type3["CodeMark"] = 39] = "CodeMark";
  Type3[Type3["CodeText"] = 40] = "CodeText";
  Type3[Type3["CodeInfo"] = 41] = "CodeInfo";
  Type3[Type3["LinkTitle"] = 42] = "LinkTitle";
  Type3[Type3["LinkLabel"] = 43] = "LinkLabel";
  Type3[Type3["URL"] = 44] = "URL";
})(Type || (Type = {}));
var LeafBlock = class {
  /**
  @internal
  */
  constructor(start, content) {
    this.start = start;
    this.content = content;
    this.marks = [];
    this.parsers = [];
  }
};
var Line = class {
  constructor() {
    this.text = "";
    this.baseIndent = 0;
    this.basePos = 0;
    this.depth = 0;
    this.markers = [];
    this.pos = 0;
    this.indent = 0;
    this.next = -1;
  }
  /**
  @internal
  */
  forward() {
    if (this.basePos > this.pos)
      this.forwardInner();
  }
  /**
  @internal
  */
  forwardInner() {
    let newPos = this.skipSpace(this.basePos);
    this.indent = this.countIndent(newPos, this.pos, this.indent);
    this.pos = newPos;
    this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);
  }
  /**
  Skip whitespace after the given position, return the position of
  the next non-space character or the end of the line if there's
  only space after `from`.
  */
  skipSpace(from) {
    return skipSpace(this.text, from);
  }
  /**
  @internal
  */
  reset(text) {
    this.text = text;
    this.baseIndent = this.basePos = this.pos = this.indent = 0;
    this.forwardInner();
    this.depth = 1;
    while (this.markers.length)
      this.markers.pop();
  }
  /**
  Move the line's base position forward to the given position.
  This should only be called by composite [block
  parsers](#BlockParser.parse) or [markup skipping
  functions](#NodeSpec.composite).
  */
  moveBase(to) {
    this.basePos = to;
    this.baseIndent = this.countIndent(to, this.pos, this.indent);
  }
  /**
  Move the line's base position forward to the given _column_.
  */
  moveBaseColumn(indent2) {
    this.baseIndent = indent2;
    this.basePos = this.findColumn(indent2);
  }
  /**
  Store a composite-block-level marker. Should be called from
  [markup skipping functions](#NodeSpec.composite) when they
  consume any non-whitespace characters.
  */
  addMarker(elt2) {
    this.markers.push(elt2);
  }
  /**
  Find the column position at `to`, optionally starting at a given
  position and column.
  */
  countIndent(to, from = 0, indent2 = 0) {
    for (let i7 = from; i7 < to; i7++)
      indent2 += this.text.charCodeAt(i7) == 9 ? 4 - indent2 % 4 : 1;
    return indent2;
  }
  /**
  Find the position corresponding to the given column.
  */
  findColumn(goal) {
    let i7 = 0;
    for (let indent2 = 0; i7 < this.text.length && indent2 < goal; i7++)
      indent2 += this.text.charCodeAt(i7) == 9 ? 4 - indent2 % 4 : 1;
    return i7;
  }
  /**
  @internal
  */
  scrub() {
    if (!this.baseIndent)
      return this.text;
    let result = "";
    for (let i7 = 0; i7 < this.basePos; i7++)
      result += " ";
    return result + this.text.slice(this.basePos);
  }
};
function skipForList(bl, cx, line2) {
  if (line2.pos == line2.text.length || bl != cx.block && line2.indent >= cx.stack[line2.depth + 1].value + line2.baseIndent)
    return true;
  if (line2.indent >= line2.baseIndent + 4)
    return false;
  let size2 = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line2, cx, false);
  return size2 > 0 && (bl.type != Type.BulletList || isHorizontalRule(line2, cx, false) < 0) && line2.text.charCodeAt(line2.pos + size2 - 1) == bl.value;
}
var DefaultSkipMarkup = {
  [Type.Blockquote](bl, cx, line2) {
    if (line2.next != 62)
      return false;
    line2.markers.push(elt(Type.QuoteMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + 1));
    line2.moveBase(line2.pos + (space(line2.text.charCodeAt(line2.pos + 1)) ? 2 : 1));
    bl.end = cx.lineStart + line2.text.length;
    return true;
  },
  [Type.ListItem](bl, _cx, line2) {
    if (line2.indent < line2.baseIndent + bl.value && line2.next > -1)
      return false;
    line2.moveBaseColumn(line2.baseIndent + bl.value);
    return true;
  },
  [Type.OrderedList]: skipForList,
  [Type.BulletList]: skipForList,
  [Type.Document]() {
    return true;
  }
};
function space(ch) {
  return ch == 32 || ch == 9 || ch == 10 || ch == 13;
}
function skipSpace(line2, i7 = 0) {
  while (i7 < line2.length && space(line2.charCodeAt(i7)))
    i7++;
  return i7;
}
function skipSpaceBack(line2, i7, to) {
  while (i7 > to && space(line2.charCodeAt(i7 - 1)))
    i7--;
  return i7;
}
function isFencedCode(line2) {
  if (line2.next != 96 && line2.next != 126)
    return -1;
  let pos = line2.pos + 1;
  while (pos < line2.text.length && line2.text.charCodeAt(pos) == line2.next)
    pos++;
  if (pos < line2.pos + 3)
    return -1;
  if (line2.next == 96) {
    for (let i7 = pos; i7 < line2.text.length; i7++)
      if (line2.text.charCodeAt(i7) == 96)
        return -1;
  }
  return pos;
}
function isBlockquote(line2) {
  return line2.next != 62 ? -1 : line2.text.charCodeAt(line2.pos + 1) == 32 ? 2 : 1;
}
function isHorizontalRule(line2, cx, breaking) {
  if (line2.next != 42 && line2.next != 45 && line2.next != 95)
    return -1;
  let count = 1;
  for (let pos = line2.pos + 1; pos < line2.text.length; pos++) {
    let ch = line2.text.charCodeAt(pos);
    if (ch == line2.next)
      count++;
    else if (!space(ch))
      return -1;
  }
  if (breaking && line2.next == 45 && isSetextUnderline(line2) > -1 && line2.depth == cx.stack.length && cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)
    return -1;
  return count < 3 ? -1 : 1;
}
function inList(cx, type) {
  for (let i7 = cx.stack.length - 1; i7 >= 0; i7--)
    if (cx.stack[i7].type == type)
      return true;
  return false;
}
function isBulletList(line2, cx, breaking) {
  return (line2.next == 45 || line2.next == 43 || line2.next == 42) && (line2.pos == line2.text.length - 1 || space(line2.text.charCodeAt(line2.pos + 1))) && (!breaking || inList(cx, Type.BulletList) || line2.skipSpace(line2.pos + 2) < line2.text.length) ? 1 : -1;
}
function isOrderedList(line2, cx, breaking) {
  let pos = line2.pos, next = line2.next;
  for (; ; ) {
    if (next >= 48 && next <= 57)
      pos++;
    else
      break;
    if (pos == line2.text.length)
      return -1;
    next = line2.text.charCodeAt(pos);
  }
  if (pos == line2.pos || pos > line2.pos + 9 || next != 46 && next != 41 || pos < line2.text.length - 1 && !space(line2.text.charCodeAt(pos + 1)) || breaking && !inList(cx, Type.OrderedList) && (line2.skipSpace(pos + 1) == line2.text.length || pos > line2.pos + 1 || line2.next != 49))
    return -1;
  return pos + 1 - line2.pos;
}
function isAtxHeading(line2) {
  if (line2.next != 35)
    return -1;
  let pos = line2.pos + 1;
  while (pos < line2.text.length && line2.text.charCodeAt(pos) == 35)
    pos++;
  if (pos < line2.text.length && line2.text.charCodeAt(pos) != 32)
    return -1;
  let size2 = pos - line2.pos;
  return size2 > 6 ? -1 : size2;
}
function isSetextUnderline(line2) {
  if (line2.next != 45 && line2.next != 61 || line2.indent >= line2.baseIndent + 4)
    return -1;
  let pos = line2.pos + 1;
  while (pos < line2.text.length && line2.text.charCodeAt(pos) == line2.next)
    pos++;
  let end = pos;
  while (pos < line2.text.length && space(line2.text.charCodeAt(pos)))
    pos++;
  return pos == line2.text.length ? end : -1;
}
var EmptyLine = /^[ \t]*$/;
var CommentEnd = /-->/;
var ProcessingEnd = /\?>/;
var HTMLBlockStyle = [
  [/^<(?:script|pre|style)(?:\s|>|$)/i, /<\/(?:script|pre|style)>/i],
  [/^\s*<!--/, CommentEnd],
  [/^\s*<\?/, ProcessingEnd],
  [/^\s*<![A-Z]/, />/],
  [/^\s*<!\[CDATA\[/, /\]\]>/],
  [/^\s*<\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\s|\/?>|$)/i, EmptyLine],
  [/^\s*(?:<\/[a-z][\w-]*\s*>|<[a-z][\w-]*(\s+[a-z:_][\w-.]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*>)\s*$/i, EmptyLine]
];
function isHTMLBlock(line2, _cx, breaking) {
  if (line2.next != 60)
    return -1;
  let rest = line2.text.slice(line2.pos);
  for (let i7 = 0, e8 = HTMLBlockStyle.length - (breaking ? 1 : 0); i7 < e8; i7++)
    if (HTMLBlockStyle[i7][0].test(rest))
      return i7;
  return -1;
}
function getListIndent(line2, pos) {
  let indentAfter = line2.countIndent(pos, line2.pos, line2.indent);
  let indented = line2.countIndent(line2.skipSpace(pos), pos, indentAfter);
  return indented >= indentAfter + 5 ? indentAfter + 1 : indented;
}
function addCodeText(marks, from, to) {
  let last4 = marks.length - 1;
  if (last4 >= 0 && marks[last4].to == from && marks[last4].type == Type.CodeText)
    marks[last4].to = to;
  else
    marks.push(elt(Type.CodeText, from, to));
}
var DefaultBlockParsers = {
  LinkReference: void 0,
  IndentedCode(cx, line2) {
    let base = line2.baseIndent + 4;
    if (line2.indent < base)
      return false;
    let start = line2.findColumn(base);
    let from = cx.lineStart + start, to = cx.lineStart + line2.text.length;
    let marks = [], pendingMarks = [];
    addCodeText(marks, from, to);
    while (cx.nextLine() && line2.depth >= cx.stack.length) {
      if (line2.pos == line2.text.length) {
        addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);
        for (let m6 of line2.markers)
          pendingMarks.push(m6);
      } else if (line2.indent < base) {
        break;
      } else {
        if (pendingMarks.length) {
          for (let m6 of pendingMarks) {
            if (m6.type == Type.CodeText)
              addCodeText(marks, m6.from, m6.to);
            else
              marks.push(m6);
          }
          pendingMarks = [];
        }
        addCodeText(marks, cx.lineStart - 1, cx.lineStart);
        for (let m6 of line2.markers)
          marks.push(m6);
        to = cx.lineStart + line2.text.length;
        let codeStart = cx.lineStart + line2.findColumn(line2.baseIndent + 4);
        if (codeStart < to)
          addCodeText(marks, codeStart, to);
      }
    }
    if (pendingMarks.length) {
      pendingMarks = pendingMarks.filter((m6) => m6.type != Type.CodeText);
      if (pendingMarks.length)
        line2.markers = pendingMarks.concat(line2.markers);
    }
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);
    return true;
  },
  FencedCode(cx, line2) {
    let fenceEnd = isFencedCode(line2);
    if (fenceEnd < 0)
      return false;
    let from = cx.lineStart + line2.pos, ch = line2.next, len = fenceEnd - line2.pos;
    let infoFrom = line2.skipSpace(fenceEnd), infoTo = skipSpaceBack(line2.text, line2.text.length, infoFrom);
    let marks = [elt(Type.CodeMark, from, from + len)];
    if (infoFrom < infoTo)
      marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));
    for (let first2 = true; cx.nextLine() && line2.depth >= cx.stack.length; first2 = false) {
      let i7 = line2.pos;
      if (line2.indent - line2.baseIndent < 4)
        while (i7 < line2.text.length && line2.text.charCodeAt(i7) == ch)
          i7++;
      if (i7 - line2.pos >= len && line2.skipSpace(i7) == line2.text.length) {
        for (let m6 of line2.markers)
          marks.push(m6);
        marks.push(elt(Type.CodeMark, cx.lineStart + line2.pos, cx.lineStart + i7));
        cx.nextLine();
        break;
      } else {
        if (!first2)
          addCodeText(marks, cx.lineStart - 1, cx.lineStart);
        for (let m6 of line2.markers)
          marks.push(m6);
        let textStart = cx.lineStart + line2.basePos, textEnd = cx.lineStart + line2.text.length;
        if (textStart < textEnd)
          addCodeText(marks, textStart, textEnd);
      }
    }
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.FencedCode, cx.prevLineEnd() - from), from);
    return true;
  },
  Blockquote(cx, line2) {
    let size2 = isBlockquote(line2);
    if (size2 < 0)
      return false;
    cx.startContext(Type.Blockquote, line2.pos);
    cx.addNode(Type.QuoteMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + 1);
    line2.moveBase(line2.pos + size2);
    return null;
  },
  HorizontalRule(cx, line2) {
    if (isHorizontalRule(line2, cx, false) < 0)
      return false;
    let from = cx.lineStart + line2.pos;
    cx.nextLine();
    cx.addNode(Type.HorizontalRule, from);
    return true;
  },
  BulletList(cx, line2) {
    let size2 = isBulletList(line2, cx, false);
    if (size2 < 0)
      return false;
    if (cx.block.type != Type.BulletList)
      cx.startContext(Type.BulletList, line2.basePos, line2.next);
    let newBase = getListIndent(line2, line2.pos + 1);
    cx.startContext(Type.ListItem, line2.basePos, newBase - line2.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + size2);
    line2.moveBaseColumn(newBase);
    return null;
  },
  OrderedList(cx, line2) {
    let size2 = isOrderedList(line2, cx, false);
    if (size2 < 0)
      return false;
    if (cx.block.type != Type.OrderedList)
      cx.startContext(Type.OrderedList, line2.basePos, line2.text.charCodeAt(line2.pos + size2 - 1));
    let newBase = getListIndent(line2, line2.pos + size2);
    cx.startContext(Type.ListItem, line2.basePos, newBase - line2.baseIndent);
    cx.addNode(Type.ListMark, cx.lineStart + line2.pos, cx.lineStart + line2.pos + size2);
    line2.moveBaseColumn(newBase);
    return null;
  },
  ATXHeading(cx, line2) {
    let size2 = isAtxHeading(line2);
    if (size2 < 0)
      return false;
    let off = line2.pos, from = cx.lineStart + off;
    let endOfSpace = skipSpaceBack(line2.text, line2.text.length, off), after = endOfSpace;
    while (after > off && line2.text.charCodeAt(after - 1) == line2.next)
      after--;
    if (after == endOfSpace || after == off || !space(line2.text.charCodeAt(after - 1)))
      after = line2.text.length;
    let buf = cx.buffer.write(Type.HeaderMark, 0, size2).writeElements(cx.parser.parseInline(line2.text.slice(off + size2 + 1, after), from + size2 + 1), -from);
    if (after < line2.text.length)
      buf.write(Type.HeaderMark, after - off, endOfSpace - off);
    let node2 = buf.finish(Type.ATXHeading1 - 1 + size2, line2.text.length - off);
    cx.nextLine();
    cx.addNode(node2, from);
    return true;
  },
  HTMLBlock(cx, line2) {
    let type = isHTMLBlock(line2, cx, false);
    if (type < 0)
      return false;
    let from = cx.lineStart + line2.pos, end = HTMLBlockStyle[type][1];
    let marks = [], trailing = end != EmptyLine;
    while (!end.test(line2.text) && cx.nextLine()) {
      if (line2.depth < cx.stack.length) {
        trailing = false;
        break;
      }
      for (let m6 of line2.markers)
        marks.push(m6);
    }
    if (trailing)
      cx.nextLine();
    let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;
    let to = cx.prevLineEnd();
    cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);
    return true;
  },
  SetextHeading: void 0
  // Specifies relative precedence for block-continue function
};
var LinkReferenceParser = class {
  constructor(leaf) {
    this.stage = 0;
    this.elts = [];
    this.pos = 0;
    this.start = leaf.start;
    this.advance(leaf.content);
  }
  nextLine(cx, line2, leaf) {
    if (this.stage == -1)
      return false;
    let content = leaf.content + "\n" + line2.scrub();
    let finish = this.advance(content);
    if (finish > -1 && finish < content.length)
      return this.complete(cx, leaf, finish);
    return false;
  }
  finish(cx, leaf) {
    if ((this.stage == 2 || this.stage == 3) && skipSpace(leaf.content, this.pos) == leaf.content.length)
      return this.complete(cx, leaf, leaf.content.length);
    return false;
  }
  complete(cx, leaf, len) {
    cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));
    return true;
  }
  nextStage(elt2) {
    if (elt2) {
      this.pos = elt2.to - this.start;
      this.elts.push(elt2);
      this.stage++;
      return true;
    }
    if (elt2 === false)
      this.stage = -1;
    return false;
  }
  advance(content) {
    for (; ; ) {
      if (this.stage == -1) {
        return -1;
      } else if (this.stage == 0) {
        if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))
          return -1;
        if (content.charCodeAt(this.pos) != 58)
          return this.stage = -1;
        this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));
        this.pos++;
      } else if (this.stage == 1) {
        if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))
          return -1;
      } else if (this.stage == 2) {
        let skip = skipSpace(content, this.pos), end = 0;
        if (skip > this.pos) {
          let title = parseLinkTitle(content, skip, this.start);
          if (title) {
            let titleEnd = lineEnd(content, title.to - this.start);
            if (titleEnd > 0) {
              this.nextStage(title);
              end = titleEnd;
            }
          }
        }
        if (!end)
          end = lineEnd(content, this.pos);
        return end > 0 && end < content.length ? end : -1;
      } else {
        return lineEnd(content, this.pos);
      }
    }
  }
};
function lineEnd(text, pos) {
  for (; pos < text.length; pos++) {
    let next = text.charCodeAt(pos);
    if (next == 10)
      break;
    if (!space(next))
      return -1;
  }
  return pos;
}
var SetextHeadingParser = class {
  nextLine(cx, line2, leaf) {
    let underline = line2.depth < cx.stack.length ? -1 : isSetextUnderline(line2);
    let next = line2.next;
    if (underline < 0)
      return false;
    let underlineMark = elt(Type.HeaderMark, cx.lineStart + line2.pos, cx.lineStart + underline);
    cx.nextLine();
    cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [
      ...cx.parser.parseInline(leaf.content, leaf.start),
      underlineMark
    ]));
    return true;
  }
  finish() {
    return false;
  }
};
var DefaultLeafBlocks = {
  LinkReference(_5, leaf) {
    return leaf.content.charCodeAt(0) == 91 ? new LinkReferenceParser(leaf) : null;
  },
  SetextHeading() {
    return new SetextHeadingParser();
  }
};
var DefaultEndLeaf = [
  (_5, line2) => isAtxHeading(line2) >= 0,
  (_5, line2) => isFencedCode(line2) >= 0,
  (_5, line2) => isBlockquote(line2) >= 0,
  (p5, line2) => isBulletList(line2, p5, true) >= 0,
  (p5, line2) => isOrderedList(line2, p5, true) >= 0,
  (p5, line2) => isHorizontalRule(line2, p5, true) >= 0,
  (p5, line2) => isHTMLBlock(line2, p5, true) >= 0
];
var scanLineResult = { text: "", end: 0 };
var BlockContext = class {
  /**
  @internal
  */
  constructor(parser4, input, fragments, ranges) {
    this.parser = parser4;
    this.input = input;
    this.ranges = ranges;
    this.line = new Line();
    this.atEnd = false;
    this.reusePlaceholders = /* @__PURE__ */ new Map();
    this.stoppedAt = null;
    this.rangeI = 0;
    this.to = ranges[ranges.length - 1].to;
    this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;
    this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);
    this.stack = [this.block];
    this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;
    this.readLine();
  }
  get parsedPos() {
    return this.absoluteLineStart;
  }
  advance() {
    if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)
      return this.finish();
    let { line: line2 } = this;
    for (; ; ) {
      for (let markI = 0; ; ) {
        let next = line2.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;
        while (markI < line2.markers.length && (!next || line2.markers[markI].from < next.end)) {
          let mark = line2.markers[markI++];
          this.addNode(mark.type, mark.from, mark.to);
        }
        if (!next)
          break;
        this.finishContext();
      }
      if (line2.pos < line2.text.length)
        break;
      if (!this.nextLine())
        return this.finish();
    }
    if (this.fragments && this.reuseFragment(line2.basePos))
      return null;
    start: for (; ; ) {
      for (let type of this.parser.blockParsers)
        if (type) {
          let result = type(this, line2);
          if (result != false) {
            if (result == true)
              return null;
            line2.forward();
            continue start;
          }
        }
      break;
    }
    let leaf = new LeafBlock(this.lineStart + line2.pos, line2.text.slice(line2.pos));
    for (let parse3 of this.parser.leafBlockParsers)
      if (parse3) {
        let parser4 = parse3(this, leaf);
        if (parser4)
          leaf.parsers.push(parser4);
      }
    lines: while (this.nextLine()) {
      if (line2.pos == line2.text.length)
        break;
      if (line2.indent < line2.baseIndent + 4) {
        for (let stop of this.parser.endLeafBlock)
          if (stop(this, line2, leaf))
            break lines;
      }
      for (let parser4 of leaf.parsers)
        if (parser4.nextLine(this, line2, leaf))
          return null;
      leaf.content += "\n" + line2.scrub();
      for (let m6 of line2.markers)
        leaf.marks.push(m6);
    }
    this.finishLeaf(leaf);
    return null;
  }
  stopAt(pos) {
    if (this.stoppedAt != null && this.stoppedAt < pos)
      throw new RangeError("Can't move stoppedAt forward");
    this.stoppedAt = pos;
  }
  reuseFragment(start) {
    if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) || !this.fragments.matches(this.block.hash))
      return false;
    let taken = this.fragments.takeNodes(this);
    if (!taken)
      return false;
    this.absoluteLineStart += taken;
    this.lineStart = toRelative(this.absoluteLineStart, this.ranges);
    this.moveRangeI();
    if (this.absoluteLineStart < this.to) {
      this.lineStart++;
      this.absoluteLineStart++;
      this.readLine();
    } else {
      this.atEnd = true;
      this.readLine();
    }
    return true;
  }
  /**
  The number of parent blocks surrounding the current block.
  */
  get depth() {
    return this.stack.length;
  }
  /**
  Get the type of the parent block at the given depth. When no
  depth is passed, return the type of the innermost parent.
  */
  parentType(depth = this.depth - 1) {
    return this.parser.nodeSet.types[this.stack[depth].type];
  }
  /**
  Move to the next input line. This should only be called by
  (non-composite) [block parsers](#BlockParser.parse) that consume
  the line directly, or leaf block parser
  [`nextLine`](#LeafBlockParser.nextLine) methods when they
  consume the current line (and return true).
  */
  nextLine() {
    this.lineStart += this.line.text.length;
    if (this.absoluteLineEnd >= this.to) {
      this.absoluteLineStart = this.absoluteLineEnd;
      this.atEnd = true;
      this.readLine();
      return false;
    } else {
      this.lineStart++;
      this.absoluteLineStart = this.absoluteLineEnd + 1;
      this.moveRangeI();
      this.readLine();
      return true;
    }
  }
  /**
  Retrieve the text of the line after the current one, without
  actually moving the context's current line forward.
  */
  peekLine() {
    return this.scanLine(this.absoluteLineEnd + 1).text;
  }
  moveRangeI() {
    while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {
      this.rangeI++;
      this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);
    }
  }
  /**
  @internal
  Collect the text for the next line.
  */
  scanLine(start) {
    let r7 = scanLineResult;
    r7.end = start;
    if (start >= this.to) {
      r7.text = "";
    } else {
      r7.text = this.lineChunkAt(start);
      r7.end += r7.text.length;
      if (this.ranges.length > 1) {
        let textOffset = this.absoluteLineStart, rangeI = this.rangeI;
        while (this.ranges[rangeI].to < r7.end) {
          rangeI++;
          let nextFrom = this.ranges[rangeI].from;
          let after = this.lineChunkAt(nextFrom);
          r7.end = nextFrom + after.length;
          r7.text = r7.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;
          textOffset = r7.end - r7.text.length;
        }
      }
    }
    return r7;
  }
  /**
  @internal
  Populate this.line with the content of the next line. Skip
  leading characters covered by composite blocks.
  */
  readLine() {
    let { line: line2 } = this, { text, end } = this.scanLine(this.absoluteLineStart);
    this.absoluteLineEnd = end;
    line2.reset(text);
    for (; line2.depth < this.stack.length; line2.depth++) {
      let cx = this.stack[line2.depth], handler = this.parser.skipContextMarkup[cx.type];
      if (!handler)
        throw new Error("Unhandled block context " + Type[cx.type]);
      if (!handler(cx, this, line2))
        break;
      line2.forward();
    }
  }
  lineChunkAt(pos) {
    let next = this.input.chunk(pos), text;
    if (!this.input.lineChunks) {
      let eol = next.indexOf("\n");
      text = eol < 0 ? next : next.slice(0, eol);
    } else {
      text = next == "\n" ? "" : next;
    }
    return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;
  }
  /**
  The end position of the previous line.
  */
  prevLineEnd() {
    return this.atEnd ? this.lineStart : this.lineStart - 1;
  }
  /**
  @internal
  */
  startContext(type, start, value = 0) {
    this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);
    this.stack.push(this.block);
  }
  /**
  Start a composite block. Should only be called from [block
  parser functions](#BlockParser.parse) that return null.
  */
  startComposite(type, start, value = 0) {
    this.startContext(this.parser.getNodeType(type), start, value);
  }
  /**
  @internal
  */
  addNode(block, from, to) {
    if (typeof block == "number")
      block = new import_common.Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);
    this.block.addChild(block, from - this.block.from);
  }
  /**
  Add a block element. Can be called by [block
  parsers](#BlockParser.parse).
  */
  addElement(elt2) {
    this.block.addChild(elt2.toTree(this.parser.nodeSet), elt2.from - this.block.from);
  }
  /**
  Add a block element from a [leaf parser](#LeafBlockParser). This
  makes sure any extra composite block markup (such as blockquote
  markers) inside the block are also added to the syntax tree.
  */
  addLeafElement(leaf, elt2) {
    this.addNode(this.buffer.writeElements(injectMarks(elt2.children, leaf.marks), -elt2.from).finish(elt2.type, elt2.to - elt2.from), elt2.from);
  }
  /**
  @internal
  */
  finishContext() {
    let cx = this.stack.pop();
    let top = this.stack[this.stack.length - 1];
    top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);
    this.block = top;
  }
  finish() {
    while (this.stack.length > 1)
      this.finishContext();
    return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));
  }
  addGaps(tree) {
    return this.ranges.length > 1 ? injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;
  }
  /**
  @internal
  */
  finishLeaf(leaf) {
    for (let parser4 of leaf.parsers)
      if (parser4.finish(this, leaf))
        return;
    let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);
    this.addNode(this.buffer.writeElements(inline, -leaf.start).finish(Type.Paragraph, leaf.content.length), leaf.start);
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
  /**
  @internal
  */
  get buffer() {
    return new Buffer2(this.parser.nodeSet);
  }
};
function injectGaps(ranges, rangeI, tree, offset, dummies) {
  let rangeEnd = ranges[rangeI].to;
  let children = [], positions = [], start = tree.from + offset;
  function movePastNext(upto, inclusive) {
    while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {
      let size2 = ranges[rangeI + 1].from - rangeEnd;
      offset += size2;
      upto += size2;
      rangeI++;
      rangeEnd = ranges[rangeI].to;
    }
  }
  for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {
    movePastNext(ch.from + offset, true);
    let from = ch.from + offset, node2, reuse = dummies.get(ch.tree);
    if (reuse) {
      node2 = reuse;
    } else if (ch.to + offset > rangeEnd) {
      node2 = injectGaps(ranges, rangeI, ch, offset, dummies);
      movePastNext(ch.to + offset, false);
    } else {
      node2 = ch.toTree();
    }
    children.push(node2);
    positions.push(from - start);
  }
  movePastNext(tree.to + offset, false);
  return new import_common.Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : void 0);
}
var MarkdownParser = class _MarkdownParser extends import_common.Parser {
  /**
  @internal
  */
  constructor(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers) {
    super();
    this.nodeSet = nodeSet;
    this.blockParsers = blockParsers;
    this.leafBlockParsers = leafBlockParsers;
    this.blockNames = blockNames;
    this.endLeafBlock = endLeafBlock;
    this.skipContextMarkup = skipContextMarkup;
    this.inlineParsers = inlineParsers;
    this.inlineNames = inlineNames;
    this.wrappers = wrappers;
    this.nodeTypes = /* @__PURE__ */ Object.create(null);
    for (let t7 of nodeSet.types)
      this.nodeTypes[t7.name] = t7.id;
  }
  createParse(input, fragments, ranges) {
    let parse3 = new BlockContext(this, input, fragments, ranges);
    for (let w6 of this.wrappers)
      parse3 = w6(parse3, input, fragments, ranges);
    return parse3;
  }
  /**
  Reconfigure the parser.
  */
  configure(spec) {
    let config = resolveConfig(spec);
    if (!config)
      return this;
    let { nodeSet, skipContextMarkup } = this;
    let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;
    if (nonEmpty(config.defineNodes)) {
      skipContextMarkup = Object.assign({}, skipContextMarkup);
      let nodeTypes2 = nodeSet.types.slice(), styles;
      for (let s5 of config.defineNodes) {
        let { name: name2, block, composite, style } = typeof s5 == "string" ? { name: s5 } : s5;
        if (nodeTypes2.some((t7) => t7.name == name2))
          continue;
        if (composite)
          skipContextMarkup[nodeTypes2.length] = (bl, cx, line2) => composite(cx, line2, bl.value);
        let id = nodeTypes2.length;
        let group = composite ? ["Block", "BlockContext"] : !block ? void 0 : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? ["Block", "LeafBlock", "Heading"] : ["Block", "LeafBlock"];
        nodeTypes2.push(import_common.NodeType.define({
          id,
          name: name2,
          props: group && [[import_common.NodeProp.group, group]]
        }));
        if (style) {
          if (!styles)
            styles = {};
          if (Array.isArray(style) || style instanceof import_highlight2.Tag)
            styles[name2] = style;
          else
            Object.assign(styles, style);
        }
      }
      nodeSet = new import_common.NodeSet(nodeTypes2);
      if (styles)
        nodeSet = nodeSet.extend((0, import_highlight2.styleTags)(styles));
    }
    if (nonEmpty(config.props))
      nodeSet = nodeSet.extend(...config.props);
    if (nonEmpty(config.remove)) {
      for (let rm of config.remove) {
        let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);
        if (block > -1)
          blockParsers[block] = leafBlockParsers[block] = void 0;
        if (inline > -1)
          inlineParsers[inline] = void 0;
      }
    }
    if (nonEmpty(config.parseBlock)) {
      for (let spec2 of config.parseBlock) {
        let found = blockNames.indexOf(spec2.name);
        if (found > -1) {
          blockParsers[found] = spec2.parse;
          leafBlockParsers[found] = spec2.leaf;
        } else {
          let pos = spec2.before ? findName(blockNames, spec2.before) : spec2.after ? findName(blockNames, spec2.after) + 1 : blockNames.length - 1;
          blockParsers.splice(pos, 0, spec2.parse);
          leafBlockParsers.splice(pos, 0, spec2.leaf);
          blockNames.splice(pos, 0, spec2.name);
        }
        if (spec2.endLeaf)
          endLeafBlock.push(spec2.endLeaf);
      }
    }
    if (nonEmpty(config.parseInline)) {
      for (let spec2 of config.parseInline) {
        let found = inlineNames.indexOf(spec2.name);
        if (found > -1) {
          inlineParsers[found] = spec2.parse;
        } else {
          let pos = spec2.before ? findName(inlineNames, spec2.before) : spec2.after ? findName(inlineNames, spec2.after) + 1 : inlineNames.length - 1;
          inlineParsers.splice(pos, 0, spec2.parse);
          inlineNames.splice(pos, 0, spec2.name);
        }
      }
    }
    if (config.wrap)
      wrappers = wrappers.concat(config.wrap);
    return new _MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);
  }
  /**
  @internal
  */
  getNodeType(name2) {
    let found = this.nodeTypes[name2];
    if (found == null)
      throw new RangeError(`Unknown node type '${name2}'`);
    return found;
  }
  /**
  Parse the given piece of inline text at the given offset,
  returning an array of [`Element`](#Element) objects representing
  the inline content.
  */
  parseInline(text, offset) {
    let cx = new InlineContext(this, text, offset);
    outer: for (let pos = offset; pos < cx.end; ) {
      let next = cx.char(pos);
      for (let token of this.inlineParsers)
        if (token) {
          let result = token(cx, next, pos);
          if (result >= 0) {
            pos = result;
            continue outer;
          }
        }
      pos++;
    }
    return cx.resolveMarkers(0);
  }
};
function nonEmpty(a6) {
  return a6 != null && a6.length > 0;
}
function resolveConfig(spec) {
  if (!Array.isArray(spec))
    return spec;
  if (spec.length == 0)
    return null;
  let conf = resolveConfig(spec[0]);
  if (spec.length == 1)
    return conf;
  let rest = resolveConfig(spec.slice(1));
  if (!rest || !conf)
    return conf || rest;
  let conc = (a6, b4) => (a6 || none).concat(b4 || none);
  let wrapA = conf.wrap, wrapB = rest.wrap;
  return {
    props: conc(conf.props, rest.props),
    defineNodes: conc(conf.defineNodes, rest.defineNodes),
    parseBlock: conc(conf.parseBlock, rest.parseBlock),
    parseInline: conc(conf.parseInline, rest.parseInline),
    remove: conc(conf.remove, rest.remove),
    wrap: !wrapA ? wrapB : !wrapB ? wrapA : (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)
  };
}
function findName(names, name2) {
  let found = names.indexOf(name2);
  if (found < 0)
    throw new RangeError(`Position specified relative to unknown parser ${name2}`);
  return found;
}
var nodeTypes = [import_common.NodeType.none];
for (let i7 = 1, name2; name2 = Type[i7]; i7++) {
  nodeTypes[i7] = import_common.NodeType.define({
    id: i7,
    name: name2,
    props: i7 >= Type.Escape ? [] : [[import_common.NodeProp.group, i7 in DefaultSkipMarkup ? ["Block", "BlockContext"] : ["Block", "LeafBlock"]]],
    top: name2 == "Document"
  });
}
var none = [];
var Buffer2 = class {
  constructor(nodeSet) {
    this.nodeSet = nodeSet;
    this.content = [];
    this.nodes = [];
  }
  write(type, from, to, children = 0) {
    this.content.push(type, from, to, 4 + children * 4);
    return this;
  }
  writeElements(elts, offset = 0) {
    for (let e8 of elts)
      e8.writeTo(this, offset);
    return this;
  }
  finish(type, length2) {
    return import_common.Tree.build({
      buffer: this.content,
      nodeSet: this.nodeSet,
      reused: this.nodes,
      topID: type,
      length: length2
    });
  }
};
var Element2 = class {
  /**
  @internal
  */
  constructor(type, from, to, children = none) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.children = children;
  }
  /**
  @internal
  */
  writeTo(buf, offset) {
    let startOff = buf.content.length;
    buf.writeElements(this.children, offset);
    buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);
  }
  /**
  @internal
  */
  toTree(nodeSet) {
    return new Buffer2(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);
  }
};
var TreeElement = class {
  constructor(tree, from) {
    this.tree = tree;
    this.from = from;
  }
  get to() {
    return this.from + this.tree.length;
  }
  get type() {
    return this.tree.type.id;
  }
  get children() {
    return none;
  }
  writeTo(buf, offset) {
    buf.nodes.push(this.tree);
    buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);
  }
  toTree() {
    return this.tree;
  }
};
function elt(type, from, to, children) {
  return new Element2(type, from, to, children);
}
var EmphasisUnderscore = { resolve: "Emphasis", mark: "EmphasisMark" };
var EmphasisAsterisk = { resolve: "Emphasis", mark: "EmphasisMark" };
var LinkStart = {};
var ImageStart = {};
var InlineDelimiter = class {
  constructor(type, from, to, side) {
    this.type = type;
    this.from = from;
    this.to = to;
    this.side = side;
  }
};
var Escapable = "!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~";
var Punctuation = /[!"#$%&'()*+,\-.\/:;<=>?@\[\\\]^_`{|}~\xA1\u2010-\u2027]/;
try {
  Punctuation = new RegExp("[\\p{S}|\\p{P}]", "u");
} catch (_5) {
}
var DefaultInline = {
  Escape(cx, next, start) {
    if (next != 92 || start == cx.end - 1)
      return -1;
    let escaped = cx.char(start + 1);
    for (let i7 = 0; i7 < Escapable.length; i7++)
      if (Escapable.charCodeAt(i7) == escaped)
        return cx.append(elt(Type.Escape, start, start + 2));
    return -1;
  },
  Entity(cx, next, start) {
    if (next != 38)
      return -1;
    let m6 = /^(?:#\d+|#x[a-f\d]+|\w+);/i.exec(cx.slice(start + 1, start + 31));
    return m6 ? cx.append(elt(Type.Entity, start, start + 1 + m6[0].length)) : -1;
  },
  InlineCode(cx, next, start) {
    if (next != 96 || start && cx.char(start - 1) == 96)
      return -1;
    let pos = start + 1;
    while (pos < cx.end && cx.char(pos) == 96)
      pos++;
    let size2 = pos - start, curSize = 0;
    for (; pos < cx.end; pos++) {
      if (cx.char(pos) == 96) {
        curSize++;
        if (curSize == size2 && cx.char(pos + 1) != 96)
          return cx.append(elt(Type.InlineCode, start, pos + 1, [
            elt(Type.CodeMark, start, start + size2),
            elt(Type.CodeMark, pos + 1 - size2, pos + 1)
          ]));
      } else {
        curSize = 0;
      }
    }
    return -1;
  },
  HTMLTag(cx, next, start) {
    if (next != 60 || start == cx.end - 1)
      return -1;
    let after = cx.slice(start + 1, cx.end);
    let url = /^(?:[a-z][-\w+.]+:[^\s>]+|[a-z\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?(?:\.[a-z\d](?:[a-z\d-]{0,61}[a-z\d])?)*)>/i.exec(after);
    if (url) {
      return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [
        elt(Type.LinkMark, start, start + 1),
        // url[0] includes the closing bracket, so exclude it from this slice
        elt(Type.URL, start + 1, start + url[0].length),
        elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)
      ]));
    }
    let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);
    if (comment)
      return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));
    let procInst = /^\?[^]*?\?>/.exec(after);
    if (procInst)
      return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));
    let m6 = /^(?:![A-Z][^]*?>|!\[CDATA\[[^]*?\]\]>|\/\s*[a-zA-Z][\w-]*\s*>|\s*[a-zA-Z][\w-]*(\s+[a-zA-Z:_][\w-.:]*(?:\s*=\s*(?:[^\s"'=<>`]+|'[^']*'|"[^"]*"))?)*\s*(\/\s*)?>)/.exec(after);
    if (!m6)
      return -1;
    return cx.append(elt(Type.HTMLTag, start, start + 1 + m6[0].length));
  },
  Emphasis(cx, next, start) {
    if (next != 95 && next != 42)
      return -1;
    let pos = start + 1;
    while (cx.char(pos) == next)
      pos++;
    let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);
    let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
    let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
    let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);
    let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);
    let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);
    let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);
    return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 : 0) | (canClose ? 2 : 0)));
  },
  HardBreak(cx, next, start) {
    if (next == 92 && cx.char(start + 1) == 10)
      return cx.append(elt(Type.HardBreak, start, start + 2));
    if (next == 32) {
      let pos = start + 1;
      while (cx.char(pos) == 32)
        pos++;
      if (cx.char(pos) == 10 && pos >= start + 2)
        return cx.append(elt(Type.HardBreak, start, pos + 1));
    }
    return -1;
  },
  Link(cx, next, start) {
    return next == 91 ? cx.append(new InlineDelimiter(
      LinkStart,
      start,
      start + 1,
      1
      /* Mark.Open */
    )) : -1;
  },
  Image(cx, next, start) {
    return next == 33 && cx.char(start + 1) == 91 ? cx.append(new InlineDelimiter(
      ImageStart,
      start,
      start + 2,
      1
      /* Mark.Open */
    )) : -1;
  },
  LinkEnd(cx, next, start) {
    if (next != 93)
      return -1;
    for (let i7 = cx.parts.length - 1; i7 >= 0; i7--) {
      let part = cx.parts[i7];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {
        if (!part.side || cx.skipSpace(part.to) == start && !/[(\[]/.test(cx.slice(start + 1, start + 2))) {
          cx.parts[i7] = null;
          return -1;
        }
        let content = cx.takeContent(i7);
        let link = cx.parts[i7] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);
        if (part.type == LinkStart)
          for (let j6 = 0; j6 < i7; j6++) {
            let p5 = cx.parts[j6];
            if (p5 instanceof InlineDelimiter && p5.type == LinkStart)
              p5.side = 0;
          }
        return link.to;
      }
    }
    return -1;
  }
};
function finishLink(cx, content, type, start, startPos) {
  let { text } = cx, next = cx.char(startPos), endPos = startPos;
  content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));
  content.push(elt(Type.LinkMark, startPos - 1, startPos));
  if (next == 40) {
    let pos = cx.skipSpace(startPos + 1);
    let dest = parseURL(text, pos - cx.offset, cx.offset), title;
    if (dest) {
      pos = cx.skipSpace(dest.to);
      if (pos != dest.to) {
        title = parseLinkTitle(text, pos - cx.offset, cx.offset);
        if (title)
          pos = cx.skipSpace(title.to);
      }
    }
    if (cx.char(pos) == 41) {
      content.push(elt(Type.LinkMark, startPos, startPos + 1));
      endPos = pos + 1;
      if (dest)
        content.push(dest);
      if (title)
        content.push(title);
      content.push(elt(Type.LinkMark, pos, endPos));
    }
  } else if (next == 91) {
    let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);
    if (label) {
      content.push(label);
      endPos = label.to;
    }
  }
  return elt(type, start, endPos, content);
}
function parseURL(text, start, offset) {
  let next = text.charCodeAt(start);
  if (next == 60) {
    for (let pos = start + 1; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (ch == 62)
        return elt(Type.URL, start + offset, pos + 1 + offset);
      if (ch == 60 || ch == 10)
        return false;
    }
    return null;
  } else {
    let depth = 0, pos = start;
    for (let escaped = false; pos < text.length; pos++) {
      let ch = text.charCodeAt(pos);
      if (space(ch)) {
        break;
      } else if (escaped) {
        escaped = false;
      } else if (ch == 40) {
        depth++;
      } else if (ch == 41) {
        if (!depth)
          break;
        depth--;
      } else if (ch == 92) {
        escaped = true;
      }
    }
    return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;
  }
}
function parseLinkTitle(text, start, offset) {
  let next = text.charCodeAt(start);
  if (next != 39 && next != 34 && next != 40)
    return false;
  let end = next == 40 ? 41 : next;
  for (let pos = start + 1, escaped = false; pos < text.length; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == end)
      return elt(Type.LinkTitle, start + offset, pos + 1 + offset);
    else if (ch == 92)
      escaped = true;
  }
  return null;
}
function parseLinkLabel(text, start, offset, requireNonWS) {
  for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {
    let ch = text.charCodeAt(pos);
    if (escaped)
      escaped = false;
    else if (ch == 93)
      return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);
    else {
      if (requireNonWS && !space(ch))
        requireNonWS = false;
      if (ch == 91)
        return false;
      else if (ch == 92)
        escaped = true;
    }
  }
  return null;
}
var InlineContext = class {
  /**
  @internal
  */
  constructor(parser4, text, offset) {
    this.parser = parser4;
    this.text = text;
    this.offset = offset;
    this.parts = [];
  }
  /**
  Get the character code at the given (document-relative)
  position.
  */
  char(pos) {
    return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset);
  }
  /**
  The position of the end of this inline section.
  */
  get end() {
    return this.offset + this.text.length;
  }
  /**
  Get a substring of this inline section. Again uses
  document-relative positions.
  */
  slice(from, to) {
    return this.text.slice(from - this.offset, to - this.offset);
  }
  /**
  @internal
  */
  append(elt2) {
    this.parts.push(elt2);
    return elt2.to;
  }
  /**
  Add a [delimiter](#DelimiterType) at this given position. `open`
  and `close` indicate whether this delimiter is opening, closing,
  or both. Returns the end of the delimiter, for convenient
  returning from [parse functions](#InlineParser.parse).
  */
  addDelimiter(type, from, to, open3, close) {
    return this.append(new InlineDelimiter(type, from, to, (open3 ? 1 : 0) | (close ? 2 : 0)));
  }
  /**
  Returns true when there is an unmatched link or image opening
  token before the current position.
  */
  get hasOpenLink() {
    for (let i7 = this.parts.length - 1; i7 >= 0; i7--) {
      let part = this.parts[i7];
      if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))
        return true;
    }
    return false;
  }
  /**
  Add an inline element. Returns the end of the element.
  */
  addElement(elt2) {
    return this.append(elt2);
  }
  /**
  Resolve markers between this.parts.length and from, wrapping matched markers in the
  appropriate node and updating the content of this.parts. @internal
  */
  resolveMarkers(from) {
    for (let i7 = from; i7 < this.parts.length; i7++) {
      let close = this.parts[i7];
      if (!(close instanceof InlineDelimiter && close.type.resolve && close.side & 2))
        continue;
      let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;
      let closeSize = close.to - close.from;
      let open3, j6 = i7 - 1;
      for (; j6 >= from; j6--) {
        let part = this.parts[j6];
        if (part instanceof InlineDelimiter && part.side & 1 && part.type == close.type && // Ignore emphasis delimiters where the character count doesn't match
        !(emp && (close.side & 1 || part.side & 2) && (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {
          open3 = part;
          break;
        }
      }
      if (!open3)
        continue;
      let type = close.type.resolve, content = [];
      let start = open3.from, end = close.to;
      if (emp) {
        let size2 = Math.min(2, open3.to - open3.from, closeSize);
        start = open3.to - size2;
        end = close.from + size2;
        type = size2 == 1 ? "Emphasis" : "StrongEmphasis";
      }
      if (open3.type.mark)
        content.push(this.elt(open3.type.mark, start, open3.to));
      for (let k6 = j6 + 1; k6 < i7; k6++) {
        if (this.parts[k6] instanceof Element2)
          content.push(this.parts[k6]);
        this.parts[k6] = null;
      }
      if (close.type.mark)
        content.push(this.elt(close.type.mark, close.from, end));
      let element = this.elt(type, start, end, content);
      this.parts[j6] = emp && open3.from != start ? new InlineDelimiter(open3.type, open3.from, start, open3.side) : null;
      let keep = this.parts[i7] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;
      if (keep)
        this.parts.splice(i7, 0, element);
      else
        this.parts[i7] = element;
    }
    let result = [];
    for (let i7 = from; i7 < this.parts.length; i7++) {
      let part = this.parts[i7];
      if (part instanceof Element2)
        result.push(part);
    }
    return result;
  }
  /**
  Find an opening delimiter of the given type. Returns `null` if
  no delimiter is found, or an index that can be passed to
  [`takeContent`](#InlineContext.takeContent) otherwise.
  */
  findOpeningDelimiter(type) {
    for (let i7 = this.parts.length - 1; i7 >= 0; i7--) {
      let part = this.parts[i7];
      if (part instanceof InlineDelimiter && part.type == type)
        return i7;
    }
    return null;
  }
  /**
  Remove all inline elements and delimiters starting from the
  given index (which you should get from
  [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),
  resolve delimiters inside of them, and return them as an array
  of elements.
  */
  takeContent(startIndex) {
    let content = this.resolveMarkers(startIndex);
    this.parts.length = startIndex;
    return content;
  }
  /**
  Skip space after the given (document) position, returning either
  the position of the next non-space character or the end of the
  section.
  */
  skipSpace(from) {
    return skipSpace(this.text, from - this.offset) + this.offset;
  }
  elt(type, from, to, children) {
    if (typeof type == "string")
      return elt(this.parser.getNodeType(type), from, to, children);
    return new TreeElement(type, from);
  }
};
function injectMarks(elements, marks) {
  if (!marks.length)
    return elements;
  if (!elements.length)
    return marks;
  let elts = elements.slice(), eI = 0;
  for (let mark of marks) {
    while (eI < elts.length && elts[eI].to < mark.to)
      eI++;
    if (eI < elts.length && elts[eI].from < mark.from) {
      let e8 = elts[eI];
      if (e8 instanceof Element2)
        elts[eI] = new Element2(e8.type, e8.from, e8.to, injectMarks(e8.children, [mark]));
    } else {
      elts.splice(eI++, 0, mark);
    }
  }
  return elts;
}
var NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];
var FragmentCursor = class {
  constructor(fragments, input) {
    this.fragments = fragments;
    this.input = input;
    this.i = 0;
    this.fragment = null;
    this.fragmentEnd = -1;
    this.cursor = null;
    if (fragments.length)
      this.fragment = fragments[this.i++];
  }
  nextFragment() {
    this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;
    this.cursor = null;
    this.fragmentEnd = -1;
  }
  moveTo(pos, lineStart) {
    while (this.fragment && this.fragment.to <= pos)
      this.nextFragment();
    if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))
      return false;
    if (this.fragmentEnd < 0) {
      let end = this.fragment.to;
      while (end > 0 && this.input.read(end - 1, end) != "\n")
        end--;
      this.fragmentEnd = end ? end - 1 : 0;
    }
    let c5 = this.cursor;
    if (!c5) {
      c5 = this.cursor = this.fragment.tree.cursor();
      c5.firstChild();
    }
    let rPos = pos + this.fragment.offset;
    while (c5.to <= rPos)
      if (!c5.parent())
        return false;
    for (; ; ) {
      if (c5.from >= rPos)
        return this.fragment.from <= lineStart;
      if (!c5.childAfter(rPos))
        return false;
    }
  }
  matches(hash) {
    let tree = this.cursor.tree;
    return tree && tree.prop(import_common.NodeProp.contextHash) == hash;
  }
  takeNodes(cx) {
    let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);
    let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;
    let prevEnd = end, prevI = blockI;
    for (; ; ) {
      if (cur.to - off > fragEnd) {
        if (cur.type.isAnonymous && cur.firstChild())
          continue;
        break;
      }
      let pos = toRelative(cur.from - off, cx.ranges);
      if (cur.to - off <= cx.ranges[cx.rangeI].to) {
        cx.addNode(cur.tree, pos);
      } else {
        let dummy = new import_common.Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);
        cx.reusePlaceholders.set(dummy, cur.tree);
        cx.addNode(dummy, pos);
      }
      if (cur.type.is("Block")) {
        if (NotLast.indexOf(cur.type.id) < 0) {
          end = cur.to - off;
          blockI = cx.block.children.length;
        } else {
          end = prevEnd;
          blockI = prevI;
          prevEnd = cur.to - off;
          prevI = cx.block.children.length;
        }
      }
      if (!cur.nextSibling())
        break;
    }
    while (cx.block.children.length > blockI) {
      cx.block.children.pop();
      cx.block.positions.pop();
    }
    return end - start;
  }
};
function toRelative(abs9, ranges) {
  let pos = abs9;
  for (let i7 = 1; i7 < ranges.length; i7++) {
    let gapFrom = ranges[i7 - 1].to, gapTo = ranges[i7].from;
    if (gapFrom < abs9)
      pos -= gapTo - gapFrom;
  }
  return pos;
}
var markdownHighlighting = (0, import_highlight2.styleTags)({
  "Blockquote/...": import_highlight2.tags.quote,
  HorizontalRule: import_highlight2.tags.contentSeparator,
  "ATXHeading1/... SetextHeading1/...": import_highlight2.tags.heading1,
  "ATXHeading2/... SetextHeading2/...": import_highlight2.tags.heading2,
  "ATXHeading3/...": import_highlight2.tags.heading3,
  "ATXHeading4/...": import_highlight2.tags.heading4,
  "ATXHeading5/...": import_highlight2.tags.heading5,
  "ATXHeading6/...": import_highlight2.tags.heading6,
  "Comment CommentBlock": import_highlight2.tags.comment,
  Escape: import_highlight2.tags.escape,
  Entity: import_highlight2.tags.character,
  "Emphasis/...": import_highlight2.tags.emphasis,
  "StrongEmphasis/...": import_highlight2.tags.strong,
  "Link/... Image/...": import_highlight2.tags.link,
  "OrderedList/... BulletList/...": import_highlight2.tags.list,
  "BlockQuote/...": import_highlight2.tags.quote,
  "InlineCode CodeText": import_highlight2.tags.monospace,
  "URL Autolink": import_highlight2.tags.url,
  "HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark": import_highlight2.tags.processingInstruction,
  "CodeInfo LinkLabel": import_highlight2.tags.labelName,
  LinkTitle: import_highlight2.tags.string,
  Paragraph: import_highlight2.tags.content
});
var parser2 = new MarkdownParser(new import_common.NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map((n4) => DefaultBlockParsers[n4]), Object.keys(DefaultBlockParsers).map((n4) => DefaultLeafBlocks[n4]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map((n4) => DefaultInline[n4]), Object.keys(DefaultInline), []);
var StrikethroughDelim = { resolve: "Strikethrough", mark: "StrikethroughMark" };
var Strikethrough = {
  defineNodes: [{
    name: "Strikethrough",
    style: { "Strikethrough/...": import_highlight2.tags.strikethrough }
  }, {
    name: "StrikethroughMark",
    style: import_highlight2.tags.processingInstruction
  }],
  parseInline: [{
    name: "Strikethrough",
    parse(cx, next, pos) {
      if (next != 126 || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)
        return -1;
      let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);
      let sBefore = /\s|^$/.test(before), sAfter = /\s|^$/.test(after);
      let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);
      return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));
    },
    after: "Emphasis"
  }]
};
function parseRow(cx, line2, startI = 0, elts, offset = 0) {
  let count = 0, first2 = true, cellStart = -1, cellEnd = -1, esc = false;
  let parseCell = () => {
    elts.push(cx.elt("TableCell", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line2.slice(cellStart, cellEnd), offset + cellStart)));
  };
  for (let i7 = startI; i7 < line2.length; i7++) {
    let next = line2.charCodeAt(i7);
    if (next == 124 && !esc) {
      if (!first2 || cellStart > -1)
        count++;
      first2 = false;
      if (elts) {
        if (cellStart > -1)
          parseCell();
        elts.push(cx.elt("TableDelimiter", i7 + offset, i7 + offset + 1));
      }
      cellStart = cellEnd = -1;
    } else if (esc || next != 32 && next != 9) {
      if (cellStart < 0)
        cellStart = i7;
      cellEnd = i7 + 1;
    }
    esc = !esc && next == 92;
  }
  if (cellStart > -1) {
    count++;
    if (elts)
      parseCell();
  }
  return count;
}
function hasPipe(str, start) {
  for (let i7 = start; i7 < str.length; i7++) {
    let next = str.charCodeAt(i7);
    if (next == 124)
      return true;
    if (next == 92)
      i7++;
  }
  return false;
}
var delimiterLine = /^\|?(\s*:?-+:?\s*\|)+(\s*:?-+:?\s*)?$/;
var TableParser = class {
  constructor() {
    this.rows = null;
  }
  nextLine(cx, line2, leaf) {
    if (this.rows == null) {
      this.rows = false;
      let lineText;
      if ((line2.next == 45 || line2.next == 58 || line2.next == 124) && delimiterLine.test(lineText = line2.text.slice(line2.pos))) {
        let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);
        if (firstCount == parseRow(cx, lineText, line2.pos))
          this.rows = [
            cx.elt("TableHeader", leaf.start, leaf.start + leaf.content.length, firstRow),
            cx.elt("TableDelimiter", cx.lineStart + line2.pos, cx.lineStart + line2.text.length)
          ];
      }
    } else if (this.rows) {
      let content = [];
      parseRow(cx, line2.text, line2.pos, content, cx.lineStart);
      this.rows.push(cx.elt("TableRow", cx.lineStart + line2.pos, cx.lineStart + line2.text.length, content));
    }
    return false;
  }
  finish(cx, leaf) {
    if (!this.rows)
      return false;
    cx.addLeafElement(leaf, cx.elt("Table", leaf.start, leaf.start + leaf.content.length, this.rows));
    return true;
  }
};
var Table = {
  defineNodes: [
    { name: "Table", block: true },
    { name: "TableHeader", style: { "TableHeader/...": import_highlight2.tags.heading } },
    "TableRow",
    { name: "TableCell", style: import_highlight2.tags.content },
    { name: "TableDelimiter", style: import_highlight2.tags.processingInstruction }
  ],
  parseBlock: [{
    name: "Table",
    leaf(_5, leaf) {
      return hasPipe(leaf.content, 0) ? new TableParser() : null;
    },
    endLeaf(cx, line2, leaf) {
      if (leaf.parsers.some((p5) => p5 instanceof TableParser) || !hasPipe(line2.text, line2.basePos))
        return false;
      let next = cx.peekLine();
      return delimiterLine.test(next) && parseRow(cx, line2.text, line2.basePos) == parseRow(cx, next, line2.basePos);
    },
    before: "SetextHeading"
  }]
};
var TaskParser = class {
  nextLine() {
    return false;
  }
  finish(cx, leaf) {
    cx.addLeafElement(leaf, cx.elt("Task", leaf.start, leaf.start + leaf.content.length, [
      cx.elt("TaskMarker", leaf.start, leaf.start + 3),
      ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)
    ]));
    return true;
  }
};
var TaskList = {
  defineNodes: [
    { name: "Task", block: true, style: import_highlight2.tags.list },
    { name: "TaskMarker", style: import_highlight2.tags.atom }
  ],
  parseBlock: [{
    name: "TaskList",
    leaf(cx, leaf) {
      return /^\[[ xX]\][ \t]/.test(leaf.content) && cx.parentType().name == "ListItem" ? new TaskParser() : null;
    },
    after: "SetextHeading"
  }]
};
function parseSubSuper(ch, node2, mark) {
  return (cx, next, pos) => {
    if (next != ch || cx.char(pos + 1) == ch)
      return -1;
    let elts = [cx.elt(mark, pos, pos + 1)];
    for (let i7 = pos + 1; i7 < cx.end; i7++) {
      let next2 = cx.char(i7);
      if (next2 == ch)
        return cx.addElement(cx.elt(node2, pos, i7 + 1, elts.concat(cx.elt(mark, i7, i7 + 1))));
      if (next2 == 92)
        elts.push(cx.elt("Escape", i7, i7++ + 2));
      if (space(next2))
        break;
    }
    return -1;
  };
}
var Superscript = {
  defineNodes: [
    { name: "Superscript", style: import_highlight2.tags.special(import_highlight2.tags.content) },
    { name: "SuperscriptMark", style: import_highlight2.tags.processingInstruction }
  ],
  parseInline: [{
    name: "Superscript",
    parse: parseSubSuper(94, "Superscript", "SuperscriptMark")
  }]
};
var Subscript = {
  defineNodes: [
    { name: "Subscript", style: import_highlight2.tags.special(import_highlight2.tags.content) },
    { name: "SubscriptMark", style: import_highlight2.tags.processingInstruction }
  ],
  parseInline: [{
    name: "Subscript",
    parse: parseSubSuper(126, "Subscript", "SubscriptMark")
  }]
};
var Emoji = {
  defineNodes: [{ name: "Emoji", style: import_highlight2.tags.character }],
  parseInline: [{
    name: "Emoji",
    parse(cx, next, pos) {
      let match;
      if (next != 58 || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))
        return -1;
      return cx.addElement(cx.elt("Emoji", pos, pos + 1 + match[0].length));
    }
  }]
};

// node_modules/feelers/dist/index.mjs
var import_common2 = require("@lezer/common");

// node_modules/@bpmn-io/feel-lint/dist/index.esm.js
var import_language = require("@codemirror/language");
function lintSyntax(syntaxTree5) {
  const lintMessages = [];
  syntaxTree5.iterate({
    enter: (ref) => {
      const node2 = ref.node;
      if (!node2.type.isError) {
        return;
      }
      const parent = node2.parent;
      const next = getNextNode(node2);
      const message = {
        from: node2.from,
        to: node2.to,
        severity: "error",
        type: "Syntax Error"
      };
      if (node2.from !== node2.to) {
        message.message = `Unrecognized token in <${parent.name}>`;
      } else if (next) {
        message.message = `Unrecognized token <${next.name}> in <${parent.name}>`;
        message.to = next.to;
      } else {
        const before = parent.enterUnfinishedNodesBefore(node2.to);
        message.message = `Incomplete <${(before || parent).name}>`;
      }
      lintMessages.push(message);
    }
  });
  return lintMessages;
}
function getNextNode(node2) {
  if (!node2) {
    return null;
  }
  return node2.nextSibling || getNextNode(node2.parent);
}
var RULE_NAME = "first-item";
var firstItem = {
  create(context) {
    return {
      enter(node2) {
        if (node2.name !== "FilterExpression") {
          return;
        }
        const content = context.readContent(node2.from, node2.to);
        if (zeroIndexPattern().test(content)) {
          const {
            from,
            to
          } = node2;
          context.report({
            from,
            to,
            message: "First item is accessed via [1]",
            severity: "warning",
            type: RULE_NAME,
            actions: [
              {
                name: "fix",
                apply(_5, start = from, end = to) {
                  context.updateContent(start, end, content.replace(zeroIndexPattern(), "[1]"));
                }
              }
            ]
          });
        }
      }
    };
  }
};
function zeroIndexPattern() {
  return /\[\s*0\s*\]$/;
}
var RULES = [
  firstItem
];
function lintRules(context) {
  const {
    readContent,
    syntaxTree: syntaxTree5,
    updateContent
  } = context;
  const lintMessages = [];
  const ruleContext = {
    readContent,
    report: (message) => {
      lintMessages.push(message);
    },
    updateContent
  };
  const rules = RULES.map((rule) => rule.create(ruleContext));
  syntaxTree5.iterate({
    enter: (ref) => {
      for (const rule of rules) {
        rule.enter && rule.enter(ref);
      }
    },
    leave: (ref) => {
      for (const rule of rules) {
        rule.leave && rule.leave(ref);
      }
    }
  });
  return lintMessages;
}
function lintAll(context) {
  const lintMessages = [
    ...lintSyntax(context.syntaxTree),
    ...lintRules(context)
  ];
  return lintMessages;
}
var cmFeelLinter = () => (editorView) => {
  if (editorView.state.doc.length === 0) {
    return [];
  }
  const tree = (0, import_language.syntaxTree)(editorView.state);
  const messages = lintAll({
    syntaxTree: tree,
    readContent: (from, to) => editorView.state.sliceDoc(from, to),
    updateContent: (from, to, content) => editorView.dispatch({
      changes: { from, to, insert: content }
    })
  });
  return messages.map((message) => ({
    ...message,
    source: message.type
  }));
};

// node_modules/@bpmn-io/cm-theme/dist/index.es.js
var import_view = require("@codemirror/view");
var import_language2 = require("@codemirror/language");
var import_highlight3 = require("@lezer/highlight");
var highlightStyle$2 = (0, import_language2.syntaxHighlighting)(import_language2.HighlightStyle.define([
  { tag: import_highlight3.tags.strong, fontWeight: "bold" },
  { tag: import_highlight3.tags.emphasis, fontStyle: "italic" }
]));
var theme$2 = import_view.EditorView.theme({
  "& .cm-lintRange": {
    position: "relative"
  },
  "& .cm-lintRange::after": {
    content: '""',
    width: "100%",
    position: "absolute",
    left: "0px",
    bottom: "-2px",
    height: "3px",
    backgroundRepeat: "repeat-x"
  },
  "& .cm-lintRange.cm-lintRange-warning, & .cm-lintRange.cm-lintRange-error": {
    backgroundImage: "none"
  },
  "& .cm-lintPoint::after": {
    bottom: "-2px"
  }
});
var commonTheme = [
  theme$2,
  highlightStyle$2
];
var _urlify = (color) => `%23${color.slice(1)}`;
var colors = {
  black: "#1f2b36",
  darkGrey: "#2f3d58",
  grey: "#404a5c",
  midGrey: "#576071",
  lightGrey: "#c5d1e5",
  offWhite: "#d9e0f5",
  snowWhite: "#eaf1ff",
  white: "#ffffff",
  mossGreen: "#7ab6aa",
  iceBlue: "#6cbfd8",
  waterBlue: "#065aaa",
  brightBlue: "#0a56b9",
  deepBlue: "#355472",
  red: "#9f1c15",
  orangeBrown: "#b4502f",
  yellow: "#debd71",
  lila: "#9a4890",
  purple: "#5b2c83"
};
var colorByRole = {
  lightBackground: colors.white,
  darkBackground: colors.snowWhite,
  selection: colors.snowWhite,
  tooltipBackground: colors.offWhite,
  error: colors.red,
  warning: colors.yellow,
  invalid: "#b40000"
};
var theme$1 = import_view.EditorView.theme(
  {
    "&": { color: colors.black, backgroundColor: colorByRole.lightBackground },
    ".cm-content": { caretColor: colors.darkGrey },
    ".cm-cursor, .cm-dropCursor": { borderLeftColor: colors.darkGrey },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: colorByRole.selection },
    ".cm-panels": { backgroundColor: colorByRole.darkBackground, color: colors.grey },
    ".cm-panels.cm-panels-top": { borderBottom: `2px solid ${colors.black}` },
    ".cm-panels.cm-panels-bottom": { borderTop: `2px solid ${colors.black}` },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: `1px solid ${colors.midGrey}`
    },
    ".cm-searchMatch.cm-searchMatch-selected": { backgroundColor: colors.offWhite },
    ".cm-activeLine": { backgroundColor: colorByRole.selection },
    ".cm-selectionMatch": { backgroundColor: colors.offWhite },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      outline: `1px solid ${colors.grey}`
    },
    "&.cm-focused .cm-matchingBracket": {
      backgroundColor: colors.snowWhite
    },
    ".cm-gutters": {
      backgroundColor: "#f3f7fe",
      color: "#52668d",
      border: "none",
      padding: "0 5px"
    },
    ".cm-activeLineGutter": {
      backgroundColor: colorByRole.selection
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: colorByRole.tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: colorByRole.tooltipBackground,
      borderBottomColor: colorByRole.tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: colorByRole.darkBackground,
        color: colors.midGrey
      }
    },
    "& .cm-lintRange.cm-lintRange-warning::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${_urlify(colorByRole.warning)}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-lintRange.cm-lintRange-error::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${_urlify(colorByRole.error)}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-diagnostic-warning": {
      border: `1px solid ${colorByRole.warning}`,
      borderLeft: `5px solid ${colorByRole.warning}`,
      background: colorByRole.lightBackground
    },
    "& .cm-diagnostic-error": {
      border: `1px solid ${colorByRole.error}`,
      borderLeft: `5px solid ${colorByRole.error}`,
      background: colorByRole.lightBackground
    },
    "& .cm-diagnostic": {
      padding: "3px 8px"
    }
  },
  { dark: false }
);
var highlightStyle$1 = (0, import_language2.syntaxHighlighting)(import_language2.HighlightStyle.define([
  {
    tag: [import_highlight3.tags.macroName, import_highlight3.tags.variableName],
    color: colors.waterBlue
  },
  {
    tag: [import_highlight3.tags.special(import_highlight3.tags.bracket)],
    color: colors.waterBlue,
    fontWeight: "bold"
  },
  {
    tag: [import_highlight3.tags.color, import_highlight3.tags.name, import_highlight3.tags.definition(import_highlight3.tags.name), import_highlight3.tags.constant(import_highlight3.tags.name), import_highlight3.tags.standard(import_highlight3.tags.name), import_highlight3.tags.propertyName],
    color: colors.deepBlue
  },
  {
    tag: [import_highlight3.tags.definition(import_highlight3.tags.variableName), import_highlight3.tags.function(import_highlight3.tags.variableName), import_highlight3.tags.function(import_highlight3.tags.propertyName)],
    color: colors.brightBlue
  },
  { tag: [import_highlight3.tags.labelName], color: colors.orangeBrown },
  {
    tag: [import_highlight3.tags.annotation],
    color: colorByRole.invalid
  },
  {
    tag: [import_highlight3.tags.number, import_highlight3.tags.changed, import_highlight3.tags.annotation, import_highlight3.tags.modifier, import_highlight3.tags.self, import_highlight3.tags.namespace, import_highlight3.tags.atom, import_highlight3.tags.bool, import_highlight3.tags.special(import_highlight3.tags.variableName)],
    color: colors.red
  },
  {
    tag: [import_highlight3.tags.typeName, import_highlight3.tags.className, import_highlight3.tags.attributeName],
    color: colors.lila
  },
  {
    tag: [import_highlight3.tags.operator, import_highlight3.tags.operatorKeyword, import_highlight3.tags.tagName, import_highlight3.tags.keyword],
    color: colors.purple
  },
  {
    tag: [import_highlight3.tags.angleBracket, import_highlight3.tags.squareBracket, import_highlight3.tags.brace, import_highlight3.tags.separator, import_highlight3.tags.punctuation],
    color: colors.midGrey
  },
  {
    tag: [import_highlight3.tags.regexp],
    color: colors.deepBlue
  },
  {
    tag: [import_highlight3.tags.quote],
    color: colors.darkGrey
  },
  { tag: [import_highlight3.tags.string, import_highlight3.tags.character, import_highlight3.tags.deleted], color: colors.orangeBrown },
  {
    tag: import_highlight3.tags.link,
    color: colors.mossGreen,
    textDecoration: "underline",
    textUnderlinePosition: "under"
  },
  {
    tag: [import_highlight3.tags.url, import_highlight3.tags.escape, import_highlight3.tags.special(import_highlight3.tags.string)],
    color: colors.red
  },
  { tag: [import_highlight3.tags.meta], color: colors.iceBlue },
  { tag: [import_highlight3.tags.comment], color: colors.midGrey, fontStyle: "italic" },
  { tag: import_highlight3.tags.strong, fontWeight: "bold", color: colors.deepBlue },
  { tag: import_highlight3.tags.emphasis, fontStyle: "italic", color: colors.deepBlue },
  { tag: import_highlight3.tags.strikethrough, textDecoration: "line-through" },
  { tag: import_highlight3.tags.heading, fontWeight: "bold", color: colors.midGray },
  { tag: import_highlight3.tags.special(import_highlight3.tags.heading1), fontWeight: "bold", color: colors.darkGrey },
  {
    tag: [import_highlight3.tags.heading1, import_highlight3.tags.heading2, import_highlight3.tags.heading3, import_highlight3.tags.heading4],
    fontWeight: "bold",
    color: colors.midGrey
  },
  { tag: [import_highlight3.tags.heading5, import_highlight3.tags.heading6, import_highlight3.tags.processingInstruction, import_highlight3.tags.inserted], color: colors.grey },
  {
    tag: [import_highlight3.tags.contentSeparator],
    color: colors.yellow
  },
  { tag: import_highlight3.tags.invalid, color: colors.midGrey, borderBottom: `1px dotted ${colorByRole.invalid}` }
]));
var bpmnioLight = [
  theme$1,
  highlightStyle$1
];
var ivory = "#abb2bf";
var peach = "#f07178";
var stone = "#7d8799";
var invalid = "#ffffff";
var pastelYellow = "#fffce1";
var pastelOrange = "#ec9e6f";
var raisinBlack = "#21252b";
var highlightBackground = "rgba(0, 0, 0, 0.5)";
var background = "#292d3e";
var tooltipBackground = "#353a42";
var selection = "rgba(128, 203, 196, 0.2)";
var cursor = "#ffcc00";
var urlHash = "%23";
var warningColorHex = "fff890";
var errorColor = "red";
var warningBackgroundColor = "#281e16";
var errorBackgroundColor = "#281616";
var theme = import_view.EditorView.theme(
  {
    "&": {
      color: "#ffffff",
      backgroundColor: background
    },
    ".cm-content": {
      caretColor: cursor
    },
    "&.cm-focused .cm-cursor": {
      borderLeftColor: cursor
    },
    "&.cm-focused .cm-selectionBackground, .cm-selectionBackground, .cm-content ::selection": { backgroundColor: selection },
    ".cm-panels": { backgroundColor: raisinBlack, color: "#ffffff" },
    ".cm-panels.cm-panels-top": { borderBottom: "2px solid black" },
    ".cm-panels.cm-panels-bottom": { borderTop: "2px solid black" },
    ".cm-searchMatch": {
      backgroundColor: "#72a1ff59",
      outline: "1px solid #457dff"
    },
    ".cm-searchMatch.cm-searchMatch-selected": {
      backgroundColor: "#6199ff2f"
    },
    ".cm-activeLine": { backgroundColor: highlightBackground },
    ".cm-selectionMatch": { backgroundColor: "#aafe661a" },
    "&.cm-focused .cm-matchingBracket, &.cm-focused .cm-nonmatchingBracket": {
      backgroundColor: "#bad0f847",
      outline: "1px solid #515a6b"
    },
    ".cm-gutters": {
      background: "#292d3e",
      color: "#676e95",
      border: "none",
      padding: "0 5px"
    },
    ".cm-activeLineGutter": {
      backgroundColor: highlightBackground
    },
    ".cm-foldPlaceholder": {
      backgroundColor: "transparent",
      border: "none",
      color: "#ddd"
    },
    ".cm-tooltip": {
      border: "none",
      backgroundColor: tooltipBackground
    },
    ".cm-tooltip .cm-tooltip-arrow:before": {
      borderTopColor: "transparent",
      borderBottomColor: "transparent"
    },
    ".cm-tooltip .cm-tooltip-arrow:after": {
      borderTopColor: tooltipBackground,
      borderBottomColor: tooltipBackground
    },
    ".cm-tooltip-autocomplete": {
      "& > ul > li[aria-selected]": {
        backgroundColor: highlightBackground,
        color: ivory
      }
    },
    "& .cm-lintRange.cm-lintRange-warning::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${urlHash + warningColorHex}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-lintRange.cm-lintRange-error::after": {
      backgroundImage: `url("data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' width='6' height='3'><path d='m0 2.5 l2 -1.5 l1 0 l2 1.5 l1 0' stroke='${errorColor}' fill='none' stroke-width='1.2'/></svg>")`
    },
    "& .cm-diagnostic-warning": {
      borderLeft: `5px solid #${warningColorHex}`,
      background: warningBackgroundColor
    },
    "& .cm-diagnostic-error": {
      borderLeft: `5px solid ${errorColor}`,
      background: errorBackgroundColor
    },
    "& .cm-diagnostic": {
      borderRadius: "2px",
      padding: "3px 8px"
    }
  },
  { dark: true }
);
var highlightStyle = (0, import_language2.syntaxHighlighting)(import_language2.HighlightStyle.define([
  // Markdown headings
  { tag: import_highlight3.tags.heading1, color: pastelYellow },
  { tag: import_highlight3.tags.heading2, color: pastelYellow },
  { tag: import_highlight3.tags.heading3, color: pastelYellow },
  { tag: import_highlight3.tags.heading4, color: pastelYellow },
  { tag: import_highlight3.tags.heading5, color: pastelYellow },
  { tag: import_highlight3.tags.heading6, color: pastelYellow },
  // Feelers
  { tag: import_highlight3.tags.special(import_highlight3.tags.bracket), color: pastelOrange, fontWeight: "bold" },
  // Everything else
  { tag: import_highlight3.tags.keyword, color: "#c792ea" },
  { tag: import_highlight3.tags.operator, color: "#89ddff" },
  { tag: import_highlight3.tags.special(import_highlight3.tags.variableName), color: "#eeffff" },
  { tag: import_highlight3.tags.typeName, color: "#f07178" },
  { tag: import_highlight3.tags.atom, color: "#f78c6c" },
  { tag: import_highlight3.tags.number, color: "#ff5370" },
  { tag: import_highlight3.tags.bool, color: "#ff5370" },
  { tag: import_highlight3.tags.definition(import_highlight3.tags.variableName), color: "#82aaff" },
  { tag: import_highlight3.tags.string, color: "#c3e88d" },
  { tag: import_highlight3.tags.comment, color: stone },
  { tag: import_highlight3.tags.tagName, color: "#ff5370" },
  { tag: import_highlight3.tags.bracket, color: "#a2a1a4" },
  { tag: import_highlight3.tags.meta, color: "#ffcb6b" },
  { tag: import_highlight3.tags.special(import_highlight3.tags.string), color: peach },
  { tag: import_highlight3.tags.propertyName, color: pastelOrange },
  { tag: import_highlight3.tags.variableName, color: pastelOrange },
  { tag: import_highlight3.tags.attributeName, color: peach },
  { tag: import_highlight3.tags.className, color: peach },
  { tag: import_highlight3.tags.invalid, color: invalid }
]));
var bpmnioDark = [
  theme,
  highlightStyle
];
var lightTheme = [...commonTheme, ...bpmnioLight];
var darkTheme = [...commonTheme, ...bpmnioDark];

// node_modules/feelers/dist/index.mjs
var Feel = 1;
var FeelBlock = 2;
var SimpleTextBlock = 3;
var CHAR_TABLE = {
  "{": 123,
  "}": 125
};
var isClosingFeelScope = (input, offset = 0) => {
  const isReadingCloseCurrent = input.peek(offset) === CHAR_TABLE["}"];
  const isReadingCloseAhead = input.peek(offset + 1) === CHAR_TABLE["}"];
  const isReadingClose = isReadingCloseCurrent && isReadingCloseAhead;
  return isReadingClose || input.peek(offset) === -1;
};
var feelBlock = new import_lr2.ExternalTokenizer((input, stack) => {
  let lookAhead = 0;
  while (!isClosingFeelScope(input, lookAhead)) {
    lookAhead++;
  }
  if (lookAhead > 0) {
    input.advance(lookAhead);
    input.acceptToken(FeelBlock);
  }
});
var isClosingTextScope = (input, offset = 0) => {
  const isReadingOpenCurrent = input.peek(offset) === CHAR_TABLE["{"];
  const isReadingOpenAhead = input.peek(offset + 1) === CHAR_TABLE["{"];
  const isReadOpen = isReadingOpenCurrent && isReadingOpenAhead;
  return isReadOpen || input.peek(offset) === -1;
};
var simpleTextBlock = new import_lr2.ExternalTokenizer((input, stack) => {
  let lookAhead = 0;
  while (!isClosingTextScope(input, lookAhead)) {
    lookAhead++;
  }
  if (lookAhead > 0) {
    input.advance(lookAhead);
    input.acceptToken(SimpleTextBlock);
  }
});
var feel = new import_lr2.ExternalTokenizer((input, stack) => {
  let lookAhead = 0;
  while (input.peek(lookAhead) !== -1) {
    lookAhead++;
  }
  if (lookAhead > 0) {
    input.advance(lookAhead);
    input.acceptToken(Feel);
  }
});
var feelersHighlighting = (0, import_highlight4.styleTags)({
  ConditionalSpanner: import_highlight4.tags.special(import_highlight4.tags.bracket),
  ConditionalSpannerClose: import_highlight4.tags.special(import_highlight4.tags.bracket),
  ConditionalSpannerCloseNl: import_highlight4.tags.special(import_highlight4.tags.bracket),
  LoopSpanner: import_highlight4.tags.special(import_highlight4.tags.bracket),
  LoopSpannerClose: import_highlight4.tags.special(import_highlight4.tags.bracket),
  LoopSpannerCloseNl: import_highlight4.tags.special(import_highlight4.tags.bracket),
  EmptyInsert: import_highlight4.tags.special(import_highlight4.tags.bracket),
  Insert: import_highlight4.tags.special(import_highlight4.tags.bracket)
});
var parser3 = import_lr2.LRParser.deserialize({
  version: 14,
  states: "$bOQOaOOOfOXO'#CbOOO`'#Cm'#CmOqOWO'#CcOvOWO'#CfOOO`'#Cp'#CpOOO`'#Ci'#CiO{OaO'#ClO!jOSOOQOOOOOO!oOPO,58{O!tOXO,58|OOO`,58|,58|O!|OQO,58}O#ROQO,59QOOO`-E6g-E6gOOO`1G.g1G.gO#WOPO1G.gOOO`1G.h1G.hO#]OaO1G.iO#qOaO1G.lOOO`7+$R7+$RO$VOPO7+$TO$_OPO7+$WOOO`<<Go<<GoOOO`<<Gr<<Gr",
  stateData: "$g~ORUO_WObPOeROgSO^`P~OQYO_ZOc[O~OQ]O~OQ^O~ORUObPOeROgSO^`XW`XX`XZ`X[`X~OPXO~Oc`O~OQaOcbO~OfcO~OfdO~OceO~ORUObPOeROgSOW`PX`P~ORUObPOeROgSOZ`P[`P~OWhOXhO~OZiO[iO~O",
  goto: "!ZePPPPPfflPPlPPrPPz!TPP!TXQOVcdXTOVcdUVOcdR_VQXOQfcRgdXUOVcd",
  nodeNames: "\u26A0 Feel FeelBlock SimpleTextBlock Feelers Insert EmptyInsert ConditionalSpanner ConditionalSpannerClose ConditionalSpannerCloseNl LoopSpanner LoopSpannerClose LoopSpannerCloseNl",
  maxTerm: 23,
  propSources: [feelersHighlighting],
  skippedNodes: [0],
  repeatNodeCount: 1,
  tokenData: "%X~RR!_!`[#o#pa#q#r$r~aO_~~dP#o#pg~lQb~str!P!Q!{~uQ#]#^{#`#a!^~!OP#Y#Z!R~!UPpq!X~!^Oe~~!aP#c#d!d~!gP#c#d!j~!mP#d#e!p~!sPpq!v~!{Og~~#OQ#]#^#U#`#a#u~#XP#Y#Z#[~#_P#q#r#b~#eP#q#r#h~#mPW~YZ#p~#uOX~~#xP#c#d#{~$OP#c#d$R~$UP#d#e$X~$[P#q#r$_~$bP#q#r$e~$jPZ~YZ$m~$rO[~R$uP#q#r$xR%PPcPfQYZ%SQ%XOfQ",
  tokenizers: [0, 1, feel, feelBlock, simpleTextBlock],
  topRules: { "Feelers": [0, 4] },
  tokenPrec: 0
});
var foldMetadata = {
  ConditionalSpanner: import_language3.foldInside,
  LoopSpanner: import_language3.foldInside
};
function createMixedLanguage(hostLanguage = null) {
  const _mixedParser = parser3.configure({
    wrap: (0, import_common2.parseMixed)((node2) => {
      if (node2.name == "Feel" || node2.name == "FeelBlock") {
        return { parser };
      }
      if (hostLanguage && node2.name == "SimpleTextBlock") {
        return { parser: hostLanguage };
      }
      return null;
    }),
    props: [
      import_language3.foldNodeProp.add(foldMetadata)
    ]
  });
  return import_language3.LRLanguage.define({ parser: _mixedParser });
}
var createFeelersLanguageSupport = (hostLanguageParser) => new import_language3.LanguageSupport(createMixedLanguage(hostLanguageParser), []);
function lintEmptyInserts(syntaxTree5) {
  const lintMessages = [];
  syntaxTree5.iterate({
    enter: (node2) => {
      if (node2.type.name === "EmptyInsert") {
        lintMessages.push(
          {
            from: node2.from,
            to: node2.to,
            severity: "warning",
            message: "this insert is empty and will be ignored",
            type: "emptyInsert"
          }
        );
      }
    }
  });
  return lintMessages;
}
function lintAll2(syntaxTree5) {
  const lintMessages = [
    ...lintEmptyInserts(syntaxTree5)
  ];
  return lintMessages;
}
function cmFeelersLinter() {
  const lintFeel = cmFeelLinter();
  return (editorView) => {
    const feelMessages = lintFeel(editorView);
    if (editorView.state.doc.length === 0) {
      return [];
    }
    const tree = (0, import_language3.syntaxTree)(editorView.state);
    const feelersMessages = lintAll2(tree);
    return [
      ...feelMessages,
      ...feelersMessages.map((message) => ({
        ...message,
        source: "feelers linter"
      }))
    ];
  };
}
var lint = (0, import_lint.linter)(cmFeelersLinter());
function FeelersEditor({
  container,
  tooltipContainer,
  hostLanguage,
  hostLanguageParser,
  onChange = () => {
  },
  onKeyDown = () => {
  },
  onLint = () => {
  },
  contentAttributes = {},
  readOnly = false,
  value = "",
  enableGutters = false,
  singleLine = false,
  lineWrap = false,
  darkMode = false
}) {
  const changeHandler = import_view2.EditorView.updateListener.of((update) => {
    if (update.docChanged) {
      onChange(update.state.doc.toString());
    }
  });
  const lintHandler = import_view2.EditorView.updateListener.of((update) => {
    const diagnosticEffects = update.transactions.flatMap((t7) => t7.effects).filter((effect) => effect.is(import_lint.setDiagnosticsEffect));
    if (!diagnosticEffects.length) {
      return;
    }
    const messages = diagnosticEffects.flatMap((effect) => effect.value);
    onLint(messages);
  });
  const contentAttributesExtension = import_view2.EditorView.contentAttributes.of(contentAttributes);
  const keyHandler = import_view2.EditorView.domEventHandlers(
    {
      keydown: onKeyDown
    }
  );
  if (typeof tooltipContainer === "string") {
    tooltipContainer = document.querySelector(tooltipContainer);
  }
  const tooltipLayout = tooltipContainer ? (0, import_view2.tooltips)({
    tooltipSpace: function() {
      return tooltipContainer.getBoundingClientRect();
    }
  }) : [];
  const _getHostLanguageParser = (hostLanguage2) => {
    switch (hostLanguage2) {
      case "markdown":
        return parser2;
      default:
        return null;
    }
  };
  const feelersLanguageSupport = createFeelersLanguageSupport(hostLanguageParser || hostLanguage && _getHostLanguageParser(hostLanguage));
  const extensions = [
    (0, import_language3.bracketMatching)(),
    changeHandler,
    contentAttributesExtension,
    (0, import_autocomplete.closeBrackets)(),
    (0, import_language3.indentOnInput)(),
    keyHandler,
    import_view2.keymap.of([
      ...import_commands.defaultKeymap
    ]),
    feelersLanguageSupport,
    lint,
    lintHandler,
    tooltipLayout,
    darkMode ? darkTheme : lightTheme,
    ...enableGutters ? [
      // todo: adjust folding boundaries first foldGutter(),
      (0, import_view2.lineNumbers)()
    ] : [],
    ...singleLine ? [
      import_state.EditorState.transactionFilter.of((tr) => tr.newDoc.lines > 1 ? [] : tr)
    ] : [],
    ...lineWrap ? [
      import_view2.EditorView.lineWrapping
    ] : []
  ];
  if (readOnly) {
    extensions.push(import_view2.EditorView.editable.of(false));
  }
  if (singleLine && value) {
    value = value.toString().split("\n")[0];
  }
  this._cmEditor = new import_view2.EditorView({
    state: import_state.EditorState.create({
      doc: value,
      extensions
    }),
    parent: container
  });
  return this;
}
FeelersEditor.prototype.setValue = function(value) {
  this._cmEditor.dispatch({
    changes: {
      from: 0,
      to: this._cmEditor.state.doc.length,
      insert: value
    }
  });
};
FeelersEditor.prototype.focus = function(position) {
  const cmEditor = this._cmEditor;
  cmEditor.contentDOM.focus();
  cmEditor.focus();
  if (typeof position === "number") {
    const end = cmEditor.state.doc.length;
    cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
  }
};
FeelersEditor.prototype.getSelection = function() {
  return this._cmEditor.state.selection;
};

// node_modules/@bpmn-io/feel-editor/dist/index.es.js
var import_autocomplete3 = require("@codemirror/autocomplete");
var import_commands2 = require("@codemirror/commands");
var import_language5 = require("@codemirror/language");
var import_lint2 = require("@codemirror/lint");
var import_state2 = require("@codemirror/state");
var import_view3 = require("@codemirror/view");
var import_highlight5 = require("@lezer/highlight");

// node_modules/lang-feel/dist/index.js
var import_language4 = require("@codemirror/language");
var import_autocomplete2 = require("@codemirror/autocomplete");
var snippets = [(0, import_autocomplete2.snippetCompletion)("function(${params}) ${body}", {
  label: "function",
  detail: "definition",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("for ${var} in ${collection} return ${value}", {
  label: "for",
  detail: "expression",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("every ${var} in ${collection} satisfies ${condition}", {
  label: "every",
  detail: "quantified expression",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("some ${var} in ${collection} satisfies ${condition}", {
  label: "some",
  detail: "quantified expression",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("if ${condition} then ${value} else ${other value}", {
  label: "if",
  detail: "block",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("{ ${key}: ${value} }", {
  label: "context",
  detail: "block",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("null", {
  label: "null",
  detail: "literal",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("true", {
  label: "true",
  detail: "literal",
  type: "keyword"
}), (0, import_autocomplete2.snippetCompletion)("false", {
  label: "false",
  detail: "literal",
  type: "keyword"
})];
function _extends() {
  _extends = Object.assign ? Object.assign.bind() : function(target) {
    for (var i7 = 1; i7 < arguments.length; i7++) {
      var source = arguments[i7];
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }
    return target;
  };
  return _extends.apply(this, arguments);
}
function contextualKeyword(options) {
  const {
    context: nodes,
    after,
    before,
    keyword
  } = options;
  return ifInside({
    nodes,
    before,
    after,
    keyword
  }, (0, import_autocomplete2.completeFromList)([{
    label: keyword,
    type: "keyword",
    boost: 10
  }]));
}
var keywordCompletions = [contextualKeyword({
  context: "InExpression",
  keyword: "in"
}), contextualKeyword({
  context: "IfExpression",
  keyword: "then",
  after: "if",
  before: "else"
}), contextualKeyword({
  context: "IfExpression",
  keyword: "else",
  after: "then"
}), contextualKeyword({
  context: "QuantifiedExpression",
  keyword: "satisfies"
}), contextualKeyword({
  context: "ForExpression",
  after: "InExpressions",
  keyword: "return"
})];
var dontComplete = ["StringLiteral", "Identifier", "LineComment", "BlockComment", "PathExpression", "Context", "Key", "ParameterName"];
var doComplete = ["Expr", "ContextEntry"];
function ifExpression(completionSource) {
  const allNodes = [...dontComplete, ...doComplete];
  return (context) => {
    const {
      state,
      pos
    } = context;
    const match = matchUp((0, import_language4.syntaxTree)(state).resolveInner(pos, -1), allNodes);
    if (match) {
      const [_5, name2] = match;
      if (dontComplete.includes(name2)) {
        return null;
      }
    }
    return completionSource(context);
  };
}
function snippetCompletion(snippets2) {
  return ifExpression((0, import_autocomplete2.completeFromList)(snippets2.map((s5) => _extends({}, s5, {
    type: "text"
  }))));
}
function matchLeft(node2, position, nodes) {
  return matchChildren(node2, position, nodes, -1);
}
function matchRight(node2, position, nodes) {
  return matchChildren(node2, position, nodes, 1);
}
function matchChildren(node2, position, nodes, direction) {
  let child = node2[direction > 0 ? "childAfter" : "childBefore"](position);
  while (child) {
    if (nodes.includes(child.name)) {
      return child;
    }
    if (child.type.isError && child.firstChild) {
      if (nodes.includes(child.firstChild.name)) {
        return child.firstChild;
      }
    }
    child = child[direction > 0 ? "nextSibling" : "prevSibling"];
  }
  return null;
}
function matchUp(node2, nodeNames) {
  if (!Array.isArray(nodeNames)) {
    nodeNames = [nodeNames];
  }
  for (; node2; node2 = node2.parent) {
    const nodeType = node2.type;
    const matchedName = nodeNames.find((name2) => name2 && nodeType.is(name2));
    if (matchedName) {
      return [node2, matchedName];
    }
    if (nodeType.isTop) {
      break;
    }
  }
  return null;
}
function ifInside(options, source) {
  const {
    nodes,
    before,
    after,
    keyword
  } = options;
  return (context) => {
    const {
      state,
      pos
    } = context;
    const match = matchUp((0, import_language4.syntaxTree)(state).resolveInner(pos, -1), nodes);
    if (!match) {
      return null;
    }
    const [node2] = match;
    if (matchLeft(node2, pos, [keyword, before])) {
      return null;
    }
    if (matchRight(node2, pos, [keyword, after])) {
      return null;
    }
    if (after && !matchLeft(node2, pos, [after])) {
      return null;
    }
    return source(context);
  };
}
var feelLanguage = import_language4.LRLanguage.define({
  parser: parser.configure({
    props: [import_language4.indentNodeProp.add({
      "Context": (0, import_language4.delimitedIndent)({
        closing: "}"
      }),
      "List FilterExpression": (0, import_language4.delimitedIndent)({
        closing: "]"
      }),
      "ParenthesizedExpression FunctionInvocation": (0, import_language4.continuedIndent)({
        except: /^\s*\)/
      }),
      "ForExpression QuantifiedExpression IfExpression": (0, import_language4.continuedIndent)({
        except: /^\s*(then|else|return|satisfies)\b/
      }),
      "FunctionDefinition": (0, import_language4.continuedIndent)({
        except: /^\s*(\(|\))/
      })
    }), import_language4.foldNodeProp.add({
      Context: import_language4.foldInside,
      List: import_language4.foldInside,
      ParenthesizedExpression: import_language4.foldInside,
      FunctionDefinition(node2) {
        const last4 = node2.getChild(")");
        if (!last4) return null;
        return {
          from: last4.to,
          to: node2.to
        };
      }
    })]
  }),
  languageData: {
    indentOnInput: /^\s*(\)|\}|\]|then|else|return|satisfies)$/,
    commentTokens: {
      line: "//",
      block: {
        open: "/*",
        close: "*/"
      }
    }
  }
});
var unaryTestsLanguage = feelLanguage.configure({
  top: "UnaryTests"
}, "FEEL unary tests");
var expressionLanguage = feelLanguage.configure({
  top: "Expression"
}, "FEEL expression");
function feel2(config = {}) {
  const language2 = config.dialect === "unaryTests" ? unaryTestsLanguage : expressionLanguage;
  const dialect = config.parserDialect;
  const contextTracker = trackVariables(config.context);
  const contextualLang = language2.configure({
    contextTracker,
    dialect
  });
  const completions2 = config.completions || [snippetCompletion(snippets), keywordCompletions].flat();
  return new import_language4.LanguageSupport(contextualLang, [...completions2.map((autocomplete) => contextualLang.data.of({
    autocomplete
  }))]);
}

// node_modules/@bpmn-io/feel-editor/dist/index.es.js
var linter2 = [(0, import_lint2.linter)(cmFeelLinter())];
var baseTheme = import_view3.EditorView.theme({
  "& .cm-content": {
    padding: "0px"
  },
  "& .cm-line": {
    padding: "0px"
  },
  "&.cm-editor.cm-focused": {
    outline: "none"
  },
  "& .cm-completionInfo": {
    whiteSpace: "pre-wrap",
    overflow: "hidden",
    textOverflow: "ellipsis"
  },
  "&.cm-editor": {
    height: "100%"
  },
  // Don't wrap whitespace for custom HTML
  "& .cm-completionInfo > *": {
    whiteSpace: "normal"
  },
  "& .cm-completionInfo ul": {
    margin: 0,
    paddingLeft: "15px"
  },
  "& .cm-completionInfo pre": {
    marginBottom: 0,
    whiteSpace: "pre-wrap"
  },
  "& .cm-completionInfo p": {
    marginTop: 0
  },
  "& .cm-completionInfo p:not(:last-of-type)": {
    marginBottom: 0
  }
});
var highlightTheme = import_view3.EditorView.baseTheme({
  "& .variableName": {
    color: "#10f"
  },
  "& .number": {
    color: "#164"
  },
  "& .string": {
    color: "#a11"
  },
  "& .bool": {
    color: "#219"
  },
  "& .function": {
    color: "#aa3731",
    fontWeight: "bold"
  },
  "& .control": {
    color: "#708"
  }
});
var syntaxClasses = (0, import_language5.syntaxHighlighting)(
  import_language5.HighlightStyle.define([
    { tag: import_highlight5.tags.variableName, class: "variableName" },
    { tag: import_highlight5.tags.name, class: "variableName" },
    { tag: import_highlight5.tags.number, class: "number" },
    { tag: import_highlight5.tags.string, class: "string" },
    { tag: import_highlight5.tags.bool, class: "bool" },
    { tag: import_highlight5.tags.function(import_highlight5.tags.variableName), class: "function" },
    { tag: import_highlight5.tags.function(import_highlight5.tags.special(import_highlight5.tags.variableName)), class: "function" },
    { tag: import_highlight5.tags.controlKeyword, class: "control" },
    { tag: import_highlight5.tags.operatorKeyword, class: "control" }
  ])
);
var theme2 = [baseTheme, highlightTheme, syntaxClasses];
function _isEmpty(node2) {
  return node2 && node2.from === node2.to;
}
function isEmpty(node2, pos) {
  const nextNode = node2.nextSibling;
  return _isEmpty(node2) || nextNode && nextNode.from === pos && _isEmpty(nextNode);
}
function isVariableName(node2) {
  return node2 && node2.parent && node2.parent.name === "VariableName";
}
function isPathExpression(node2) {
  if (!node2) {
    return false;
  }
  if (node2.name === "PathExpression") {
    return true;
  }
  return isPathExpression(node2.parent);
}
function pathExpressionCompletion({ variables }) {
  return (context) => {
    const nodeBefore = (0, import_language5.syntaxTree)(context.state).resolve(context.pos, -1);
    if (!isPathExpression(nodeBefore)) {
      return;
    }
    const expression = findPathExpression(nodeBefore);
    const from = nodeBefore === expression ? context.pos : nodeBefore.from;
    const path = getPath(expression, context);
    let options = variables;
    for (var i7 = 0; i7 < path.length - 1; i7++) {
      var childVar = options.find((val) => val.name === path[i7].name);
      if (!childVar) {
        return null;
      }
      if (childVar.isList !== "optional" && !!childVar.isList !== path[i7].isList) {
        return;
      }
      options = childVar.entries;
    }
    if (!options) return;
    options = options.map((v5) => ({
      label: v5.name,
      type: "variable",
      info: v5.info,
      detail: v5.detail
    }));
    const result = {
      from,
      options
    };
    return result;
  };
}
function findPathExpression(node2) {
  while (node2) {
    if (node2.name === "PathExpression") {
      return node2;
    }
    node2 = node2.parent;
  }
}
function getPath(node2, context) {
  let path = [];
  for (let child = node2.firstChild; child; child = child.nextSibling) {
    if (child.name === "PathExpression") {
      path.push(...getPath(child, context));
    } else if (child.name === "FilterExpression") {
      path.push(...getFilter(child, context));
    } else {
      path.push({
        name: getNodeContent(child, context),
        isList: false
      });
    }
  }
  return path;
}
function getFilter(node2, context) {
  const list = node2.firstChild;
  if (list.name === "PathExpression") {
    const path = getPath(list, context);
    const last4 = path[path.length - 1];
    last4.isList = true;
    return path;
  }
  return [{
    name: getNodeContent(list, context),
    isList: true
  }];
}
function getNodeContent(node2, context) {
  return context.state.sliceDoc(node2.from, node2.to);
}
function variableCompletion({ variables = [], builtins = [] }) {
  const options = getVariableSuggestions(variables, builtins);
  if (!options.length) {
    return (context) => null;
  }
  return (context) => {
    const {
      pos,
      state
    } = context;
    const nodeBefore = (0, import_language5.syntaxTree)(state).resolve(pos, -1);
    if (isEmpty(nodeBefore, pos)) {
      return context.explicit ? {
        from: pos,
        options
      } : null;
    }
    if (!isVariableName(nodeBefore) || isPathExpression(nodeBefore)) {
      return null;
    }
    return {
      from: nodeBefore.from,
      options
    };
  };
}
function getVariableSuggestions(variables, builtins) {
  return [].concat(
    variables.map((v5) => createVariableSuggestion(v5)),
    builtins.map((b4) => createVariableSuggestion(b4))
  );
}
function createVariableSuggestion(variable, boost) {
  if (variable.type === "function") {
    return createFunctionVariable(variable, boost);
  }
  return {
    label: variable.name,
    type: "variable",
    info: variable.info,
    detail: variable.detail,
    boost
  };
}
function createFunctionVariable(variable, boost) {
  const {
    name: name2,
    info,
    detail,
    params = []
  } = variable;
  const paramsWithNames = params.map(({ name: name3, type }, index5) => ({
    name: name3 || `param ${index5 + 1}`,
    type
  }));
  const template = `${name2}(${paramsWithNames.map((p5) => "${" + p5.name + "}").join(", ")})`;
  const paramsSignature = paramsWithNames.map(({ name: name3, type }) => type ? `${name3}: ${type}` : name3).join(", ");
  const label = `${name2}(${paramsSignature})`;
  return (0, import_autocomplete3.snippetCompletion)(template, {
    label,
    type: "function",
    info,
    detail,
    boost
  });
}
function completions({ variables = [], builtins = [] }) {
  return [
    pathExpressionCompletion({ variables }),
    variableCompletion({ variables, builtins }),
    snippetCompletion(snippets.map((snippet) => ({ ...snippet, boost: -1 }))),
    ...keywordCompletions
  ];
}
function language(options) {
  return feel2(options);
}
function createContext(variables) {
  return variables.slice().reverse().reduce((context, builtin) => {
    context[builtin.name] = () => {
    };
    return context;
  }, {});
}
var builtinsFacet = import_state2.Facet.define();
var variablesFacet = import_state2.Facet.define();
var dialectFacet = import_state2.Facet.define();
var parserDialectFacet = import_state2.Facet.define();
function configure({
  dialect = "expression",
  parserDialect,
  variables = [],
  builtins = [],
  completions: completions$1 = completions({ builtins, variables })
}) {
  const context = createContext([...variables, ...builtins]);
  return [
    dialectFacet.of(dialect),
    builtinsFacet.of(builtins),
    variablesFacet.of(variables),
    parserDialectFacet.of(parserDialect),
    language({
      dialect,
      parserDialect,
      context,
      completions: completions$1
    })
  ];
}
function get3(state) {
  const builtins = state.facet(builtinsFacet)[0];
  const variables = state.facet(variablesFacet)[0];
  const dialect = state.facet(dialectFacet)[0];
  const parserDialect = state.facet(parserDialectFacet)[0];
  return {
    builtins,
    variables,
    dialect,
    parserDialect
  };
}
var camundaTags = [
  {
    name: "not(negand)",
    description: '<p>Returns the logical negation of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">not(negand: boolean): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">not(true)\n// false\n\nnot(null)\n// null\n</code></pre>\n'
  },
  {
    name: "is defined(value)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Checks if a given value is not <code>null</code>. If the value is <code>null</code> then the function returns <code>false</code>.\nOtherwise, the function returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is defined(value: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is defined(1)\n// true\n\nis defined(null)\n// false\n\nis defined(x)\n// false - if no variable &quot;x&quot; exists\n\nis defined(x.y)\n// false - if no variable &quot;x&quot; exists or it doesn&#39;t have a property &quot;y&quot;\n</code></pre>\n<p>:::caution Breaking change</p>\n<p>This function worked differently in previous versions. It returned <code>true</code> if the value was <code>null</code>.\nSince this version, the function returns <code>false</code> if the value is <code>null</code>.</p>\n<p>:::</p>\n'
  },
  {
    name: "get or else(value, default)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Return the provided value parameter if not <code>null</code>, otherwise return the default parameter</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get or else(value: Any, default: Any): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get or else(&quot;this&quot;, &quot;default&quot;)\n// &quot;this&quot;\n\nget or else(null, &quot;default&quot;)\n// &quot;default&quot;\n\nget or else(null, null)\n// null\n</code></pre>\n'
  },
  {
    name: "assert(value, condition)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">assert(value: Any, condition: Any)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">assert(x, x != null)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0)\n// 4 - if x is 4\n// error - if x is less than zero\n</code></pre>\n'
  },
  {
    name: "assert(value, condition, cause)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Verify that the given condition is met. If the condition is <code>true</code>, the function returns the value.\nOtherwise, the evaluation fails with an error containing the given message.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">assert(value: Any, condition: Any, cause: String)\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">assert(x, x != null, &quot;&#39;x&#39; should not be null&quot;)\n// &quot;value&quot; - if x is &quot;value&quot;\n// error(&#39;x&#39; should not be null) - if x is null or doesn&#39;t exist\n\nassert(x, x &gt;= 0, &quot;&#39;x&#39; should be positive&quot;)\n// 4 - if x is 4\n// error(&#39;x&#39; should be positive) - if x is less than zero\n</code></pre>\n'
  },
  {
    name: "get value(context, key)",
    description: '<p>Returns the value of the context entry with the given key.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get value(context: context, key: string): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get value({foo: 123}, &quot;foo&quot;)\n// 123\n\nget value({a: 1}, &quot;b&quot;)\n// null\n</code></pre>\n'
  },
  {
    name: "get value(context, keys)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the value of the context entry for a context path defined by the given keys.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it returns the value at the nested entry <code>k1.k2</code> of the context.</p>\n<p>If <code>keys</code> are empty or the nested entry defined by the keys doesn&#39;t exist in the context, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get value(context: context, keys: list&lt;string&gt;): Any\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get value({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;])\n// 0\n\nget value({x: {y: {z:0}}}, [&quot;x&quot;, &quot;y&quot;])\n// {z:0}\n\nget value({a: {b: 3}}, [&quot;b&quot;])\n// null\n</code></pre>\n'
  },
  {
    name: "get entries(context)",
    description: '<p>Returns the entries of the context as a list of key-value-pairs.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">get entries(context: context): list&lt;context&gt;\n</code></pre>\n<p>The return value is a list of contexts. Each context contains two entries for &quot;key&quot; and &quot;value&quot;.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">get entries({foo: 123})\n// [{key: &quot;foo&quot;, value: 123}]\n</code></pre>\n'
  },
  {
    name: "context put(context, key, value)",
    description: '<p>Adds a new entry with the given key and value to the context. Returns a new context that includes the entry.</p>\n<p>If an entry for the same key already exists in the context, it overrides the value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context put(context: context, key: string, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context put({x:1}, &quot;y&quot;, 2)\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context put()</code> replaced the previous function <code>put()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n'
  },
  {
    name: "context put(context, keys, value)",
    description: '<p>Adds a new entry with the given value to the context. The path of the entry is defined by the keys. Returns a new context that includes the entry.</p>\n<p>If <code>keys</code> contains the keys <code>[k1, k2]</code> then it adds the nested entry <code>k1.k2 = value</code> to the context.</p>\n<p>If an entry for the same keys already exists in the context, it overrides the value.</p>\n<p>If <code>keys</code> are empty, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context put(context: context, keys: list&lt;string&gt;, value: Any): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context put({x:1}, [&quot;y&quot;], 2)\n// {x:1, y:2}\n\ncontext put({x:1, y: {z:0}}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n\ncontext put({x:1}, [&quot;y&quot;, &quot;z&quot;], 2)\n// {x:1, y: {z:2}}\n</code></pre>\n'
  },
  {
    name: "context merge(contexts)",
    description: '<p>Union the given contexts. Returns a new context that includes all entries of the given contexts.</p>\n<p>If an entry for the same key already exists in a context, it overrides the value. The entries are overridden in the same order as in the list of contexts.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context merge(contexts: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context merge([{x:1}, {y:2}])\n// {x:1, y:2}\n\ncontext merge([{x:1, y: 0}, {y:2}])\n// {x:1, y:2}\n</code></pre>\n<p>:::info\nThe function <code>context merge()</code> replaced the previous function <code>put all()</code> (Camunda Extension). The\nprevious function is deprecated and should not be used anymore.\n:::</p>\n'
  },
  {
    name: "string(from)",
    description: '<p>Returns the given value as a string representation.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string(from: Any): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string(1.1)\n// &quot;1.1&quot;\n\nstring(date(&quot;2012-12-25&quot;))\n// &quot;2012-12-25&quot;\n</code></pre>\n'
  },
  {
    name: "number(from)",
    description: '<p>Parses the given string to a number.</p>\n<p>Returns <code>null</code> if the string is not a number.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">number(from: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">number(&quot;1500.5&quot;)\n// 1500.5\n</code></pre>\n'
  },
  {
    name: "context(entries)",
    description: '<p>Constructs a context of the given list of key-value pairs. It is the reverse function to <a href="feel-built-in-functions-context.md#get-entriescontext">get entries()</a>.</p>\n<p>Each key-value pair must be a context with two entries: <code>key</code> and <code>value</code>. The entry with name <code>key</code> must have a value of the type <code>string</code>.</p>\n<p>It might override context entries if the keys are equal. The entries are overridden in the same order as the contexts in the given list.</p>\n<p>Returns <code>null</code> if one of the entries is not a context or if a context doesn&#39;t contain the required entries.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">context(entries: list&lt;context&gt;): context\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">context([{&quot;key&quot;:&quot;a&quot;, &quot;value&quot;:1}, {&quot;key&quot;:&quot;b&quot;, &quot;value&quot;:2}])\n// {a:1, b:2}\n</code></pre>\n'
  },
  {
    name: "date(from)",
    description: '<p>Returns a date from the given value.</p>\n<p>Returns <code>null</code> if the string is not a valid calendar date. For example, <code>&quot;2024-06-31&quot;</code> is invalid because June has\nonly 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date(from: string): date\n</code></pre>\n<p>Parses the given string into a date.</p>\n<pre><code class="language-feel">date(from: date and time): date\n</code></pre>\n<p>Extracts the date component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date(&quot;2018-04-29&quot;)\n// date(&quot;2018-04-29&quot;)\n\ndate(date and time(&quot;2012-12-25T11:00:00&quot;))\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
  },
  {
    name: "date(year, month, day)",
    description: '<p>Returns a date from the given components.</p>\n<p>Returns <code>null</code> if the components don&#39;t represent a valid calendar date. For example, <code>2024,6,31</code> is invalid because\nJune has only 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date(year: number, month: number, day: number): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date(2012, 12, 25)\n// date(&quot;2012-12-25&quot;)\n</code></pre>\n'
  },
  {
    name: "time(from)",
    description: '<p>Returns a time from the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(from: string): time\n</code></pre>\n<p>Parses the given string into a time.</p>\n<pre><code class="language-feel">time(from: date and time): time\n</code></pre>\n<p>Extracts the time component from the given date and time.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(&quot;12:00:00&quot;)\n// time(&quot;12:00:00&quot;)\n\ntime(date and time(&quot;2012-12-25T11:00:00&quot;))\n// time(&quot;11:00:00&quot;)\n</code></pre>\n'
  },
  {
    name: "time(hour, minute, second)",
    description: '<p>Returns a time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(hour: number, minute: number, second: number): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(23, 59, 0)\n// time(&quot;23:59:00&quot;)\n</code></pre>\n'
  },
  {
    name: "time(hour, minute, second, offset)",
    description: '<p>Returns a time from the given components, including a timezone offset.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">time(hour: number, minute: number, second: number, offset: days and time duration): time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">time(14, 30, 0, duration(&quot;PT1H&quot;))\n// time(&quot;14:30:00+01:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time(from)",
    description: '<p>Parses the given string into a date and time.</p>\n<p>Returns <code>null</code> if the string is not a valid calendar date. For example, <code>&quot;2024-06-31T10:00:00&quot;</code> is invalid because\nJune has only 30 days.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(from: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(&quot;2018-04-29T09:30:00&quot;)\n// date and time(&quot;2018-04-29T09:30:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time(date, time)",
    description: '<p>Returns a date and time from the given components.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(date: date, time: time): date and time\n</code></pre>\n<pre><code class="language-feel">date and time(date: date and time, time: time): date and time\n</code></pre>\n<p>Returns a date and time value that consists of the date component of <code>date</code> combined with <code>time</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(date(&quot;2012-12-24&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-24T23:59:00&quot;)\n\ndate and time(date and time(&quot;2012-12-25T11:00:00&quot;),time(&quot;T23:59:00&quot;))\n// date and time(&quot;2012-12-25T23:59:00&quot;)\n</code></pre>\n'
  },
  {
    name: "date and time(date, timezone)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given date and time value at the given timezone.</p>\n<p>If <code>date</code> has a different timezone than <code>timezone</code> then it adjusts the time to match the local time of <code>timezone</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">date and time(date: date and time, timezone: string): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">date and time(@&quot;2020-07-31T14:27:30@Europe/Berlin&quot;, &quot;America/Los_Angeles&quot;)\n// date and time(&quot;2020-07-31T05:27:30@America/Los_Angeles&quot;)\n\ndate and time(@&quot;2020-07-31T14:27:30&quot;, &quot;Z&quot;)\n// date and time(&quot;2020-07-31T12:27:30Z&quot;)\n</code></pre>\n'
  },
  {
    name: "duration(from)",
    description: '<p>Parses the given string into a duration. The duration is either a days and time duration or a years and months duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">duration(from: string): days and time duration\n</code></pre>\n<pre><code class="language-feel">duration(from: string): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">duration(&quot;P5D&quot;)\n// duration(&quot;P5D&quot;)\n\nduration(&quot;P32Y&quot;)\n// duration(&quot;P32Y&quot;)\n</code></pre>\n'
  },
  {
    name: "years and months duration(from, to)",
    description: '<p>Returns the years and months duration between <code>from</code> and <code>to</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">years and months duration(from: date, to: date): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">years and months duration(date(&quot;2011-12-22&quot;), date(&quot;2013-08-24&quot;))\n// duration(&quot;P1Y8M&quot;)\n</code></pre>\n'
  },
  {
    name: "list contains(list, element)",
    description: '<p>Returns <code>true</code> if the given list contains the element. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">list contains(list: list, element: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">list contains([1,2,3], 2)\n// true\n</code></pre>\n'
  },
  {
    name: "count(list)",
    description: '<p>Returns the number of elements of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">count(list: list): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">count([1,2,3])\n// 3\n</code></pre>\n'
  },
  {
    name: "min(list)",
    description: '<p>Returns the minimum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">min(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">min([1,2,3])\n// 1\n\nmin(1,2,3)\n// 1\n</code></pre>\n'
  },
  {
    name: "max(list)",
    description: '<p>Returns the maximum of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">max(list: list): Any\n</code></pre>\n<p>All elements in <code>list</code> should have the same type and be comparable.</p>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">max([1,2,3])\n// 3\n\nmax(1,2,3)\n// 3\n</code></pre>\n'
  },
  {
    name: "sum(list)",
    description: '<p>Returns the sum of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sum(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sum([1,2,3])\n// 6\n\nsum(1,2,3)\n// 6\n</code></pre>\n'
  },
  {
    name: "product(list)",
    description: '<p>Returns the product of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">product(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">product([2, 3, 4])\n// 24\n\nproduct(2, 3, 4)\n// 24\n</code></pre>\n'
  },
  {
    name: "mean(list)",
    description: '<p>Returns the arithmetic mean (i.e. average) of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">mean(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">mean([1,2,3])\n// 2\n\nmean(1,2,3)\n// 2\n</code></pre>\n'
  },
  {
    name: "median(list)",
    description: '<p>Returns the median element of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">median(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">median(8, 2, 5, 3, 4)\n// 4\n\nmedian([6, 1, 2, 3])\n// 2.5\n</code></pre>\n'
  },
  {
    name: "stddev(list)",
    description: '<p>Returns the standard deviation of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">stddev(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">stddev(2, 4, 7, 5)\n// 2.0816659994661326\n\nstddev([2, 4, 7, 5])\n// 2.0816659994661326\n</code></pre>\n'
  },
  {
    name: "mode(list)",
    description: '<p>Returns the mode of the given list of numbers.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">mode(list: list&lt;number&gt;): number\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">mode(6, 3, 9, 6, 6)\n// [6]\n\nmode([6, 1, 9, 6, 1])\n// [1, 6]\n</code></pre>\n'
  },
  {
    name: "all(list)",
    description: '<p>Returns <code>false</code> if any element of the given list is <code>false</code>. Otherwise, returns <code>true</code>.</p>\n<p>If the given list is empty, it returns <code>true</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">all(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">all([true,false])\n// false\n\nall(false,null,true)\n// false\n</code></pre>\n<p>:::info\nThe function <code>all()</code> replaced the previous function <code>and()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n'
  },
  {
    name: "any(list)",
    description: '<p>Returns <code>true</code> if any element of the given list is <code>true</code>. Otherwise, returns <code>false</code>.</p>\n<p>If the given list is empty, it returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">any(list: list&lt;boolean&gt;): boolean\n</code></pre>\n<p>The parameter <code>list</code> can be passed as a list or as a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">any([false,true])\n// true\n\nany(false,null,true)\n// true\n</code></pre>\n<p>:::info\nThe function <code>any()</code> replaced the previous function <code>or()</code>. The previous function is deprecated and\nshould not be used anymore.\n:::</p>\n'
  },
  {
    name: "sublist(list, start position)",
    description: '<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sublist(list: list, start position: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sublist([1,2,3], 2)\n// [2,3]\n</code></pre>\n'
  },
  {
    name: "sublist(list, start position, length)",
    description: '<p>Returns a partial list of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sublist(list: list, start position: number, length: number): list\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sublist([1,2,3], 1, 2)\n// [1,2]\n</code></pre>\n'
  },
  {
    name: "append(list, items)",
    description: '<p>Returns the given list with all <code>items</code> appended.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">append(list: list, items: Any): list\n</code></pre>\n<p>The parameter <code>items</code> can be a single element or a sequence of elements.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">append([1], 2, 3)\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "concatenate(lists)",
    description: '<p>Returns a list that includes all elements of the given lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">concatenate(lists: list): list\n</code></pre>\n<p>The parameter <code>lists</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">concatenate([1,2],[3])\n// [1,2,3]\n\nconcatenate([1],[2],[3])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "insert before(list, position, newItem)",
    description: '<p>Returns the given list with <code>newItem</code> inserted at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">insert before(list: list, position: number, newItem: Any): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">insert before([1,3],1,2)\n// [2,1,3]\n</code></pre>\n'
  },
  {
    name: "remove(list, position)",
    description: '<p>Returns the given list without the element at <code>position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">remove(list: list, position: number): list\n</code></pre>\n<p>The <code>position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">remove([1,2,3], 2)\n// [1,3]\n</code></pre>\n'
  },
  {
    name: "reverse(list)",
    description: '<p>Returns the given list in revered order.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">reverse(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">reverse([1,2,3])\n// [3,2,1]\n</code></pre>\n'
  },
  {
    name: "index of(list, match)",
    description: '<p>Returns an ascending list of positions containing <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">index of(list: list, match: Any): list&lt;number&gt;\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">index of([1,2,3,2],2)\n// [2,4]\n</code></pre>\n'
  },
  {
    name: "union(list)",
    description: '<p>Returns a list that includes all elements of the given lists without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">union(list: list): list\n</code></pre>\n<p>The parameter <code>list</code> is a sequence of lists.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">union([1,2],[2,3])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "distinct values(list)",
    description: '<p>Returns the given list without duplicates.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">distinct values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">distinct values([1,2,3,2,1])\n// [1,2,3]\n</code></pre>\n'
  },
  {
    name: "duplicate values(list)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns all duplicate values of the given list.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">duplicate values(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">duplicate values([1,2,3,2,1])\n// [1,2]\n</code></pre>\n'
  },
  {
    name: "flatten(list)",
    description: '<p>Returns a list that includes all elements of the given list without nested lists.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">flatten(list: list): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">flatten([[1,2],[[3]], 4])\n// [1,2,3,4]\n</code></pre>\n'
  },
  {
    name: "sort(list, precedes)",
    description: '<p>Returns the given list sorted by the <code>precedes</code> function.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sort(list: list, precedes: function&lt;(Any, Any) -&gt; boolean&gt;): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sort(list: [3,1,4,5,2], precedes: function(x,y) x &lt; y)\n// [1,2,3,4,5]\n</code></pre>\n'
  },
  {
    name: "string join(list)",
    description: '<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;])\n// &quot;abc&quot;\n\nstring join([&quot;a&quot;,null,&quot;c&quot;])\n// &quot;ac&quot;\n\nstring join([])\n// &quot;&quot;\n</code></pre>\n'
  },
  {
    name: "string join(list, delimiter)",
    description: '<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string contains a <code>delimiter</code> between each element.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;, delimiter: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;], &quot;X&quot;)\n// &quot;a&quot;\n\nstring join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;)\n// &quot;a, b, c&quot;\n</code></pre>\n'
  },
  {
    name: "string join(list, delimiter, prefix, suffix)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Joins a list of strings into a single string. This is similar to\nJava&#39;s <a href="https://docs.oracle.com/en/java/javase/11/docs/api/java.base/java/util/stream/Collectors.html#joining(java.lang.CharSequence,java.lang.CharSequence,java.lang.CharSequence)">joining</a>\nfunction.</p>\n<p>If an item of the list is <code>null</code>, the item is ignored for the result string. If an item is\nneither a string nor <code>null</code>, the function returns <code>null</code> instead of a string.</p>\n<p>The resulting string starts with <code>prefix</code>, contains a <code>delimiter</code> between each element, and ends\nwith <code>suffix</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string join(list: list&lt;string&gt;, delimiter: string, prefix: string, suffix: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string join([&quot;a&quot;,&quot;b&quot;,&quot;c&quot;], &quot;, &quot;, &quot;[&quot;, &quot;]&quot;)\n// &quot;[a, b, c]&quot;\n</code></pre>\n'
  },
  {
    name: "is empty(list)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns <code>true</code> if the given list is empty. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is empty(list: list): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is empty([])\n// true\n\nis empty([1,2,3])\n// false\n</code></pre>\n'
  },
  {
    name: "partition(list\uFF0C size)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns consecutive sublists of a list, each of the same size (the final list may be smaller).</p>\n<p>If <code>size</code> is less than <code>0</code>, it returns <code>null</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">partition(list: list, size: number): list\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">partition([1,2,3,4,5], 2)\n// [[1,2], [3,4], [5]]\n\npartition([], 2)\n// []\n\npartition([1,2], 0)\n// null\n</code></pre>\n'
  },
  {
    name: "decimal(n, scale)",
    description: '<p>Rounds the given value at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">decimal(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">decimal(1/3, 2)\n// .33\n\ndecimal(1.5, 0)\n// 2\n</code></pre>\n'
  },
  {
    name: "floor(n)",
    description: '<p>Rounds the given value with rounding mode flooring.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">floor(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">floor(1.5)\n// 1\n\nfloor(-1.5)\n// -2\n</code></pre>\n'
  },
  {
    name: "floor(n, scale)",
    description: '<p>Rounds the given value with rounding mode flooring at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">floor(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">floor(-1.56, 1)\n// -1.6\n</code></pre>\n'
  },
  {
    name: "ceiling(n)",
    description: '<p>Rounds the given value with rounding mode ceiling.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ceiling(n: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ceiling(1.5)\n// 2\n\nceiling(-1.5)\n// -1\n</code></pre>\n'
  },
  {
    name: "ceiling(n, scale)",
    description: '<p>Rounds the given value with rounding mode ceiling at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ceiling(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ceiling(-1.56, 1)\n// -1.5\n</code></pre>\n'
  },
  {
    name: "round up(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round up(5.5)\n// 6\n\nround up(-5.5)\n// -6\n\nround up(1.121, 2)\n// 1.13\n\nround up(-1.126, 2)\n// -1.13\n</code></pre>\n'
  },
  {
    name: "round down(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round down(5.5, 0)\n// 5\n\nround down (-5.5, 0)\n// -5\n\nround down (1.121, 2)\n// 1.12\n\nround down (-1.126, 2)\n// -1.12\n</code></pre>\n'
  },
  {
    name: "round half up(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-half-up at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round half up(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round half up(5.5, 0)\n// 6\n\nround half up(-5.5, 0)\n// -6\n\nround half up(1.121, 2)\n// 1.12\n\nround half up(-1.126, 2)\n// -1.13\n</code></pre>\n'
  },
  {
    name: "round half down(n, scale)",
    description: '<p>Rounds the given value with the rounding mode round-half-down at the given scale.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">round half down(n: number, scale: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">round half down (5.5, 0)\n// 5\n\nround half down (-5.5, 0)\n// -5\n\nround half down (1.121, 2)\n// 1.12\n\nround half down (-1.126, 2)\n// -1.13\n</code></pre>\n'
  },
  {
    name: "abs(number)",
    description: '<p>Returns the absolute value of the given numeric value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">abs(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">abs(10)\n// 10\n\nabs(-10)\n// 10\n</code></pre>\n'
  },
  {
    name: "modulo(dividend, divisor)",
    description: '<p>Returns the remainder of the division of dividend by divisor.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">modulo(dividend: number, divisor: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">modulo(12, 5)\n// 2\n</code></pre>\n'
  },
  {
    name: "sqrt(number)",
    description: '<p>Returns the square root of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">sqrt(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">sqrt(16)\n// 4\n</code></pre>\n'
  },
  {
    name: "log(number)",
    description: '<p>Returns the natural logarithm (base e) of the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">log(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">log(10)\n// 2.302585092994046\n</code></pre>\n'
  },
  {
    name: "exp(number)",
    description: '<p>Returns the Euler\u2019s number e raised to the power of the given number .</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">exp(number: number): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">exp(5)\n// 148.4131591025766\n</code></pre>\n'
  },
  {
    name: "odd(number)",
    description: '<p>Returns <code>true</code> if the given value is odd. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">odd(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">odd(5)\n// true\n\nodd(2)\n// false\n</code></pre>\n'
  },
  {
    name: "even(number)",
    description: '<p>Returns <code>true</code> if the given is even. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">even(number: number): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">even(5)\n// false\n\neven(2)\n// true\n</code></pre>\n'
  },
  {
    name: "random number()",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns a random number between <code>0</code> and <code>1</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">random number(): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">random number()\n// 0.9701618132579795\n</code></pre>\n'
  },
  {
    name: "before(point1, point2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before(1, 10)\n// true\n\nbefore(10, 1)\n// false\n</code></pre>\n'
  },
  {
    name: "before(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before([1..5], 10)\n// true\n</code></pre>\n'
  },
  {
    name: "before(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before(1, [2..5])\n// true\n</code></pre>\n'
  },
  {
    name: "before(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">before([1..5], [6..10])\n// true\n\nbefore([1..5),[5..10])\n// true\n</code></pre>\n'
  },
  {
    name: "after(point1, point2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after(10, 1)\n// true\n\nafter(1, 10)\n// false\n</code></pre>\n'
  },
  {
    name: "after(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after([1..5], 10)\n// false\n</code></pre>\n'
  },
  {
    name: "after(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after(12, [2..5])\n// true\n</code></pre>\n'
  },
  {
    name: "after(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">after([6..10], [1..5])\n// true\n\nafter([5..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "meets(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">meets(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">meets([1..5], [5..10])\n// true\n\nmeets([1..3], [4..6])\n// false\n\nmeets([1..3], [3..5])\n// true\n\nmeets([1..5], (5..8])\n// false\n</code></pre>\n'
  },
  {
    name: "met by(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">met by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">met by([5..10], [1..5])\n// true\n\nmet by([3..4], [1..2])\n// false\n\nmet by([3..5], [1..3])\n// true\n\nmet by((5..8], [1..5))\n// false\n\nmet by([5..10], [1..5))\n// false\n</code></pre>\n'
  },
  {
    name: "overlaps(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps([5..10], [1..6])\n// true\n\noverlaps((3..7], [1..4])\n// true\n\noverlaps([1..3], (3..6])\n// false\n\noverlaps((5..8], [1..5))\n// false\n\noverlaps([4..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "overlaps before(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps before(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps before([1..5], [4..10])\n// true\n\noverlaps before([3..4], [1..2])\n// false\n\noverlaps before([1..3], (3..5])\n// false\n\noverlaps before([1..5), (3..8])\n// true\n\noverlaps before([1..5), [5..10])\n// false\n</code></pre>\n'
  },
  {
    name: "overlaps after(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">overlaps after(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">overlaps after([4..10], [1..5])\n// true\n\noverlaps after([3..4], [1..2])\n// false\n\noverlaps after([3..5], [1..3))\n// false\n\noverlaps after((5..8], [1..5))\n// false\n\noverlaps after([4..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "finishes(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finishes(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finishes(5, [1..5])\n// true\n\nfinishes(10, [1..7])\n// false\n</code></pre>\n'
  },
  {
    name: "finishes(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finishes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finishes([3..5], [1..5])\n// true\n\nfinishes((1..5], [1..5))\n// false\n\nfinishes([5..10], [1..10))\n// false\n</code></pre>\n'
  },
  {
    name: "finished by(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finished by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finished by([5..10], 10)\n// true\n\nfinished by([3..4], 2)\n// false\n</code></pre>\n'
  },
  {
    name: "finished by(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">finished by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">finished by([1..5], [3..5])\n// true\n\nfinished by((5..8], [1..5))\n// false\n\nfinished by([5..10], (1..10))\n// false\n</code></pre>\n'
  },
  {
    name: "includes(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">includes(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">includes([5..10], 6)\n// true\n\nincludes([3..4], 5)\n// false\n</code></pre>\n'
  },
  {
    name: "includes(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">includes(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">includes([1..10], [4..6])\n// true\n\nincludes((5..8], [1..5))\n// false\n\nincludes([1..10], [1..5))\n// true\n</code></pre>\n'
  },
  {
    name: "during(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">during(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">during(5, [1..10])\n// true\n\nduring(12, [1..10])\n// false\n\nduring(1, (1..10])\n// false\n</code></pre>\n'
  },
  {
    name: "during(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">during(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">during([4..6], [1..10))\n// true\n\nduring((1..5], (1..10])\n// true\n</code></pre>\n'
  },
  {
    name: "starts(point, range)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts(point: Any, range: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts(1, [1..5])\n// true\n\nstarts(1, (1..8])\n// false\n</code></pre>\n'
  },
  {
    name: "starts(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts((1..5], [1..5])\n// false\n\nstarts([1..10], [1..5])\n// false\n\nstarts((1..5), (1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "started by(range, point)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">started by(range: range, point: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">started by([1..10], 1)\n// true\n\nstarted by((1..10], 1)\n// false\n</code></pre>\n'
  },
  {
    name: "started by(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">started by(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">started by([1..10], [1..5])\n// true\n\nstarted by((1..10], [1..5))\n// false\n\nstarted by([1..10], [1..10))\n// true\n</code></pre>\n'
  },
  {
    name: "coincides(point1, point2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">coincides(point1: Any, point2: Any): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">coincides(5, 5)\n// true\n\ncoincides(3, 4)\n// false\n</code></pre>\n'
  },
  {
    name: "coincides(range1, range2)",
    description: '<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">coincides(range1: range, range2: range): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">coincides([1..5], [1..5])\n// true\n\ncoincides((1..5], [1..5))\n// false\n\ncoincides([1..5], [2..6])\n// false\n</code></pre>\n'
  },
  {
    name: "substring(string, start position)",
    description: '<p>Returns a substring of the given value starting at <code>start position</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring(string: string, start position: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring(&quot;foobar&quot;, 3)\n// &quot;obar&quot;\n\nsubstring(&quot;foobar&quot;, -2)\n// &quot;ar&quot;\n</code></pre>\n'
  },
  {
    name: "substring(string, start position, length)",
    description: '<p>Returns a substring of the given value, starting at <code>start position</code> with the given <code>length</code>. If <code>length</code> is greater than\nthe remaining characters of the value, it returns all characters from <code>start position</code> until the end.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring(string: string, start position: number, length: number): string\n</code></pre>\n<p>The <code>start position</code> starts at the index <code>1</code>. The last position is <code>-1</code>.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring(&quot;foobar&quot;, 3, 3)\n// &quot;oba&quot;\n\nsubstring(&quot;foobar&quot;, -3, 2)\n// &quot;ba&quot;\n\nsubstring(&quot;foobar&quot;, 3, 10)\n// &quot;obar&quot;\n</code></pre>\n'
  },
  {
    name: "string length(string)",
    description: '<p>Returns the number of characters in the given value.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">string length(string: string): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">string length(&quot;foo&quot;)\n// 3\n</code></pre>\n'
  },
  {
    name: "upper case(string)",
    description: '<p>Returns the given value with all characters are uppercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">upper case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">upper case(&quot;aBc4&quot;)\n// &quot;ABC4&quot;\n</code></pre>\n'
  },
  {
    name: "lower case(string)",
    description: '<p>Returns the given value with all characters are lowercase.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">lower case(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">lower case(&quot;aBc4&quot;)\n// &quot;abc4&quot;\n</code></pre>\n'
  },
  {
    name: "substring before(string, match)",
    description: '<p>Returns a substring of the given value that contains all characters before <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring before(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring before(&quot;foobar&quot;, &quot;bar&quot;)\n// &quot;foo&quot;\n</code></pre>\n'
  },
  {
    name: "substring after(string, match)",
    description: '<p>Returns a substring of the given value that contains all characters after <code>match</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">substring after(string: string, match: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">substring after(&quot;foobar&quot;, &quot;ob&quot;)\n// &quot;ar&quot;\n</code></pre>\n'
  },
  {
    name: "contains(string, match)",
    description: '<p>Returns <code>true</code> if the given value contains the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">contains(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">contains(&quot;foobar&quot;, &quot;of&quot;)\n// false\n</code></pre>\n'
  },
  {
    name: "starts with(string, match)",
    description: '<p>Returns <code>true</code> if the given value starts with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">starts with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">starts with(&quot;foobar&quot;, &quot;fo&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "ends with(string, match)",
    description: '<p>Returns <code>true</code> if the given value ends with the substring <code>match</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">ends with(string: string, match: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">ends with(&quot;foobar&quot;, &quot;r&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "matches(input, pattern)",
    description: '<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">matches(input: string, pattern: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">matches(&quot;foobar&quot;, &quot;^fo*bar&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "matches(input, pattern, flags)",
    description: '<p>Returns <code>true</code> if the given value matches the <code>pattern</code>. Otherwise, returns <code>false</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">matches(input: string, pattern: string, flags: string): boolean\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">matches(&quot;FooBar&quot;, &quot;foo&quot;, &quot;i&quot;)\n// true\n</code></pre>\n'
  },
  {
    name: "replace(input, pattern, replacement)",
    description: '<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">replace(input: string, pattern: string, replacement: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">replace(&quot;abcd&quot;, &quot;(ab)|(a)&quot;, &quot;[1=$1][2=$2]&quot;)\n// &quot;[1=ab][2=]cd&quot;\n\nreplace(&quot;0123456789&quot;, &quot;(\\d{3})(\\d{3})(\\d{4})&quot;, &quot;($1) $2-$3&quot;)\n// &quot;(012) 345-6789&quot;\n</code></pre>\n'
  },
  {
    name: "replace(input, pattern, replacement, flags)",
    description: '<p>Returns the resulting string after replacing all occurrences of <code>pattern</code> with <code>replacement</code>.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">replace(input: string, pattern: string, replacement: string, flags: string): string\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p>The <code>replacement</code> can access the match groups by using <code>$</code> and the number of the group, for example,\n<code>$1</code> to access the first group.</p>\n<p>The <code>flags</code> can contain one or more of the following characters:</p>\n<ul>\n<li><code>s</code> (dot-all)</li>\n<li><code>m</code> (multi-line)</li>\n<li><code>i</code> (case insensitive)</li>\n<li><code>x</code> (comments)</li>\n</ul>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">replace(&quot;How do you feel?&quot;, &quot;Feel&quot;, &quot;FEEL&quot;, &quot;i&quot;)\n// &quot;How do you FEEL?&quot;\n</code></pre>\n'
  },
  {
    name: "split(string, delimiter)",
    description: '<p>Splits the given value into a list of substrings, breaking at each occurrence of the <code>delimiter</code> pattern.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">split(string: string, delimiter: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>delimiter</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">split(&quot;John Doe&quot;, &quot;\\s&quot; )\n// [&quot;John&quot;, &quot;Doe&quot;]\n\nsplit(&quot;a;b;c;;&quot;, &quot;;&quot;)\n// [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;&quot;, &quot;&quot;]\n</code></pre>\n'
  },
  {
    name: "extract(string, pattern)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns all matches of the pattern in the given string. Returns an empty list if the pattern doesn&#39;t\nmatch.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">extract(string: string, pattern: string): list&lt;string&gt;\n</code></pre>\n<p>The <code>pattern</code> is a string that contains a regular expression.</p>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">extract(&quot;references are 1234, 1256, 1378&quot;, &quot;12[0-9]*&quot;)\n// [&quot;1234&quot;,&quot;1256&quot;]\n</code></pre>\n'
  },
  {
    name: "trim(string)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given string without leading and trailing spaces.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">trim(string: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">trim(&quot;  hello world  &quot;)\n// &quot;hello world&quot;\n\ntrim(&quot;hello   world &quot;)\n// &quot;hello   world&quot;\n</code></pre>\n'
  },
  {
    name: "uuid()",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns a UUID (Universally Unique Identifier) with 36 characters.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">uuid(): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">uuid()\n// &quot;7793aab1-d761-4d38-916b-b7270e309894&quot;\n</code></pre>\n'
  },
  {
    name: "to base64(value)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns the given string encoded in Base64 format.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">to base64(value: string): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">to base64(&quot;FEEL&quot;)\n// &quot;RkVFTA==&quot;\n</code></pre>\n'
  },
  {
    name: "is blank(string)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Returns <code>true</code> if the given string is blank (empty or contains only whitespaces).</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">is blank(string: string): boolean\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">is blank(&quot;&quot;)\n// true\n\nis blank(&quot; &quot;)\n// true\n\nis blank(&quot;hello world&quot;)\n// false\n</code></pre>\n'
  },
  {
    name: "now()",
    description: '<p>Returns the current date and time including the timezone.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">now(): date and time\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">now()\n// date and time(&quot;2020-07-31T14:27:30@Europe/Berlin&quot;)\n</code></pre>\n'
  },
  {
    name: "today()",
    description: '<p>Returns the current date.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">today(): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">today()\n// date(&quot;2020-07-31&quot;)\n</code></pre>\n'
  },
  {
    name: "day of week(date)",
    description: '<p>Returns the day of the week according to the Gregorian calendar. Note that it always returns the English name of the day.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">day of week(date: date): string\n</code></pre>\n<pre><code class="language-feel">day of week(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">day of week(date(&quot;2019-09-17&quot;))\n// &quot;Tuesday&quot;\n\nday of week(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;Tuesday&quot;\n</code></pre>\n'
  },
  {
    name: "day of year(date)",
    description: '<p>Returns the Gregorian number of the day within the year.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">day of year(date: date): number\n</code></pre>\n<pre><code class="language-feel">day of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">day of year(date(&quot;2019-09-17&quot;))\n// 260\n\nday of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 260\n</code></pre>\n'
  },
  {
    name: "week of year(date)",
    description: '<p>Returns the Gregorian number of the week within the year, according to ISO 8601.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">week of year(date: date): number\n</code></pre>\n<pre><code class="language-feel">week of year(date: date and time): number\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">week of year(date(&quot;2019-09-17&quot;))\n// 38\n\nweek of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// 38\n</code></pre>\n'
  },
  {
    name: "month of year(date)",
    description: '<p>Returns the month of the year according to the Gregorian calendar. Note that it always returns the English name of the month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">month of year(date: date): string\n</code></pre>\n<pre><code class="language-feel">month of year(date: date and time): string\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">month of year(date(&quot;2019-09-17&quot;))\n// &quot;September&quot;\n\nmonth of year(date and time(&quot;2019-09-17T12:00:00&quot;))\n// &quot;September&quot;\n</code></pre>\n'
  },
  {
    name: "abs(n)",
    description: '<p>Returns the absolute value of a given duration.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">abs(n: days and time duration): days and time duration\n</code></pre>\n<pre><code class="language-feel">abs(n: years and months duration): years and months duration\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">abs(duration(&quot;-PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;PT5H&quot;))\n// &quot;duration(&quot;PT5H&quot;)&quot;\n\nabs(duration(&quot;-P2M&quot;))\n// duration(&quot;P2M&quot;)\n</code></pre>\n'
  },
  {
    name: "last day of month(date)",
    description: '<p><em>Camunda Extension</em></p>\n<p>Takes the month of the given date or date-time value and returns the last day of this month.</p>\n<p><strong>Function signature</strong></p>\n<pre><code class="language-feel">last day of month(date: date): date\n</code></pre>\n<pre><code class="language-feel">last day of month(date: date and time): date\n</code></pre>\n<p><strong>Examples</strong></p>\n<pre><code class="language-feel">last day of month(date(&quot;2022-10-01&quot;))\n// date(&quot;2022-10-31&quot;))\n\nlast day of month(date and time(&quot;2022-10-16T12:00:00&quot;))\n// date(&quot;2022-10-31&quot;))\n</code></pre>\n'
  }
];
function parseBuiltins(builtins) {
  return builtins.map(parseBuiltin);
}
function parseBuiltin(builtin) {
  const {
    name: name2,
    description
  } = builtin;
  const match = name2.match(/^([\w\s]+)\((.*)\)$/);
  const functionName = match[1];
  const functionArguments = match[2];
  const params = functionArguments ? functionArguments.split(", ").map((name3) => ({ name: name3 })) : [];
  return {
    name: functionName,
    type: "function",
    params,
    info: () => {
      return domify$1(`<div class="description">${description}<div>`);
    },
    boost: 0
  };
}
var camunda = parseBuiltins(camundaTags);
var coreConf = new import_state2.Compartment();
var placeholderConf = new import_state2.Compartment();
function FeelEditor({
  extensions: editorExtensions = [],
  dialect = "expression",
  parserDialect,
  container,
  contentAttributes = {},
  tooltipContainer,
  onChange = () => {
  },
  onKeyDown = () => {
  },
  onLint = () => {
  },
  placeholder: placeholder$1 = "",
  readOnly = false,
  value = "",
  builtins = camunda,
  variables = []
}) {
  const changeHandler = import_view3.EditorView.updateListener.of((update) => {
    if (update.docChanged) {
      onChange(update.state.doc.toString());
    }
  });
  const lintHandler = import_view3.EditorView.updateListener.of((update) => {
    const diagnosticEffects = update.transactions.flatMap((t7) => t7.effects).filter((effect) => effect.is(import_lint2.setDiagnosticsEffect));
    if (!diagnosticEffects.length) {
      return;
    }
    const messages = diagnosticEffects.flatMap((effect) => effect.value);
    onLint(messages);
  });
  const keyHandler = import_view3.EditorView.domEventHandlers(
    {
      keydown: onKeyDown
    }
  );
  if (typeof tooltipContainer === "string") {
    tooltipContainer = document.querySelector(tooltipContainer);
  }
  const tooltipLayout = tooltipContainer ? (0, import_view3.tooltips)({
    tooltipSpace: function() {
      return tooltipContainer.getBoundingClientRect();
    }
  }) : [];
  const extensions = [
    (0, import_autocomplete3.autocompletion)(),
    coreConf.of(configure({
      dialect,
      builtins,
      variables,
      parserDialect
    })),
    (0, import_language5.bracketMatching)(),
    (0, import_language5.indentOnInput)(),
    (0, import_autocomplete3.closeBrackets)(),
    import_view3.EditorView.contentAttributes.of(contentAttributes),
    changeHandler,
    keyHandler,
    import_view3.keymap.of([
      ...import_commands2.defaultKeymap
    ]),
    linter2,
    lintHandler,
    tooltipLayout,
    placeholderConf.of((0, import_view3.placeholder)(placeholder$1)),
    theme2,
    ...editorExtensions
  ];
  if (readOnly) {
    extensions.push(import_view3.EditorView.editable.of(false));
  }
  this._cmEditor = new import_view3.EditorView({
    state: import_state2.EditorState.create({
      doc: value,
      extensions
    }),
    parent: container
  });
  return this;
}
FeelEditor.prototype.setValue = function(value) {
  this._cmEditor.dispatch({
    changes: {
      from: 0,
      to: this._cmEditor.state.doc.length,
      insert: value
    }
  });
};
FeelEditor.prototype.focus = function(position) {
  const cmEditor = this._cmEditor;
  cmEditor.contentDOM.focus();
  cmEditor.focus();
  if (typeof position === "number") {
    const end = cmEditor.state.doc.length;
    cmEditor.dispatch({ selection: { anchor: position <= end ? position : end } });
  }
};
FeelEditor.prototype.getSelection = function() {
  return this._cmEditor.state.selection;
};
FeelEditor.prototype.setVariables = function(variables) {
  const config = get3(this._cmEditor.state);
  this._cmEditor.dispatch({
    effects: [
      coreConf.reconfigure(configure({
        ...config,
        variables
      }))
    ]
  });
};
FeelEditor.prototype.setPlaceholder = function(placeholder$1) {
  this._cmEditor.dispatch({
    effects: placeholderConf.reconfigure((0, import_view3.placeholder)(placeholder$1))
  });
};

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var import_view4 = require("@codemirror/view");

// node_modules/tabbable/dist/index.esm.js
var candidateSelectors = ["input:not([inert])", "select:not([inert])", "textarea:not([inert])", "a[href]:not([inert])", "button:not([inert])", "[tabindex]:not(slot):not([inert])", "audio[controls]:not([inert])", "video[controls]:not([inert])", '[contenteditable]:not([contenteditable="false"]):not([inert])', "details>summary:first-of-type:not([inert])", "details:not([inert])"];
var candidateSelector = /* @__PURE__ */ candidateSelectors.join(",");
var NoElement = typeof Element === "undefined";
var matches2 = NoElement ? function() {
} : Element.prototype.matches || Element.prototype.msMatchesSelector || Element.prototype.webkitMatchesSelector;
var getRootNode = !NoElement && Element.prototype.getRootNode ? function(element) {
  var _element$getRootNode;
  return element === null || element === void 0 ? void 0 : (_element$getRootNode = element.getRootNode) === null || _element$getRootNode === void 0 ? void 0 : _element$getRootNode.call(element);
} : function(element) {
  return element === null || element === void 0 ? void 0 : element.ownerDocument;
};
var isInert = function isInert2(node2, lookUp) {
  var _node$getAttribute;
  if (lookUp === void 0) {
    lookUp = true;
  }
  var inertAtt = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute = node2.getAttribute) === null || _node$getAttribute === void 0 ? void 0 : _node$getAttribute.call(node2, "inert");
  var inert = inertAtt === "" || inertAtt === "true";
  var result = inert || lookUp && node2 && isInert2(node2.parentNode);
  return result;
};
var isContentEditable = function isContentEditable2(node2) {
  var _node$getAttribute2;
  var attValue = node2 === null || node2 === void 0 ? void 0 : (_node$getAttribute2 = node2.getAttribute) === null || _node$getAttribute2 === void 0 ? void 0 : _node$getAttribute2.call(node2, "contenteditable");
  return attValue === "" || attValue === "true";
};
var getCandidates = function getCandidates2(el, includeContainer, filter2) {
  if (isInert(el)) {
    return [];
  }
  var candidates = Array.prototype.slice.apply(el.querySelectorAll(candidateSelector));
  if (includeContainer && matches2.call(el, candidateSelector)) {
    candidates.unshift(el);
  }
  candidates = candidates.filter(filter2);
  return candidates;
};
var getCandidatesIteratively = function getCandidatesIteratively2(elements, includeContainer, options) {
  var candidates = [];
  var elementsToCheck = Array.from(elements);
  while (elementsToCheck.length) {
    var element = elementsToCheck.shift();
    if (isInert(element, false)) {
      continue;
    }
    if (element.tagName === "SLOT") {
      var assigned = element.assignedElements();
      var content = assigned.length ? assigned : element.children;
      var nestedCandidates = getCandidatesIteratively2(content, true, options);
      if (options.flatten) {
        candidates.push.apply(candidates, nestedCandidates);
      } else {
        candidates.push({
          scopeParent: element,
          candidates: nestedCandidates
        });
      }
    } else {
      var validCandidate = matches2.call(element, candidateSelector);
      if (validCandidate && options.filter(element) && (includeContainer || !elements.includes(element))) {
        candidates.push(element);
      }
      var shadowRoot = element.shadowRoot || // check for an undisclosed shadow
      typeof options.getShadowRoot === "function" && options.getShadowRoot(element);
      var validShadowRoot = !isInert(shadowRoot, false) && (!options.shadowRootFilter || options.shadowRootFilter(element));
      if (shadowRoot && validShadowRoot) {
        var _nestedCandidates = getCandidatesIteratively2(shadowRoot === true ? element.children : shadowRoot.children, true, options);
        if (options.flatten) {
          candidates.push.apply(candidates, _nestedCandidates);
        } else {
          candidates.push({
            scopeParent: element,
            candidates: _nestedCandidates
          });
        }
      } else {
        elementsToCheck.unshift.apply(elementsToCheck, element.children);
      }
    }
  }
  return candidates;
};
var hasTabIndex = function hasTabIndex2(node2) {
  return !isNaN(parseInt(node2.getAttribute("tabindex"), 10));
};
var getTabIndex = function getTabIndex2(node2) {
  if (!node2) {
    throw new Error("No node provided");
  }
  if (node2.tabIndex < 0) {
    if ((/^(AUDIO|VIDEO|DETAILS)$/.test(node2.tagName) || isContentEditable(node2)) && !hasTabIndex(node2)) {
      return 0;
    }
  }
  return node2.tabIndex;
};
var getSortOrderTabIndex = function getSortOrderTabIndex2(node2, isScope) {
  var tabIndex = getTabIndex(node2);
  if (tabIndex < 0 && isScope && !hasTabIndex(node2)) {
    return 0;
  }
  return tabIndex;
};
var sortOrderedTabbables = function sortOrderedTabbables2(a6, b4) {
  return a6.tabIndex === b4.tabIndex ? a6.documentOrder - b4.documentOrder : a6.tabIndex - b4.tabIndex;
};
var isInput = function isInput2(node2) {
  return node2.tagName === "INPUT";
};
var isHiddenInput = function isHiddenInput2(node2) {
  return isInput(node2) && node2.type === "hidden";
};
var isDetailsWithSummary = function isDetailsWithSummary2(node2) {
  var r7 = node2.tagName === "DETAILS" && Array.prototype.slice.apply(node2.children).some(function(child) {
    return child.tagName === "SUMMARY";
  });
  return r7;
};
var getCheckedRadio = function getCheckedRadio2(nodes, form) {
  for (var i7 = 0; i7 < nodes.length; i7++) {
    if (nodes[i7].checked && nodes[i7].form === form) {
      return nodes[i7];
    }
  }
};
var isTabbableRadio = function isTabbableRadio2(node2) {
  if (!node2.name) {
    return true;
  }
  var radioScope = node2.form || getRootNode(node2);
  var queryRadios = function queryRadios2(name2) {
    return radioScope.querySelectorAll('input[type="radio"][name="' + name2 + '"]');
  };
  var radioSet;
  if (typeof window !== "undefined" && typeof window.CSS !== "undefined" && typeof window.CSS.escape === "function") {
    radioSet = queryRadios(window.CSS.escape(node2.name));
  } else {
    try {
      radioSet = queryRadios(node2.name);
    } catch (err) {
      console.error("Looks like you have a radio button with a name attribute containing invalid CSS selector characters and need the CSS.escape polyfill: %s", err.message);
      return false;
    }
  }
  var checked = getCheckedRadio(radioSet, node2.form);
  return !checked || checked === node2;
};
var isRadio = function isRadio2(node2) {
  return isInput(node2) && node2.type === "radio";
};
var isNonTabbableRadio = function isNonTabbableRadio2(node2) {
  return isRadio(node2) && !isTabbableRadio(node2);
};
var isNodeAttached = function isNodeAttached2(node2) {
  var _nodeRoot;
  var nodeRoot = node2 && getRootNode(node2);
  var nodeRootHost = (_nodeRoot = nodeRoot) === null || _nodeRoot === void 0 ? void 0 : _nodeRoot.host;
  var attached = false;
  if (nodeRoot && nodeRoot !== node2) {
    var _nodeRootHost, _nodeRootHost$ownerDo, _node$ownerDocument;
    attached = !!((_nodeRootHost = nodeRootHost) !== null && _nodeRootHost !== void 0 && (_nodeRootHost$ownerDo = _nodeRootHost.ownerDocument) !== null && _nodeRootHost$ownerDo !== void 0 && _nodeRootHost$ownerDo.contains(nodeRootHost) || node2 !== null && node2 !== void 0 && (_node$ownerDocument = node2.ownerDocument) !== null && _node$ownerDocument !== void 0 && _node$ownerDocument.contains(node2));
    while (!attached && nodeRootHost) {
      var _nodeRoot2, _nodeRootHost2, _nodeRootHost2$ownerD;
      nodeRoot = getRootNode(nodeRootHost);
      nodeRootHost = (_nodeRoot2 = nodeRoot) === null || _nodeRoot2 === void 0 ? void 0 : _nodeRoot2.host;
      attached = !!((_nodeRootHost2 = nodeRootHost) !== null && _nodeRootHost2 !== void 0 && (_nodeRootHost2$ownerD = _nodeRootHost2.ownerDocument) !== null && _nodeRootHost2$ownerD !== void 0 && _nodeRootHost2$ownerD.contains(nodeRootHost));
    }
  }
  return attached;
};
var isZeroArea = function isZeroArea2(node2) {
  var _node$getBoundingClie = node2.getBoundingClientRect(), width = _node$getBoundingClie.width, height = _node$getBoundingClie.height;
  return width === 0 && height === 0;
};
var isHidden4 = function isHidden5(node2, _ref) {
  var displayCheck = _ref.displayCheck, getShadowRoot = _ref.getShadowRoot;
  if (getComputedStyle(node2).visibility === "hidden") {
    return true;
  }
  var isDirectSummary = matches2.call(node2, "details>summary:first-of-type");
  var nodeUnderDetails = isDirectSummary ? node2.parentElement : node2;
  if (matches2.call(nodeUnderDetails, "details:not([open]) *")) {
    return true;
  }
  if (!displayCheck || displayCheck === "full" || displayCheck === "legacy-full") {
    if (typeof getShadowRoot === "function") {
      var originalNode = node2;
      while (node2) {
        var parentElement = node2.parentElement;
        var rootNode = getRootNode(node2);
        if (parentElement && !parentElement.shadowRoot && getShadowRoot(parentElement) === true) {
          return isZeroArea(node2);
        } else if (node2.assignedSlot) {
          node2 = node2.assignedSlot;
        } else if (!parentElement && rootNode !== node2.ownerDocument) {
          node2 = rootNode.host;
        } else {
          node2 = parentElement;
        }
      }
      node2 = originalNode;
    }
    if (isNodeAttached(node2)) {
      return !node2.getClientRects().length;
    }
    if (displayCheck !== "legacy-full") {
      return true;
    }
  } else if (displayCheck === "non-zero-area") {
    return isZeroArea(node2);
  }
  return false;
};
var isDisabledFromFieldset = function isDisabledFromFieldset2(node2) {
  if (/^(INPUT|BUTTON|SELECT|TEXTAREA)$/.test(node2.tagName)) {
    var parentNode = node2.parentElement;
    while (parentNode) {
      if (parentNode.tagName === "FIELDSET" && parentNode.disabled) {
        for (var i7 = 0; i7 < parentNode.children.length; i7++) {
          var child = parentNode.children.item(i7);
          if (child.tagName === "LEGEND") {
            return matches2.call(parentNode, "fieldset[disabled] *") ? true : !child.contains(node2);
          }
        }
        return true;
      }
      parentNode = parentNode.parentElement;
    }
  }
  return false;
};
var isNodeMatchingSelectorFocusable = function isNodeMatchingSelectorFocusable2(options, node2) {
  if (node2.disabled || // we must do an inert look up to filter out any elements inside an inert ancestor
  //  because we're limited in the type of selectors we can use in JSDom (see related
  //  note related to `candidateSelectors`)
  isInert(node2) || isHiddenInput(node2) || isHidden4(node2, options) || // For a details element with a summary, the summary element gets the focus
  isDetailsWithSummary(node2) || isDisabledFromFieldset(node2)) {
    return false;
  }
  return true;
};
var isNodeMatchingSelectorTabbable = function isNodeMatchingSelectorTabbable2(options, node2) {
  if (isNonTabbableRadio(node2) || getTabIndex(node2) < 0 || !isNodeMatchingSelectorFocusable(options, node2)) {
    return false;
  }
  return true;
};
var isValidShadowRootTabbable = function isValidShadowRootTabbable2(shadowHostNode) {
  var tabIndex = parseInt(shadowHostNode.getAttribute("tabindex"), 10);
  if (isNaN(tabIndex) || tabIndex >= 0) {
    return true;
  }
  return false;
};
var sortByOrder = function sortByOrder2(candidates) {
  var regularTabbables = [];
  var orderedTabbables = [];
  candidates.forEach(function(item, i7) {
    var isScope = !!item.scopeParent;
    var element = isScope ? item.scopeParent : item;
    var candidateTabindex = getSortOrderTabIndex(element, isScope);
    var elements = isScope ? sortByOrder2(item.candidates) : element;
    if (candidateTabindex === 0) {
      isScope ? regularTabbables.push.apply(regularTabbables, elements) : regularTabbables.push(element);
    } else {
      orderedTabbables.push({
        documentOrder: i7,
        tabIndex: candidateTabindex,
        item,
        isScope,
        content: elements
      });
    }
  });
  return orderedTabbables.sort(sortOrderedTabbables).reduce(function(acc, sortable) {
    sortable.isScope ? acc.push.apply(acc, sortable.content) : acc.push(sortable.content);
    return acc;
  }, []).concat(regularTabbables);
};
var tabbable = function tabbable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorTabbable.bind(null, options),
      flatten: false,
      getShadowRoot: options.getShadowRoot,
      shadowRootFilter: isValidShadowRootTabbable
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorTabbable.bind(null, options));
  }
  return sortByOrder(candidates);
};
var focusable = function focusable2(container, options) {
  options = options || {};
  var candidates;
  if (options.getShadowRoot) {
    candidates = getCandidatesIteratively([container], options.includeContainer, {
      filter: isNodeMatchingSelectorFocusable.bind(null, options),
      flatten: true,
      getShadowRoot: options.getShadowRoot
    });
  } else {
    candidates = getCandidates(container, options.includeContainer, isNodeMatchingSelectorFocusable.bind(null, options));
  }
  return candidates;
};
var isTabbable = function isTabbable2(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches2.call(node2, candidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorTabbable(options, node2);
};
var focusableCandidateSelector = /* @__PURE__ */ candidateSelectors.concat("iframe").join(",");
var isFocusable = function isFocusable2(node2, options) {
  options = options || {};
  if (!node2) {
    throw new Error("No node provided");
  }
  if (matches2.call(node2, focusableCandidateSelector) === false) {
    return false;
  }
  return isNodeMatchingSelectorFocusable(options, node2);
};

// node_modules/focus-trap/dist/focus-trap.esm.js
function _arrayLikeToArray(r7, a6) {
  (null == a6 || a6 > r7.length) && (a6 = r7.length);
  for (var e8 = 0, n4 = Array(a6); e8 < a6; e8++) n4[e8] = r7[e8];
  return n4;
}
function _arrayWithoutHoles(r7) {
  if (Array.isArray(r7)) return _arrayLikeToArray(r7);
}
function _defineProperty(e8, r7, t7) {
  return (r7 = _toPropertyKey(r7)) in e8 ? Object.defineProperty(e8, r7, {
    value: t7,
    enumerable: true,
    configurable: true,
    writable: true
  }) : e8[r7] = t7, e8;
}
function _iterableToArray(r7) {
  if ("undefined" != typeof Symbol && null != r7[Symbol.iterator] || null != r7["@@iterator"]) return Array.from(r7);
}
function _nonIterableSpread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}
function ownKeys(e8, r7) {
  var t7 = Object.keys(e8);
  if (Object.getOwnPropertySymbols) {
    var o5 = Object.getOwnPropertySymbols(e8);
    r7 && (o5 = o5.filter(function(r8) {
      return Object.getOwnPropertyDescriptor(e8, r8).enumerable;
    })), t7.push.apply(t7, o5);
  }
  return t7;
}
function _objectSpread2(e8) {
  for (var r7 = 1; r7 < arguments.length; r7++) {
    var t7 = null != arguments[r7] ? arguments[r7] : {};
    r7 % 2 ? ownKeys(Object(t7), true).forEach(function(r8) {
      _defineProperty(e8, r8, t7[r8]);
    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(e8, Object.getOwnPropertyDescriptors(t7)) : ownKeys(Object(t7)).forEach(function(r8) {
      Object.defineProperty(e8, r8, Object.getOwnPropertyDescriptor(t7, r8));
    });
  }
  return e8;
}
function _toConsumableArray(r7) {
  return _arrayWithoutHoles(r7) || _iterableToArray(r7) || _unsupportedIterableToArray(r7) || _nonIterableSpread();
}
function _toPrimitive(t7, r7) {
  if ("object" != typeof t7 || !t7) return t7;
  var e8 = t7[Symbol.toPrimitive];
  if (void 0 !== e8) {
    var i7 = e8.call(t7, r7 || "default");
    if ("object" != typeof i7) return i7;
    throw new TypeError("@@toPrimitive must return a primitive value.");
  }
  return ("string" === r7 ? String : Number)(t7);
}
function _toPropertyKey(t7) {
  var i7 = _toPrimitive(t7, "string");
  return "symbol" == typeof i7 ? i7 : i7 + "";
}
function _unsupportedIterableToArray(r7, a6) {
  if (r7) {
    if ("string" == typeof r7) return _arrayLikeToArray(r7, a6);
    var t7 = {}.toString.call(r7).slice(8, -1);
    return "Object" === t7 && r7.constructor && (t7 = r7.constructor.name), "Map" === t7 || "Set" === t7 ? Array.from(r7) : "Arguments" === t7 || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(t7) ? _arrayLikeToArray(r7, a6) : void 0;
  }
}
var activeFocusTraps = {
  activateTrap: function activateTrap(trapStack, trap) {
    if (trapStack.length > 0) {
      var activeTrap = trapStack[trapStack.length - 1];
      if (activeTrap !== trap) {
        activeTrap._setPausedState(true);
      }
    }
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex === -1) {
      trapStack.push(trap);
    } else {
      trapStack.splice(trapIndex, 1);
      trapStack.push(trap);
    }
  },
  deactivateTrap: function deactivateTrap(trapStack, trap) {
    var trapIndex = trapStack.indexOf(trap);
    if (trapIndex !== -1) {
      trapStack.splice(trapIndex, 1);
    }
    if (trapStack.length > 0 && !trapStack[trapStack.length - 1]._isManuallyPaused()) {
      trapStack[trapStack.length - 1]._setPausedState(false);
    }
  }
};
var isSelectableInput = function isSelectableInput2(node2) {
  return node2.tagName && node2.tagName.toLowerCase() === "input" && typeof node2.select === "function";
};
var isEscapeEvent = function isEscapeEvent2(e8) {
  return (e8 === null || e8 === void 0 ? void 0 : e8.key) === "Escape" || (e8 === null || e8 === void 0 ? void 0 : e8.key) === "Esc" || (e8 === null || e8 === void 0 ? void 0 : e8.keyCode) === 27;
};
var isTabEvent = function isTabEvent2(e8) {
  return (e8 === null || e8 === void 0 ? void 0 : e8.key) === "Tab" || (e8 === null || e8 === void 0 ? void 0 : e8.keyCode) === 9;
};
var isKeyForward = function isKeyForward2(e8) {
  return isTabEvent(e8) && !e8.shiftKey;
};
var isKeyBackward = function isKeyBackward2(e8) {
  return isTabEvent(e8) && e8.shiftKey;
};
var delay = function delay2(fn2) {
  return setTimeout(fn2, 0);
};
var valueOrHandler = function valueOrHandler2(value) {
  for (var _len = arguments.length, params = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
    params[_key - 1] = arguments[_key];
  }
  return typeof value === "function" ? value.apply(void 0, params) : value;
};
var getActualTarget = function getActualTarget2(event2) {
  return event2.target.shadowRoot && typeof event2.composedPath === "function" ? event2.composedPath()[0] : event2.target;
};
var internalTrapStack = [];
var createFocusTrap = function createFocusTrap2(elements, userOptions) {
  var doc = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.document) || document;
  var trapStack = (userOptions === null || userOptions === void 0 ? void 0 : userOptions.trapStack) || internalTrapStack;
  var config = _objectSpread2({
    returnFocusOnDeactivate: true,
    escapeDeactivates: true,
    delayInitialFocus: true,
    isKeyForward,
    isKeyBackward
  }, userOptions);
  var state = {
    // containers given to createFocusTrap()
    // @type {Array<HTMLElement>}
    containers: [],
    // list of objects identifying tabbable nodes in `containers` in the trap
    // NOTE: it's possible that a group has no tabbable nodes if nodes get removed while the trap
    //  is active, but the trap should never get to a state where there isn't at least one group
    //  with at least one tabbable node in it (that would lead to an error condition that would
    //  result in an error being thrown)
    // @type {Array<{
    //   container: HTMLElement,
    //   tabbableNodes: Array<HTMLElement>, // empty if none
    //   focusableNodes: Array<HTMLElement>, // empty if none
    //   posTabIndexesFound: boolean,
    //   firstTabbableNode: HTMLElement|undefined,
    //   lastTabbableNode: HTMLElement|undefined,
    //   firstDomTabbableNode: HTMLElement|undefined,
    //   lastDomTabbableNode: HTMLElement|undefined,
    //   nextTabbableNode: (node: HTMLElement, forward: boolean) => HTMLElement|undefined
    // }>}
    containerGroups: [],
    // same order/length as `containers` list
    // references to objects in `containerGroups`, but only those that actually have
    //  tabbable nodes in them
    // NOTE: same order as `containers` and `containerGroups`, but __not necessarily__
    //  the same length
    tabbableGroups: [],
    nodeFocusedBeforeActivation: null,
    mostRecentlyFocusedNode: null,
    active: false,
    paused: false,
    manuallyPaused: false,
    // timer ID for when delayInitialFocus is true and initial focus in this trap
    //  has been delayed during activation
    delayInitialFocusTimer: void 0,
    // the most recent KeyboardEvent for the configured nav key (typically [SHIFT+]TAB), if any
    recentNavEvent: void 0
  };
  var trap;
  var getOption = function getOption2(configOverrideOptions, optionName, configOptionName) {
    return configOverrideOptions && configOverrideOptions[optionName] !== void 0 ? configOverrideOptions[optionName] : config[configOptionName || optionName];
  };
  var findContainerIndex = function findContainerIndex2(element, event2) {
    var composedPath = typeof (event2 === null || event2 === void 0 ? void 0 : event2.composedPath) === "function" ? event2.composedPath() : void 0;
    return state.containerGroups.findIndex(function(_ref) {
      var container = _ref.container, tabbableNodes = _ref.tabbableNodes;
      return container.contains(element) || // fall back to explicit tabbable search which will take into consideration any
      //  web components if the `tabbableOptions.getShadowRoot` option was used for
      //  the trap, enabling shadow DOM support in tabbable (`Node.contains()` doesn't
      //  look inside web components even if open)
      (composedPath === null || composedPath === void 0 ? void 0 : composedPath.includes(container)) || tabbableNodes.find(function(node2) {
        return node2 === element;
      });
    });
  };
  var getNodeForOption = function getNodeForOption2(optionName) {
    var _ref2 = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, _ref2$hasFallback = _ref2.hasFallback, hasFallback = _ref2$hasFallback === void 0 ? false : _ref2$hasFallback, _ref2$params = _ref2.params, params = _ref2$params === void 0 ? [] : _ref2$params;
    var optionValue = config[optionName];
    if (typeof optionValue === "function") {
      optionValue = optionValue.apply(void 0, _toConsumableArray(params));
    }
    if (optionValue === true) {
      optionValue = void 0;
    }
    if (!optionValue) {
      if (optionValue === void 0 || optionValue === false) {
        return optionValue;
      }
      throw new Error("`".concat(optionName, "` was specified but was not a node, or did not return a node"));
    }
    var node2 = optionValue;
    if (typeof optionValue === "string") {
      try {
        node2 = doc.querySelector(optionValue);
      } catch (err) {
        throw new Error("`".concat(optionName, '` appears to be an invalid selector; error="').concat(err.message, '"'));
      }
      if (!node2) {
        if (!hasFallback) {
          throw new Error("`".concat(optionName, "` as selector refers to no known node"));
        }
      }
    }
    return node2;
  };
  var getInitialFocusNode = function getInitialFocusNode2() {
    var node2 = getNodeForOption("initialFocus", {
      hasFallback: true
    });
    if (node2 === false) {
      return false;
    }
    if (node2 === void 0 || node2 && !isFocusable(node2, config.tabbableOptions)) {
      if (findContainerIndex(doc.activeElement) >= 0) {
        node2 = doc.activeElement;
      } else {
        var firstTabbableGroup = state.tabbableGroups[0];
        var firstTabbableNode = firstTabbableGroup && firstTabbableGroup.firstTabbableNode;
        node2 = firstTabbableNode || getNodeForOption("fallbackFocus");
      }
    } else if (node2 === null) {
      node2 = getNodeForOption("fallbackFocus");
    }
    if (!node2) {
      throw new Error("Your focus-trap needs to have at least one focusable element");
    }
    return node2;
  };
  var updateTabbableNodes = function updateTabbableNodes2() {
    state.containerGroups = state.containers.map(function(container) {
      var tabbableNodes = tabbable(container, config.tabbableOptions);
      var focusableNodes = focusable(container, config.tabbableOptions);
      var firstTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[0] : void 0;
      var lastTabbableNode = tabbableNodes.length > 0 ? tabbableNodes[tabbableNodes.length - 1] : void 0;
      var firstDomTabbableNode = focusableNodes.find(function(node2) {
        return isTabbable(node2);
      });
      var lastDomTabbableNode = focusableNodes.slice().reverse().find(function(node2) {
        return isTabbable(node2);
      });
      var posTabIndexesFound = !!tabbableNodes.find(function(node2) {
        return getTabIndex(node2) > 0;
      });
      return {
        container,
        tabbableNodes,
        focusableNodes,
        /** True if at least one node with positive `tabindex` was found in this container. */
        posTabIndexesFound,
        /** First tabbable node in container, __tabindex__ order; `undefined` if none. */
        firstTabbableNode,
        /** Last tabbable node in container, __tabindex__ order; `undefined` if none. */
        lastTabbableNode,
        // NOTE: DOM order is NOT NECESSARILY "document position" order, but figuring that out
        //  would require more than just https://developer.mozilla.org/en-US/docs/Web/API/Node/compareDocumentPosition
        //  because that API doesn't work with Shadow DOM as well as it should (@see
        //  https://github.com/whatwg/dom/issues/320) and since this first/last is only needed, so far,
        //  to address an edge case related to positive tabindex support, this seems like a much easier,
        //  "close enough most of the time" alternative for positive tabindexes which should generally
        //  be avoided anyway...
        /** First tabbable node in container, __DOM__ order; `undefined` if none. */
        firstDomTabbableNode,
        /** Last tabbable node in container, __DOM__ order; `undefined` if none. */
        lastDomTabbableNode,
        /**
         * Finds the __tabbable__ node that follows the given node in the specified direction,
         *  in this container, if any.
         * @param {HTMLElement} node
         * @param {boolean} [forward] True if going in forward tab order; false if going
         *  in reverse.
         * @returns {HTMLElement|undefined} The next tabbable node, if any.
         */
        nextTabbableNode: function nextTabbableNode(node2) {
          var forward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : true;
          var nodeIdx = tabbableNodes.indexOf(node2);
          if (nodeIdx < 0) {
            if (forward) {
              return focusableNodes.slice(focusableNodes.indexOf(node2) + 1).find(function(el) {
                return isTabbable(el);
              });
            }
            return focusableNodes.slice(0, focusableNodes.indexOf(node2)).reverse().find(function(el) {
              return isTabbable(el);
            });
          }
          return tabbableNodes[nodeIdx + (forward ? 1 : -1)];
        }
      };
    });
    state.tabbableGroups = state.containerGroups.filter(function(group) {
      return group.tabbableNodes.length > 0;
    });
    if (state.tabbableGroups.length <= 0 && !getNodeForOption("fallbackFocus")) {
      throw new Error("Your focus-trap must have at least one container with at least one tabbable node in it at all times");
    }
    if (state.containerGroups.find(function(g6) {
      return g6.posTabIndexesFound;
    }) && state.containerGroups.length > 1) {
      throw new Error("At least one node with a positive tabindex was found in one of your focus-trap's multiple containers. Positive tabindexes are only supported in single-container focus-traps.");
    }
  };
  var _getActiveElement = function getActiveElement(el) {
    var activeElement = el.activeElement;
    if (!activeElement) {
      return;
    }
    if (activeElement.shadowRoot && activeElement.shadowRoot.activeElement !== null) {
      return _getActiveElement(activeElement.shadowRoot);
    }
    return activeElement;
  };
  var _tryFocus = function tryFocus(node2) {
    if (node2 === false) {
      return;
    }
    if (node2 === _getActiveElement(document)) {
      return;
    }
    if (!node2 || !node2.focus) {
      _tryFocus(getInitialFocusNode());
      return;
    }
    node2.focus({
      preventScroll: !!config.preventScroll
    });
    state.mostRecentlyFocusedNode = node2;
    if (isSelectableInput(node2)) {
      node2.select();
    }
  };
  var getReturnFocusNode = function getReturnFocusNode2(previousActiveElement) {
    var node2 = getNodeForOption("setReturnFocus", {
      params: [previousActiveElement]
    });
    return node2 ? node2 : node2 === false ? false : previousActiveElement;
  };
  var findNextNavNode = function findNextNavNode2(_ref3) {
    var target = _ref3.target, event2 = _ref3.event, _ref3$isBackward = _ref3.isBackward, isBackward = _ref3$isBackward === void 0 ? false : _ref3$isBackward;
    target = target || getActualTarget(event2);
    updateTabbableNodes();
    var destinationNode = null;
    if (state.tabbableGroups.length > 0) {
      var containerIndex = findContainerIndex(target, event2);
      var containerGroup = containerIndex >= 0 ? state.containerGroups[containerIndex] : void 0;
      if (containerIndex < 0) {
        if (isBackward) {
          destinationNode = state.tabbableGroups[state.tabbableGroups.length - 1].lastTabbableNode;
        } else {
          destinationNode = state.tabbableGroups[0].firstTabbableNode;
        }
      } else if (isBackward) {
        var startOfGroupIndex = state.tabbableGroups.findIndex(function(_ref4) {
          var firstTabbableNode = _ref4.firstTabbableNode;
          return target === firstTabbableNode;
        });
        if (startOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target, false))) {
          startOfGroupIndex = containerIndex;
        }
        if (startOfGroupIndex >= 0) {
          var destinationGroupIndex = startOfGroupIndex === 0 ? state.tabbableGroups.length - 1 : startOfGroupIndex - 1;
          var destinationGroup = state.tabbableGroups[destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? destinationGroup.lastTabbableNode : destinationGroup.lastDomTabbableNode;
        } else if (!isTabEvent(event2)) {
          destinationNode = containerGroup.nextTabbableNode(target, false);
        }
      } else {
        var lastOfGroupIndex = state.tabbableGroups.findIndex(function(_ref5) {
          var lastTabbableNode = _ref5.lastTabbableNode;
          return target === lastTabbableNode;
        });
        if (lastOfGroupIndex < 0 && (containerGroup.container === target || isFocusable(target, config.tabbableOptions) && !isTabbable(target, config.tabbableOptions) && !containerGroup.nextTabbableNode(target))) {
          lastOfGroupIndex = containerIndex;
        }
        if (lastOfGroupIndex >= 0) {
          var _destinationGroupIndex = lastOfGroupIndex === state.tabbableGroups.length - 1 ? 0 : lastOfGroupIndex + 1;
          var _destinationGroup = state.tabbableGroups[_destinationGroupIndex];
          destinationNode = getTabIndex(target) >= 0 ? _destinationGroup.firstTabbableNode : _destinationGroup.firstDomTabbableNode;
        } else if (!isTabEvent(event2)) {
          destinationNode = containerGroup.nextTabbableNode(target);
        }
      }
    } else {
      destinationNode = getNodeForOption("fallbackFocus");
    }
    return destinationNode;
  };
  var checkPointerDown = function checkPointerDown2(e8) {
    var target = getActualTarget(e8);
    if (findContainerIndex(target, e8) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e8)) {
      trap.deactivate({
        // NOTE: by setting `returnFocus: false`, deactivate() will do nothing,
        //  which will result in the outside click setting focus to the node
        //  that was clicked (and if not focusable, to "nothing"); by setting
        //  `returnFocus: true`, we'll attempt to re-focus the node originally-focused
        //  on activation (or the configured `setReturnFocus` node), whether the
        //  outside click was on a focusable node or not
        returnFocus: config.returnFocusOnDeactivate
      });
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e8)) {
      return;
    }
    e8.preventDefault();
  };
  var checkFocusIn = function checkFocusIn2(event2) {
    var target = getActualTarget(event2);
    var targetContained = findContainerIndex(target, event2) >= 0;
    if (targetContained || target instanceof Document) {
      if (targetContained) {
        state.mostRecentlyFocusedNode = target;
      }
    } else {
      event2.stopImmediatePropagation();
      var nextNode;
      var navAcrossContainers = true;
      if (state.mostRecentlyFocusedNode) {
        if (getTabIndex(state.mostRecentlyFocusedNode) > 0) {
          var mruContainerIdx = findContainerIndex(state.mostRecentlyFocusedNode);
          var tabbableNodes = state.containerGroups[mruContainerIdx].tabbableNodes;
          if (tabbableNodes.length > 0) {
            var mruTabIdx = tabbableNodes.findIndex(function(node2) {
              return node2 === state.mostRecentlyFocusedNode;
            });
            if (mruTabIdx >= 0) {
              if (config.isKeyForward(state.recentNavEvent)) {
                if (mruTabIdx + 1 < tabbableNodes.length) {
                  nextNode = tabbableNodes[mruTabIdx + 1];
                  navAcrossContainers = false;
                }
              } else {
                if (mruTabIdx - 1 >= 0) {
                  nextNode = tabbableNodes[mruTabIdx - 1];
                  navAcrossContainers = false;
                }
              }
            }
          }
        } else {
          if (!state.containerGroups.some(function(g6) {
            return g6.tabbableNodes.some(function(n4) {
              return getTabIndex(n4) > 0;
            });
          })) {
            navAcrossContainers = false;
          }
        }
      } else {
        navAcrossContainers = false;
      }
      if (navAcrossContainers) {
        nextNode = findNextNavNode({
          // move FROM the MRU node, not event-related node (which will be the node that is
          //  outside the trap causing the focus escape we're trying to fix)
          target: state.mostRecentlyFocusedNode,
          isBackward: config.isKeyBackward(state.recentNavEvent)
        });
      }
      if (nextNode) {
        _tryFocus(nextNode);
      } else {
        _tryFocus(state.mostRecentlyFocusedNode || getInitialFocusNode());
      }
    }
    state.recentNavEvent = void 0;
  };
  var checkKeyNav = function checkKeyNav2(event2) {
    var isBackward = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;
    state.recentNavEvent = event2;
    var destinationNode = findNextNavNode({
      event: event2,
      isBackward
    });
    if (destinationNode) {
      if (isTabEvent(event2)) {
        event2.preventDefault();
      }
      _tryFocus(destinationNode);
    }
  };
  var checkTabKey = function checkTabKey2(event2) {
    if (config.isKeyForward(event2) || config.isKeyBackward(event2)) {
      checkKeyNav(event2, config.isKeyBackward(event2));
    }
  };
  var checkEscapeKey = function checkEscapeKey2(event2) {
    if (isEscapeEvent(event2) && valueOrHandler(config.escapeDeactivates, event2) !== false) {
      event2.preventDefault();
      trap.deactivate();
    }
  };
  var checkClick = function checkClick2(e8) {
    var target = getActualTarget(e8);
    if (findContainerIndex(target, e8) >= 0) {
      return;
    }
    if (valueOrHandler(config.clickOutsideDeactivates, e8)) {
      return;
    }
    if (valueOrHandler(config.allowOutsideClick, e8)) {
      return;
    }
    e8.preventDefault();
    e8.stopImmediatePropagation();
  };
  var addListeners = function addListeners2() {
    if (!state.active) {
      return;
    }
    activeFocusTraps.activateTrap(trapStack, trap);
    state.delayInitialFocusTimer = config.delayInitialFocus ? delay(function() {
      _tryFocus(getInitialFocusNode());
    }) : _tryFocus(getInitialFocusNode());
    doc.addEventListener("focusin", checkFocusIn, true);
    doc.addEventListener("mousedown", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("touchstart", checkPointerDown, {
      capture: true,
      passive: false
    });
    doc.addEventListener("click", checkClick, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkTabKey, {
      capture: true,
      passive: false
    });
    doc.addEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var removeListeners = function removeListeners2() {
    if (!state.active) {
      return;
    }
    doc.removeEventListener("focusin", checkFocusIn, true);
    doc.removeEventListener("mousedown", checkPointerDown, true);
    doc.removeEventListener("touchstart", checkPointerDown, true);
    doc.removeEventListener("click", checkClick, true);
    doc.removeEventListener("keydown", checkTabKey, true);
    doc.removeEventListener("keydown", checkEscapeKey);
    return trap;
  };
  var checkDomRemoval = function checkDomRemoval2(mutations) {
    var isFocusedNodeRemoved = mutations.some(function(mutation) {
      var removedNodes = Array.from(mutation.removedNodes);
      return removedNodes.some(function(node2) {
        return node2 === state.mostRecentlyFocusedNode;
      });
    });
    if (isFocusedNodeRemoved) {
      _tryFocus(getInitialFocusNode());
    }
  };
  var mutationObserver = typeof window !== "undefined" && "MutationObserver" in window ? new MutationObserver(checkDomRemoval) : void 0;
  var updateObservedNodes = function updateObservedNodes2() {
    if (!mutationObserver) {
      return;
    }
    mutationObserver.disconnect();
    if (state.active && !state.paused) {
      state.containers.map(function(container) {
        mutationObserver.observe(container, {
          subtree: true,
          childList: true
        });
      });
    }
  };
  trap = {
    get active() {
      return state.active;
    },
    get paused() {
      return state.paused;
    },
    activate: function activate(activateOptions) {
      if (state.active) {
        return this;
      }
      var onActivate = getOption(activateOptions, "onActivate");
      var onPostActivate = getOption(activateOptions, "onPostActivate");
      var checkCanFocusTrap = getOption(activateOptions, "checkCanFocusTrap");
      if (!checkCanFocusTrap) {
        updateTabbableNodes();
      }
      state.active = true;
      state.paused = false;
      state.nodeFocusedBeforeActivation = doc.activeElement;
      onActivate === null || onActivate === void 0 || onActivate();
      var finishActivation = function finishActivation2() {
        if (checkCanFocusTrap) {
          updateTabbableNodes();
        }
        addListeners();
        updateObservedNodes();
        onPostActivate === null || onPostActivate === void 0 || onPostActivate();
      };
      if (checkCanFocusTrap) {
        checkCanFocusTrap(state.containers.concat()).then(finishActivation, finishActivation);
        return this;
      }
      finishActivation();
      return this;
    },
    deactivate: function deactivate(deactivateOptions) {
      if (!state.active) {
        return this;
      }
      var options = _objectSpread2({
        onDeactivate: config.onDeactivate,
        onPostDeactivate: config.onPostDeactivate,
        checkCanReturnFocus: config.checkCanReturnFocus
      }, deactivateOptions);
      clearTimeout(state.delayInitialFocusTimer);
      state.delayInitialFocusTimer = void 0;
      removeListeners();
      state.active = false;
      state.paused = false;
      updateObservedNodes();
      activeFocusTraps.deactivateTrap(trapStack, trap);
      var onDeactivate = getOption(options, "onDeactivate");
      var onPostDeactivate = getOption(options, "onPostDeactivate");
      var checkCanReturnFocus = getOption(options, "checkCanReturnFocus");
      var returnFocus = getOption(options, "returnFocus", "returnFocusOnDeactivate");
      onDeactivate === null || onDeactivate === void 0 || onDeactivate();
      var finishDeactivation = function finishDeactivation2() {
        delay(function() {
          if (returnFocus) {
            _tryFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation));
          }
          onPostDeactivate === null || onPostDeactivate === void 0 || onPostDeactivate();
        });
      };
      if (returnFocus && checkCanReturnFocus) {
        checkCanReturnFocus(getReturnFocusNode(state.nodeFocusedBeforeActivation)).then(finishDeactivation, finishDeactivation);
        return this;
      }
      finishDeactivation();
      return this;
    },
    pause: function pause(pauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = true;
      return this._setPausedState(true, pauseOptions);
    },
    unpause: function unpause(unpauseOptions) {
      if (!state.active) {
        return this;
      }
      state.manuallyPaused = false;
      if (trapStack[trapStack.length - 1] !== this) {
        return this;
      }
      return this._setPausedState(false, unpauseOptions);
    },
    updateContainerElements: function updateContainerElements(containerElements) {
      var elementsAsArray = [].concat(containerElements).filter(Boolean);
      state.containers = elementsAsArray.map(function(element) {
        return typeof element === "string" ? doc.querySelector(element) : element;
      });
      if (state.active) {
        updateTabbableNodes();
      }
      updateObservedNodes();
      return this;
    }
  };
  Object.defineProperties(trap, {
    _isManuallyPaused: {
      value: function value() {
        return state.manuallyPaused;
      }
    },
    _setPausedState: {
      value: function value(paused, options) {
        if (state.paused === paused) {
          return this;
        }
        state.paused = paused;
        if (paused) {
          var onPause = getOption(options, "onPause");
          var onPostPause = getOption(options, "onPostPause");
          onPause === null || onPause === void 0 || onPause();
          removeListeners();
          updateObservedNodes();
          onPostPause === null || onPostPause === void 0 || onPostPause();
        } else {
          var onUnpause = getOption(options, "onUnpause");
          var onPostUnpause = getOption(options, "onPostUnpause");
          onUnpause === null || onUnpause === void 0 || onUnpause();
          updateTabbableNodes();
          addListeners();
          updateObservedNodes();
          onPostUnpause === null || onPostUnpause === void 0 || onPostUnpause();
        }
        return this;
      }
    }
  });
  trap.updateContainerElements(elements);
  return trap;
};

// node_modules/@bpmn-io/properties-panel/dist/index.esm.js
var ArrowIcon = function ArrowIcon2(props) {
  return u5("svg", {
    ...props,
    children: u5("path", {
      fillRule: "evenodd",
      d: "m11.657 8-4.95 4.95a1 1 0 0 1-1.414-1.414L8.828 8 5.293 4.464A1 1 0 1 1 6.707 3.05L11.657 8Z"
    })
  });
};
ArrowIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var CloseIcon = function CloseIcon2(props) {
  return u5("svg", {
    ...props,
    children: u5("path", {
      fillRule: "evenodd",
      d: "m12 4.7-.7-.7L8 7.3 4.7 4l-.7.7L7.3 8 4 11.3l.7.7L8 8.7l3.3 3.3.7-.7L8.7 8 12 4.7Z",
      fill: "currentColor"
    })
  });
};
CloseIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var CreateIcon = function CreateIcon2(props) {
  return u5("svg", {
    ...props,
    children: u5("path", {
      fillRule: "evenodd",
      d: "M9 13V9h4a1 1 0 0 0 0-2H9V3a1 1 0 1 0-2 0v4H3a1 1 0 1 0 0 2h4v4a1 1 0 0 0 2 0Z"
    })
  });
};
CreateIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var DeleteIcon = function DeleteIcon2(props) {
  return u5("svg", {
    ...props,
    children: u5("path", {
      fillRule: "evenodd",
      d: "M12 6v7c0 1.1-.4 1.55-1.5 1.55h-5C4.4 14.55 4 14.1 4 13V6h8Zm-1.5 1.5h-5v4.3c0 .66.5 1.2 1.111 1.2H9.39c.611 0 1.111-.54 1.111-1.2V7.5ZM13 3h-2l-1-1H6L5 3H3v1.5h10V3Z"
    })
  });
};
DeleteIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16"
};
var DragIcon = function DragIcon2(props) {
  return u5("svg", {
    ...props,
    children: [u5("path", {
      fill: "#fff",
      style: {
        mixBlendMode: "multiply"
      },
      d: "M0 0h16v16H0z"
    }), u5("path", {
      fill: "#fff",
      style: {
        mixBlendMode: "multiply"
      },
      d: "M0 0h16v16H0z"
    }), u5("path", {
      d: "M7 3H5v2h2V3zm4 0H9v2h2V3zM7 7H5v2h2V7zm4 0H9v2h2V7zm-4 4H5v2h2v-2zm4 0H9v2h2v-2z",
      fill: "#161616"
    })]
  });
};
DragIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var ExternalLinkIcon = function ExternalLinkIcon2(props) {
  return u5("svg", {
    ...props,
    children: u5("path", {
      fillRule: "evenodd",
      clipRule: "evenodd",
      d: "M12.637 12.637v-4.72h1.362v4.721c0 .36-.137.676-.411.95-.275.275-.591.412-.95.412H3.362c-.38 0-.703-.132-.967-.396A1.315 1.315 0 0 1 2 12.638V3.362c0-.38.132-.703.396-.967S2.982 2 3.363 2h4.553v1.363H3.363v9.274h9.274ZM14 2H9.28l-.001 1.362h2.408L5.065 9.984l.95.95 6.622-6.622v2.409H14V2Z",
      fill: "currentcolor"
    })
  });
};
ExternalLinkIcon.defaultProps = {
  width: "16",
  height: "16",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var FeelIcon$1 = function FeelIcon(props) {
  return u5("svg", {
    ...props,
    children: u5("path", {
      d: "M3.617 11.99c-.137.684-.392 1.19-.765 1.518-.362.328-.882.492-1.558.492H0l.309-1.579h1.264l1.515-7.64h-.912l.309-1.579h.911l.236-1.191c.137-.685.387-1.192.75-1.52C4.753.164 5.277 0 5.953 0h1.294L6.94 1.579H5.675l-.323 1.623h1.264l-.309 1.579H5.043l-1.426 7.208ZM5.605 11.021l3.029-4.155L7.28 3.202h2.073l.706 2.547h.176l1.691-2.547H14l-3.014 4.051 1.338 3.768H10.25l-.706-2.606H9.37L7.678 11.02H5.605Z",
      fill: "currentcolor"
    })
  });
};
FeelIcon$1.defaultProps = {
  width: "14",
  height: "14",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
};
var LaunchIcon = function LaunchIcon2(props) {
  return u5("svg", {
    ...props,
    children: [u5("path", {
      d: "M26 28H6a2.003 2.003 0 0 1-2-2V6a2.003 2.003 0 0 1 2-2h10v2H6v20h20V16h2v10a2.003 2.003 0 0 1-2 2Z"
    }), u5("path", {
      d: "M20 2v2h6.586L18 12.586 19.414 14 28 5.414V12h2V2H20z"
    })]
  });
};
LaunchIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  viewBox: "0 0 32 32"
};
var PopupIcon = function PopupIcon2(props) {
  return u5("svg", {
    ...props,
    children: [u5("path", {
      fill: "currentColor",
      d: "M28 4H10a2.006 2.006 0 0 0-2 2v14a2.006 2.006 0 0 0 2 2h18a2.006 2.006 0 0 0 2-2V6a2.006 2.006 0 0 0-2-2Zm0 16H10V6h18Z"
    }), u5("path", {
      fill: "currentColor",
      d: "M18 26H4V16h2v-2H4a2.006 2.006 0 0 0-2 2v10a2.006 2.006 0 0 0 2 2h14a2.006 2.006 0 0 0 2-2v-2h-2Z"
    })]
  });
};
PopupIcon.defaultProps = {
  xmlns: "http://www.w3.org/2000/svg",
  width: "16",
  height: "16",
  viewBox: "0 0 32 32"
};
function Header(props) {
  const {
    element,
    headerProvider
  } = props;
  const {
    getElementIcon,
    getDocumentationRef,
    getElementLabel,
    getTypeLabel
  } = headerProvider;
  const label = getElementLabel(element);
  const type = getTypeLabel(element);
  const documentationRef = getDocumentationRef && getDocumentationRef(element);
  const ElementIcon = getElementIcon(element);
  return u5("div", {
    class: "bio-properties-panel-header",
    children: [u5("div", {
      class: "bio-properties-panel-header-icon",
      children: ElementIcon && u5(ElementIcon, {
        width: "32",
        height: "32",
        viewBox: "0 0 32 32"
      })
    }), u5("div", {
      class: "bio-properties-panel-header-labels",
      children: [u5("div", {
        title: type,
        class: "bio-properties-panel-header-type",
        children: type
      }), label ? u5("div", {
        title: label,
        class: "bio-properties-panel-header-label",
        children: label
      }) : null]
    }), u5("div", {
      class: "bio-properties-panel-header-actions",
      children: documentationRef ? u5("a", {
        rel: "noreferrer",
        class: "bio-properties-panel-header-link",
        href: documentationRef,
        title: "Open documentation",
        target: "_blank",
        children: u5(ExternalLinkIcon, {})
      }) : null
    })]
  });
}
var DescriptionContext = F3({
  description: {},
  getDescriptionForId: () => {
  }
});
var ErrorsContext = F3({
  errors: {}
});
var EventContext = F3({
  eventBus: null
});
var LayoutContext = F3({
  layout: {},
  setLayout: () => {
  },
  getLayoutForKey: () => {
  },
  setLayoutForKey: () => {
  }
});
var TooltipContext = F3({
  tooltip: {},
  getTooltipForId: () => {
  }
});
function useTooltipContext(id, element) {
  const {
    getTooltipForId
  } = q4(TooltipContext);
  return getTooltipForId(id, element);
}
function TooltipWrapper(props) {
  const {
    forId,
    element
  } = props;
  const contextDescription = useTooltipContext(forId, element);
  const value = props.value || contextDescription;
  if (!value) {
    return props.children;
  }
  return u5(Tooltip, {
    ...props,
    value,
    forId: `bio-properties-panel-${forId}`
  });
}
function Tooltip(props) {
  const {
    forId,
    value,
    parent,
    direction = "right",
    position
  } = props;
  const [visible, setVisible3] = h4(false);
  const SHOW_DELAY = 200;
  let timeout = null;
  const wrapperRef = _4(null);
  const tooltipRef = _4(null);
  const show = (_5, delay3) => {
    if (visible) return;
    if (delay3) {
      timeout = setTimeout(() => {
        setVisible3(true);
      }, SHOW_DELAY);
    } else {
      setVisible3(true);
    }
  };
  const hide = () => {
    clearTimeout(timeout);
    setVisible3(false);
  };
  const handleMouseLeave = ({
    relatedTarget
  }) => {
    if (relatedTarget === wrapperRef.current || relatedTarget === tooltipRef.current || (relatedTarget == null ? void 0 : relatedTarget.parentElement) === tooltipRef.current) {
      return;
    }
    hide();
  };
  const handleFocusOut = (e8) => {
    var _a;
    const {
      target
    } = e8;
    const isHovered = target.matches(":hover") || ((_a = tooltipRef.current) == null ? void 0 : _a.matches(":hover"));
    if (target === wrapperRef.current && isHovered) {
      e8.stopPropagation();
      return;
    }
    hide();
  };
  const hideTooltipViaEscape = (e8) => {
    e8.code === "Escape" && hide();
  };
  const renderTooltip = () => {
    return u5("div", {
      class: `bio-properties-panel-tooltip ${direction}`,
      role: "tooltip",
      id: "bio-properties-panel-tooltip",
      "aria-labelledby": forId,
      style: position || getTooltipPosition(wrapperRef.current),
      ref: tooltipRef,
      onClick: (e8) => e8.stopPropagation(),
      onMouseLeave: handleMouseLeave,
      children: [u5("div", {
        class: "bio-properties-panel-tooltip-content",
        children: value
      }), u5("div", {
        class: "bio-properties-panel-tooltip-arrow"
      })]
    });
  };
  return u5("div", {
    class: "bio-properties-panel-tooltip-wrapper",
    tabIndex: "0",
    ref: wrapperRef,
    onMouseEnter: (e8) => show(e8, true),
    onMouseLeave: handleMouseLeave,
    onFocus: show,
    onBlur: handleFocusOut,
    onKeyDown: hideTooltipViaEscape,
    children: [props.children, visible ? parent ? j5(renderTooltip(), parent.current) : renderTooltip() : null]
  });
}
function getTooltipPosition(refElement) {
  const refPosition = refElement.getBoundingClientRect();
  const right = `calc(100% - ${refPosition.x}px)`;
  const top = `${refPosition.top - 10}px`;
  return `right: ${right}; top: ${top};`;
}
function useDescriptionContext(id, element) {
  const {
    getDescriptionForId
  } = q4(DescriptionContext);
  return getDescriptionForId(id, element);
}
function useError(id) {
  const {
    errors
  } = q4(ErrorsContext);
  return errors[id];
}
function useErrors() {
  const {
    errors
  } = q4(ErrorsContext);
  return errors;
}
function useEvent(event2, callback, eventBus) {
  const eventContext = q4(EventContext);
  if (!eventBus) {
    ({
      eventBus
    } = eventContext);
  }
  const didMount = _4(false);
  if (eventBus && !didMount.current) {
    eventBus.on(event2, callback);
  }
  p4(() => {
    if (eventBus && didMount.current) {
      eventBus.on(event2, callback);
    }
    didMount.current = true;
    return () => {
      if (eventBus) {
        eventBus.off(event2, callback);
      }
    };
  }, [callback, event2, eventBus]);
}
var KEY_LENGTH = 6;
function useKeyFactory(dependencies = []) {
  const map4 = F4(() => /* @__PURE__ */ new Map(), dependencies);
  const getKey = (el) => {
    let key = map4.get(el);
    if (!key) {
      key = Math.random().toString().slice(-KEY_LENGTH);
      map4.set(el, key);
    }
    return key;
  };
  return getKey;
}
function useLayoutState(path, defaultValue) {
  const {
    getLayoutForKey,
    setLayoutForKey
  } = q4(LayoutContext);
  const layoutForKey = getLayoutForKey(path, defaultValue);
  const setState = T4((newValue) => {
    setLayoutForKey(path, newValue);
  }, [setLayoutForKey]);
  return [layoutForKey, setState];
}
function usePrevious(value) {
  const ref = _4();
  p4(() => {
    ref.current = value;
  });
  return ref.current;
}
function useShowEntryEvent(id) {
  const {
    onShow
  } = q4(LayoutContext);
  const ref = _4();
  const focus = _4(false);
  const onShowEntry = T4((event2) => {
    if (event2.id === id) {
      onShow();
      if (!focus.current) {
        focus.current = true;
      }
    }
  }, [id]);
  p4(() => {
    if (focus.current && ref.current) {
      if (isFunction(ref.current.focus)) {
        ref.current.focus();
      }
      if (isFunction(ref.current.select)) {
        ref.current.select();
      }
      focus.current = false;
    }
  });
  useEvent("propertiesPanel.showEntry", onShowEntry);
  return ref;
}
function useStickyIntersectionObserver(ref, scrollContainerSelector, setSticky) {
  const [scrollContainer, setScrollContainer] = h4(query(scrollContainerSelector));
  const updateScrollContainer = T4(() => {
    const newScrollContainer = query(scrollContainerSelector);
    if (newScrollContainer !== scrollContainer) {
      setScrollContainer(newScrollContainer);
    }
  }, [scrollContainerSelector, scrollContainer]);
  p4(() => {
    updateScrollContainer();
  }, [updateScrollContainer]);
  useEvent("propertiesPanel.attach", updateScrollContainer);
  useEvent("propertiesPanel.detach", updateScrollContainer);
  p4(() => {
    const Observer = IntersectionObserver;
    if (!Observer) {
      return;
    }
    if (!ref.current || !scrollContainer) {
      return;
    }
    const observer = new Observer((entries) => {
      if (scrollContainer.scrollHeight === 0) {
        return;
      }
      entries.forEach((entry) => {
        if (entry.intersectionRatio < 1) {
          setSticky(true);
        } else if (entry.intersectionRatio === 1) {
          setSticky(false);
        }
      });
    }, {
      root: scrollContainer,
      rootMargin: "0px 0px 999999% 0px",
      // Use bottom margin to avoid stickyness when scrolling out to bottom
      threshold: [1]
    });
    observer.observe(ref.current);
    return () => {
      observer.unobserve(ref.current);
    };
  }, [ref.current, scrollContainer, setSticky]);
}
function useStaticCallback(callback) {
  const callbackRef = _4(callback);
  callbackRef.current = callback;
  return T4((...args) => callbackRef.current(...args), []);
}
function useElementVisible(element) {
  const [visible, setVisible3] = h4(!!element && !!element.clientHeight);
  y4(() => {
    if (!element) return;
    const resizeObserver = new ResizeObserver(([entry]) => {
      requestAnimationFrame(() => {
        const newVisible = !!entry.contentRect.height;
        if (newVisible !== visible) {
          setVisible3(newVisible);
        }
      });
    });
    resizeObserver.observe(element);
    return () => resizeObserver.disconnect();
  }, [element, visible]);
  return visible;
}
function Group(props) {
  const {
    element,
    entries = [],
    id,
    label,
    shouldOpen = false
  } = props;
  const groupRef = _4(null);
  const [open3, setOpen] = useLayoutState(["groups", id, "open"], shouldOpen);
  const onShow = T4(() => setOpen(true), [setOpen]);
  const toggleOpen = () => setOpen(!open3);
  const [edited, setEdited] = h4(false);
  const [sticky, setSticky] = h4(false);
  p4(() => {
    const scheduled = requestAnimationFrame(() => {
      const hasOneEditedEntry = entries.find((entry) => {
        const {
          id: id2,
          isEdited: isEdited2
        } = entry;
        const entryNode = query(`[data-entry-id="${id2}"]`);
        if (!isFunction(isEdited2) || !entryNode) {
          return false;
        }
        const inputNode = query(".bio-properties-panel-input", entryNode);
        return isEdited2(inputNode);
      });
      setEdited(hasOneEditedEntry);
    });
    return () => cancelAnimationFrame(scheduled);
  }, [entries, setEdited]);
  const allErrors = useErrors();
  const hasErrors = entries.some((entry) => allErrors[entry.id]);
  useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
  const propertiesPanelContext = {
    ...q4(LayoutContext),
    onShow
  };
  return u5("div", {
    class: "bio-properties-panel-group",
    "data-group-id": "group-" + id,
    ref: groupRef,
    children: [u5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-header", edited ? "" : "empty", open3 ? "open" : "", sticky && open3 ? "sticky" : ""),
      onClick: toggleOpen,
      children: [u5("div", {
        title: props.tooltip ? null : label,
        "data-title": label,
        class: "bio-properties-panel-group-header-title",
        children: u5(TooltipWrapper, {
          value: props.tooltip,
          forId: "group-" + id,
          element,
          parent: groupRef,
          children: label
        })
      }), u5("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [u5(DataMarker, {
          edited,
          hasErrors
        }), u5("button", {
          type: "button",
          title: "Toggle section",
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: u5(ArrowIcon, {
            class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        })]
      })]
    }), u5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-entries", open3 ? "open" : ""),
      children: u5(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map((entry) => {
          const {
            component: Component2,
            id: id2
          } = entry;
          return y3(Component2, {
            ...entry,
            element,
            key: id2
          });
        })
      })
    })]
  });
}
function DataMarker(props) {
  const {
    edited,
    hasErrors
  } = props;
  if (hasErrors) {
    return u5("div", {
      title: "Section contains an error",
      class: "bio-properties-panel-dot bio-properties-panel-dot--error"
    });
  }
  if (edited) {
    return u5("div", {
      title: "Section contains data",
      class: "bio-properties-panel-dot"
    });
  }
  return null;
}
function Placeholder(props) {
  const {
    text,
    icon: Icon
  } = props;
  return u5("div", {
    class: "bio-properties-panel open",
    children: u5("section", {
      class: "bio-properties-panel-placeholder",
      children: [Icon && u5(Icon, {
        class: "bio-properties-panel-placeholder-icon"
      }), u5("p", {
        class: "bio-properties-panel-placeholder-text",
        children: text
      })]
    })
  });
}
function Description(props) {
  const {
    element,
    forId,
    value
  } = props;
  const contextDescription = useDescriptionContext(forId, element);
  const description = value || contextDescription;
  if (description) {
    return u5("div", {
      class: "bio-properties-panel-description",
      children: description
    });
  }
}
var noop$6 = () => {
};
var useBufferedFocus$1 = function(editor, ref) {
  const [buffer, setBuffer] = h4(void 0);
  ref.current = F4(() => ({
    focus: (offset) => {
      if (editor) {
        editor.focus(offset);
      } else {
        if (typeof offset === "undefined") {
          offset = Infinity;
        }
        setBuffer(offset);
      }
    }
  }), [editor]);
  p4(() => {
    if (typeof buffer !== "undefined" && editor) {
      editor.focus(buffer);
      setBuffer(false);
    }
  }, [editor, buffer]);
};
var CodeEditor$1 = N3((props, ref) => {
  const {
    onInput,
    disabled,
    tooltipContainer,
    enableGutters,
    value,
    onLint = noop$6,
    onPopupOpen = noop$6,
    popupOpen,
    contentAttributes = {},
    hostLanguage = null,
    singleLine = false
  } = props;
  const inputRef = _4();
  const [editor, setEditor] = h4();
  const [localValue, setLocalValue] = h4(value || "");
  useBufferedFocus$1(editor, ref);
  const handleInput = useStaticCallback((newValue) => {
    onInput(newValue);
    setLocalValue(newValue);
  });
  p4(() => {
    let editor2;
    editor2 = new FeelersEditor({
      container: inputRef.current,
      onChange: handleInput,
      value: localValue,
      onLint,
      contentAttributes,
      tooltipContainer,
      enableGutters,
      hostLanguage,
      singleLine,
      lineWrap: true
    });
    setEditor(editor2);
    return () => {
      onLint([]);
      inputRef.current.innerHTML = "";
      setEditor(null);
    };
  }, []);
  p4(() => {
    if (!editor) {
      return;
    }
    if (value === localValue) {
      return;
    }
    editor.setValue(value);
    setLocalValue(value);
  }, [value]);
  const handleClick = () => {
    ref.current.focus();
  };
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feelers-editor-container", popupOpen ? "popupOpen" : null),
    children: [u5("div", {
      class: "bio-properties-panel-feelers-editor__open-popup-placeholder",
      children: "Opened in editor"
    }), u5("div", {
      name: props.name,
      class: (0, import_classnames.default)("bio-properties-panel-feelers-editor bio-properties-panel-input", localValue ? "edited" : null, disabled ? "disabled" : null),
      ref: inputRef,
      onClick: handleClick
    }), u5("button", {
      type: "button",
      title: "Open pop-up editor",
      class: "bio-properties-panel-open-feel-popup",
      onClick: () => onPopupOpen("feelers"),
      children: u5(PopupIcon, {})
    })]
  });
});
var noop$5 = () => {
};
var useBufferedFocus = function(editor, ref) {
  const [buffer, setBuffer] = h4(void 0);
  ref.current = F4(() => ({
    focus: (offset) => {
      if (editor) {
        editor.focus(offset);
      } else {
        if (typeof offset === "undefined") {
          offset = Infinity;
        }
        setBuffer(offset);
      }
    }
  }), [editor]);
  p4(() => {
    if (typeof buffer !== "undefined" && editor) {
      editor.focus(buffer);
      setBuffer(false);
    }
  }, [editor, buffer]);
};
var CodeEditor = N3((props, ref) => {
  const {
    contentAttributes,
    enableGutters,
    value,
    onInput,
    onFeelToggle = noop$5,
    onLint = noop$5,
    onPopupOpen = noop$5,
    placeholder: placeholder2,
    popupOpen,
    disabled,
    tooltipContainer,
    variables
  } = props;
  const inputRef = _4();
  const [editor, setEditor] = h4();
  const [localValue, setLocalValue] = h4(value || "");
  useBufferedFocus(editor, ref);
  const handleInput = useStaticCallback((newValue) => {
    onInput(newValue);
    setLocalValue(newValue);
  });
  p4(() => {
    let editor2;
    const onKeyDown = (e8) => {
      if (e8.key !== "Backspace" || !editor2) {
        return;
      }
      const selection2 = editor2.getSelection();
      const range = selection2.ranges[selection2.mainIndex];
      if (range.from === 0 && range.to === 0) {
        onFeelToggle();
      }
    };
    editor2 = new FeelEditor({
      container: inputRef.current,
      onChange: handleInput,
      onKeyDown,
      onLint,
      placeholder: placeholder2,
      tooltipContainer,
      value: localValue,
      variables,
      extensions: [...enableGutters ? [(0, import_view4.lineNumbers)()] : [], import_view4.EditorView.lineWrapping],
      contentAttributes
    });
    setEditor(editor2);
    return () => {
      onLint([]);
      inputRef.current.innerHTML = "";
      setEditor(null);
    };
  }, []);
  p4(() => {
    if (!editor) {
      return;
    }
    if (value === localValue) {
      return;
    }
    editor.setValue(value);
    setLocalValue(value);
  }, [value]);
  p4(() => {
    if (!editor) {
      return;
    }
    editor.setVariables(variables);
  }, [variables]);
  p4(() => {
    if (!editor) {
      return;
    }
    editor.setPlaceholder(placeholder2);
  }, [placeholder2]);
  const handleClick = () => {
    ref.current.focus();
  };
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feel-editor-container", disabled ? "disabled" : null, popupOpen ? "popupOpen" : null),
    children: [u5("div", {
      class: "bio-properties-panel-feel-editor__open-popup-placeholder",
      children: "Opened in editor"
    }), u5("div", {
      name: props.name,
      class: (0, import_classnames.default)("bio-properties-panel-input", localValue ? "edited" : null),
      ref: inputRef,
      onClick: handleClick
    }), u5("button", {
      type: "button",
      title: "Open pop-up editor",
      class: "bio-properties-panel-open-feel-popup",
      onClick: () => onPopupOpen(),
      children: u5(PopupIcon, {})
    })]
  });
});
function FeelIndicator(props) {
  const {
    active
  } = props;
  if (!active) {
    return null;
  }
  return u5("span", {
    class: "bio-properties-panel-feel-indicator",
    children: "="
  });
}
var noop$4 = () => {
};
function FeelIcon2(props) {
  const {
    feel: feel3 = false,
    active,
    disabled = false,
    onClick = noop$4
  } = props;
  const feelRequiredLabel = "FEEL expression is mandatory";
  const feelOptionalLabel = `Click to ${active ? "remove" : "set a"} dynamic value with FEEL expression`;
  const handleClick = (e8) => {
    onClick(e8);
    if (!e8.pointerType) {
      e8.stopPropagation();
    }
  };
  return u5("button", {
    type: "button",
    class: (0, import_classnames.default)("bio-properties-panel-feel-icon", active ? "active" : null, feel3 === "required" ? "required" : "optional"),
    onClick: handleClick,
    disabled: feel3 === "required" || disabled,
    title: feel3 === "required" ? feelRequiredLabel : feelOptionalLabel,
    children: u5(FeelIcon$1, {})
  });
}
var FeelPopupContext = F3({
  open: () => {
  },
  close: () => {
  },
  source: null
});
function createDragger(fn2, dragPreview) {
  let self2;
  let startX, startY;
  function onDragStart(event2) {
    self2 = this;
    startX = event2.clientX;
    startY = event2.clientY;
    if (event2.dataTransfer) {
      event2.dataTransfer.setDragImage(dragPreview || emptyCanvas(), 0, 0);
    }
    document.addEventListener("dragover", onDrag, true);
    document.addEventListener("dragenter", preventDefault3, true);
    document.addEventListener("dragend", onEnd);
    document.addEventListener("drop", preventDefault3);
  }
  function onDrag(event2) {
    const delta2 = {
      x: event2.clientX - startX,
      y: event2.clientY - startY
    };
    return fn2.call(self2, event2, delta2);
  }
  function onEnd() {
    document.removeEventListener("dragover", onDrag, true);
    document.removeEventListener("dragenter", preventDefault3, true);
    document.removeEventListener("dragend", onEnd);
    document.removeEventListener("drop", preventDefault3);
  }
  return onDragStart;
}
function preventDefault3(event2) {
  event2.preventDefault();
  event2.stopPropagation();
}
function emptyCanvas() {
  return domify$1('<canvas width="0" height="0" />');
}
var noop$3 = () => {
};
function PopupComponent(props, globalRef) {
  const {
    container,
    className,
    delayInitialFocus,
    position,
    width,
    height,
    onClose,
    onPostActivate = noop$3,
    onPostDeactivate = noop$3,
    returnFocus = true,
    closeOnEscape = true,
    title
  } = props;
  const focusTrapRef = _4(null);
  const localRef = _4(null);
  const popupRef = globalRef || localRef;
  const containerNode = F4(() => getContainerNode(container), [container]);
  const handleKeydown = (event2) => {
    event2.stopPropagation();
    if (closeOnEscape && event2.key === "Escape") {
      onClose();
    }
  };
  const handleFocus = () => {
    if (focusTrapRef.current) {
      focusTrapRef.current.activate();
    }
  };
  let style = {};
  if (position) {
    style = {
      ...style,
      top: position.top + "px",
      left: position.left + "px"
    };
  }
  if (width) {
    style.width = width + "px";
  }
  if (height) {
    style.height = height + "px";
  }
  p4(() => {
    if (popupRef.current) {
      popupRef.current.addEventListener("focusin", handleFocus);
    }
    return () => {
      popupRef.current.removeEventListener("focusin", handleFocus);
    };
  }, [popupRef]);
  p4(() => {
    if (popupRef.current) {
      focusTrapRef.current = createFocusTrap(popupRef.current, {
        clickOutsideDeactivates: true,
        delayInitialFocus,
        fallbackFocus: popupRef.current,
        onPostActivate,
        onPostDeactivate,
        returnFocusOnDeactivate: returnFocus
      });
      focusTrapRef.current.activate();
    }
    return () => focusTrapRef.current && focusTrapRef.current.deactivate();
  }, [popupRef]);
  useEvent("propertiesPanel.detach", onClose);
  return j5(u5("div", {
    "aria-label": title,
    tabIndex: -1,
    ref: popupRef,
    onKeyDown: handleKeydown,
    role: "dialog",
    class: (0, import_classnames.default)("bio-properties-panel-popup", className),
    style,
    children: props.children
  }), containerNode || document.body);
}
var Popup = N3(PopupComponent);
Popup.Title = Title;
Popup.Body = Body;
Popup.Footer = Footer;
function Title(props) {
  const {
    children,
    className,
    draggable,
    emit = () => {
    },
    title,
    showCloseButton = false,
    closeButtonTooltip = "Close popup",
    onClose,
    ...rest
  } = props;
  const context = _4({
    startPosition: null,
    newPosition: null
  });
  const dragPreviewRef = _4();
  const titleRef = _4();
  const onMove = (event2, delta2) => {
    cancel(event2);
    const {
      x: dx,
      y: dy
    } = delta2;
    const newPosition = {
      x: context.current.startPosition.x + dx,
      y: context.current.startPosition.y + dy
    };
    const popupParent = getPopupParent(titleRef.current);
    popupParent.style.top = newPosition.y + "px";
    popupParent.style.left = newPosition.x + "px";
    emit("dragover", {
      newPosition,
      delta: delta2
    });
  };
  const onMoveStart = (event2) => {
    const onDragStart = createDragger(onMove, dragPreviewRef.current);
    onDragStart(event2);
    event2.stopPropagation();
    const popupParent = getPopupParent(titleRef.current);
    const bounds = popupParent.getBoundingClientRect();
    context.current.startPosition = {
      x: bounds.left,
      y: bounds.top
    };
    emit("dragstart");
  };
  const onMoveEnd = () => {
    context.current.newPosition = null;
    emit("dragend");
  };
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-popup__header", draggable && "draggable", className),
    ref: titleRef,
    draggable,
    onDragStart: onMoveStart,
    onDragEnd: onMoveEnd,
    ...rest,
    children: [draggable && u5(g3, {
      children: [u5("div", {
        ref: dragPreviewRef,
        class: "bio-properties-panel-popup__drag-preview"
      }), u5("div", {
        class: "bio-properties-panel-popup__drag-handle",
        children: u5(DragIcon, {})
      })]
    }), u5("div", {
      class: "bio-properties-panel-popup__title",
      children: title
    }), children, showCloseButton && u5("button", {
      title: closeButtonTooltip,
      class: "bio-properties-panel-popup__close",
      onClick: onClose,
      children: u5(CloseIcon, {})
    })]
  });
}
function Body(props) {
  const {
    children,
    className,
    ...rest
  } = props;
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-popup__body", className),
    ...rest,
    children
  });
}
function Footer(props) {
  const {
    children,
    className,
    ...rest
  } = props;
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-popup__footer", className),
    ...rest,
    children: props.children
  });
}
function getPopupParent(node2) {
  return node2.closest(".bio-properties-panel-popup");
}
function cancel(event2) {
  event2.preventDefault();
  event2.stopPropagation();
}
function getContainerNode(node2) {
  if (typeof node2 === "string") {
    return query(node2);
  }
  return node2;
}
var FEEL_POPUP_WIDTH = 700;
var FEEL_POPUP_HEIGHT = 250;
function FEELPopupRoot(props) {
  const {
    element,
    eventBus = {
      fire() {
      },
      on() {
      },
      off() {
      }
    },
    popupContainer,
    getPopupLinks = () => []
  } = props;
  const prevElement = usePrevious(element);
  const [popupConfig, setPopupConfig] = h4({});
  const [open3, setOpen] = h4(false);
  const [source, setSource] = h4(null);
  const [sourceElement, setSourceElement] = h4(null);
  const emit = (type, context) => {
    eventBus.fire("feelPopup." + type, context);
  };
  const isOpen = T4(() => {
    return !!open3;
  }, [open3]);
  useUpdateEffect(() => {
    if (!open3) {
      emit("closed");
    }
  }, [open3]);
  const handleOpen = (entryId, config, _sourceElement) => {
    setSource(entryId);
    setPopupConfig(config);
    setOpen(true);
    setSourceElement(_sourceElement);
    emit("open");
  };
  const handleClose = (event2 = {}) => {
    const {
      id
    } = event2;
    if (id && id !== source) {
      return;
    }
    setOpen(false);
    setSource(null);
  };
  const feelPopupContext = {
    open: handleOpen,
    close: handleClose,
    source
  };
  p4(() => {
    if (element && prevElement && element !== prevElement) {
      handleClose();
    }
  }, [element]);
  p4(() => {
    const handlePopupOpen = (context) => {
      const {
        entryId,
        popupConfig: popupConfig2,
        sourceElement: sourceElement2
      } = context;
      handleOpen(entryId, popupConfig2, sourceElement2);
    };
    const handleIsOpen = () => {
      return isOpen();
    };
    eventBus.on("feelPopup._close", handleClose);
    eventBus.on("feelPopup._open", handlePopupOpen);
    eventBus.on("feelPopup._isOpen", handleIsOpen);
    return () => {
      eventBus.off("feelPopup._close", handleClose);
      eventBus.off("feelPopup._open", handleOpen);
      eventBus.off("feelPopup._isOpen", handleIsOpen);
    };
  }, [eventBus, isOpen]);
  return u5(FeelPopupContext.Provider, {
    value: feelPopupContext,
    children: [open3 && u5(FeelPopupComponent, {
      onClose: handleClose,
      container: popupContainer,
      getLinks: getPopupLinks,
      sourceElement,
      emit,
      ...popupConfig
    }), props.children]
  });
}
function FeelPopupComponent(props) {
  const {
    container,
    getLinks,
    id,
    hostLanguage,
    onInput,
    onClose,
    position,
    singleLine,
    sourceElement,
    title,
    tooltipContainer,
    type,
    value,
    variables,
    emit
  } = props;
  const editorRef = _4();
  const popupRef = _4();
  const isAutoCompletionOpen = _4(false);
  const handleSetReturnFocus = () => {
    sourceElement && sourceElement.focus();
  };
  const onKeyDownCapture = (event2) => {
    if (event2.key === "Escape") {
      isAutoCompletionOpen.current = autoCompletionOpen(event2.target);
    }
  };
  const onKeyDown = (event2) => {
    if (event2.key === "Escape") {
      if (!isAutoCompletionOpen.current) {
        onClose();
        isAutoCompletionOpen.current = false;
      }
    }
  };
  p4(() => {
    emit("opened", {
      domNode: popupRef.current
    });
    return () => emit("close", {
      domNode: popupRef.current
    });
  }, []);
  p4(() => {
    if (editorRef.current) {
      editorRef.current.focus();
    }
  }, [editorRef]);
  return u5(Popup, {
    container,
    className: "bio-properties-panel-feel-popup",
    emit,
    position,
    title,
    onClose,
    returnFocus: false,
    closeOnEscape: false,
    delayInitialFocus: false,
    onPostDeactivate: handleSetReturnFocus,
    height: FEEL_POPUP_HEIGHT,
    width: FEEL_POPUP_WIDTH,
    ref: popupRef,
    children: [u5(Popup.Title, {
      title,
      emit,
      showCloseButton: true,
      closeButtonTooltip: "Save and close",
      onClose,
      draggable: true,
      children: u5(g3, {
        children: getLinks(type).map((link, index5) => {
          return u5("a", {
            rel: "noreferrer",
            href: link.href,
            target: "_blank",
            class: "bio-properties-panel-feel-popup__title-link",
            children: [link.title, u5(LaunchIcon, {})]
          }, index5);
        })
      })
    }), u5(Popup.Body, {
      children: u5("div", {
        onKeyDownCapture,
        onKeyDown,
        class: "bio-properties-panel-feel-popup__body",
        children: [type === "feel" && u5(CodeEditor, {
          enableGutters: true,
          id: prefixId$8(id),
          name: id,
          onInput,
          value,
          variables,
          ref: editorRef,
          tooltipContainer
        }), type === "feelers" && u5(CodeEditor$1, {
          id: prefixId$8(id),
          contentAttributes: {
            "aria-label": title
          },
          enableGutters: true,
          hostLanguage,
          name: id,
          onInput,
          value,
          ref: editorRef,
          singleLine,
          tooltipContainer
        })]
      })
    })]
  });
}
function prefixId$8(id) {
  return `bio-properties-panel-${id}`;
}
function autoCompletionOpen(element) {
  return element.closest(".cm-editor").querySelector(".cm-tooltip-autocomplete");
}
function useUpdateEffect(effect, deps) {
  const isMounted = _4(false);
  p4(() => {
    if (isMounted.current) {
      return effect();
    } else {
      isMounted.current = true;
    }
  }, deps);
}
function ToggleSwitch(props) {
  const {
    id,
    label,
    onInput,
    value,
    switcherLabel,
    inline,
    onFocus,
    onBlur,
    inputRef,
    tooltip
  } = props;
  const [localValue, setLocalValue] = h4(value);
  const handleInputCallback = async () => {
    onInput(!value);
  };
  const handleInput = (e8) => {
    handleInputCallback();
    setLocalValue(e8.target.value);
  };
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-toggle-switch", {
      inline
    }),
    children: [u5("label", {
      class: "bio-properties-panel-label",
      for: prefixId$7(id),
      children: u5(TooltipWrapper, {
        value: tooltip,
        forId: id,
        element: props.element,
        children: label
      })
    }), u5("div", {
      class: "bio-properties-panel-field-wrapper",
      children: [u5("label", {
        class: "bio-properties-panel-toggle-switch__switcher",
        children: [u5("input", {
          ref: inputRef,
          id: prefixId$7(id),
          class: "bio-properties-panel-input",
          type: "checkbox",
          onFocus,
          onBlur,
          name: id,
          onInput: handleInput,
          checked: !!localValue
        }), u5("span", {
          class: "bio-properties-panel-toggle-switch__slider"
        })]
      }), switcherLabel && u5("p", {
        class: "bio-properties-panel-toggle-switch__label",
        children: switcherLabel
      })]
    })]
  });
}
function ToggleSwitchEntry(props) {
  const {
    element,
    id,
    description,
    label,
    switcherLabel,
    inline,
    getValue,
    setValue,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const value = getValue(element);
  return u5("div", {
    class: "bio-properties-panel-entry bio-properties-panel-toggle-switch-entry",
    "data-entry-id": id,
    children: [u5(ToggleSwitch, {
      id,
      label,
      value,
      onInput: setValue,
      onFocus,
      onBlur,
      switcherLabel,
      inline,
      tooltip,
      element
    }), u5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$8(node2) {
  return node2 && !!node2.checked;
}
function prefixId$7(id) {
  return `bio-properties-panel-${id}`;
}
function NumberField(props) {
  const {
    debounce: debounce2,
    disabled,
    displayLabel = true,
    id,
    inputRef,
    label,
    max: max8,
    min: min5,
    onInput,
    step,
    value = "",
    onFocus,
    onBlur
  } = props;
  const [localValue, setLocalValue] = h4(value);
  const handleInputCallback = F4(() => {
    return debounce2((target) => {
      if (target.validity.valid) {
        onInput(target.value ? parseFloat(target.value) : void 0);
      }
    });
  }, [onInput, debounce2]);
  const handleInput = (e8) => {
    handleInputCallback(e8.target);
    setLocalValue(e8.target.value);
  };
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u5("div", {
    class: "bio-properties-panel-numberfield",
    children: [displayLabel && u5("label", {
      for: prefixId$6(id),
      class: "bio-properties-panel-label",
      children: label
    }), u5("input", {
      id: prefixId$6(id),
      ref: inputRef,
      type: "number",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      max: max8,
      min: min5,
      onInput: handleInput,
      onFocus,
      onBlur,
      step,
      value: localValue
    })]
  });
}
function prefixId$6(id) {
  return `bio-properties-panel-${id}`;
}
var noop$2 = () => {
};
function FeelTextfieldComponent(props) {
  const {
    debounce: debounce2,
    id,
    element,
    label,
    hostLanguage,
    onInput,
    onBlur,
    onError,
    placeholder: placeholder2,
    feel: feel3,
    value = "",
    disabled = false,
    variables,
    singleLine,
    tooltipContainer,
    OptionalComponent = OptionalFeelInput,
    tooltip
  } = props;
  const [localValue, _setLocalValue] = h4(value);
  const editorRef = useShowEntryEvent(id);
  const containerRef = _4();
  const feelActive = isString(localValue) && localValue.startsWith("=") || feel3 === "required";
  const feelOnlyValue = isString(localValue) && localValue.startsWith("=") ? localValue.substring(1) : localValue;
  const [focus, _setFocus] = h4(void 0);
  const {
    open: openPopup,
    source: popupSource
  } = q4(FeelPopupContext);
  const popuOpen = popupSource === id;
  const setFocus = (offset = 0) => {
    const hasFocus = containerRef.current.contains(document.activeElement);
    const position = hasFocus ? document.activeElement.selectionStart : Infinity;
    _setFocus(position + offset);
  };
  const handleInputCallback = F4(() => {
    return debounce2((newValue) => {
      onInput(newValue);
    });
  }, [onInput, debounce2]);
  const setLocalValue = (newValue) => {
    _setLocalValue(newValue);
    if (typeof newValue === "undefined" || newValue === "" || newValue === "=") {
      handleInputCallback(void 0);
    } else {
      handleInputCallback(newValue);
    }
  };
  const handleFeelToggle = useStaticCallback(() => {
    if (feel3 === "required") {
      return;
    }
    if (!feelActive) {
      setLocalValue("=" + localValue);
    } else {
      setLocalValue(feelOnlyValue);
    }
  });
  const handleLocalInput = (newValue) => {
    if (feelActive) {
      newValue = "=" + newValue;
    }
    if (newValue === localValue) {
      return;
    }
    setLocalValue(newValue);
    if (!feelActive && isString(newValue) && newValue.startsWith("=")) {
      setFocus(-1);
    }
  };
  const handleOnBlur = (e8) => {
    if (onBlur) {
      onBlur(e8);
    }
    setLocalValue(e8.target.value.trim());
  };
  const handleLint = useStaticCallback((lint2 = []) => {
    const syntaxError = lint2.some((report) => report.type === "Syntax Error");
    if (syntaxError) {
      onError("Unparsable FEEL expression.");
    } else {
      onError(void 0);
    }
  });
  const handlePopupOpen = (type = "feel") => {
    const popupOptions = {
      id,
      hostLanguage,
      onInput: handleLocalInput,
      position: calculatePopupPosition(containerRef.current),
      singleLine,
      title: getPopupTitle(element, label),
      tooltipContainer,
      type,
      value: feelOnlyValue,
      variables
    };
    openPopup(id, popupOptions, editorRef.current);
  };
  p4(() => {
    if (typeof focus !== "undefined") {
      editorRef.current.focus(focus);
      _setFocus(void 0);
    }
  }, [focus]);
  p4(() => {
    if (value === localValue) {
      return;
    }
    if (!value) {
      setLocalValue(feelActive ? "=" : "");
      return;
    }
    setLocalValue(value);
  }, [value]);
  p4(() => {
    const copyHandler = (event2) => {
      if (!feelActive) {
        return;
      }
      event2.clipboardData.setData("application/FEEL", event2.clipboardData.getData("text"));
    };
    const pasteHandler = (event2) => {
      if (feelActive || popuOpen) {
        return;
      }
      const data = event2.clipboardData.getData("application/FEEL");
      if (data) {
        setTimeout(() => {
          handleFeelToggle();
          setFocus();
        });
      }
    };
    containerRef.current.addEventListener("copy", copyHandler);
    containerRef.current.addEventListener("cut", copyHandler);
    containerRef.current.addEventListener("paste", pasteHandler);
    return () => {
      containerRef.current.removeEventListener("copy", copyHandler);
      containerRef.current.removeEventListener("cut", copyHandler);
      containerRef.current.removeEventListener("paste", pasteHandler);
    };
  }, [containerRef, feelActive, handleFeelToggle, setFocus]);
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-feel-entry", {
      "feel-active": feelActive
    }),
    children: [u5("label", {
      for: prefixId$5(id),
      class: "bio-properties-panel-label",
      onClick: () => setFocus(),
      children: [u5(TooltipWrapper, {
        value: tooltip,
        forId: id,
        element: props.element,
        children: label
      }), u5(FeelIcon2, {
        label,
        feel: feel3,
        onClick: handleFeelToggle,
        active: feelActive
      })]
    }), u5("div", {
      class: "bio-properties-panel-feel-container",
      ref: containerRef,
      children: [u5(FeelIndicator, {
        active: feelActive,
        disabled: feel3 !== "optional" || disabled,
        onClick: handleFeelToggle
      }), feelActive ? u5(CodeEditor, {
        name: id,
        onInput: handleLocalInput,
        contentAttributes: {
          "id": prefixId$5(id),
          "aria-label": label
        },
        disabled,
        popupOpen: popuOpen,
        onFeelToggle: () => {
          handleFeelToggle();
          setFocus(true);
        },
        onLint: handleLint,
        onPopupOpen: handlePopupOpen,
        placeholder: placeholder2,
        value: feelOnlyValue,
        variables,
        ref: editorRef,
        tooltipContainer
      }) : u5(OptionalComponent, {
        ...props,
        popupOpen: popuOpen,
        onInput: handleLocalInput,
        onBlur: handleOnBlur,
        contentAttributes: {
          "id": prefixId$5(id),
          "aria-label": label
        },
        value: localValue,
        ref: editorRef,
        onPopupOpen: handlePopupOpen,
        containerRef
      })]
    })]
  });
}
var FeelTextfield = withAutoClosePopup(FeelTextfieldComponent);
var OptionalFeelInput = N3((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur,
    placeholder: placeholder2
  } = props;
  const inputRef = _4();
  ref.current = {
    focus: (position) => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      if (typeof position === "number") {
        if (position > value.length) {
          position = value.length;
        }
        input.setSelectionRange(position, position);
      }
    }
  };
  return u5("input", {
    id: prefixId$5(id),
    type: "text",
    ref: inputRef,
    name: id,
    spellCheck: "false",
    autoComplete: "off",
    disabled,
    class: "bio-properties-panel-input",
    onInput: (e8) => onInput(e8.target.value),
    onFocus,
    onBlur,
    placeholder: placeholder2,
    value: value || ""
  });
});
var OptionalFeelNumberField = N3((props, ref) => {
  const {
    id,
    debounce: debounce2,
    disabled,
    onInput,
    value,
    min: min5,
    max: max8,
    step,
    onFocus,
    onBlur
  } = props;
  const inputRef = _4();
  ref.current = {
    focus: (position) => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      if (typeof position === "number" && position !== Infinity) {
        if (position > value.length) {
          position = value.length;
        }
        input.setSelectionRange(position, position);
      }
    }
  };
  return u5(NumberField, {
    id,
    debounce: debounce2,
    disabled,
    displayLabel: false,
    inputRef,
    max: max8,
    min: min5,
    onInput,
    step,
    value,
    onFocus,
    onBlur
  });
});
var OptionalFeelTextArea = N3((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur,
    placeholder: placeholder2
  } = props;
  const inputRef = _4();
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
      input.setSelectionRange(0, 0);
    }
  };
  return u5("textarea", {
    id: prefixId$5(id),
    type: "text",
    ref: inputRef,
    name: id,
    spellCheck: "false",
    autoComplete: "off",
    disabled,
    class: "bio-properties-panel-input",
    onInput: (e8) => onInput(e8.target.value),
    onFocus,
    onBlur,
    placeholder: placeholder2,
    value: value || "",
    "data-gramm": "false"
  });
});
var OptionalFeelToggleSwitch = N3((props, ref) => {
  const {
    id,
    onInput,
    value,
    onFocus,
    onBlur,
    switcherLabel
  } = props;
  const inputRef = _4();
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
    }
  };
  return u5(ToggleSwitch, {
    id,
    value,
    inputRef,
    onInput,
    onFocus,
    onBlur,
    switcherLabel
  });
});
var OptionalFeelCheckbox = N3((props, ref) => {
  const {
    id,
    disabled,
    onInput,
    value,
    onFocus,
    onBlur
  } = props;
  const inputRef = _4();
  const handleChange = ({
    target
  }) => {
    onInput(target.checked);
  };
  ref.current = {
    focus: () => {
      const input = inputRef.current;
      if (!input) {
        return;
      }
      input.focus();
    }
  };
  return u5("input", {
    ref: inputRef,
    id: prefixId$5(id),
    name: id,
    onFocus,
    onBlur,
    type: "checkbox",
    class: "bio-properties-panel-input",
    onChange: handleChange,
    checked: value,
    disabled
  });
});
function FeelEntry(props) {
  const {
    element,
    id,
    description,
    debounce: debounce2,
    disabled,
    feel: feel3,
    label,
    getValue,
    setValue,
    tooltipContainer,
    hostLanguage,
    singleLine,
    validate,
    show = noop$2,
    example,
    variables,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    tooltip
  } = props;
  const [validationError, setValidationError] = h4(null);
  const [localError, setLocalError] = h4(null);
  let value = getValue(element);
  p4(() => {
    if (isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setValidationError(newValidationError);
    }
  }, [value, validate]);
  const onInput = useStaticCallback((newValue) => {
    let newValidationError = null;
    if (isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    if (newValue !== value) {
      setValue(newValue, newValidationError);
    }
    setValidationError(newValidationError);
  });
  const onError = T4((err) => {
    setLocalError(err);
  }, []);
  const temporaryError = useError(id);
  const error4 = temporaryError || localError || validationError;
  return u5("div", {
    class: (0, import_classnames.default)(props.class, "bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [y3(FeelTextfield, {
      ...props,
      debounce: debounce2,
      disabled,
      feel: feel3,
      id,
      key: element,
      label,
      onInput,
      onError,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      example,
      hostLanguage,
      singleLine,
      show,
      value,
      variables,
      tooltipContainer,
      OptionalComponent: props.OptionalComponent,
      tooltip
    }), error4 && u5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), u5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$6(node2) {
  if (!node2) {
    return false;
  }
  if (node2.type === "checkbox") {
    return !!node2.checked || node2.classList.contains("edited");
  }
  return !!node2.value || node2.classList.contains("edited");
}
function prefixId$5(id) {
  return `bio-properties-panel-${id}`;
}
function calculatePopupPosition(element) {
  const {
    top,
    left
  } = element.getBoundingClientRect();
  return {
    left: left - FEEL_POPUP_WIDTH - 20,
    top
  };
}
function getPopupTitle(element, label) {
  let popupTitle = "";
  if (element && element.type) {
    popupTitle = `${element.type} / `;
  }
  return `${popupTitle}${label}`;
}
function withAutoClosePopup(Component2) {
  return function(props) {
    const {
      id
    } = props;
    const {
      close
    } = q4(FeelPopupContext);
    const closePopup = useStaticCallback(close);
    p4(() => {
      return () => {
        closePopup({
          id
        });
      };
    }, []);
    return u5(Component2, {
      ...props
    });
  };
}
var DEFAULT_LAYOUT = {};
var DEFAULT_DESCRIPTION = {};
var DEFAULT_TOOLTIP = {};
function PropertiesPanel(props) {
  const {
    element,
    headerProvider,
    placeholderProvider,
    groups,
    layoutConfig,
    layoutChanged,
    descriptionConfig,
    descriptionLoaded,
    tooltipConfig,
    tooltipLoaded,
    feelPopupContainer,
    getFeelPopupLinks,
    eventBus
  } = props;
  const [layout, setLayout] = h4(createLayout(layoutConfig));
  useUpdateLayoutEffect(() => {
    const newLayout = createLayout(layoutConfig);
    setLayout(newLayout);
  }, [layoutConfig]);
  p4(() => {
    if (typeof layoutChanged === "function") {
      layoutChanged(layout);
    }
  }, [layout, layoutChanged]);
  const getLayoutForKey = (key, defaultValue) => {
    return get(layout, key, defaultValue);
  };
  const setLayoutForKey = (key, config) => {
    const newLayout = assign({}, layout);
    set(newLayout, key, config);
    setLayout(newLayout);
  };
  const layoutContext = {
    layout,
    setLayout,
    getLayoutForKey,
    setLayoutForKey
  };
  const description = F4(() => createDescriptionContext(descriptionConfig), [descriptionConfig]);
  p4(() => {
    if (typeof descriptionLoaded === "function") {
      descriptionLoaded(description);
    }
  }, [description, descriptionLoaded]);
  const getDescriptionForId = (id, element2) => {
    return description[id] && description[id](element2);
  };
  const descriptionContext = {
    description,
    getDescriptionForId
  };
  const tooltip = F4(() => createTooltipContext(tooltipConfig), [tooltipConfig]);
  p4(() => {
    if (typeof tooltipLoaded === "function") {
      tooltipLoaded(tooltip);
    }
  }, [tooltip, tooltipLoaded]);
  const getTooltipForId = (id, element2) => {
    return tooltip[id] && tooltip[id](element2);
  };
  const tooltipContext = {
    tooltip,
    getTooltipForId
  };
  const [errors, setErrors] = h4({});
  const onSetErrors = ({
    errors: errors2
  }) => setErrors(errors2);
  useEvent("propertiesPanel.setErrors", onSetErrors, eventBus);
  const errorsContext = {
    errors
  };
  const eventContext = {
    eventBus
  };
  const propertiesPanelContext = {
    element
  };
  if (placeholderProvider && !element) {
    return u5(Placeholder, {
      ...placeholderProvider.getEmpty()
    });
  }
  if (placeholderProvider && isArray(element)) {
    return u5(Placeholder, {
      ...placeholderProvider.getMultiple()
    });
  }
  return u5(LayoutContext.Provider, {
    value: propertiesPanelContext,
    children: u5(ErrorsContext.Provider, {
      value: errorsContext,
      children: u5(DescriptionContext.Provider, {
        value: descriptionContext,
        children: u5(TooltipContext.Provider, {
          value: tooltipContext,
          children: u5(LayoutContext.Provider, {
            value: layoutContext,
            children: u5(EventContext.Provider, {
              value: eventContext,
              children: u5(FEELPopupRoot, {
                element,
                eventBus,
                popupContainer: feelPopupContainer,
                getPopupLinks: getFeelPopupLinks,
                children: u5("div", {
                  class: "bio-properties-panel",
                  children: [u5(Header, {
                    element,
                    headerProvider
                  }), u5("div", {
                    class: "bio-properties-panel-scroll-container",
                    children: groups.map((group) => {
                      const {
                        component: Component2 = Group,
                        id
                      } = group;
                      return y3(Component2, {
                        ...group,
                        key: id,
                        element
                      });
                    })
                  })]
                })
              })
            })
          })
        })
      })
    })
  });
}
function createLayout(overrides = {}, defaults = DEFAULT_LAYOUT) {
  return {
    ...defaults,
    ...overrides
  };
}
function createDescriptionContext(overrides = {}) {
  return {
    ...DEFAULT_DESCRIPTION,
    ...overrides
  };
}
function createTooltipContext(overrides = {}) {
  return {
    ...DEFAULT_TOOLTIP,
    ...overrides
  };
}
function useUpdateLayoutEffect(effect, deps) {
  const isMounted = _4(false);
  y4(() => {
    if (isMounted.current) {
      return effect();
    } else {
      isMounted.current = true;
    }
  }, deps);
}
function translateFallback(template, replacements) {
  replacements = replacements || {};
  return template.replace(/{([^}]+)}/g, function(_5, key) {
    return replacements[key] || "{" + key + "}";
  });
}
function CollapsibleEntry(props) {
  const {
    element,
    entries = [],
    id,
    label,
    open: shouldOpen,
    remove: remove4,
    translate: translate4 = translateFallback
  } = props;
  const [open3, setOpen] = h4(shouldOpen);
  const toggleOpen = () => setOpen(!open3);
  const {
    onShow
  } = q4(LayoutContext);
  const propertiesPanelContext = {
    ...q4(LayoutContext),
    onShow: T4(() => {
      setOpen(true);
      if (isFunction(onShow)) {
        onShow();
      }
    }, [onShow, setOpen])
  };
  const placeholderLabel = translate4("<empty>");
  return u5("div", {
    "data-entry-id": id,
    class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry", open3 ? "open" : ""),
    children: [u5("div", {
      class: "bio-properties-panel-collapsible-entry-header",
      onClick: toggleOpen,
      children: [u5("div", {
        title: label || placeholderLabel,
        class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry-header-title", !label && "empty"),
        children: label || placeholderLabel
      }), u5("button", {
        type: "button",
        title: translate4("Toggle list item"),
        class: "bio-properties-panel-arrow  bio-properties-panel-collapsible-entry-arrow",
        children: u5(ArrowIcon, {
          class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
        })
      }), remove4 ? u5("button", {
        type: "button",
        title: translate4("Delete item"),
        class: "bio-properties-panel-remove-entry",
        onClick: remove4,
        children: u5(DeleteIcon, {})
      }) : null]
    }), u5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-collapsible-entry-entries", open3 ? "open" : ""),
      children: u5(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: entries.map((entry) => {
          const {
            component: Component2,
            id: id2
          } = entry;
          return y3(Component2, {
            ...entry,
            element,
            key: id2
          });
        })
      })
    })]
  });
}
function ListItem(props) {
  const {
    autoFocusEntry,
    autoOpen,
    translate: translate4 = translateFallback
  } = props;
  p4(() => {
    if (autoOpen && autoFocusEntry) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        if (isFunction(focusableInput.select)) {
          focusableInput.select();
        } else if (isFunction(focusableInput.focus)) {
          focusableInput.focus();
        }
        focusableInput.scrollIntoView();
      }
    }
  }, [autoOpen, autoFocusEntry]);
  return u5("div", {
    class: "bio-properties-panel-list-item",
    children: u5(CollapsibleEntry, {
      ...props,
      open: autoOpen,
      translate: translate4
    })
  });
}
var noop$1 = () => {
};
function ListGroup(props) {
  const {
    add: add5,
    element,
    id,
    items,
    label,
    shouldOpen = false,
    translate: translate4 = translateFallback
  } = props;
  p4(() => {
    if (props.shouldSort != void 0) {
      console.warn("the property 'shouldSort' is no longer supported");
    }
  }, [props.shouldSort]);
  const groupRef = _4(null);
  const [open3, setOpen] = useLayoutState(["groups", id, "open"], shouldOpen);
  const [sticky, setSticky] = h4(false);
  const onShow = T4(() => setOpen(true), [setOpen]);
  const [localItems, setLocalItems] = h4([]);
  const [addTriggered, setAddTriggered] = h4(false);
  const prevElement = usePrevious(element);
  const toggleOpen = T4(() => setOpen(!open3), [open3]);
  const openItemIds = element === prevElement && open3 && addTriggered ? getNewItemIds(items, localItems) : [];
  p4(() => {
    setLocalItems(items);
    setAddTriggered(false);
  }, [items]);
  useStickyIntersectionObserver(groupRef, "div.bio-properties-panel-scroll-container", setSticky);
  const hasItems = !!items.length;
  const propertiesPanelContext = {
    ...q4(LayoutContext),
    onShow
  };
  const handleAddClick = (e8) => {
    setAddTriggered(true);
    setOpen(true);
    add5(e8);
  };
  const allErrors = useErrors();
  const hasError = items.some((item) => {
    if (allErrors[item.id]) {
      return true;
    }
    if (!item.entries) {
      return;
    }
    return item.entries.some((entry) => allErrors[entry.id]);
  });
  return u5("div", {
    class: "bio-properties-panel-group",
    "data-group-id": "group-" + id,
    ref: groupRef,
    children: [u5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-group-header", hasItems ? "" : "empty", hasItems && open3 ? "open" : "", sticky && open3 ? "sticky" : ""),
      onClick: hasItems ? toggleOpen : noop$1,
      children: [u5("div", {
        title: props.tooltip ? null : label,
        "data-title": label,
        class: "bio-properties-panel-group-header-title",
        children: u5(TooltipWrapper, {
          value: props.tooltip,
          forId: "group-" + id,
          element,
          parent: groupRef,
          children: label
        })
      }), u5("div", {
        class: "bio-properties-panel-group-header-buttons",
        children: [add5 ? u5("button", {
          type: "button",
          title: translate4("Create new list item"),
          class: "bio-properties-panel-group-header-button bio-properties-panel-add-entry",
          onClick: handleAddClick,
          children: [u5(CreateIcon, {}), !hasItems ? u5("span", {
            class: "bio-properties-panel-add-entry-label",
            children: translate4("Create")
          }) : null]
        }) : null, hasItems ? u5("div", {
          title: translate4(`List contains {numOfItems} item${items.length != 1 ? "s" : ""}`, {
            numOfItems: items.length
          }),
          class: (0, import_classnames.default)("bio-properties-panel-list-badge", hasError ? "bio-properties-panel-list-badge--error" : ""),
          children: items.length
        }) : null, hasItems ? u5("button", {
          type: "button",
          title: translate4("Toggle section"),
          class: "bio-properties-panel-group-header-button bio-properties-panel-arrow",
          children: u5(ArrowIcon, {
            class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        }) : null]
      })]
    }), u5("div", {
      class: (0, import_classnames.default)("bio-properties-panel-list", open3 && hasItems ? "open" : ""),
      children: u5(LayoutContext.Provider, {
        value: propertiesPanelContext,
        children: items.map((item, index5) => {
          if (!item) {
            return;
          }
          const {
            id: id2
          } = item;
          const autoOpen = openItemIds.includes(item.id);
          return y3(ListItem, {
            ...item,
            autoOpen,
            element,
            index: index5,
            key: id2,
            translate: translate4
          });
        })
      })
    })]
  });
}
function getNewItemIds(newItems, oldItems) {
  const newIds = newItems.map((item) => item.id);
  const oldIds = oldItems.map((item) => item.id);
  return newIds.filter((itemId) => !oldIds.includes(itemId));
}
function Checkbox(props) {
  const {
    id,
    label,
    onChange,
    disabled,
    value = false,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const [localValue, setLocalValue] = h4(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.checked);
  };
  const handleChange = (e8) => {
    handleChangeCallback(e8);
    setLocalValue(e8.target.value);
  };
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  const ref = useShowEntryEvent(id);
  return u5("div", {
    class: "bio-properties-panel-checkbox",
    children: [u5("input", {
      ref,
      id: prefixId$4(id),
      name: id,
      onFocus,
      onBlur,
      type: "checkbox",
      class: "bio-properties-panel-input",
      onChange: handleChange,
      checked: localValue,
      disabled
    }), u5("label", {
      for: prefixId$4(id),
      class: "bio-properties-panel-label",
      children: u5(TooltipWrapper, {
        value: tooltip,
        forId: id,
        element: props.element,
        children: label
      })
    })]
  });
}
function CheckboxEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue,
    setValue,
    disabled,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const value = getValue(element);
  const error4 = useError(id);
  return u5("div", {
    class: "bio-properties-panel-entry bio-properties-panel-checkbox-entry",
    "data-entry-id": id,
    children: [u5(Checkbox, {
      disabled,
      id,
      label,
      onChange: setValue,
      onFocus,
      onBlur,
      value,
      tooltip,
      element
    }, element), error4 && u5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), u5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$5(node2) {
  return node2 && !!node2.checked;
}
function prefixId$4(id) {
  return `bio-properties-panel-${id}`;
}
function List2(props) {
  const {
    id,
    element,
    items = [],
    component,
    label = "<empty>",
    open: shouldOpen,
    onAdd,
    onRemove,
    autoFocusEntry,
    ...restProps
  } = props;
  const [open3, setOpen] = h4(!!shouldOpen);
  const hasItems = !!items.length;
  const toggleOpen = () => hasItems && setOpen(!open3);
  const elementChanged = usePrevious(element) !== element;
  const newItems = useNewItems(items, elementChanged);
  p4(() => {
    if (open3 && !hasItems) {
      setOpen(false);
    }
  }, [open3, hasItems]);
  function addItem(event2) {
    event2.stopPropagation();
    onAdd();
    if (!open3) {
      setOpen(true);
    }
  }
  return u5("div", {
    "data-entry-id": id,
    class: (0, import_classnames.default)("bio-properties-panel-entry", "bio-properties-panel-list-entry", hasItems ? "" : "empty", open3 ? "open" : ""),
    children: [u5("div", {
      class: "bio-properties-panel-list-entry-header",
      onClick: toggleOpen,
      children: [u5("div", {
        title: label,
        class: (0, import_classnames.default)("bio-properties-panel-list-entry-header-title", open3 && "open"),
        children: label
      }), u5("div", {
        class: "bio-properties-panel-list-entry-header-buttons",
        children: [u5("button", {
          type: "button",
          title: "Create new list item",
          onClick: addItem,
          class: "bio-properties-panel-add-entry",
          children: [u5(CreateIcon, {}), !hasItems ? u5("span", {
            class: "bio-properties-panel-add-entry-label",
            children: "Create"
          }) : null]
        }), hasItems && u5("div", {
          title: `List contains ${items.length} item${items.length != 1 ? "s" : ""}`,
          class: "bio-properties-panel-list-badge",
          children: items.length
        }), hasItems && u5("button", {
          type: "button",
          title: "Toggle list item",
          class: "bio-properties-panel-arrow",
          children: u5(ArrowIcon, {
            class: open3 ? "bio-properties-panel-arrow-down" : "bio-properties-panel-arrow-right"
          })
        })]
      })]
    }), hasItems && u5(ItemsList, {
      ...restProps,
      autoFocusEntry,
      component,
      element,
      id,
      items,
      newItems,
      onRemove,
      open: open3
    })]
  });
}
function ItemsList(props) {
  const {
    autoFocusEntry,
    component: Component2,
    element,
    id,
    items,
    newItems,
    onRemove,
    open: open3,
    ...restProps
  } = props;
  const getKey = useKeyFactory();
  const newItem = newItems[0];
  p4(() => {
    if (newItem && autoFocusEntry) {
      const entry = query(`[data-entry-id="${id}"]`);
      const selector = typeof autoFocusEntry === "boolean" ? ".bio-properties-panel-input" : autoFocusEntry;
      const focusableInput = query(selector, entry);
      if (focusableInput) {
        if (isFunction(focusableInput.select)) {
          focusableInput.select();
        } else if (isFunction(focusableInput.focus)) {
          focusableInput.focus();
        }
      }
    }
  }, [newItem, autoFocusEntry, id]);
  return u5("ol", {
    class: (0, import_classnames.default)("bio-properties-panel-list-entry-items", open3 ? "open" : ""),
    children: items.map((item, index5) => {
      const key = getKey(item);
      return u5("li", {
        class: "bio-properties-panel-list-entry-item",
        children: [u5(Component2, {
          ...restProps,
          element,
          id,
          index: index5,
          item,
          open: item === newItem
        }), onRemove && u5("button", {
          type: "button",
          title: "Delete item",
          class: "bio-properties-panel-remove-entry bio-properties-panel-remove-list-entry",
          onClick: () => onRemove && onRemove(item),
          children: u5(DeleteIcon, {})
        })]
      }, key);
    })
  });
}
function useNewItems(items = [], shouldReset) {
  const previousItems = usePrevious(items.slice()) || [];
  if (shouldReset) {
    return [];
  }
  return previousItems ? items.filter((item) => !previousItems.includes(item)) : [];
}
function Select(props) {
  const {
    id,
    label,
    onChange,
    options = [],
    value = "",
    disabled,
    onFocus,
    onBlur,
    tooltip
  } = props;
  const ref = useShowEntryEvent(id);
  const [localValue, setLocalValue] = h4(value);
  const handleChangeCallback = ({
    target
  }) => {
    onChange(target.value);
  };
  const handleChange = (e8) => {
    handleChangeCallback(e8);
    setLocalValue(e8.target.value);
  };
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u5("div", {
    class: "bio-properties-panel-select",
    children: [u5("label", {
      for: prefixId$3(id),
      class: "bio-properties-panel-label",
      children: u5(TooltipWrapper, {
        value: tooltip,
        forId: id,
        element: props.element,
        children: label
      })
    }), u5("select", {
      ref,
      id: prefixId$3(id),
      name: id,
      class: "bio-properties-panel-input",
      onInput: handleChange,
      onFocus,
      onBlur,
      value: localValue,
      disabled,
      children: options.map((option, idx) => {
        if (option.children) {
          return u5("optgroup", {
            label: option.label,
            children: option.children.map((child, idx2) => u5("option", {
              value: child.value,
              disabled: child.disabled,
              children: child.label
            }, idx2))
          }, idx);
        }
        return u5("option", {
          value: option.value,
          disabled: option.disabled,
          children: option.label
        }, idx);
      })
    })]
  });
}
function SelectEntry(props) {
  const {
    element,
    id,
    description,
    label,
    getValue,
    setValue,
    getOptions,
    disabled,
    onFocus,
    onBlur,
    validate,
    tooltip
  } = props;
  const options = getOptions(element);
  const globalError = useError(id);
  const [localError, setLocalError] = h4(null);
  let value = getValue(element);
  p4(() => {
    if (isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate]);
  const onChange = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error4 = globalError || localError;
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [u5(Select, {
      id,
      label,
      value,
      onChange,
      onFocus,
      onBlur,
      options,
      disabled,
      tooltip,
      element
    }, element), error4 && u5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), u5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$3(node2) {
  return node2 && !!node2.value;
}
function prefixId$3(id) {
  return `bio-properties-panel-${id}`;
}
function Simple(props) {
  const {
    debounce: debounce2,
    disabled,
    element,
    getValue,
    id,
    onBlur,
    onFocus,
    setValue
  } = props;
  const value = getValue(element);
  const [localValue, setLocalValue] = h4(value);
  const handleInputCallback = F4(() => {
    return debounce2((target) => setValue(target.value.length ? target.value : void 0));
  }, [setValue, debounce2]);
  const handleInput = (e8) => {
    handleInputCallback(e8.target);
    setLocalValue(e8.target.value);
  };
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u5("div", {
    class: "bio-properties-panel-simple",
    children: u5("input", {
      id: prefixId$2(id),
      type: "text",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      "aria-label": localValue || "<empty>",
      onFocus,
      onBlur,
      value: localValue
    }, element)
  });
}
function prefixId$2(id) {
  return `bio-properties-panel-${id}`;
}
function resizeToContents(element) {
  element.style.height = "auto";
  element.style.height = `${element.scrollHeight + 2}px`;
}
function TextArea(props) {
  const {
    id,
    label,
    debounce: debounce2,
    onInput,
    value = "",
    disabled,
    monospace,
    onFocus,
    onBlur,
    autoResize = true,
    placeholder: placeholder2,
    rows = autoResize ? 1 : 2,
    tooltip
  } = props;
  const [localValue, setLocalValue] = h4(value);
  const ref = useShowEntryEvent(id);
  const visible = useElementVisible(ref.current);
  const handleInputCallback = F4(() => {
    return debounce2((target) => onInput(target.value.length ? target.value : void 0));
  }, [onInput, debounce2]);
  const handleInput = (e8) => {
    handleInputCallback(e8.target);
    autoResize && resizeToContents(e8.target);
    setLocalValue(e8.target.value);
  };
  const handleOnBlur = (e8) => {
    if (onBlur) {
      onBlur(e8);
    }
    setLocalValue(e8.target.value.trim());
  };
  y4(() => {
    autoResize && resizeToContents(ref.current);
  }, []);
  y4(() => {
    visible && autoResize && resizeToContents(ref.current);
  }, [visible]);
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u5("div", {
    class: "bio-properties-panel-textarea",
    children: [u5("label", {
      for: prefixId$1(id),
      class: "bio-properties-panel-label",
      children: u5(TooltipWrapper, {
        value: tooltip,
        forId: id,
        element: props.element,
        children: label
      })
    }), u5("textarea", {
      ref,
      id: prefixId$1(id),
      name: id,
      spellCheck: "false",
      class: (0, import_classnames.default)("bio-properties-panel-input", monospace ? "bio-properties-panel-input-monospace" : "", autoResize ? "auto-resize" : ""),
      onInput: handleInput,
      onFocus,
      onBlur: handleOnBlur,
      placeholder: placeholder2,
      rows,
      value: localValue,
      disabled,
      "data-gramm": "false"
    })]
  });
}
function TextAreaEntry(props) {
  const {
    element,
    id,
    description,
    debounce: debounce2,
    label,
    getValue,
    setValue,
    rows,
    monospace,
    disabled,
    validate,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    autoResize,
    tooltip
  } = props;
  const globalError = useError(id);
  const [localError, setLocalError] = h4(null);
  let value = getValue(element);
  p4(() => {
    if (isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate]);
  const onInput = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error4 = globalError || localError;
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [u5(TextArea, {
      id,
      label,
      value,
      onInput,
      onFocus,
      onBlur,
      rows,
      debounce: debounce2,
      monospace,
      disabled,
      placeholder: placeholder2,
      autoResize,
      tooltip,
      element
    }, element), error4 && u5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), u5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited$1(node2) {
  return node2 && !!node2.value;
}
function prefixId$1(id) {
  return `bio-properties-panel-${id}`;
}
function Textfield(props) {
  const {
    debounce: debounce2,
    disabled = false,
    id,
    label,
    onInput,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    value = "",
    tooltip
  } = props;
  const [localValue, setLocalValue] = h4(value || "");
  const ref = useShowEntryEvent(id);
  const handleInputCallback = F4(() => {
    return debounce2((target) => onInput(target.value.length ? target.value : void 0));
  }, [onInput, debounce2]);
  const handleOnBlur = (e8) => {
    if (onBlur) {
      onBlur(e8);
    }
    setLocalValue(e8.target.value.trim());
  };
  const handleInput = (e8) => {
    handleInputCallback(e8.target);
    setLocalValue(e8.target.value);
  };
  p4(() => {
    if (value === localValue) {
      return;
    }
    setLocalValue(value);
  }, [value]);
  return u5("div", {
    class: "bio-properties-panel-textfield",
    children: [u5("label", {
      for: prefixId(id),
      class: "bio-properties-panel-label",
      children: u5(TooltipWrapper, {
        value: tooltip,
        forId: id,
        element: props.element,
        children: label
      })
    }), u5("input", {
      ref,
      id: prefixId(id),
      type: "text",
      name: id,
      spellCheck: "false",
      autoComplete: "off",
      disabled,
      class: "bio-properties-panel-input",
      onInput: handleInput,
      onFocus,
      onBlur: handleOnBlur,
      placeholder: placeholder2,
      value: localValue
    })]
  });
}
function TextfieldEntry(props) {
  const {
    element,
    id,
    description,
    debounce: debounce2,
    disabled,
    label,
    getValue,
    setValue,
    validate,
    onFocus,
    onBlur,
    placeholder: placeholder2,
    tooltip
  } = props;
  const globalError = useError(id);
  const [localError, setLocalError] = h4(null);
  let value = getValue(element);
  p4(() => {
    if (isFunction(validate)) {
      const newValidationError = validate(value) || null;
      setLocalError(newValidationError);
    }
  }, [value, validate]);
  const onInput = (newValue) => {
    let newValidationError = null;
    if (isFunction(validate)) {
      newValidationError = validate(newValue) || null;
    }
    setValue(newValue, newValidationError);
    setLocalError(newValidationError);
  };
  const error4 = globalError || localError;
  return u5("div", {
    class: (0, import_classnames.default)("bio-properties-panel-entry", error4 ? "has-error" : ""),
    "data-entry-id": id,
    children: [u5(Textfield, {
      debounce: debounce2,
      disabled,
      id,
      label,
      onInput,
      onFocus,
      onBlur,
      placeholder: placeholder2,
      value,
      tooltip,
      element
    }, element), error4 && u5("div", {
      class: "bio-properties-panel-error",
      children: error4
    }), u5(Description, {
      forId: id,
      element,
      value: description
    })]
  });
}
function isEdited(node2) {
  return node2 && !!node2.value;
}
function prefixId(id) {
  return `bio-properties-panel-${id}`;
}
var DEFAULT_DEBOUNCE_TIME = 300;
function debounceInput(debounceDelay) {
  return function _debounceInput(fn2) {
    if (debounceDelay !== false) {
      var debounceTime = isNumber(debounceDelay) ? debounceDelay : DEFAULT_DEBOUNCE_TIME;
      return debounce(fn2, debounceTime);
    } else {
      return fn2;
    }
  };
}
debounceInput.$inject = ["config.debounceInput"];
var index$1 = {
  debounceInput: ["factory", debounceInput]
};
var FeelPopupModule = class {
  constructor(eventBus) {
    this._eventBus = eventBus;
  }
  /**
   * Check if the FEEL popup is open.
   * @return {Boolean}
   */
  isOpen() {
    return this._eventBus.fire("feelPopup._isOpen");
  }
  /**
   * Open the FEEL popup.
   *
   * @param {String} entryId
   * @param {Object} popupConfig
   * @param {HTMLElement} sourceElement
   */
  open(entryId, popupConfig, sourceElement) {
    return this._eventBus.fire("feelPopup._open", {
      entryId,
      popupConfig,
      sourceElement
    });
  }
  /**
   * Close the FEEL popup.
   */
  close() {
    return this._eventBus.fire("feelPopup._close");
  }
};
FeelPopupModule.$inject = ["eventBus"];
var index2 = {
  feelPopup: ["type", FeelPopupModule]
};

// node_modules/@bpmn-io/extract-process-variables/zeebe/index.mjs
function getInputOutput(element) {
  return (getElements(element, "zeebe:IoMapping") || [])[0];
}
function getInputParameters(element) {
  return getParameters(element, "inputParameters");
}
function getOutMappings(element) {
  return (getInputOutput(element) || {}).outputParameters;
}
function getInMappings(element) {
  return (getInputOutput(element) || {}).inputParameters;
}
function getInputElement(loopCharacteristics) {
  const extensionElement = getElements(loopCharacteristics, "zeebe:LoopCharacteristics")[0];
  return extensionElement && extensionElement.inputElement;
}
function getOutputCollection(loopCharacteristics) {
  const extensionElement = getElements(loopCharacteristics, "zeebe:LoopCharacteristics")[0];
  return extensionElement && extensionElement.outputCollection;
}
function getCalledDecision(element) {
  return (getElements(element, "zeebe:CalledDecision") || [])[0];
}
function getScript(element) {
  return (getElements(element, "zeebe:Script") || [])[0];
}
function getElements(element, type, property) {
  var elements = getExtensionElements(element, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters(element, property) {
  var inputOutput = getInputOutput(element);
  return inputOutput && inputOutput.get(property) || [];
}
function getExtensionElements(element, type) {
  var elements = [];
  var extensionElements = element.get("extensionElements");
  if (typeof extensionElements !== "undefined") {
    var extensionValues = extensionElements.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = filter(extensionValues, function(value) {
        return is$2(value, type);
      });
    }
  }
  return elements;
}
function is$2(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function getParents3(element) {
  var parents = [];
  var current = element;
  while (current.$parent) {
    parents.push(current.$parent);
    current = current.$parent;
  }
  return parents;
}
function eachElement2(elements, fn2, depth) {
  depth = depth || 0;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(s5, i7) {
    var filter2 = fn2(s5, i7, depth);
    if (isArray(filter2) && filter2.length) {
      eachElement2(filter2, fn2, depth + 1);
    }
  });
}
function add3(elements, e8, unique) {
  var canAdd = !unique || elements.indexOf(e8) === -1;
  if (canAdd) {
    elements.push(e8);
  }
  return canAdd;
}
function selfAndFlowElements(elements, unique, maxDepth) {
  var result = [], processedFlowElements = [];
  eachElement2(elements, function(element, i7, depth) {
    add3(result, element, unique);
    var flowElements = element.flowElements;
    if (maxDepth === -1 || depth < maxDepth) {
      if (flowElements && add3(processedFlowElements, flowElements, unique)) {
        return flowElements;
      }
    }
  });
  return result;
}
function selfAndAllFlowElements2(elements, allowDuplicates) {
  return selfAndFlowElements(elements, !allowDuplicates, -1);
}
function getElement(elementId, rootElement) {
  var allElements = selfAndAllFlowElements2(rootElement);
  return find(allElements, function(element) {
    return element.id === elementId;
  });
}
function addVariableToList(variablesList, newVariable) {
  var foundIdx = findIndex(variablesList, function(variable) {
    return variable.name === newVariable.name && variable.scope === newVariable.scope;
  });
  if (foundIdx >= 0) {
    variablesList[foundIdx].origin = combineArrays$1(
      variablesList[foundIdx].origin,
      newVariable.origin
    );
  } else {
    variablesList.push(newVariable);
  }
}
function createProcessVariable(flowElement, name2, defaultScope) {
  var scope = getScope$1(flowElement, defaultScope, name2);
  return {
    name: name2,
    origin: [flowElement],
    scope
  };
}
function getScope$1(element, globalScope, variableName) {
  var parents = getParents3(element);
  var scopedParent = find(parents, function(parent) {
    return is$1(parent, "bpmn:SubProcess") && hasInputParameter(parent, variableName);
  });
  return scopedParent ? scopedParent : globalScope;
}
function is$1(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function hasInputParameter(element, name2) {
  return find(getInputParameters(element), function(input) {
    return input.target === name2;
  });
}
function combineArrays$1(a6, b4) {
  return a6.concat(b4);
}
function extractInMappings(options) {
  var elements = options.elements, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var inMappings = getInMappings(element);
    forEach(inMappings, function(mapping) {
      var newVariable = createProcessVariable(
        element,
        mapping.target,
        element
      );
      addVariableToList(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractInputElement(options) {
  var elements = options.elements, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var loopCharacteristics = element.loopCharacteristics;
    var inputElement = loopCharacteristics && getInputElement(loopCharacteristics);
    if (inputElement) {
      var newVariable = createProcessVariable(
        element,
        inputElement,
        element
      );
      addVariableToList(processVariables, newVariable);
    }
  });
  return processVariables;
}
function extractOutMappings(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var outMappings = getOutMappings(element);
    forEach(outMappings, function(mapping) {
      var newVariable = createProcessVariable(
        element,
        mapping.target,
        containerElement
      );
      addVariableToList(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractOutputCollections(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var loopCharacteristics = element.loopCharacteristics;
    var outputCollection = loopCharacteristics && getOutputCollection(loopCharacteristics);
    if (outputCollection) {
      var newVariable = createProcessVariable(
        element,
        outputCollection,
        containerElement
      );
      addVariableToList(processVariables, newVariable);
    }
  });
  return processVariables;
}
function extractResultVariables(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var baseElement = getCalledDecision(element) || getScript(element);
    if (!baseElement) {
      return;
    }
    var resultVariable = baseElement.resultVariable;
    if (processVariables.some((x6) => x6.origin[0] === element && x6.scope === containerElement)) {
      containerElement = element;
      if (processVariables.some((variable) => variable.name === resultVariable)) {
        return processVariables;
      }
    }
    if (resultVariable) {
      var newVariable = createProcessVariable(
        element,
        resultVariable,
        containerElement
      );
      addVariableToList(processVariables, newVariable);
    }
  });
  return processVariables;
}
var extractors = [
  extractInMappings,
  extractInputElement,
  extractOutMappings,
  extractOutputCollections,
  extractResultVariables
];
function getProcessVariables(containerElement, additionalExtractors = []) {
  var processVariables = [];
  var elements = selfAndAllFlowElements2([containerElement], false);
  const allPromises = [];
  forEach([...extractors, ...additionalExtractors], function(extractor) {
    allPromises.push(extractor({
      elements,
      containerElement,
      processVariables
    }));
  });
  return Promise.all(allPromises).then(() => processVariables);
}
async function getVariablesForScope(scope, rootElement, additionalExtractors = []) {
  var allVariables = await getProcessVariables(rootElement, additionalExtractors);
  var scopeElement = getElement(scope, rootElement);
  var scopeVariables = filter(allVariables, function(variable) {
    return variable.scope.id === scopeElement.id;
  });
  var parents = getParents3(scopeElement);
  var parentsScopeVariables = filter(allVariables, function(variable) {
    return find(parents, function(parent) {
      return parent.id === variable.scope.id;
    });
  });
  return combineArrays(scopeVariables, parentsScopeVariables);
}
function getVariablesForElement(element, additionalExtractors = []) {
  return getVariablesForScope(getScope(element), getRootElement2(element), additionalExtractors);
}
function getScope(element) {
  const bo = getBusinessObject3(element);
  if (is5(element, "bpmn:Participant")) {
    return bo.processRef.id;
  }
  return bo.id;
}
function getRootElement2(element) {
  const businessObject = getBusinessObject3(element);
  if (is5(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is5(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  let parent = businessObject;
  while (parent.$parent && !is5(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function combineArrays(a6, b4) {
  return a6.concat(b4);
}
function getBusinessObject3(element) {
  return element && element.businessObject || element;
}
function is5(element, type) {
  var bo = getBusinessObject3(element);
  return bo && typeof bo.$instanceOf === "function" && bo.$instanceOf(type);
}

// node_modules/array-move/index.js
function arrayMoveMutable(array, fromIndex, toIndex) {
  const startIndex = fromIndex < 0 ? array.length + fromIndex : fromIndex;
  if (startIndex >= 0 && startIndex < array.length) {
    const endIndex = toIndex < 0 ? array.length + toIndex : toIndex;
    const [item] = array.splice(fromIndex, 1);
    array.splice(endIndex, 0, item);
  }
}

// node_modules/@bpmn-io/extract-process-variables/dist/index.mjs
function getInputOutput2(element) {
  return (getElements2(element, "camunda:InputOutput") || [])[0];
}
function getInputParameters2(element) {
  return getParameters2(element, "inputParameters");
}
function getOutputParameters(element) {
  return getParameters2(element, "outputParameters");
}
function getFormFields(element) {
  var formData = getFormData(element);
  return formData && formData.get("fields") || [];
}
function getFormData(element) {
  return getElements2(element, "camunda:FormData")[0];
}
function getOutMappings2(element) {
  return getElements2(element, "camunda:Out");
}
function getElements2(element, type, property) {
  var elements = getExtensionElements2(element, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters2(element, property) {
  var inputOutput = getInputOutput2(element);
  return inputOutput && inputOutput.get(property) || [];
}
function getExtensionElements2(element, type) {
  var elements = [];
  var extensionElements = element.get("extensionElements");
  if (typeof extensionElements !== "undefined") {
    var extensionValues = extensionElements.get("values");
    if (typeof extensionValues !== "undefined") {
      elements = filter(extensionValues, function(value) {
        return is$22(value, type);
      });
    }
  }
  return elements;
}
function is$22(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function getParents4(element) {
  var parents = [];
  var current = element;
  while (current.$parent) {
    parents.push(current.$parent);
    current = current.$parent;
  }
  return parents;
}
function eachElement3(elements, fn2, depth) {
  depth = depth || 0;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(s5, i7) {
    var filter2 = fn2(s5, i7, depth);
    if (isArray(filter2) && filter2.length) {
      eachElement3(filter2, fn2, depth + 1);
    }
  });
}
function add4(elements, e8, unique) {
  var canAdd = !unique || elements.indexOf(e8) === -1;
  if (canAdd) {
    elements.push(e8);
  }
  return canAdd;
}
function selfAndFlowElements2(elements, unique, maxDepth) {
  var result = [], processedFlowElements = [];
  eachElement3(elements, function(element, i7, depth) {
    add4(result, element, unique);
    var flowElements = element.flowElements;
    if (maxDepth === -1 || depth < maxDepth) {
      if (flowElements && add4(processedFlowElements, flowElements, unique)) {
        return flowElements;
      }
    }
  });
  return result;
}
function selfAndAllFlowElements3(elements, allowDuplicates) {
  return selfAndFlowElements2(elements, !allowDuplicates, -1);
}
function getElement2(elementId, rootElement) {
  var allElements = selfAndAllFlowElements3(rootElement);
  return find(allElements, function(element) {
    return element.id === elementId;
  });
}
function addVariableToList2(variablesList, newVariable) {
  var foundIdx = findIndex(variablesList, function(variable) {
    return variable.name === newVariable.name && variable.scope === newVariable.scope;
  });
  if (foundIdx >= 0) {
    variablesList[foundIdx].origin = combineArrays$12(
      variablesList[foundIdx].origin,
      newVariable.origin
    );
  } else {
    variablesList.push(newVariable);
  }
}
function createProcessVariable2(flowElement, name2, defaultScope) {
  var scope = getScope2(flowElement, defaultScope, name2);
  return {
    name: name2,
    origin: [flowElement],
    scope
  };
}
function getScope2(element, globalScope, variableName) {
  var parents = getParents4(element);
  var scopedParent = find(parents, function(parent) {
    return is$12(parent, "bpmn:SubProcess") && hasInputParameter2(parent, variableName);
  });
  return scopedParent ? scopedParent : globalScope;
}
function is$12(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function hasInputParameter2(element, name2) {
  return find(getInputParameters2(element), function(input) {
    return input.name === name2;
  });
}
function combineArrays$12(a6, b4) {
  return a6.concat(b4);
}
function extractOutputParameters(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var outputParameters = getOutputParameters(element);
    forEach(outputParameters, function(parameter) {
      var newVariable = createProcessVariable2(
        element,
        parameter.name,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractResultVariables2(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var resultVariable = getResultVariable(element);
    if (resultVariable) {
      var newVariable = createProcessVariable2(
        element,
        resultVariable,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    }
  });
  return processVariables;
}
function getResultVariable(element) {
  return element.get("camunda:resultVariable");
}
function extractFormFields(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var formFields = getFormFields(element);
    forEach(formFields, function(field) {
      var newVariable = createProcessVariable2(
        element,
        field.id,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    });
  });
  return processVariables;
}
function extractOutMappings2(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var outMappings = getOutMappings2(element);
    forEach(outMappings, function(mapping) {
      if (mapping.local) {
        return;
      }
      var newVariable = createProcessVariable2(
        element,
        mapping.target,
        containerElement
      );
      addVariableToList2(processVariables, newVariable);
    });
  });
  return processVariables;
}
function getEventDefinitions(element, type) {
  var eventDefinitions = element.eventDefinitions;
  if (!eventDefinitions || !type) {
    return eventDefinitions;
  }
  return filter(eventDefinitions, function(definition) {
    return is6(definition, type);
  });
}
function getErrorEventDefinitions(element) {
  return getEventDefinitions(element, "bpmn:ErrorEventDefinition");
}
function getEscalationEventDefinitions(element) {
  return getEventDefinitions(element, "bpmn:EscalationEventDefinition");
}
function is6(element, type) {
  return element && typeof element.$instanceOf === "function" && element.$instanceOf(type);
}
function extractEventDefinitionVariables(options) {
  var elements = options.elements, containerElement = options.containerElement, processVariables = options.processVariables;
  var addVariable = function(element, name2) {
    var newVariable = createProcessVariable2(
      element,
      name2,
      containerElement
    );
    addVariableToList2(processVariables, newVariable);
  };
  if (!isArray(elements)) {
    elements = [elements];
  }
  forEach(elements, function(element) {
    var errorEventDefinitions = getErrorEventDefinitions(element);
    forEach(errorEventDefinitions, function(definition) {
      var errorCodeVariable = definition.get("errorCodeVariable"), errorMessageVariable = definition.get("errorMessageVariable");
      if (errorCodeVariable) {
        addVariable(element, errorCodeVariable);
      }
      if (errorMessageVariable) {
        addVariable(element, errorMessageVariable);
      }
    });
    var escalationEventDefinitions = getEscalationEventDefinitions(element);
    forEach(escalationEventDefinitions, function(definition) {
      var escalationCodeVariable = definition.get("escalationCodeVariable");
      if (escalationCodeVariable) {
        addVariable(element, escalationCodeVariable);
      }
    });
  });
  return processVariables;
}
var extractors2 = [
  extractOutputParameters,
  extractResultVariables2,
  extractFormFields,
  extractOutMappings2,
  extractEventDefinitionVariables
];
function getProcessVariables2(containerElement, additionalExtractors = []) {
  const allPromises = [];
  var processVariables = [];
  var elements = selfAndAllFlowElements3([containerElement], false);
  forEach([...extractors2, ...additionalExtractors], function(extractor) {
    allPromises.push(
      extractor({
        elements,
        containerElement,
        processVariables
      })
    );
  });
  return Promise.all(allPromises).then(() => processVariables);
}
async function getVariablesForScope2(scope, rootElement, additionalExtractors = []) {
  var allVariables = await getProcessVariables2(rootElement, additionalExtractors);
  var scopeElement = getElement2(scope, rootElement);
  var scopeVariables = filter(allVariables, function(variable) {
    return variable.scope.id === scopeElement.id;
  });
  var parents = getParents4(scopeElement);
  var parentsScopeVariables = filter(allVariables, function(variable) {
    return find(parents, function(parent) {
      return parent.id === variable.scope.id;
    });
  });
  return combineArrays2(scopeVariables, parentsScopeVariables);
}
function combineArrays2(a6, b4) {
  return a6.concat(b4);
}

// node_modules/bpmn-js-properties-panel/dist/index.esm.js
var BpmnPropertiesPanelContext = F3({
  selectedElement: null,
  injector: null,
  getService() {
    return null;
  }
});
function useService(type, strict) {
  const {
    getService
  } = q4(BpmnPropertiesPanelContext);
  return getService(type, strict);
}
function _extends$1o() {
  return _extends$1o = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1o.apply(null, arguments);
}
var AssociationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1o({
  width: "32",
  height: "32",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /* @__PURE__ */ wn.createElement("path", {
  stroke: "#000",
  strokeWidth: "2",
  fill: "none",
  strokeDasharray: "3.3,6",
  strokeLinecap: "square",
  d: "M1.5 30.5l29-29"
}));
function _extends$1n() {
  return _extends$1n = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1n.apply(null, arguments);
}
var BusinessRuleTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1n({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zM5.296 7.398v12.665h16.87V7.398H5.296zm.718 4.386h15.433v3.44H9.985v-3.432h-.719v3.431H6.014v-3.44zm0 4.158h3.252v3.403H6.014v-3.403zm3.97 0h11.463v3.403H9.985v-3.403z"
}), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.079 8.209v3.587H21.44V8.209z"
}));
function _extends$1m() {
  return _extends$1m = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1m.apply(null, arguments);
}
var CallActivityIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1m({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M24.978 3c3.761 0 6.89 2.979 7.018 6.695l.004.238V22.4c0 3.747-3.05 6.804-6.783 6.93l-.24.003H7.023c-3.761 0-6.89-2.978-7.018-6.695L0 22.4V9.933C0 6.187 3.05 3.13 6.783 3.004L7.023 3h17.955zm0 3.667H7.022c-1.842 0-3.255 1.344-3.35 3.079l-.005.187V22.4c0 1.761 1.35 3.167 3.16 3.262l.195.005L10 25.666V15h12v10.666h2.978c1.842 0 3.255-1.344 3.35-3.079l.005-.187V9.933c0-1.761-1.35-3.166-3.16-3.261l-.195-.005zm-3.732 9.087H10.754v9.912h10.491v-9.912zm-4.475 1.817v2.658h2.658v1.542H16.77v2.658H15.23V21.77H12.57V20.23h2.658V17.57h1.542z"
}));
function _extends$1l() {
  return _extends$1l = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1l.apply(null, arguments);
}
var CollaborationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1l({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("g", {
  fillRule: "evenodd"
}, /* @__PURE__ */ wn.createElement("path", {
  fillRule: "nonzero",
  d: "M0 0v8.62h32V0H0zm1.655 7.054v-5.37h28.62v5.37H1.656zM0 23.38V32h32v-8.62H0zm1.655 7.054v-5.37h28.62v5.37H1.656z"
}), /* @__PURE__ */ wn.createElement("path", {
  d: "M24 8l4 7h-8l4-7zm0 2l-2.28 4h4.56L24 10zM23.5 21h1v3h-1zM23.5 15h1v3h-1zM8 24l-4-7h8l-4 7zm0-2l2.28-4H5.72L8 22zM7.5 8h1v3h-1zM7.5 14h1v3h-1z"
})));
function _extends$1k() {
  return _extends$1k = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1k.apply(null, arguments);
}
var ConditionalFlowIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1k({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M32 .041S20.42 5.95 14.537 8.713c1.26 1.15 2.432 2.392 3.648 3.588-5.703 5.78-3.15 3.303-8.087 8.316l-8.472 1.377L0 32l10.006-1.626.098-.598 1.279-7.873c4.975-5.052 2.403-2.555 8.118-8.346 1.218 1.214 2.43 2.435 3.648 3.648C26.29 11.018 32 .041 32 .041zM9.603 22.397L8.54 28.91 2.03 29.97l1.061-6.515 6.512-1.058z"
}));
function _extends$1j() {
  return _extends$1j = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1j.apply(null, arguments);
}
var ConnectionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1j({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M32 .06S20.33 6.014 14.403 8.798c1.27 1.16 2.451 2.41 3.676 3.616L0 30.734 1.325 32l18.08-18.32c1.227 1.223 2.448 2.453 3.676 3.676C26.247 11.12 32 .06 32 .06z"
}));
function _extends$1i() {
  return _extends$1i = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1i.apply(null, arguments);
}
var DataInputOutputAssociationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1i({
  width: "32",
  height: "32",
  xmlns: "http://www.w3.org/2000/svg"
}, props), /* @__PURE__ */ wn.createElement("path", {
  stroke: "#000",
  strokeWidth: "2",
  strokeLinecap: "round",
  strokeDasharray: "1.1,4.3",
  d: "M1.5 30.5L27 5"
}), /* @__PURE__ */ wn.createElement("path", {
  d: "M31.803.197L26.5 16.107l-1.52-1.52 3.783-11.35-11.35 3.783-1.52-1.52z"
}));
function _extends$1h() {
  return _extends$1h = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1h.apply(null, arguments);
}
var DataInputIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1h({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M20.833 0H3.488v32H28V7.36L20.833 0zm-2.105 1.818v7.507h7.454v20.857H5.306V1.818h13.422zm1.818.493l5.06 5.196h-5.06V2.311zm-9.182.86v3.744H7.081v3.222h4.283v3.743l5.7-5.354-5.7-5.354zm.808 1.868l3.711 3.487-3.71 3.487V9.329H7.888V7.723h4.283V5.039z"
}));
function _extends$1g() {
  return _extends$1g = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1g.apply(null, arguments);
}
var DataObjectIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M21.345 0H4v32h24.512V7.36L21.345 0zM19.24 1.818v7.507h7.454v20.857H5.818V1.818H19.24zm1.818.493l5.06 5.196h-5.06V2.311z"
}));
function _extends$1f() {
  return _extends$1f = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1f.apply(null, arguments);
}
var DataOutputIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M20.833 0H3.488v32H28V7.36L20.833 0zm-2.105 1.818v7.507h7.454v20.857H5.306V1.818h13.422zm1.818.493l5.06 5.196h-5.06V2.311zm-9.182.86v3.744H7.081v3.222h4.283v3.743l5.7-5.354-5.7-5.354z"
}));
function _extends$1e() {
  return _extends$1e = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1e.apply(null, arguments);
}
var DataStoreIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.008 1c-3.712 0-7.417.306-10.319.939-1.45.316-2.7.71-3.68 1.226C1.065 3.662.297 4.304.061 5.23a.823.823 0 00-.035.15L0 5.502l.017.084c-.012 7.41 0 14.46 0 22.08l.017.082c.203.985.995 1.656 1.975 2.172.98.517 2.23.91 3.68 1.226 2.902.633 6.607.94 10.319.94 3.711 0 7.416-.307 10.318-.94 1.451-.316 2.701-.71 3.68-1.226.98-.516 1.772-1.187 1.975-2.172l.017-.082V5.541a.825.825 0 000-.106v-.016l-.002-.013a.823.823 0 00-.046-.197c-.244-.916-1.007-1.55-1.943-2.044-.98-.516-2.23-.91-3.68-1.226C23.423 1.306 19.718 1 16.006 1zm0 1.646c3.62 0 7.245.308 9.968.901 1.36.297 2.497.67 3.263 1.074.612.323.932.643 1.063.882-.131.24-.451.56-1.063.882-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.901-1.361-.297-2.497-.67-3.264-1.074-.611-.322-.931-.642-1.062-.882.13-.24.451-.56 1.062-.882.767-.403 1.903-.777 3.264-1.074 2.723-.593 6.348-.9 9.968-.9zM1.664 7.647c.112.067.227.132.345.194.98.517 2.23.91 3.68 1.226 2.902.633 6.607.94 10.319.94 3.711 0 7.416-.307 10.318-.94 1.451-.316 2.701-.71 3.68-1.226.119-.062.234-.127.346-.194v1.93c-.08.245-.398.619-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.9-1.361-.298-2.497-.671-3.264-1.075-.714-.376-1.032-.75-1.112-.995v-1.93zm0 4.187c.112.067.227.132.345.195.98.516 2.23.91 3.68 1.226 2.902.632 6.607.938 10.319.938 3.711 0 7.416-.306 10.318-.938 1.451-.317 2.701-.71 3.68-1.226.119-.063.234-.128.346-.195v1.93c-.08.245-.398.619-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.901-9.968.901-3.62 0-7.245-.307-9.968-.9-1.361-.298-2.497-.67-3.264-1.075-.714-.376-1.032-.75-1.112-.995v-1.93zm0 4.188c.112.067.227.131.345.194.98.516 2.23.91 3.68 1.226 2.902.633 6.607.939 10.319.939 3.711 0 7.416-.306 10.318-.94 1.451-.316 2.701-.709 3.68-1.225.119-.063.234-.127.346-.194V27.47c-.08.245-.398.618-1.113.995-.766.404-1.902.777-3.263 1.074-2.723.594-6.349.9-9.968.9-3.62 0-7.245-.306-9.968-.9-1.361-.297-2.497-.67-3.264-1.074-.714-.377-1.032-.75-1.112-.995V16.022z"
}));
function _extends$1d() {
  return _extends$1d = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1d.apply(null, arguments);
}
var DefaultFlowIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M32 .06S20.33 6.014 14.403 8.798c1.27 1.16 2.451 2.41 3.676 3.616L6.84 23.804H.046v1.755h5.063L0 30.735 1.325 32l6.357-6.441h7.145v-1.756H9.414l9.99-10.123c1.228 1.223 2.45 2.453 3.677 3.676C26.247 11.12 32 .06 32 .06z"
}));
function _extends$1c() {
  return _extends$1c = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1c.apply(null, arguments);
}
var EndEventCancelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-3.955 3.918L8.94 12.072l3.985 3.985-3.913 3.913 3.048 3.047 3.913-3.913 3.987 3.987 3.096-3.096-3.987-3.987 3.913-3.913-3.047-3.048-3.913 3.913-3.985-3.985z"
}));
function _extends$1b() {
  return _extends$1b = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1b.apply(null, arguments);
}
var EndEventCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-.56 5.744l-7.407 5.23 7.408 5.234v-5.057c2.384 1.687 4.771 3.371 7.157 5.057V10.801l-7.157 5.054v-5.054z"
}));
function _extends$1a() {
  return _extends$1a = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1a.apply(null, arguments);
}
var EndEventErrorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm6.132 4.166l-3.633 7.363-4.516-5.874-4.102 12.131 4.599-5.91 4.743 5.427 2.909-13.137z"
}));
function _extends$19() {
  return _extends$19 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$19.apply(null, arguments);
}
var EndEventEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$19({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 3.9c-1.672 4.653-2.733 9.5-4.406 14.153 1.535-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.497-4.71-2.91-9.445-4.406-14.155z"
}));
function _extends$18() {
  return _extends$18 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$18.apply(null, arguments);
}
var EndEventLinkIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$18({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.532 18.532 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm1.78 4.065v3.555H9.779v6.713h7.994v3.554l5.828-6.91-5.828-6.912z"
}));
function _extends$17() {
  return _extends$17 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$17.apply(null, arguments);
}
var EndEventMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$17({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.532 18.532 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm-5.91 5.448l6.041 4.9 6.04-4.9H10.084zm-1.34 1.137v9.92h14.513v-9.718l-7.132 5.786-7.381-5.988z"
}));
function _extends$16() {
  return _extends$16 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$16.apply(null, arguments);
}
var EndEventMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$16({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676 0C7.943.007.834 6.45.104 14.16c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 4.958 23.394.313 16.978.032A18.529 18.529 0 0015.676 0zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.011 3.039l-7.619 5.53 2.91 8.95h9.418l2.91-8.95-7.619-5.53z"
}));
function _extends$15() {
  return _extends$15 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$15.apply(null, arguments);
}
var EndEventNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$15({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.84.042C8.654-.01 1.913 5.437.4 12.454-1.057 18.62 1.554 25.495 6.784 29.09c5.076 3.636 12.31 3.92 17.59.544 5.309-3.251 8.435-9.744 7.445-15.921C30.91 7.307 25.795 1.738 19.442.422a16.064 16.064 0 00-3.602-.38zm.382 5.01c5.28-.017 10.13 4.353 10.669 9.61.687 5.025-2.552 10.281-7.423 11.792-4.754 1.617-10.486-.447-12.962-4.856-2.74-4.575-1.574-11.094 2.768-14.27a11.05 11.05 0 016.948-2.276z"
}));
function _extends$14() {
  return _extends$14 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$14.apply(null, arguments);
}
var EndEventSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$14({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 3.492c-2.261 4.07-4.532 8.136-6.797 12.204h13.595L15.999 8.55z"
}));
function _extends$13() {
  return _extends$13 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$13.apply(null, arguments);
}
var EndEventTerminateIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$13({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.676.051C7.943.058.834 6.501.104 14.21c-.783 6.565 2.912 13.427 8.942 16.216 5.6 2.737 12.789 1.87 17.434-2.344 4.725-4.09 6.79-11.06 4.714-17.006C29.22 5.009 23.394.364 16.978.083A18.532 18.532 0 0015.676.05zm.317 5.006c5.695-.165 10.916 4.858 10.983 10.555.246 5.212-3.67 10.33-8.864 11.204-5.026 1.007-10.6-1.898-12.36-6.777-1.894-4.826.039-10.928 4.649-13.46a11.082 11.082 0 015.592-1.522zm.006 2.859c-5.264-.2-9.495 5.551-7.755 10.516 1.366 5.085 8.108 7.436 12.339 4.301 4.455-2.807 4.708-9.943.462-13.058A8.128 8.128 0 0016 7.915z"
}));
function _extends$12() {
  return _extends$12 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$12.apply(null, arguments);
}
var EventSubProcessExpandedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$12({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M7.295 4.78h1.779V3.003h-1.78V4.78zm3.558 0h1.779V3.003h-1.78V4.78zm3.557 0h1.78V3.003h-1.78V4.78zm3.558 0h1.78V3.003h-1.78V4.78zm3.558 0h1.779V3.003h-1.779V4.78zm3.558 0c.55.014 1.106-.034 1.654.045l.245-1.762c-.629-.096-1.266-.05-1.9-.061V4.78zM5.732 3.004a5.933 5.933 0 00-.915.093c.111.582.226 1.164.315 1.75.358-.101.947.098.746-.483-.096-.382.164-1.208-.146-1.36zm22.372 2.281c.427.234.812.547 1.13.915.42-.4 1.002-.777 1.33-1.18a5.863 5.863 0 00-1.593-1.289l-.867 1.554zm-25.27-1.44c-.587.354-1.11.811-1.539 1.345.47.333.96.86 1.417 1.077.299-.362.66-.673 1.065-.913-.328-.493-.55-1.055-.944-1.509zM30.515 7.26c-.563.046-.557.342-.378.784.154.25-.097.862.25.85.525-.023 1.14.043 1.612-.032a5.891 5.891 0 00-.362-2.027l-1.122.425zM.268 7.114A6.042 6.042 0 000 9.052h1.78c-.013-.5.047-1.003.208-1.478L.296 7.027l-.026.079-.002.008zM30.22 12.45H32v-1.779h-1.779v1.779zm-30.22.16h1.78v-1.779H0v1.78zm30.22 3.398H32v-1.78h-1.779v1.78zm-30.22.16h1.78v-1.779H0v1.779zm30.22 3.398H32v-1.78h-1.779v1.78zm-30.22.16h1.78v-1.78H0v1.78zm30.22 3.397H32v-1.779h-1.779v1.78zm-30.22.16h1.78v-1.778H0v1.778zm30.137 1.47a4.059 4.059 0 01-.522 1.32c.506.283 1.046.715 1.53.908a5.836 5.836 0 00.744-1.918c-.576-.094-1.209-.264-1.752-.31zm-29.984.51c.157.676.435 1.325.82 1.904l1.486-.977a4.065 4.065 0 01-.577-1.347l-1.73.42zm28.427 1.943c-.371.277-.79.49-1.234.627l.548 1.693a5.84 5.84 0 001.835-.96l-1.082-1.412-.066.05-.001.002zm-26.164 1.47c.567.413 1.21.722 1.886.907.14-.569.343-1.175.444-1.722a4.062 4.062 0 01-1.283-.624l-1.047 1.438zm3.88 1.119h1.779v-1.78h-1.78v1.78zm3.55 0h1.787v-1.78H9.846v1.78zm3.565 0h1.78v-1.78h-1.78v1.78zm3.558 0h1.78v-1.78h-1.78v1.78zm3.451 0h1.743v-1.78h-1.743v1.78zm3.665 0h1.779v-1.78h-1.78v1.78zm-1.922-.545V16.776H9.846V29.25h12.318zM10.967 17.905h10.068V27.97H10.967V17.905zm1.336 3.998v1.711h7.396v-1.711h-7.396z",
  opacity: ".97"
}));
function _extends$11() {
  return _extends$11 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$11.apply(null, arguments);
}
var GatewayComplexIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$11({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm-.327 6.79v.007l-.145.027-.118.08-.083.123-.028.145v4.954L11.793 10.8l-.125-.08-.14-.029-.144.027-.122.082-.46.46-.085.125-.026.142.028.14.08.125 3.505 3.505H9.347l-.001-.002-.145.032-.118.08-.083.122-.028.146v.652l.029.147.082.119.12.08.144.032h4.956L10.8 20.207v-.001l-.084.124-.026.142.028.14.08.124.46.461.126.082.14.029.143-.027.124-.084L15.3 17.69v4.964-.001l.028.147.082.12.12.08.144.031h.652l.148-.03.118-.08.083-.12.028-.146v-4.962l3.505 3.505.126.082.14.027.142-.027.124-.084.461-.46.083-.123s.028-.144.027-.146l-.028-.14-.082-.126-3.496-3.496h4.948l.148-.03.119-.08.082-.12.028-.147v-.652l-.028-.145-.083-.122-.119-.08s-.147-.033-.147-.031h-4.964l3.512-3.512.082-.122.029-.144-.028-.14-.084-.124-.46-.461-.123-.082-.14-.027-.145.027-.122.082-3.507 3.507V9.348l-.028-.146-.082-.122-.12-.08-.147-.029h-.652z"
}));
function _extends$10() {
  return _extends$10 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$10.apply(null, arguments);
}
var GatewayEventBasedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$10({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16 0a1.29 1.29 0 00-.918.373L.371 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.915.372A1.294 1.294 0 0016 0zm-.002 2.181l13.821 13.821-13.821 13.821-13.821-13.82L15.998 2.18zm0 5.876l-.254.185-7.377 5.355 2.915 8.964h9.433l2.915-8.964-7.631-5.54zm0 1.07l6.614 4.8-2.526 7.769h-8.175l-2.526-7.768 6.614-4.802z"
}));
function _extends$$() {
  return _extends$$ = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$$.apply(null, arguments);
}
var GatewayNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$$({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.373a1.313 1.313 0 00-1.833 0L.373 15.084zm1.806.918L16 2.182l13.821 13.82L16 29.823 2.179 16.003z"
}));
function _extends$_() {
  return _extends$_ = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$_.apply(null, arguments);
}
var GatewayOrIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$_({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm0 6.379a7.447 7.447 0 00-7.44 7.441A7.447 7.447 0 0016 23.443 7.447 7.447 0 0023.443 16a7.447 7.447 0 00-7.441-7.441zm0 .825a6.61 6.61 0 016.617 6.616A6.61 6.61 0 0116 22.618 6.61 6.61 0 019.385 16 6.61 6.61 0 0116 9.385z"
}));
function _extends$Z() {
  return _extends$Z = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$Z.apply(null, arguments);
}
var GatewayParallelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$Z({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.001 0a1.29 1.29 0 00-.917.373L.373 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.917.372A1.294 1.294 0 0016.002 0zM16 2.181l13.821 13.821L16 29.823 2.179 16.003 16 2.18zm-.377 5.708l-.168.032-.136.092-.096.14-.032.168v6.868h-6.87l-.002-.002-.166.037-.137.092v-.002l-.095.141-.033.167v.753s.032.169.034.17l.094.138.138.092.167.036h6.87v6.867l-.001-.001.033.17.095.138.138.092s.166.035.167.037h.752l.17-.036.137-.092.095-.137.033-.17v-6.867h6.868l.17-.035.137-.092.095-.137.033-.17v-.753s-.033-.165-.032-.167l-.096-.14-.138-.093s-.17-.037-.17-.035H16.81V8.323l-.033-.168-.094-.14-.138-.092-.17-.034h-.752z"
}));
function _extends$Y() {
  return _extends$Y = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$Y.apply(null, arguments);
}
var GatewayXorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$Y({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16 0a1.29 1.29 0 00-.918.373L.371 15.084a1.316 1.316 0 00.002 1.834l14.71 14.709a1.313 1.313 0 001.833 0l14.711-14.711a1.316 1.316 0 00-.002-1.834L16.915.372A1.294 1.294 0 0016 0zm-.002 2.181l13.821 13.821-13.821 13.821-13.821-13.82L15.998 2.18zm-5.162 7.69l-.166.032-.141.096-.532.532s-.097.142-.097.144l-.03.164.032.162.093.144 4.857 4.858-4.855 4.855v-.001L9.9 21l-.03.164.032.162s.093.142.093.144l.531.532.146.095.162.032.164-.03.144-.097 4.855-4.856 4.857 4.857.145.095.162.032.164-.03.144-.097.531-.532.095-.14.033-.168-.033-.162-.095-.146L17.144 16 22 11.144l.095-.14.033-.166-.033-.163-.097-.144-.532-.532-.14-.095-.163-.032-.166.032-.141.095L16 14.855l-4.858-4.858v-.002l-.144-.092-.162-.032z"
}));
function _extends$X() {
  return _extends$X = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$X.apply(null, arguments);
}
var GroupIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$X({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.34.016c-2.333.025-4.684 1.77-5.29 4.17C.608 5.848.88 7.608.804 9.314v2.922h2.041c.038-2.332-.076-4.673.062-7C3.14 3.355 4.869 1.938 6.643 2.04h8.956V.009c-3.086 0-6.173-.02-9.258 0v.007zm13.094 2.023h1.92V.009h-1.92v2.03zm5.756 0c1.265-.069 2.66.045 3.602 1.055 1.036.983 1.201 2.523 1.122 3.91v6.313h2.078c-.03-2.677.062-5.36-.047-8.032-.17-2.743-2.62-5.111-5.215-5.236-.511-.064-1.027-.02-1.54-.033v2.023zM.803 18.319h2.041v-2.026H.804v2.026zm29.11 1.084h2.08v-2.03h-2.08v2.03zM.804 26.148c.004 2.218 1.393 4.366 3.313 5.28 1.728.853 3.681.448 5.521.544.43-.112 1.29.231 1.435-.183v-1.847c-1.788-.043-3.584.094-5.365-.082-1.67-.354-2.919-2.048-2.863-3.844v-3.644H.804v3.777zm29.11-.068c.04 1.961-1.508 3.787-3.381 3.842-1.954.06-3.914.02-5.87.026v2.03c2.118-.042 4.242.08 6.355-.063 2.524-.264 4.818-2.644 4.94-5.323.08-1.039.014-2.085.035-3.126h-2.078v2.613zm-15.006 5.898h1.92v-2.03h-1.92v2.03z"
}));
function _extends$W() {
  return _extends$W = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$W.apply(null, arguments);
}
var IntermediateEventCatchCancelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$W({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.111.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.454 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.215-2.282-2.022-5.3-3.217-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.082 11.082 0 0116 5.021zm-3.956 3.946l-3.096 3.097 3.985 3.985-3.913 3.913 3.047 3.048 3.913-3.913 3.988 3.987 3.097-3.096L19.076 16l3.914-3.913-3.048-3.048-3.913 3.913-3.986-3.985zm-.002 1.222l3.988 3.987 3.913-3.913 1.826 1.826-3.913 3.913 3.985 3.986-1.873 1.873-3.985-3.985-3.913 3.913-1.827-1.827 3.914-3.913-3.988-3.987 1.873-1.873z"
}));
function _extends$V() {
  return _extends$V = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$V.apply(null, arguments);
}
var IntermediateEventCatchCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$V({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm-.56 5.772l-7.408 5.231 7.409 5.234v-5.057c2.385 1.687 4.771 3.371 7.157 5.057V10.793l-7.157 5.055v-5.055zm-.865 1.665v7.125l-5.048-3.562 5.048-3.563zm7.161 0v7.132l-5.048-3.566 5.048-3.566z"
}));
function _extends$U() {
  return _extends$U = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$U.apply(null, arguments);
}
var IntermediateEventCatchConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$U({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.97.04h-.127C8.713-.018 2.003 5.334.437 12.286c-1.51 6.123.98 13.005 6.136 16.665 5.125 3.788 12.546 4.105 17.912.623 5.272-3.276 8.33-9.766 7.325-15.916-.904-6.241-5.79-11.7-11.95-13.143A16.082 16.082 0 0015.97.04zm-.181 1.724c.115 0 .23 0 .347.003 6.625-.066 12.823 5.149 13.89 11.69 1.13 5.91-1.908 12.349-7.262 15.138-5.473 3.013-12.866 1.884-17.116-2.726C1.291 21.372.444 13.914 3.802 8.602c2.493-4.112 7.169-6.819 11.987-6.838zm.283 1.554c-.117 0-.234.002-.351.005-6.1 0-11.691 5.049-12.346 11.114-.78 5.684 2.795 11.612 8.218 13.52 5.139 1.943 11.416.101 14.624-4.38 3.461-4.583 3.262-11.538-.596-15.831-2.36-2.747-5.924-4.423-9.549-4.428zm-.078 1.695c.078 0 .156 0 .234.003 5.4 0 10.321 4.556 10.734 9.942.563 5.13-2.958 10.364-7.971 11.678-4.832 1.41-10.457-.935-12.746-5.446-2.463-4.559-1.2-10.795 3.014-13.883a11.072 11.072 0 016.735-2.294zm-5.352 4.266V22.761h10.716V9.279H10.642zm.863.866h8.987v11.75h-8.987v-11.75zm.927 1.323v.862h7.133v-.862h-7.133zm0 2.602v.866h7.133v-.866h-7.133zm0 3.008v.862h7.133v-.862h-7.133zm0 2.717v.863h7.133v-.863h-7.133z"
}));
function _extends$T() {
  return _extends$T = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$T.apply(null, arguments);
}
var IntermediateEventCatchErrorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$T({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm6.132 4.194c-1.21 2.455-2.422 4.91-3.633 7.364l-4.516-5.875-4.103 12.133 4.6-5.912c1.58 1.81 3.162 3.619 4.744 5.429L22.13 9.215zM14.383 13.1l4.295 5.445 1.073-2.387-1.027 4.131-4.384-5.157-1.778 2.75 1.821-4.782z"
}));
function _extends$S() {
  return _extends$S = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$S.apply(null, arguments);
}
var IntermediateEventCatchEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$S({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.927c-1.672 4.654-2.734 9.502-4.406 14.155 1.534-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.496-4.71-2.91-9.446-4.406-14.156zm.032 2.929c.822 2.586 1.598 5.186 2.42 7.771l-2.42-2.612c-.682.597-2.452 2.884-2.338 2.388.87-2.487 1.447-5.067 2.338-7.547z"
}));
function _extends$R() {
  return _extends$R = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$R.apply(null, arguments);
}
var IntermediateEventCatchLinkIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$R({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm1.78 4.093v3.555H9.785v6.714h7.994v3.554l5.829-6.911-5.83-6.912zm.974 2.584l3.61 4.295-3.61 4.294v-1.933h-7.88v-4.688h7.88v-1.968z"
}));
function _extends$Q() {
  return _extends$Q = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$Q.apply(null, arguments);
}
var IntermediateEventCatchMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$Q({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm-7.245 5.475v11.06h14.502v-11.06H8.754zm3.222 1.728h8.057c-1.427.878-2.854 2.806-4.281 3.016l-3.776-3.016zm9.554 1.017v6.587H10.48V13.24l5.524 4.414 5.526-4.414z"
}));
function _extends$P() {
  return _extends$P = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$P.apply(null, arguments);
}
var IntermediateEventCatchMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$P({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.073l-7.62 5.531 2.91 8.95h9.42l2.91-8.95-7.62-5.53zm0 1.067l6.604 4.794-2.523 7.757h-8.162l-2.522-7.757 6.603-4.794z"
}));
function _extends$O() {
  return _extends$O = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$O.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$O({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M10.638 9.563V23.056h10.724V9.563H10.638zm.863.866h8.995v11.76H11.5V10.43zm.928 1.324v.862h7.139v-.862h-7.14zm0 2.605v.866h7.139v-.866h-7.14zm0 3.01v.863h7.139v-.863h-7.14zm0 2.72v.863h7.139v-.864h-7.14zM15.999.308h-.004l-.188.001h-.011l-.188.004h-.011L15.41.32h-.011l-.187.008h-.005L15.2.33l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.37h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003.178-.001h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 1.023l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.62h-.005l-.005-.002-.182-.035h-.006L18.938.58l-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.43 17.783.41l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.37h-.005L17.38.368l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.328h-.011L16.6.32h-.011l-.187-.006h-.011L16.204.31h-.011L16.005.31H16zm9.016 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zm-18.381.344l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003L4.682 5l-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.595h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01L16.32 3.6h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 13.135l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187V16.7l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zm-30.21.572l-.161.001-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158-.074-.155-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178-.001-.177v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057-.159-.028zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14v-.005l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 23.019l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 27.127l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z"
}));
function _extends$N() {
  return _extends$N = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$N.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$N({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.012 9.222c-1.673 4.657-2.735 9.508-4.409 14.164 1.536-1.526 2.874-3.236 4.41-4.762l4.408 4.762c-1.497-4.712-2.911-9.451-4.409-14.164zm.032 2.93c.823 2.588 1.599 5.19 2.421 7.777l-2.42-2.614c-.683.598-2.454 2.886-2.34 2.39.871-2.489 1.448-5.07 2.34-7.552zM16.012.312c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$M() {
  return _extends$M = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$M.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$M({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M8.742 10.464v11.072h14.516V10.464H8.742zm3.224 1.73h8.066a69569 69569 0 00-4.034 3.22l-4.032-3.22zm9.565 1.018v6.594H10.469v-6.593L16 17.63l5.532-4.419zM16 0h-.005l-.188.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06h-.005L17.38.06l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0H16zm9.015 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zM6.634 3.28l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.286h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 12.826l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zM.938 15L.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 22.71l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 26.818l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z"
}));
function _extends$L() {
  return _extends$L = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$L.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$L({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M23.637 13.902l-7.625-5.535-7.624 5.535 2.912 8.956h9.425l2.912-8.956zm-1.017.33l-2.524 7.762H11.93l-2.524-7.762 6.607-4.796 6.608 4.796zM16.012.311c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$K() {
  return _extends$K = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$K.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingParallelIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$K({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M13.51 9.081v4.428H9.08v4.982h4.428v4.428h4.982V18.49h4.428v-4.982H18.49V9.081h-4.982zm.83.83h3.32v4.428h4.429v3.322H17.66v4.428h-3.32v-4.454H9.91v-3.296h4.428V9.911zM16 0h-.005l-.188.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.011L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.185.027h-.005l-.005.001-.184.029h-.005l-.005.001-.183.031-.006.001-.005.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.176.027.17.03.174.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.087-.135.061-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.145-.073-.128-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.006-.001-.183-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06h-.005L17.38.06l-.187-.015h-.005l-.005-.001-.187-.013h-.011L16.8.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0H16zm9.015 2.935l-.16.004-.158.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.126.125.124.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.084.152.084.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.16-.016.155-.046.144-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.003-.005-.002-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.003-.005-.101-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.005-.003-.004-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.004-.004-.003-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.004-.004-.132-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027zM6.634 3.28l-.161.008-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.004-.003.005-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.004-.003.005-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023zM16 3.286h-.005l-.148.001h-.01l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.047.12.048.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.139-.107-.12-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.006-.002-.005-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.142-.031-.005-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.002-.143-.025-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.011l-.147-.001H16zm-5.482 1.366l-.16.008-.157.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.005.003-.004.004-.11.096-.004.004-.004.003-.11.098-.003.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.004.004-.003.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.004-.086.118-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.03.15-.057.138-.085.119-.109.082-.105.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022zm13.91 2.116l-.162.008-.157.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.025.159.055.152.082.138.086.103.09.09.094.098.092.099.093.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.114.068.118.067.115.065.118.064.117.062.117.061.121.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.048.127.047.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.085.137.11.119.129.096.145.07.155.043.16.013.161-.017.154-.046.144-.075.126-.1.106-.12.082-.14.055-.151.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.06-.132-.001-.005-.002-.004-.061-.132-.003-.004-.002-.005-.063-.13-.002-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.074-.125-.002-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.081-.12-.003-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.118-.003-.004-.004-.004-.087-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.094-.113-.003-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.11-.004-.003-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023zM4.45 12.826l-.161.002-.158.032-.15.06-.135.088-.118.11-.094.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.005-.019.145v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.005l-.001.006-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.005.033.142v.005l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.104.102-.125.076-.142.049-.153.02-.16-.011-.161-.031-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.133-.024-.133-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.133.01-.138.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029zm26.698 1.601l-.161.01-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.025.175-.026.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.16-.062.165-.062.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.079.158-.08.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.119.13.097.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.005.002-.004.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.171.001-.005.002-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.181.001-.005.001-.005.037-.182.002-.005v-.005l.036-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02zM.938 15L.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.004.074.17.002.005.002.004.076.169.002.004.002.005.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.157-.07-.16-.068-.16-.067-.165-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15zm26.798 2.024l-.16.007-.157.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.133-.026.133-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.063.119-.062.116-.067.119-.066.116-.069.115-.069.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.107-.085.11-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.081-.12.003-.005.003-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.005.003-.004.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.002-.005.003-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.001-.006.042-.138.001-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.142.001-.005.001-.005.031-.141.001-.006.002-.005.029-.142v-.005l.002-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022zM6.841 22.71l-.16.024-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.109.04.048.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.105.004.004.004.004.103.105.004.004.004.003.105.104.003.004.004.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.004.003.005.004.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.002.126.073.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.067.005.003.004.002.13.066.004.002.005.003.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.002.133.057.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.16-.015.156-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.159-.061-.149-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.08-.11-.08-.109-.081-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006zm15.063 2.701l-.16.014-.156.044-.12.057-.06.034-.12.066-.117.064-.118.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.035-.13.036-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021.005-.001h.006l.143-.023.006-.001h.005l.143-.025h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.037h.005l.005-.002.14-.038.005-.002h.005l.14-.04.005-.002.005-.001.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.057.005-.002.005-.002.132-.057.005-.003.005-.002.132-.06.005-.001.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.003.005-.002.128-.066.005-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.003.065-.037.132-.093.112-.115.089-.135.062-.149.034-.157.003-.161-.026-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.046-.16-.016zM6.33 26.818l-.16.023-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.004.003.005.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.002.162.088.005.003.004.002.164.086.005.003.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.168.076.005.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.06.005.003.005.001.175.06.005.001.005.002.176.057.005.001.005.002.176.055.006.001.005.002.177.052.005.002.005.001.178.05.005.002.005.002.178.048.006.001.005.002.179.046.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.17-.044-.168-.046-.167-.047-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006zm19.215.087l-.16.01-.157.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.158.073-.157.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.047-.17.046-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.007.133-.016.115-.024.005-.001.005-.001.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002.005-.001.18-.046.004-.002h.005l.179-.05h.005l.005-.002.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.004-.002.005-.002.172-.068.005-.002.005-.002.171-.07.005-.001.005-.002.17-.072.005-.002.004-.002.17-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.003.167-.08.004-.002.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.003.163-.086.005-.002.005-.003.162-.088.005-.002.005-.003.161-.09.005-.002.004-.003.16-.092.005-.003.005-.002.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.003.155-.101.005-.003.004-.003.154-.104.004-.003.004-.003.153-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.112.004-.003.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02z",
  opacity: ".98"
}));
function _extends$J() {
  return _extends$J = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$J.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$J({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.012 8.816L9.21 21.026h13.606l-6.803-12.21zm0 1.776l5.332 9.57H10.681l5.331-9.57zm0-10.281c-1.448.02-2.93.157-4.302.628-.852.447-.255 1.863.66 1.574 2.255-.608 4.648-.607 6.922-.108.934.075 1.228-1.376.338-1.67C18.451.44 17.227.317 16.012.311zm9.012 2.934c-.913-.104-1.272 1.258-.454 1.648 1.834 1.36 3.293 3.185 4.31 5.22.526.776 1.842.098 1.515-.78a15.522 15.522 0 00-5.06-6.006c-.1-.044-.203-.07-.31-.082zM6.65 3.59c-.762.089-1.24.809-1.805 1.267C3.38 6.295 2.163 8.007 1.37 9.905c-.266.898 1.094 1.484 1.564.675a14.825 14.825 0 014.327-5.56c.476-.515.09-1.419-.612-1.431zm9.362.007c-.698.066-1.689-.16-2.033.635-.282.733.535 1.358 1.217 1.125 1.806-.147 3.63.203 5.293.907.902.255 1.472-1.112.656-1.573-1.6-.735-3.374-1.089-5.133-1.094zm-5.479 1.365c-.835.15-1.517.76-2.21 1.226-1.203.94-2.318 2.061-3.057 3.402-.33.904 1.063 1.552 1.547.723 1.045-1.656 2.596-2.925 4.285-3.873.545-.499.171-1.463-.565-1.478zm13.903 2.115c-.875-.07-1.22 1.173-.501 1.627 1.325 1.34 2.188 3.062 2.748 4.84.468.84 1.869.21 1.557-.699-.604-2.118-1.751-4.097-3.351-5.615a.93.93 0 00-.453-.153zM4.467 13.132c-.822-.07-.996.826-1.046 1.455-.256 1.93-.094 3.933.562 5.769.406.844 1.807.365 1.612-.551a11.498 11.498 0 01-.334-5.808.874.874 0 00-.794-.865zm26.687 1.6c-.746-.037-1.014.785-.879 1.395.043 2.393-.57 4.771-1.66 6.894-.31.884 1.02 1.536 1.53.75a15.632 15.632 0 001.821-8.372.876.876 0 00-.812-.667zm-30.197.571c-.782-.073-1.044.775-.933 1.404.068 2.414.661 4.833 1.809 6.962.534.77 1.842.076 1.505-.798a14.833 14.833 0 01-1.603-6.861.876.876 0 00-.778-.707zm26.787 2.024c-.777-.048-.952.797-1.021 1.392-.354 1.692-1.202 3.231-2.216 4.608-.407.872.925 1.638 1.48.852 1.361-1.733 2.296-3.827 2.582-6.017a.874.874 0 00-.825-.835zM6.857 23.012c-.808.018-1.082 1.122-.47 1.59 1.393 1.607 3.187 2.886 5.194 3.599.91.222 1.43-1.165.598-1.596a11.495 11.495 0 01-4.723-3.396.899.899 0 00-.599-.197zm15.057 2.7c-.81.194-1.504.76-2.325.972-1.203.458-2.5.536-3.758.664-.869.307-.573 1.728.346 1.663 2.201-.034 4.412-.626 6.293-1.778.604-.495.227-1.532-.556-1.521zM6.346 27.118c-.833.008-1.11 1.218-.395 1.617 1.986 1.602 4.358 2.749 6.868 3.226.933.076 1.227-1.376.338-1.67a14.838 14.838 0 01-6.345-3.066.929.929 0 00-.466-.107zm19.208.087c-.766.09-1.241.841-1.922 1.158-1.516.991-3.251 1.58-4.996 2.005-.872.405-.346 1.849.584 1.604 2.543-.526 4.98-1.66 6.963-3.344.47-.52.072-1.42-.63-1.423z"
}));
function _extends$I() {
  return _extends$I = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$I.apply(null, arguments);
}
var IntermediateEventCatchNonInterruptingTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$I({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.998 8.406c-3.018-.041-5.92 1.926-7.031 4.727-1.138 2.695-.51 6.012 1.537 8.103 1.99 2.141 5.268 2.93 8.014 1.927 2.878-.98 4.992-3.827 5.068-6.87.153-2.957-1.624-5.88-4.3-7.137a7.552 7.552 0 00-3.288-.75zm0 1.384c2.759-.052 5.373 1.973 6.015 4.655.704 2.578-.482 5.517-2.791 6.867-2.358 1.48-5.682 1.086-7.618-.918-2.043-1.971-2.407-5.381-.84-7.745 1.11-1.763 3.15-2.88 5.234-2.86zm1.962 1.765l-2.074 3.762c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.182l1.993-3.615c-.252-.14-.505-.278-.757-.417zm-1.965-8.268h-.158l-.147.003h-.011l-.147.005h-.011l-.146.007h-.011l-.146.009h-.011l-.146.01h-.005l-.005.001-.146.012h-.011l-.145.014h-.006l-.005.001-.05.006-.158.031-.15.06-.135.088-.117.111-.094.13-.069.147-.04.156-.01.16.019.16.049.154.076.142.102.125.123.105.14.08.152.051.16.023.134-.003.045-.005.135-.013.133-.01.136-.01.135-.007.137-.006.136-.004.136-.003h.274l.136.003.136.004.136.006.136.007.136.01.133.01.135.013.135.014.135.016.134.018.132.018.134.021.133.023.133.024.133.025.13.027.132.03.132.03.129.031.13.034.129.035.129.036.13.04.126.038.128.042.126.042.128.045.127.047.126.048.12.047.127.051.123.052.006.002.147.048.16.021.16-.009.157-.038.147-.067.131-.093.112-.116.089-.135.062-.149.033-.158.004-.16-.027-.16-.055-.151-.083-.138-.107-.121-.127-.099-.118-.063-.004-.001-.005-.003-.005-.002-.133-.056-.005-.002-.005-.002-.134-.054-.004-.002-.005-.002-.135-.053-.005-.002-.005-.002-.135-.051-.005-.002-.005-.002-.135-.05-.005-.001-.005-.002-.137-.048-.005-.001-.005-.002-.137-.046-.005-.002-.005-.002-.137-.044-.005-.002-.005-.001-.138-.043-.005-.002-.006-.001-.138-.042-.005-.001-.005-.002-.14-.04H19.4l-.005-.002-.14-.038-.005-.001-.005-.002-.14-.036-.005-.001-.005-.001-.141-.035-.005-.001-.005-.001-.142-.033-.005-.001-.005-.001-.141-.031-.006-.002h-.005l-.142-.03-.005-.001-.005-.001-.143-.028h-.005l-.005-.001-.143-.026-.006-.001-.005-.001-.143-.024-.005-.001-.006-.001-.143-.022-.006-.001h-.005l-.144-.022h-.005l-.006-.001-.144-.019h-.005l-.006-.001-.144-.017h-.006l-.005-.001-.145-.016h-.011l-.145-.014H17.1l-.005-.001-.146-.012h-.01l-.146-.01-.006-.001h-.005l-.146-.009h-.011l-.147-.006h-.01l-.147-.005h-.011l-.147-.003h-.01l-.148-.001h-.01zM10.357 4.66l-.156.037-.123.053-.06.032-.005.002-.004.003-.128.069-.004.002-.005.003-.126.07-.005.003-.004.002-.126.072-.005.003-.004.003-.125.073-.004.003-.005.003-.124.075-.004.003-.005.002-.123.077-.004.003-.005.003-.122.078-.004.003-.005.003-.121.08-.004.002-.005.003-.12.082-.005.003-.004.003-.12.083-.004.003-.004.003-.118.084-.005.003-.004.003-.118.086-.004.003-.004.003-.117.088-.004.003-.004.003-.116.089-.004.003-.004.004-.114.09-.005.003-.004.003-.113.092-.004.004-.004.003-.113.093-.004.004-.004.003-.111.095-.004.003-.005.004-.11.096-.004.004-.004.003-.109.098-.004.003-.004.004-.108.1-.004.003-.004.003-.107.101-.004.004-.004.003-.106.102-.003.004-.004.004-.105.103-.004.004-.004.004-.103.105-.004.004-.004.003-.102.106-.003.004-.004.004-.1.107-.004.004-.004.004-.099.108-.004.004-.003.004-.098.11-.003.003-.004.004-.096.11-.004.005-.003.004-.095.111-.003.004-.004.004-.093.113-.003.004-.004.004-.092.113-.003.004-.003.005-.09.114-.004.004-.003.004-.089.116-.003.004-.003.004-.088.117-.003.004-.003.005-.086.117-.003.004-.003.005-.084.118-.003.004-.003.005-.083.12-.003.003-.003.005-.082.12-.003.005-.002.004-.068.103-.076.142-.048.154-.018.16.011.161.041.156.07.146.095.13.117.11.136.086.15.06.158.03.162.002.158-.029.15-.058.138-.085.119-.108.082-.106.065-.099.075-.11.077-.113.077-.107.08-.11.08-.108.084-.108.083-.105.086-.106.086-.104.088-.104.089-.101.09-.102.093-.101.093-.099.094-.097.095-.096.098-.097.098-.095.099-.093.1-.092.103-.091.101-.089.104-.088.104-.086.106-.086.106-.083.106-.082.109-.082.108-.079.11-.078.11-.076.112-.076.112-.074.113-.072.113-.071.115-.07.115-.068.118-.067.117-.065.12-.065.054-.029.135-.088.116-.111.094-.132.068-.146.04-.156.009-.161-.02-.16-.05-.153-.078-.142-.102-.125-.123-.103-.141-.079-.153-.051-.16-.022-.16.008zm13.91 2.116l-.158.037-.147.066-.132.092-.113.116-.09.134-.063.148-.034.157-.005.162.026.159.054.152.082.139.086.102.09.09.094.098.093.099.092.1.091.103.089.101.088.104.086.104.086.106.083.105.083.108.08.108.081.11.077.107.077.112.075.111.075.114.072.113.071.113.07.115.068.117.067.115.065.118.064.117.062.118.061.12.059.119.059.122.056.121.054.12.055.125.051.123.051.125.048.123.049.127.046.126.044.125.043.128.042.129.039.126.038.13.022.076.058.15.086.137.109.119.129.096.145.07.155.043.16.013.161-.017.155-.046.143-.074.126-.1.106-.122.082-.138.055-.152.025-.16-.005-.16-.026-.132-.023-.082-.002-.005-.001-.005-.042-.139-.001-.005-.002-.005-.043-.138-.001-.005-.002-.005-.044-.137-.002-.005-.002-.005-.046-.137-.002-.005-.001-.005-.048-.137-.002-.005-.002-.005-.05-.135-.001-.005-.002-.005-.051-.135-.002-.005-.002-.005-.053-.135-.002-.005-.002-.005-.054-.133-.002-.005-.002-.005-.057-.133-.002-.005-.002-.005-.057-.132-.003-.005-.002-.005-.059-.132-.002-.005-.002-.004-.061-.132-.003-.004-.002-.005-.062-.13-.003-.005-.002-.005-.064-.13-.003-.004-.002-.005-.066-.129-.002-.004-.003-.005-.067-.128-.002-.005-.003-.004-.069-.128-.002-.004-.003-.005-.07-.126-.003-.005-.003-.004-.072-.126-.002-.005-.003-.004-.073-.125-.003-.004-.003-.005-.075-.124-.003-.004-.003-.005-.076-.123-.003-.004-.003-.005-.078-.122-.003-.004-.003-.005-.08-.121-.003-.004-.003-.005-.08-.12-.004-.005-.003-.004-.083-.12-.003-.004-.003-.004-.084-.118-.003-.005-.003-.004-.086-.117-.003-.005-.003-.004-.088-.117-.003-.004-.003-.004-.09-.116-.002-.004-.004-.004-.09-.114-.003-.005-.004-.004-.091-.113-.004-.004-.003-.004-.093-.113-.004-.004-.003-.004-.095-.111-.004-.004-.003-.004-.096-.11-.004-.005-.003-.004-.098-.109-.004-.004-.003-.004-.1-.108-.003-.004-.004-.004-.1-.107-.004-.004-.004-.004-.102-.106-.003-.003-.004-.004-.093-.095-.124-.103-.14-.08-.153-.05-.16-.023-.16.008zM4.288 12.828l-.158.032-.15.06-.135.088-.117.11-.095.131-.069.146-.035.129-.026.132v.005l-.002.005-.025.143-.001.005-.001.006-.024.143-.001.005-.001.006-.022.143-.001.006-.001.005-.02.144-.001.005-.001.006-.019.144v.005l-.001.006-.017.144v.006l-.001.005-.016.145v.011l-.014.145v.006l-.001.005-.012.146v.01l-.01.146-.001.006v.005l-.009.146v.011l-.007.146v.011l-.004.147v.011l-.003.147v.01l-.002.148v.01l.001.148v.01l.003.147v.011l.005.147v.01l.007.147v.011l.009.146v.011l.01.146v.01l.013.146v.011l.014.145v.005l.001.006.016.145v.011l.018.144v.006l.001.005.019.144v.006l.001.005.021.144v.005l.002.006.022.143v.006l.002.005.024.143v.005l.002.006.025.143.001.005.001.005.028.143.001.005.001.005.03.142v.005l.002.006.03.141.002.005.001.006.033.14v.006l.002.005.035.14v.006l.002.005.036.14.002.005.001.005.038.14.001.005.002.005.04.14v.005l.002.005.042.138.001.006.002.005.042.138.002.005.002.005.017.054.064.148.09.134.114.114.132.092.148.065.157.037.16.007.16-.023.153-.052.14-.08.123-.103.102-.126.076-.142.049-.153.02-.16-.01-.161-.032-.13-.017-.051-.039-.126-.038-.13-.037-.128-.035-.13-.033-.128-.033-.134-.03-.13-.029-.131-.026-.13-.026-.132-.024-.134-.023-.133-.02-.132-.02-.136-.017-.132-.016-.135-.014-.135-.012-.133-.012-.138-.009-.133-.007-.136-.006-.138-.004-.134-.003-.136v-.274l.003-.136.004-.134.006-.139.007-.136.01-.132.01-.139.013-.132.014-.135.016-.135.017-.132.02-.137.02-.13.023-.134.024-.133.024-.126.016-.16-.014-.161-.044-.155-.072-.145-.098-.128-.12-.108-.137-.084-.15-.057-.16-.029-.16.002zm23.286 4.202l-.156.038-.148.066-.132.092-.113.115-.09.134-.062.148-.03.127-.001.004-.023.134-.024.134-.026.132-.026.13-.03.132-.03.129-.032.134-.033.128-.035.13-.037.128-.038.13-.04.126-.04.128-.044.128-.044.126-.046.126-.048.126-.05.125-.05.125-.051.122-.054.123-.055.122-.056.12-.058.122-.06.12-.061.12-.062.119-.063.116-.067.119-.066.116-.068.115-.07.115-.07.113-.073.113-.074.112-.076.113-.077.112-.077.107-.08.11-.08.108-.085.109-.044.056-.088.135-.06.15-.033.158-.002.16.027.16.057.15.083.138.108.12.128.098.144.072.155.045.16.015.161-.016.155-.044.144-.073.128-.098.09-.099.05-.061.003-.004.003-.005.089-.115.003-.004.003-.005.088-.116.003-.004.003-.005.086-.117.003-.004.003-.005.084-.118.003-.004.003-.005.083-.12.003-.004.003-.004.082-.12.003-.005.002-.004.08-.121.003-.005.003-.004.078-.122.003-.005.003-.004.077-.123.002-.005.003-.004.075-.124.003-.005.003-.004.073-.125.003-.004.003-.005.072-.126.002-.004.003-.005.07-.126.003-.005.002-.005.07-.127.002-.004.002-.005.068-.128.002-.005.002-.004.066-.13.003-.004.002-.005.064-.13.002-.004.003-.005.062-.13.003-.005.002-.005.06-.13.003-.005.002-.005.06-.132.002-.005.002-.005.057-.132.003-.005.002-.005.056-.133.002-.005.002-.005.054-.134.002-.004.002-.005.053-.135.002-.005.002-.005.051-.135.002-.005.002-.005.05-.135.001-.005.002-.005.048-.137.001-.005.002-.005.046-.137.002-.005.002-.005.044-.137.002-.005.002-.005.042-.138.002-.005.002-.006.04-.138.002-.005.002-.005.04-.14V19.4l.002-.005.038-.14.001-.005.002-.005.036-.14.001-.005.001-.005.035-.141.001-.005.001-.005.033-.141.001-.006.001-.005.031-.141.002-.006v-.005l.03-.142.001-.005.001-.005.028-.143v-.005l.002-.005.025-.143.001-.006.001-.005.024-.143.001-.005.001-.006.001-.006.01-.161-.02-.16-.05-.154-.077-.141-.102-.125-.123-.104-.141-.079-.153-.051-.16-.022-.16.007zM6.681 22.734l-.152.053-.14.08-.122.105-.101.126-.076.142-.048.154-.018.16.011.161.041.156.07.146.077.11.04.047.003.004.003.004.095.111.003.004.004.004.096.11.004.005.003.004.098.109.003.004.004.004.1.108.003.004.003.004.101.107.004.004.003.004.102.106.004.003.004.004.103.105.004.004.004.004.105.103.004.004.003.003.106.102.004.004.004.004.107.1.004.004.004.004.108.099.004.003.004.004.11.098.003.003.004.004.11.096.005.004.004.003.11.095.005.003.004.004.113.093.004.003.004.004.113.091.004.004.005.003.114.09.004.004.004.003.116.089.004.003.004.003.117.088.004.003.004.003.118.086.004.003.005.003.118.084.004.003.005.003.119.083.004.003.005.003.12.081.005.003.004.003.121.08.005.003.004.003.122.078.005.003.004.003.123.076.005.003.004.003.124.075.005.003.004.003.125.073.004.003.005.003.126.072.004.002.005.003.126.07.005.003.004.002.128.07.004.002.005.002.128.068.005.002.004.002.13.066.004.003.005.002.13.064.004.002.005.003.13.062.005.002.004.003.132.06.004.003.005.002.132.06.005.002.005.002.132.057.005.002.005.003.133.056.005.002.005.002.133.054.005.002.005.002.13.05.154.045.16.016.161-.015.155-.045.144-.072.128-.098.108-.12.083-.138.057-.15.028-.16-.003-.16-.032-.158-.061-.15-.088-.135-.11-.117-.132-.094-.12-.058-.124-.049-.126-.051-.122-.051-.122-.054-.12-.054-.126-.058-.119-.057-.12-.06-.12-.06-.118-.063-.117-.064-.119-.066-.116-.066-.115-.068-.115-.07-.113-.07-.115-.074-.112-.074-.11-.075-.11-.076-.112-.079-.11-.08-.109-.082-.106-.082-.104-.082-.106-.086-.105-.087-.101-.086-.105-.091-.1-.09-.1-.091-.1-.094-.097-.094-.1-.098-.093-.095-.096-.1-.093-.098-.092-.101-.089-.1-.09-.102-.088-.104-.036-.043-.114-.114-.133-.091-.148-.065-.157-.036-.161-.006-.16.024zm15.063 2.691l-.156.044-.12.057-.06.034-.12.066-.116.064-.119.062-.12.061-.12.06-.118.057-.126.058-.12.054-.122.054-.122.05-.126.052-.125.05-.124.046-.127.047-.125.044-.129.043-.126.04-.13.042-.128.038-.127.036-.13.035-.131.034-.129.031-.132.03-.13.03-.135.027-.133.026-.13.023-.13.022-.137.021-.132.02-.134.017-.132.015-.138.015-.135.013-.133.01-.138.01-.136.007-.134.006-.136.004-.14.003-.16.018-.155.047-.142.076-.127.1-.105.122-.08.14-.054.151-.025.16.006.16.035.158.064.148.09.134.114.114.133.092.147.065.157.036.134.008.145-.002h.011l.147-.005h.01l.147-.007h.011l.146-.009h.011l.146-.01h.005l.005-.001.146-.012h.011l.145-.014h.005l.006-.001.145-.016h.011l.144-.018h.006l.005-.001.144-.02h.011l.144-.021h.005l.006-.002.143-.022h.006l.005-.002.143-.024h.005l.006-.002.143-.026h.005l.005-.002.143-.027.005-.001.005-.001.142-.03h.005l.005-.002.142-.03.005-.002.005-.001.142-.033.005-.001.005-.001.14-.035.006-.001.005-.001.14-.036.005-.002.005-.001.14-.038.005-.001.005-.002.14-.04h.005l.005-.002.138-.042.005-.001.006-.002.138-.043.005-.001.005-.002.137-.044.005-.002.005-.002.137-.046.005-.002.005-.001.137-.048.005-.002.005-.002.135-.05.005-.001.005-.002.135-.051.005-.002.005-.002.135-.053.005-.002.004-.002.134-.054.005-.002.005-.002.133-.056.005-.003.005-.002.132-.057.005-.002.005-.003.132-.059.005-.002.004-.002.131-.061.005-.003.005-.002.13-.062.005-.003.005-.002.13-.064.004-.002.005-.003.129-.066.004-.002.005-.003.128-.067.005-.002.004-.003.127-.069.005-.002.005-.003.126-.07.005-.003.004-.002.065-.038.132-.093.112-.115.089-.135.062-.149.034-.157.004-.161-.027-.16-.055-.15-.082-.14-.107-.12-.127-.1-.144-.073-.154-.045-.16-.017-.161.014zM15.994 0l-.187.001h-.011l-.188.004h-.011l-.187.006h-.011l-.187.008h-.005L15.2.02l-.187.01h-.005l-.005.001-.187.013h-.01L14.62.06h-.01l-.186.018h-.011l-.185.02-.005.001h-.006l-.185.022-.005.001h-.005l-.185.025h-.005l-.005.001-.184.027h-.006l-.005.001-.184.029h-.005l-.005.001-.183.031-.005.001-.006.001-.182.033-.006.001-.005.001-.182.035-.005.001-.005.001-.182.038h-.005l-.005.002-.181.04h-.005l-.005.002-.18.042-.006.001-.005.001-.18.044-.005.002h-.005l-.17.045-.152.054-.139.082-.121.106-.1.127-.074.143-.046.155-.017.16.013.16.043.156.07.145.097.13.119.108.137.085.15.058.159.03.16-.001.133-.023.165-.043.168-.041.171-.04.171-.037.172-.036.17-.033.173-.03.17-.03.177-.027.171-.025.175-.022.175-.02.175-.02.176-.016.175-.014.177-.012.176-.01.177-.007.174-.006.177-.003L16 1.73h.177l.178.004.174.006.177.007.176.01.177.012.175.014.176.017.175.018.175.02.175.023.171.025.177.027.17.03.173.03.17.033.171.036.154.033.16.02.161-.01.156-.04.146-.069.131-.094.111-.117.088-.135.06-.15.032-.158.002-.16-.027-.16-.057-.15L20 .714l-.108-.12-.128-.097-.144-.073-.129-.038-.158-.035-.005-.001-.005-.001L19.14.31h-.005l-.005-.002-.182-.035h-.006l-.005-.002-.182-.033h-.006l-.005-.002-.183-.03-.005-.001-.005-.001-.184-.029h-.005l-.006-.001-.184-.027h-.005l-.005-.001-.185-.024h-.005L17.968.12 17.783.1l-.006-.001h-.005l-.185-.02h-.006l-.005-.001L17.39.06 17.385.06h-.005l-.187-.015h-.005l-.005-.001-.187-.013h-.01L16.799.02h-.011L16.6.01h-.011l-.187-.006h-.011L16.204 0h-.011L16.005 0h-.01zm8.86 2.939l-.157.033-.15.062-.134.09-.116.111-.093.132-.067.147-.038.156-.01.161.022.16.05.153.078.141.103.124.102.087.045.034.142.106.137.105.14.11.136.11.135.112.134.115.134.117.13.115.132.122.128.12.127.122.127.125.123.126.124.128.121.13.118.128.118.132.117.133.113.134.113.136.11.136.109.137.109.142.104.14.103.14.101.142.1.144.099.146.095.145.094.147.093.15.092.15.087.149.087.15.085.152.083.155.08.152.08.155.04.081.084.138.11.119.128.096.145.072.155.043.16.013.161-.016.155-.046.143-.074.127-.099.106-.12.083-.14.055-.151.026-.16-.004-.16-.034-.158-.05-.124-.042-.085-.002-.004-.003-.005-.084-.165-.002-.004-.003-.005-.086-.164-.002-.004-.003-.005-.088-.162-.002-.005-.003-.005-.09-.161-.002-.005-.003-.004-.092-.16-.002-.005-.003-.005-.094-.16-.003-.004-.003-.004-.096-.159-.002-.004-.003-.005-.098-.157-.003-.004-.003-.005-.1-.156-.003-.004-.002-.005-.102-.154-.003-.005-.003-.004-.104-.154-.003-.004-.003-.005-.106-.152-.003-.004-.003-.005-.108-.151-.003-.004-.003-.005-.11-.15-.003-.004-.003-.004-.111-.15-.004-.003-.003-.005-.113-.147-.004-.004-.003-.005-.115-.146-.004-.004-.003-.004-.117-.145-.004-.004-.003-.004-.12-.144-.003-.004-.003-.004-.121-.142-.003-.004-.004-.004-.123-.141-.003-.004-.004-.004-.125-.14-.003-.004-.004-.004-.127-.138-.003-.004-.004-.004-.128-.136-.004-.004-.004-.004-.13-.135-.004-.004-.003-.004-.133-.134-.003-.004-.004-.003-.134-.133-.004-.003-.004-.004-.135-.13-.004-.004-.004-.004-.136-.128-.004-.004-.004-.004-.138-.126-.004-.004-.004-.003-.14-.125-.004-.004-.004-.003-.14-.123-.005-.004-.004-.003-.142-.121-.004-.004-.004-.003-.144-.12-.004-.003-.004-.003-.145-.117-.004-.004-.004-.003-.147-.115-.004-.004-.004-.003-.148-.113-.004-.003-.004-.004-.149-.111-.004-.003-.004-.004-.05-.036-.14-.083-.15-.055-.16-.027-.16.004zm-18.381.348l-.157.037-.147.066-.111.074-.04.032-.005.003-.004.004-.145.117-.004.003-.004.004-.144.119-.004.003-.004.004-.142.12-.004.004-.004.004-.141.123-.004.003-.004.004-.14.125-.004.003-.004.004-.138.126-.004.004-.004.004-.136.128-.004.004-.004.004-.135.13-.004.004-.004.003-.134.133-.004.003-.004.004-.132.134-.003.004-.004.004-.13.135-.004.004-.004.004-.128.136-.004.004-.004.004-.126.138-.004.004-.003.004-.125.14-.004.004-.003.004-.123.14-.004.005-.003.004-.121.142-.004.004-.003.004-.12.144-.003.004-.003.004-.117.145-.004.004-.003.004-.115.146-.004.005-.003.004-.113.147-.003.005-.004.004-.111.149-.003.004-.004.004-.11.15-.002.005-.003.004-.108.151-.003.005-.003.004-.106.152-.003.005-.003.004-.104.154-.003.004-.003.005-.102.154-.003.005-.002.004-.1.156-.003.005-.003.004-.098.157-.003.005-.003.004-.096.159-.002.004-.003.005-.094.16-.003.004-.002.004-.092.16-.003.005-.003.005-.09.161-.002.005-.003.005-.088.162-.002.005-.003.004-.086.164-.002.005-.002.004-.084.165-.003.005-.002.004-.082.166-.002.005-.003.004-.08.167-.002.004-.002.005-.078.168-.002.004-.002.005-.045.1-.053.153-.023.16.007.16.037.157.065.148.092.132.114.114.134.09.148.064.157.035.161.006.16-.025.152-.054.14-.08.121-.106.1-.126.065-.118.043-.095.074-.16.075-.155.077-.157.08-.155.08-.152.083-.155.085-.152.086-.15.088-.149.091-.15.094-.15.094-.147.095-.145.099-.146.1-.144.1-.142.104-.14.104-.14.11-.142.107-.137.11-.136.114-.136.113-.134.117-.133.118-.132.117-.129.122-.13.124-.127.123-.126.127-.125.127-.122.128-.12.132-.122.13-.115.133-.117.135-.115.135-.111.136-.11.037-.03.117-.11.094-.132.068-.146.04-.156.01-.161-.02-.16-.05-.154-.076-.141-.102-.125-.123-.104-.14-.08-.153-.051-.16-.023-.161.008zm24.514 11.15l-.157.04-.146.067-.131.093-.112.117-.088.135-.061.149-.033.157-.005.134.006.14.006.176.003.177.001.178-.001.177-.003.178-.006.177-.007.176-.01.177-.012.176-.015.176-.016.173-.018.175-.02.175-.024.174-.024.175-.027.17-.03.174-.03.173-.033.17-.036.172-.037.17-.04.17-.042.172-.043.168-.045.166-.048.169-.05.167-.052.168-.053.164-.056.166-.058.166-.06.161-.061.164-.063.158-.066.165-.068.16-.07.16-.07.158-.075.159-.074.155-.078.158-.081.158-.06.15-.03.158-.001.161.029.159.058.15.085.137.108.12.13.096.144.07.156.044.16.013.16-.017.155-.046.143-.074.127-.1.107-.12.07-.115.083-.164.003-.005.002-.004.082-.166.002-.005.003-.004.08-.167.002-.005.002-.004.078-.168.002-.004.002-.005.076-.169.002-.004.002-.005.074-.17.002-.004.002-.005.072-.17.002-.005.002-.005.07-.17.002-.006.001-.005.068-.172.002-.004.002-.005.065-.173.002-.005.002-.005.063-.173.002-.005.002-.005.06-.174.003-.005.001-.005.06-.175.001-.005.002-.005.057-.176.001-.005.002-.005.055-.177.001-.005.002-.005.052-.177.002-.005.001-.005.051-.178.001-.005.002-.005.048-.179.002-.005v-.005l.047-.179.001-.005.002-.005.044-.18v-.005l.002-.005.042-.18.001-.006.001-.005.04-.18.001-.006.001-.005.038-.182v-.005l.002-.005.035-.182v-.006l.002-.005.033-.182v-.006l.002-.005.03-.183.001-.005.001-.005.029-.184v-.005l.001-.006.027-.184v-.005l.001-.005.024-.185v-.005l.001-.005.022-.185v-.006l.001-.005.02-.185v-.006l.001-.005.017-.186v-.005l.001-.005.015-.187v-.005l.001-.005.013-.187v-.01l.01-.187.001-.006v-.005l.009-.187v-.011l.006-.187v-.011l.004-.188v-.011l.001-.188v-.01l-.001-.188v-.011l-.004-.188v-.011l-.006-.187v-.011l-.007-.145-.022-.16-.05-.152-.08-.141-.103-.124-.125-.102-.141-.077-.153-.05-.16-.02-.161.009zM.777 15l-.158.032-.15.06-.136.087-.117.11-.095.131-.068.146-.04.156-.012.133-.001.14v.01l.001.188v.011l.004.188v.011l.006.187v.011l.008.187v.011l.011.187v.005l.001.005.013.187v.01l.016.187v.01l.018.186v.011l.02.185.001.005v.006l.022.185.001.005v.005l.025.185v.005l.001.005.027.184v.006l.001.005.029.184v.005l.001.005.031.183.001.005.001.006.033.182.001.005.001.006.035.182.001.005.001.005.038.182v.005l.002.005.04.181v.005l.002.005.042.18.001.006.001.005.044.18.002.005v.005l.047.18.001.004.002.005.048.179.002.005.001.005.05.178.002.005.001.005.053.177.002.005.001.005.055.177.002.005.001.005.057.176.002.005.001.005.06.175.001.005.002.005.061.174.002.005.002.005.063.173.002.005.002.005.065.173.002.005.002.004.067.172.002.005.002.005.07.171.002.005.002.005.072.17.002.005.002.005.074.169.002.005.002.004.076.169.002.005.002.004.078.168.002.004.002.005.08.167.003.004.002.005.082.166.002.004.003.005.02.04.086.136.11.118.13.095.146.07.156.041.16.012.16-.019.155-.048.142-.075.126-.1.105-.123.08-.14.054-.152.024-.16-.006-.16-.036-.158-.051-.123-.018-.034-.078-.158L3.1 22.1l-.074-.16-.071-.156-.07-.162-.068-.16-.067-.164-.062-.158-.062-.164-.059-.161-.058-.166-.056-.166-.053-.164-.052-.168-.05-.167-.048-.17-.045-.165-.043-.168-.043-.172-.039-.17-.037-.17-.036-.172-.033-.17-.03-.173-.03-.174-.027-.17-.025-.175-.022-.174-.021-.175-.018-.175-.017-.173-.014-.176-.012-.176-.01-.177-.007-.176-.006-.177-.003-.178L1.73 16v-.134l-.013-.16-.044-.156-.072-.144-.097-.129-.12-.108-.137-.085-.15-.057L.938 15 .777 15zM6.17 26.842l-.152.052-.14.08-.122.105-.101.126-.076.142-.048.154-.02.16.012.161.041.156.07.146.094.13.096.093.032.026.004.003.004.004.145.117.004.003.004.004.146.115.005.003.004.004.147.113.005.003.004.004.149.111.004.003.004.003.15.11.005.003.004.003.151.108.005.003.004.003.152.106.005.003.004.003.154.104.004.003.005.003.154.102.005.002.004.003.156.1.005.003.004.003.157.098.005.003.004.002.159.096.004.003.005.003.16.094.004.003.004.002.16.092.005.003.005.002.161.09.005.003.005.003.162.088.005.002.004.002.164.087.005.002.004.002.165.084.005.003.004.002.166.082.004.002.005.003.167.08.004.002.005.002.168.078.004.002.005.002.169.076.004.002.005.002.17.074.004.002.005.002.17.072.005.002.005.002.17.07.006.002.005.001.171.068.005.002.005.002.173.065.005.002.005.002.173.063.005.002.005.002.174.061.005.002.005.001.175.06.005.001.005.002.176.057.005.001.005.002.177.055.005.001.005.002.177.052.005.002.005.001.178.051.005.001.005.002.178.048.006.002h.005l.179.047.005.001.005.002.18.044h.005l.005.002.18.042.006.001.005.001.159.035.16.02.16-.01.157-.04.146-.069.13-.094.112-.117.087-.136.06-.149.033-.158.002-.161-.028-.159-.057-.15-.084-.138-.108-.12-.128-.098-.144-.072-.128-.039-.154-.033-.168-.04-.171-.041-.169-.044-.17-.045-.166-.048-.168-.05-.165-.051-.166-.054-.166-.056-.163-.057-.165-.06-.161-.062-.164-.064-.16-.065-.16-.068-.162-.07-.157-.07-.157-.074-.157-.075-.156-.077-.153-.079-.156-.082-.153-.082-.154-.086-.15-.086-.152-.09-.148-.09-.147-.092-.149-.095-.145-.095-.144-.098-.145-.1-.143-.102-.14-.103-.14-.104-.14-.108-.139-.11-.136-.11-.027-.022-.133-.091-.148-.065-.157-.036-.161-.006-.16.024zm19.214.073l-.156.039-.146.067-.11.076-.064.051-.139.11-.14.108-.14.104-.14.103-.143.101-.145.101-.144.098-.145.095-.149.095-.148.093-.147.089-.152.09-.15.086-.154.086-.153.082-.156.082-.153.079-.156.077-.157.075-.157.073-.158.071-.16.07-.16.068-.161.065-.164.064-.161.061-.165.06-.163.058-.166.056-.166.054-.166.051-.167.05-.167.048-.17.045-.168.044-.171.042-.168.039-.17.037-.11.023-.154.047-.143.075-.126.1-.106.122-.081.139-.054.152-.025.16.006.16.035.158.063.148.09.133.114.115.132.092.148.065.157.037.16.008.133-.017.115-.024h.005l.005-.002.181-.04h.005l.005-.002.18-.042.006-.001.005-.001.18-.044.005-.002h.005l.18-.047.004-.001.005-.002.179-.048.005-.002.005-.001.178-.05.005-.002.005-.002.177-.052.005-.002.005-.001.177-.055.005-.002.005-.001.176-.057.005-.002.005-.002.175-.059.005-.001.005-.002.174-.061.005-.002.005-.002.173-.063.005-.002.005-.002.173-.065.005-.002.004-.002.172-.068.005-.001.005-.002.171-.07.005-.002.005-.002.17-.072.005-.002.005-.002.169-.074.005-.002.004-.002.169-.076.004-.002.005-.002.168-.078.004-.002.005-.002.167-.08.004-.003.005-.002.166-.082.004-.002.005-.003.165-.084.004-.002.005-.002.163-.087.005-.002.005-.002.162-.088.005-.003.005-.003.161-.09.005-.002.004-.003.16-.092.005-.002.005-.003.16-.094.004-.003.004-.003.158-.096.005-.002.004-.003.158-.098.004-.003.005-.003.156-.1.004-.003.004-.002.155-.102.005-.003.004-.003.154-.104.004-.003.005-.003.152-.106.004-.003.005-.003.151-.108.004-.003.005-.003.15-.11.004-.003.004-.003.149-.111.004-.004.004-.003.148-.113.004-.004.004-.003.147-.115.004-.004.004-.003.068-.055.116-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.05-.153-.08-.14-.103-.125-.124-.102-.142-.077-.153-.05-.16-.02-.16.009z"
}));
function _extends$H() {
  return _extends$H = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$H.apply(null, arguments);
}
var IntermediateEventCatchParallelMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$H({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.003C8.195-.157.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.408 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.215-2.282-2.022-5.3-3.217-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.082 11.082 0 0116 4.975zm-2.15 3.281v5.534H8.213v4.38h5.636v5.534h4.31V18.17h5.639v-4.38h-5.64V8.256h-4.31zm.865.865h2.583v5.534h5.635v2.65h-5.635v5.533h-2.583v-5.534h-5.64v-2.649h5.64V9.121z"
}));
function _extends$G() {
  return _extends$G = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$G.apply(null, arguments);
}
var IntermediateEventCatchSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$G({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.521L9.206 20.745h13.598L16.005 8.542zm0 1.775l5.329 9.564H10.677l5.328-9.564z"
}));
function _extends$F() {
  return _extends$F = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$F.apply(null, arguments);
}
var IntermediateEventCatchTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$F({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.97.04h-.127C8.713-.018 2.003 5.334.437 12.286c-1.51 6.123.98 13.005 6.136 16.665 5.125 3.788 12.546 4.105 17.912.623 5.272-3.276 8.33-9.766 7.325-15.916-.904-6.241-5.79-11.7-11.95-13.143A16.082 16.082 0 0015.97.04zm-.181 1.724c.115 0 .23 0 .347.003 6.625-.066 12.823 5.149 13.89 11.69 1.13 5.91-1.908 12.349-7.262 15.138-5.473 3.013-12.866 1.884-17.116-2.726C1.291 21.372.444 13.914 3.802 8.602c2.493-4.112 7.169-6.819 11.987-6.838zm.283 1.554c-.117 0-.234.002-.351.005-6.1 0-11.691 5.049-12.346 11.114-.78 5.684 2.795 11.612 8.218 13.52 5.139 1.943 11.416.101 14.624-4.38 3.461-4.583 3.262-11.538-.596-15.831-2.36-2.747-5.924-4.423-9.549-4.428zm-.078 1.695c.078 0 .156 0 .234.003 5.4 0 10.321 4.556 10.734 9.942.563 5.13-2.958 10.364-7.971 11.678-4.832 1.41-10.457-.935-12.746-5.446-2.463-4.559-1.2-10.795 3.014-13.883a11.072 11.072 0 016.735-2.294zm-.137 3.42c-2.965.02-5.792 1.968-6.884 4.722-1.137 2.693-.509 6.007 1.536 8.096 1.988 2.14 5.263 2.929 8.007 1.926 2.875-.98 4.987-3.824 5.063-6.865.154-2.954-1.622-5.875-4.295-7.13a7.545 7.545 0 00-3.427-.75zm.27 1.381c2.708.013 5.249 2.014 5.88 4.652.704 2.576-.481 5.512-2.788 6.862-2.356 1.478-5.677 1.084-7.611-.918-2.042-1.97-2.405-5.376-.839-7.738 1.11-1.762 3.146-2.877 5.229-2.857h.13zm1.831 1.764l-2.072 3.76c-.64.068-.792 1.039-.202 1.298.39.27.696-.18 1.051-.164h3.168v-.864h-3.18l1.992-3.612-.757-.418z"
}));
function _extends$E() {
  return _extends$E = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$E.apply(null, arguments);
}
var IntermediateEventNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$E({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.848.001C8.113-.093.931 6.281.125 13.983c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.207C29.105 4.938 23.55.48 17.367.06A16.448 16.448 0 0015.848 0v.001zm.293 1.727c7.113-.099 13.662 5.97 14.077 13.08.56 6.299-3.516 12.735-9.582 14.679-5.798 2.004-12.806-.12-16.283-5.237C.717 19.159.874 11.638 5.016 6.876 7.722 3.638 11.902 1.63 16.14 1.728zm-.415 1.555C9.157 3.258 3.256 9.156 3.278 15.729c-.16 5.965 4.365 11.725 10.293 12.737 5.409 1.065 11.37-1.744 13.775-6.753 2.534-4.986 1.386-11.627-2.953-15.251-2.364-2.077-5.512-3.27-8.667-3.18zm.507 1.692c5.82-.026 11.013 5.318 10.79 11.143-.024 5.3-4.313 10.267-9.636 10.803-5.075.667-10.426-2.588-11.885-7.553-1.535-4.744.494-10.46 4.925-12.885a11.072 11.072 0 015.806-1.508z"
}));
function _extends$D() {
  return _extends$D = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$D.apply(null, arguments);
}
var IntermediateEventThrowCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$D({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm-.56 5.772l-7.408 5.231 7.409 5.234v-5.057c2.385 1.687 4.771 3.371 7.157 5.057V10.747l-7.157 5.055v-5.055z"
}));
function _extends$C() {
  return _extends$C = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$C.apply(null, arguments);
}
var IntermediateEventThrowEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$C({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm.006 3.927c-1.672 4.654-2.734 9.502-4.406 14.155 1.534-1.525 2.872-3.234 4.406-4.759l4.406 4.76c-1.496-4.71-2.91-9.446-4.406-14.156z"
}));
function _extends$B() {
  return _extends$B = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$B.apply(null, arguments);
}
var IntermediateEventThrowLinkIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$B({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.049C8.195-.11.935 6.286.125 14.03c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.93 23.445.453 17.201.095c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.22.872 11.725 4.985 6.962c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 5.021c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 5.021zm1.78 4.093v3.555H9.785v6.714h7.994v3.554l5.829-6.911-5.83-6.912z"
}));
function _extends$A() {
  return _extends$A = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$A.apply(null, arguments);
}
var IntermediateEventThrowMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$A({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm-5.91 5.475l6.04 4.901 6.042-4.9H10.088zm-1.341 1.138v9.921h14.514V11.79l-7.132 5.787-7.382-5.99z"
}));
function _extends$z() {
  return _extends$z = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$z.apply(null, arguments);
}
var IntermediateEventThrowMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$z({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.073l-7.62 5.532 2.91 8.95h9.42l2.91-8.95-7.62-5.532z"
}));
function _extends$y() {
  return _extends$y = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$y.apply(null, arguments);
}
var IntermediateEventThrowSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$y({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.975.003C8.195-.156.935 6.24.125 13.985c-.855 6.55 2.741 13.46 8.74 16.314 5.666 2.847 13.012 1.99 17.71-2.33 4.745-4.162 6.727-11.243 4.532-17.206C29.09 4.884 23.445.407 17.201.049c-.408-.03-.817-.046-1.226-.046zm-.181 1.724c7.134-.269 13.84 5.68 14.399 12.804.686 6.283-3.267 12.792-9.283 14.862-5.847 2.162-13.025.06-16.557-5.141C.728 19.174.872 11.679 4.985 6.916c2.632-3.171 6.671-5.174 10.809-5.19zm.283 1.553c-6.6-.21-12.671 5.585-12.79 12.185-.292 5.964 4.129 11.817 10.034 12.953 5.47 1.198 11.584-1.613 14.025-6.702 2.525-4.97 1.396-11.585-2.912-15.216-2.282-2.021-5.3-3.216-8.357-3.22zM16 4.975c5.818-.154 11.117 5.082 11.024 10.905.103 5.384-4.23 10.5-9.636 11.043-5.075.667-10.426-2.587-11.885-7.552-1.53-4.73.48-10.428 4.888-12.864A11.083 11.083 0 0116 4.975zm.006 3.52c-2.261 4.07-4.533 8.136-6.798 12.205h13.596L16.005 8.495z"
}));
function _extends$x() {
  return _extends$x = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$x.apply(null, arguments);
}
var LaneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$x({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M0 7v18.62h32V7H0zm1.655 17.056V8.684h28.62v15.372H1.656z"
}));
function _extends$w() {
  return _extends$w = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$w.apply(null, arguments);
}
var ManualTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$w({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm4.43 1.328c-.222.005-.43.09-.606.203-.985.638-4.356 2.977-5.096 3.486-.67.46-1.12 1.153-1.38 1.974-.27.858-.235 1.793-.232 2.576.002.59.016 1.104.17 1.727.22.908.634 1.63 1.23 2.118.597.49 1.363.732 2.23.734 3.038.012 6.078.016 9.119 0 .327-.002.645-.127.848-.37.204-.241.287-.56.291-.914a1.732 1.732 0 00-.097-.625h.327c.335 0 .641-.11.852-.316.21-.206.317-.475.374-.754a1.783 1.783 0 00-.126-1.143 1.18 1.18 0 00.877-.521c.196-.306.257-.666.258-1.025.001-.375-.088-.738-.293-1.033a1.179 1.179 0 00-.958-.512h-.478c.108-.237.156-.505.155-.782-.003-.373-.098-.721-.316-.99a1.21 1.21 0 00-.943-.43c-2.273-.004-4.236.018-6.412.012l-.19-.001c.102-.104.202-.205.312-.314.337-.336.662-.652.83-.869.4-.516.46-1.215.123-1.729-.178-.272-.439-.456-.72-.494a.93.93 0 00-.148-.008zm.029.728l.022.001c.055.008.115.027.209.172.132.201.126.606-.09.884-.079.102-.431.465-.767.8-.337.334-.657.643-.815.836-.153.186-.096.338-.056.435.04.096.085.212.298.263.063.014.066.01.086.012l.066.003c2.429.027 4.986-.004 7.223-.003.194 0 .293.056.379.162.086.105.151.286.153.533 0 .257-.065.467-.155.59-.09.124-.183.182-.37.183-1.706-.001-3.411-.005-5.117-.009v.731c2.23.004 4.461.01 6.692.012.17 0 .265.06.361.2.096.138.164.364.163.615 0 .268-.058.501-.143.634-.085.132-.162.193-.385.195-2.32-.001-4.554-.006-6.688-.003v.73c1.905 0 3.809.003 5.713.001.194.005.316.09.416.26.102.173.151.442.093.728-.04.193-.102.313-.17.38-.067.065-.148.108-.343.108h-5.71l.002.734c1.445 0 2.89-.01 4.334-.001.162 0 .232.041.297.123.064.081.123.238.12.488-.003.244-.061.385-.12.455-.06.07-.127.11-.296.11-3.037.016-6.076.012-9.113 0-.735-.002-1.316-.196-1.77-.568-.454-.372-.793-.935-.986-1.728-.134-.546-.146-.978-.148-1.558-.003-.796-.018-1.664.199-2.354.222-.705.582-1.24 1.096-1.593.75-.515 4.14-2.866 5.079-3.474a.504.504 0 01.241-.087z"
}));
function _extends$v() {
  return _extends$v = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$v.apply(null, arguments);
}
var MessageFlowIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$v({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M4.073 26.607l1.295 1.296L1.325 32l-.662-.633L0 30.735l4.073-4.128zm6.953-7.046l1.296 1.296L1.325 32l7.555-7.656-1.295-1.296 1.455-1.474 1.986-2.013zM32 .06s-2.699 5.189-5.417 10.462l-.326.633c-1.14 2.214-2.265 4.407-3.176 6.2-1.228-1.222-2.449-2.452-3.676-3.675l-3.57 3.618-1.297-1.296 3.541-3.588c-.98-.964-1.932-1.958-2.923-2.91l-.753-.706c2.68-1.258 6.533-3.165 9.95-4.876l.617-.309C28.838 1.673 32 .06 32 .06zm-4.126 4.06l-.015.007-.115.057-.048.024-.115.057L17.7 9.172l5.017 4.948 5.157-10z"
}));
function _extends$u() {
  return _extends$u = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$u.apply(null, arguments);
}
var ParticipantIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$u({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M0 5v22.069h32V5H0zm30.276 1.684v18.82H6.62V6.684h23.655zm-28.62 0h3.31v18.82h-3.31V6.684z"
}));
function _extends$t() {
  return _extends$t = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$t.apply(null, arguments);
}
var ProcessIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$t({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  fillRule: "evenodd",
  d: "M16.177 0l.137.002c.452.009.9.037 1.342.082.346.036.62.303.68.646l.437 2.536c.055.319.296.57.608.655.986.269 1.923.653 2.796 1.14.28.155.624.145.885-.039l2.083-1.47a.775.775 0 01.937.022c.86.699 1.645 1.484 2.343 2.343.22.27.223.653.023.937l-1.439 2.038a.833.833 0 00-.031.896c.512.889.92 1.846 1.204 2.855a.833.833 0 00.653.601l2.435.42c.342.059.61.333.645.679a15.928 15.928 0 01.08 2.064l-.003.114c-.012.382-.038.76-.077 1.134a.775.775 0 01-.645.68l-2.396.412a.835.835 0 00-.656.61 12.511 12.511 0 01-1.2 2.917.832.832 0 00.034.892l1.396 1.978c.2.284.196.667-.023.936a16.104 16.104 0 01-2.343 2.343.775.775 0 01-.937.023l-1.99-1.404a.833.833 0 00-.88-.026c-.907.516-1.886.922-2.916 1.2a.833.833 0 00-.61.656l-.414 2.396a.775.775 0 01-.679.646 16.096 16.096 0 01-3.312 0 .775.775 0 01-.679-.646l-.423-2.452a.834.834 0 00-.598-.636 12.474 12.474 0 01-1.468-.514 12.49 12.49 0 01-1.417-.68.833.833 0 00-.878.03l-2.026 1.43a.775.775 0 01-.937-.023 16.069 16.069 0 01-2.342-2.342.774.774 0 01-.024-.936l1.402-1.986a.833.833 0 00.032-.896 12.507 12.507 0 01-1.214-2.911.833.833 0 00-.655-.606l-2.386-.412a.775.775 0 01-.646-.678 16.097 16.097 0 010-3.314.775.775 0 01.646-.678l2.386-.412a.833.833 0 00.655-.606 12.507 12.507 0 011.214-2.911.833.833 0 00-.032-.896L3.552 6.853a.774.774 0 01.023-.936 16.091 16.091 0 012.343-2.343.775.775 0 01.937-.023l2.03 1.433c.26.177.6.182.874.028.915-.512 1.88-.9 2.87-1.167a.833.833 0 00.612-.656l.424-2.46a.775.775 0 01.679-.645C14.845.032 15.348.004 15.85 0h.326zM16 6.4c-5.302 0-9.6 4.297-9.6 9.599 0 5.302 4.298 9.6 9.6 9.6s9.6-4.298 9.6-9.6-4.298-9.6-9.6-9.6zm-3 4.283c0-1.425 1.637-2.203 2.715-1.29l5.69 4.815c.794.672.794 1.91 0 2.583l-5.69 4.815c-1.078.913-2.715.134-2.715-1.29z"
}));
function _extends$s() {
  return _extends$s = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$s.apply(null, arguments);
}
var ReceiveTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$s({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zM5.23 7.764v11.577h17.55V7.764H5.23zm1.816.758h13.917l-6.959 4.577-6.958-4.577zm-1.06.21l8.018 5.274 8.018-5.275v9.853H5.987V8.73z"
}));
function _extends$r() {
  return _extends$r = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$r.apply(null, arguments);
}
var ScriptTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$r({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm2.99 3.077l-.077.045-.026.015c-1.09.646-1.84 1.239-2.336 1.818-.496.579-.735 1.162-.742 1.725-.014 1.119.812 1.958 1.544 2.708.732.75 1.385 1.456 1.446 2.041.032.298-.039.598-.364 1.008-.324.408-.911.897-1.85 1.445l-1.388.808h8.56l.101-.059c.996-.58 1.667-1.116 2.094-1.655.429-.54.603-1.107.547-1.638-.11-1.052-.967-1.818-1.688-2.556-.721-.739-1.306-1.436-1.298-2.092.004-.331.132-.7.535-1.171.402-.47 1.08-1.02 2.119-1.636l1.362-.806h-8.54zm.241.867h5.271a6.83 6.83 0 00-1.113 1.01c-.496.58-.736 1.163-.743 1.726-.014 1.119.812 1.958 1.544 2.708.732.75 1.385 1.456 1.446 2.041.032.298-.039.598-.364 1.008-.312.393-.872.862-1.753 1.386H8.728c.367-.286.658-.566.88-.847.43-.54.604-1.107.548-1.638-.11-1.052-.968-1.818-1.688-2.556-.721-.739-1.306-1.435-1.298-2.092.004-.331.132-.7.534-1.171.389-.454 1.04-.984 2.021-1.575zm-1.233 1.48v.4h4.12v-.4h-4.12zm-.154 2.158v.4H12.6v-.4H8.34zm1.931 2.158v.4h4.126v-.4H10.27zm.59 2.158v.4h4.276v-.4h-4.276z"
}));
function _extends$q() {
  return _extends$q = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$q.apply(null, arguments);
}
var SendTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$q({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm-1.38 3.16l8.332 4.717L21.78 8.16H5.114zm.021 1.745v9.309H21.8V9.905l-8.353 4.655-8.31-4.655z"
}));
function _extends$p() {
  return _extends$p = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$p.apply(null, arguments);
}
var ServiceTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$p({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 3C2.916 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.012C28.015 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5zm1.22 1.681V7.84c-.329.093-.63.223-.914.382l-.83-.82-1.554 1.561.83.82c-.16.288-.285.594-.372.911l-1.177.002v2.2l1.189-.004c.109.431.345.819.58 1.165v-1.898l-1.038.004v-.737l1.034-.002.058-.294c.084-.429.252-.838.493-1.203l.165-.25-.727-.718.523-.526.728.719.247-.165c.379-.25.793-.417 1.206-.505l.291-.06-.002-1.01h.75L9.19 8.417H11.16c-.185-.221-.951-.508-1.237-.588L9.93 6.68H7.713zm2.078 2.105l.003 1.158a4.19 4.19 0 00-.915.383l-.83-.821-1.553 1.562.83.82c-.16.288-.286.593-.373.91l-1.176.003v2.2l1.188-.004c.094.326.224.624.383.905l-.85.847 1.57 1.543.847-.843c.29.161.599.286.919.373v1.198c.756.006 1.56.003 2.206.003V17.81a4.19 4.19 0 00.915-.383l.847.835 1.554-1.56-.848-.836c.16-.288.286-.594.373-.912l1.152-.007V12.75l-1.165.007a4.09 4.09 0 00-.382-.905l.805-.807-1.57-1.546-.804.806a4.16 4.16 0 00-.915-.372l.007-1.147H9.792zm.732.73h.751l-.006 1.005.297.058c.43.085.844.252 1.21.492l.25.162.701-.704.528.52-.702.704.169.25c.248.374.412.779.505 1.196l.061.292 1.016-.006v.737l-1.01.006-.058.292c-.085.43-.252.838-.494 1.205l-.165.25.744.733-.523.525-.743-.734-.248.165c-.378.247-.789.418-1.203.503l-.294.058v1.067h-.745v-1.059l-.295-.057a3.395 3.395 0 01-1.21-.492l-.248-.162-.747.743-.528-.52.747-.744-.17-.25a3.546 3.546 0 01-.506-1.196l-.06-.291-1.04.004v-.738l1.034-.002.058-.294c.085-.428.252-.837.493-1.203l.165-.25-.726-.718.522-.526.728.72.248-.166a3.546 3.546 0 011.205-.504l.292-.06-.003-1.01zm.388 2.685a1.65 1.65 0 00-1.645 1.645c0 .904.74 1.645 1.645 1.645a1.65 1.65 0 001.645-1.645 1.65 1.65 0 00-1.645-1.645zm0 .73a.91.91 0 01.915.915.91.91 0 01-.915.914.91.91 0 01-.915-.914.91.91 0 01.915-.915z"
}));
function _extends$o() {
  return _extends$o = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$o.apply(null, arguments);
}
var StartEventCompensationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$o({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm-.566 9.03l-7.415 5.235 7.415 5.238v-5.062c2.386 1.689 4.775 3.375 7.163 5.062V10.761l-7.163 5.058v-5.058zm-.866 1.666v7.13L9.51 15.993l5.052-3.565zm7.166 0v7.137l-5.052-3.568 5.052-3.569z"
}));
function _extends$n() {
  return _extends$n = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$n.apply(null, arguments);
}
var StartEventConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$n({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16 0C7.174 0 0 7.174 0 16s7.174 16 16 16 16-7.174 16-16S24.826 0 16 0zm0 1.73c7.892 0 14.27 6.378 14.27 14.27 0 7.891-6.379 14.27-14.27 14.27S1.73 23.891 1.73 16C1.73 8.108 8.108 1.73 16 1.73zm-5.362 7.523v13.493h10.724V9.253H10.638zm.863.866h8.995V21.88H11.501V10.12zm.928 1.324v.863h7.139v-.863h-7.139zm0 2.605v.867h7.139v-.867h-7.139zm0 3.01v.864h7.139v-.863h-7.139zm0 2.72v.863h7.139v-.863h-7.139z"
}));
function _extends$m() {
  return _extends$m = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$m.apply(null, arguments);
}
var StartEventErrorIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$m({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.995.005C9.705-.08 3.643 3.968 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994.005zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626-4.814-3.838-6.538-10.939-4.067-16.57 2.14-5.205 7.515-8.774 13.147-8.708zm6.13 7.45l-3.635 7.37-4.52-5.88c-1.37 4.048-2.738 8.095-4.106 12.143l4.603-5.917 4.748 5.433 2.91-13.149zm-7.754 3.889l4.299 5.449 1.073-2.39-1.028 4.135-4.387-5.16-1.78 2.75 1.823-4.784z"
}));
function _extends$l() {
  return _extends$l = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$l.apply(null, arguments);
}
var StartEventEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$l({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm0 7.183c-1.674 4.658-2.736 9.509-4.41 14.166 1.535-1.526 2.874-3.236 4.41-4.763l4.41 4.763c-1.499-4.713-2.913-9.453-4.41-14.166zm.032 2.931c.822 2.588 1.598 5.19 2.42 7.778l-2.42-2.615c-.683.598-2.455 2.887-2.34 2.39.871-2.489 1.448-5.07 2.34-7.553z"
}));
function _extends$k() {
  return _extends$k = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$k.apply(null, arguments);
}
var StartEventMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$k({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm-7.257 8.732v11.069h14.513v-11.07H8.738zm3.224 1.73h8.064c-1.428.878-2.857 2.807-4.285 3.018l-3.779-3.019zm9.562 1.017v6.593H10.465V13.21l5.528 4.417 5.53-4.418z"
}));
function _extends$j() {
  return _extends$j = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$j.apply(null, arguments);
}
var StartEventMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$j({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.995.001C9.705-.084 3.643 3.964 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994 0zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626C2.101 23.171.377 16.07 2.848 10.44c2.14-5.205 7.515-8.774 13.147-8.708zm0 6.328l-7.626 5.536c.97 2.986 1.942 5.971 2.913 8.957h9.426l2.912-8.957-7.625-5.536zm0 1.068l6.609 4.798-2.525 7.763H11.91l-2.524-7.763 6.609-4.798z"
}));
function _extends$i() {
  return _extends$i = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$i.apply(null, arguments);
}
var StartEventNonInterruptingConditionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$i({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M10.632 9.189V22.68h10.723V9.189H10.632zm.862.865h8.994v11.76H11.494v-11.76zm.928 1.324v.863h7.138v-.863h-7.138zm0 2.605v.866h7.138v-.866h-7.138zm0 3.01v.863h7.138v-.863h-7.138zm0 2.72v.862h7.138v-.863h-7.138zM16.12 0h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136-.109-.118-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006l-.216-.042-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006l-.006-.001-.22-.017-.005-.001h-.006L17.06.03h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012L16.132 0h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zM6.377 3.21l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1v.003l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114v-.008l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V15.95l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z"
}));
function _extends$h() {
  return _extends$h = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$h.apply(null, arguments);
}
var StartEventNonInterruptingEscalationIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$h({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16 9.209c-1.674 4.655-2.735 9.504-4.408 14.16 1.534-1.526 2.873-3.235 4.407-4.761l4.408 4.76c-1.497-4.71-2.91-9.448-4.408-14.16zm.031 2.93c.822 2.586 1.598 5.187 2.42 7.774l-2.42-2.614c-.682.598-2.453 2.886-2.34 2.389.873-2.488 1.45-5.068 2.34-7.55zM16.132.364c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.564c-.734.078-1.196.762-1.735 1.206C3.552 6.02 2.55 7.511 1.681 9.053c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786A15.932 15.932 0 011.728 16a.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$g() {
  return _extends$g = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$g.apply(null, arguments);
}
var StartEventNonInterruptingMessageIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$g({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M8.746 10.393v11.064h14.506V10.393H8.746zm3.223 1.728h8.06c-1.428.879-2.856 2.807-4.283 3.018l-3.777-3.018zm9.557 1.018v6.59H10.473v-6.59l5.525 4.416 5.528-4.416zM16.132 0c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.2c-.734.078-1.196.762-1.735 1.206C3.552 5.656 2.55 7.147 1.681 8.69c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786a15.932 15.932 0 01-1.672-6.874.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$f() {
  return _extends$f = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$f.apply(null, arguments);
}
var StartEventNonInterruptingMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$f({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M23.621 13.524L16 7.99l-7.622 5.534 2.911 8.952h9.422l2.911-8.952zm-1.016.33l-2.523 7.759h-8.165l-2.524-7.76L16 9.059l6.606 4.796zM16.132 0c-1.51.016-3.055.139-4.492.614-.854.442-.266 1.861.651 1.578 2.266-.58 4.656-.596 6.944-.144.935.063 1.21-1.391.318-1.674-1.118-.26-2.274-.361-3.42-.374zm8.865 2.777c-.931-.1-1.262 1.29-.425 1.666 1.863 1.364 3.222 3.298 4.322 5.296.617.737 1.875-.145 1.398-.979-1.184-2.275-2.808-4.384-4.923-5.866a.863.863 0 00-.372-.117zM6.55 3.2c-.734.078-1.196.762-1.735 1.206C3.552 5.656 2.55 7.147 1.681 8.69c-.31.533-.71 1.33-.03 1.767.615.432 1.282-.132 1.446-.742.796-1.475 1.746-2.89 2.934-4.08.43-.548 1.292-.822 1.34-1.595a.874.874 0 00-.822-.839zm24.582 11.078c-.771-.033-1.004.82-.873 1.437.13 2.395-.471 4.797-1.615 6.897-.33.876.984 1.559 1.512.785a14.276 14.276 0 001.761-8.54.865.865 0 00-.785-.579zm-30.195.666c-.774-.06-1.032.785-.905 1.407.117 2.41.732 4.81 1.858 6.945.528.774 1.84.09 1.51-.786a15.932 15.932 0 01-1.672-6.874.876.876 0 00-.79-.692zm24.57 11.817c-.762.099-1.243.835-1.919 1.16-1.514 1.002-3.237 1.632-4.978 2.092-.864.423-.307 1.855.616 1.591 2.528-.578 4.93-1.75 6.913-3.421.469-.522.07-1.42-.631-1.422zm-19.16.042c-.845.001-1.12 1.228-.395 1.628 1.665 1.401 3.667 2.348 5.76 2.912.618.178 1.482.565 1.893-.177.355-.628-.226-1.297-.87-1.326-1.972-.515-3.912-1.285-5.5-2.594-.26-.213-.522-.472-.888-.443z"
}));
function _extends$e() {
  return _extends$e = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$e.apply(null, arguments);
}
var StartEventNonInterruptingParallelMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$e({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M13.503 9.016v4.428H9.075v4.98h4.428v4.428h4.98v-4.427h4.428v-4.981h-4.427V9.016h-4.981zm.83.83h3.32v4.428h4.428v3.32h-4.428v4.428h-3.32v-4.454H9.905v-3.294h4.428V9.846zM16.12 0h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136-.109-.118-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006l-.216-.042-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006l-.006-.001-.22-.017-.005-.001h-.006L17.06.03h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012L16.132 0h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zM6.377 3.21l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1v.003l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114v-.008l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V15.95l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z",
  opacity: ".98"
}));
function _extends$d() {
  return _extends$d = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$d.apply(null, arguments);
}
var StartEventNonInterruptingSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$d({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16.007 8.82L9.21 21.022h13.596L16.007 8.82zm0 1.775l5.328 9.563H10.68l5.327-9.563zM16.14.386c-1.571.236-4.195-.284-4.9 1.381.619 1.703 2.745.069 4.085.365 1.421-.13 2.84.2 4.235.259C21.27.784 18.19.344 17 .413a20.456 20.456 0 00-.86-.027zM25 3.162c-2.19.694.401 2.26 1.181 3.094 1.083 1.152 1.954 2.484 2.715 3.864 1.48 1.005 1.845-1.26.81-2.03-1.158-1.897-2.613-3.704-4.513-4.89l-.192-.038zm-18.438.423c-1.793.712-2.909 2.548-4.01 4.061-.773.814-2.211 3.653.005 3.211 1.123-1.469 1.87-3.306 3.267-4.614.664-.7 2.73-2.013.738-2.658zm24.57 11.072c-1.659.435-.468 2.667-.99 3.895a13.427 13.427 0 01-1.497 4.435c-.23 1.659 1.991 1.165 2.018-.199a14.277 14.277 0 001.254-7.552.865.865 0 00-.785-.579zm-30.18.666c-1.677.386-.633 2.667-.608 3.876.371 1.623.792 3.35 1.79 4.696 2.382.321.571-2.338.292-3.492a15.92 15.92 0 01-.684-4.39.877.877 0 00-.79-.69zm24.558 11.81c-1.755.865-3.303 2.266-5.274 2.765-1.162-.016-3.074 1.271-1.331 2.102 2.66-.447 5.163-1.733 7.236-3.445.472-.506.06-1.432-.631-1.421zm-19.151.043c-2.004.786.416 2.405 1.43 2.913 1.608.904 3.379 1.636 5.208 1.877 1.77-.804-.228-2.094-1.357-2.073-1.75-.537-3.403-1.396-4.798-2.586l-.227-.104-.256-.027z"
}));
function _extends$c() {
  return _extends$c = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$c.apply(null, arguments);
}
var StartEventNonInterruptingTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$c({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.991 8.7c-3.018-.042-5.92 1.925-7.03 4.725-1.138 2.695-.509 6.011 1.537 8.102 1.99 2.142 5.267 2.93 8.013 1.927 2.877-.98 4.99-3.826 5.067-6.87.153-2.956-1.624-5.88-4.299-7.135a7.551 7.551 0 00-3.288-.75zm0 1.383c2.758-.052 5.372 1.972 6.014 4.654.704 2.578-.482 5.516-2.79 6.867-2.358 1.48-5.682 1.085-7.617-.919-2.043-1.97-2.407-5.38-.84-7.743 1.11-1.764 3.149-2.88 5.233-2.86zm1.962 1.764l-2.074 3.762c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.182l1.993-3.614-.757-.418zM16.12.358h-.232l-.22.004h-.012l-.221.006h-.012l-.22.01h-.012l-.22.013h-.012l-.22.016h-.012l-.22.019h-.005l-.006.001-.22.021h-.006l-.005.001-.22.025h-.011l-.22.028h-.005l-.006.002-.219.03h-.005l-.006.001-.218.033-.006.001-.006.001-.217.036-.006.001-.006.001-.217.039-.006.001-.006.001-.216.042-.006.001-.006.001-.215.045-.006.001-.006.002-.215.047-.006.002-.006.001-.214.05-.006.002-.006.002-.115.029-.152.053-.14.081-.122.106-.1.126-.075.143-.047.154-.018.16.012.16.042.156.07.145.095.13.118.11.137.086.15.059.158.03h.161l.132-.022.11-.028.202-.047.203-.046.208-.043.202-.039.206-.037.206-.034.205-.03.208-.03.205-.025.209-.023.208-.02.21-.017.209-.015.207-.011.21-.009.21-.006.207-.003h.21l.21.002.207.005.207.008.212.011.207.014.208.017.209.019.208.022.205.025.206.028.207.03.208.035.205.036.202.039.052.01.16.018.16-.012.156-.042.146-.07.13-.096.109-.119.085-.136.06-.15.03-.159v-.16l-.03-.16-.059-.15-.086-.136L19.823.9l-.13-.096-.145-.07-.128-.038-.057-.011-.006-.002h-.006L19.135.64l-.006-.001-.006-.001-.217-.039H18.9l-.006-.002-.217-.035-.006-.001-.006-.001-.218-.032-.006-.001-.006-.001-.218-.03h-.006l-.006-.001-.219-.027h-.011l-.22-.024-.005-.001h-.006l-.22-.021h-.006L17.512.42l-.22-.017-.005-.001h-.006l-.22-.015h-.012l-.22-.012h-.012l-.22-.01h-.012l-.22-.005h-.012l-.221-.003h-.012zm8.715 2.783l-.157.034-.149.063-.134.089-.116.112-.092.132-.067.147-.038.157-.008.16.021.16.051.153.079.141.103.124.102.087.052.038h.001l.087.064v.001l.082.061.002.001.076.059h.001l.084.065.082.066.002.001.079.063.002.002.077.063.081.067.002.002.077.065.076.065.001.002.08.07.078.07h.002l.075.068.077.072.002.001.073.069.077.073.072.07.002.001.077.076.07.07v.001l.075.076.07.073.002.001.074.079.002.002.069.074.069.075.074.082.07.08.002.001.068.079h.001l.067.079.068.082.065.078.001.002.068.083.067.084.063.081.001.002.067.087.002.002.063.084.001.001.064.087.008.01.008.01.095.12.093.121.09.119.087.119.088.122.086.123.084.12.081.122.001.002.084.126.08.126.08.127.077.126.079.131.074.127.075.131.073.131.07.13.07.133.069.133.045.09.086.137.109.119.13.096.144.07.156.042.16.013.16-.017.155-.047.143-.075.126-.1.106-.121.082-.14.054-.151.025-.16-.005-.16-.035-.158-.05-.124-.048-.095-.002-.004-.002-.004-.073-.14-.002-.005-.002-.004-.074-.14-.002-.004-.002-.004-.076-.14-.002-.003-.002-.004-.077-.139-.003-.004-.002-.004-.078-.138-.003-.004-.002-.003-.08-.137-.002-.004-.003-.004-.081-.136-.002-.004-.003-.004-.083-.136-.002-.003-.002-.004-.085-.135-.002-.004-.003-.003-.085-.134-.003-.004-.002-.004-.087-.132-.003-.004-.003-.004-.088-.132-.003-.003-.002-.004-.09-.13-.003-.005-.003-.003-.091-.13-.003-.004-.002-.004-.093-.129-.003-.003-.003-.004-.094-.128-.003-.004-.003-.003-.095-.127-.003-.004-.003-.004-.097-.125-.003-.004-.003-.004-.09-.114-.06-.082-.003-.003-.002-.003-.069-.091-.002-.004-.002-.003-.07-.09-.003-.003-.002-.003-.07-.09-.003-.003-.002-.003-.071-.09-.002-.003-.003-.002-.072-.089-.002-.003-.002-.003-.073-.088-.002-.003-.002-.002-.074-.087-.002-.003-.002-.003-.074-.086-.003-.003-.002-.003-.074-.086-.003-.002-.002-.003-.075-.085-.003-.003-.002-.002-.076-.084-.002-.003-.003-.003-.076-.083-.002-.003-.003-.003-.077-.082-.002-.003-.003-.002-.077-.082-.003-.003-.003-.002-.078-.081-.002-.003-.003-.003-.078-.08-.003-.002-.003-.003-.079-.08-.002-.002-.003-.002-.08-.08-.002-.002-.003-.002-.08-.078-.003-.003-.003-.002-.08-.077-.003-.003-.003-.002-.082-.077-.002-.002-.003-.002-.082-.076-.003-.002-.002-.003-.083-.075-.003-.002-.002-.003-.084-.074-.002-.002-.003-.002-.084-.074-.003-.002-.002-.002-.085-.073-.002-.002-.003-.003-.085-.071-.003-.003-.002-.002-.086-.07-.003-.003-.002-.002-.086-.07-.003-.003-.003-.002-.086-.07-.003-.002-.003-.002-.087-.069-.002-.002-.003-.002-.088-.068-.002-.002-.003-.002-.088-.067-.003-.003-.003-.002-.088-.066-.003-.002-.003-.002-.089-.066-.003-.002-.003-.002-.057-.042-.14-.082-.15-.055-.16-.026-.16.004zm-18.458.426l-.157.037-.148.066-.111.074-.007.006-.003.002-.003.002-.086.069-.003.002-.002.002-.086.07-.003.002-.002.002-.086.07-.002.003-.003.002-.085.071-.002.002-.003.003-.084.071-.003.003-.002.002-.084.072-.003.003-.002.002-.083.073-.003.003-.002.002-.083.074-.002.002-.003.003-.082.074-.003.003-.002.002-.081.076-.003.002-.003.002-.08.077-.003.002-.003.003-.08.076-.002.003-.003.002-.08.078-.002.002-.003.003-.079.078-.002.003-.003.002-.078.08-.003.002-.002.002-.078.08-.002.003-.003.002-.077.08-.003.004-.002.002-.077.081-.002.003-.003.003-.076.082-.002.002-.003.003-.075.082-.002.003-.003.003-.074.083-.003.003-.002.003-.074.084-.003.003-.002.002-.074.085-.002.003-.002.003-.073.085-.003.003-.002.003-.072.086-.002.003-.003.003-.071.087-.003.003-.002.002-.07.088-.003.003-.002.003-.07.088-.003.003-.002.003-.07.09-.002.002-.002.003-.069.09-.002.003-.003.003-.068.09-.002.003-.002.003-.067.092-.003.003-.002.003-.067.092-.002.003-.002.003-.066.092-.002.003-.002.004-.066.093-.002.003-.002.003-.065.094-.002.003-.002.004-.064.094-.002.003-.002.004-.063.095-.002.003-.002.003-.063.097-.002.003-.002.003-.046.073-.05.07-.003.002-.002.003-.067.093-.003.003-.002.003-.066.094-.002.003-.002.003-.066.094-.002.003-.002.003-.064.094-.002.004-.002.003-.064.094-.002.004-.002.003-.062.095-.002.003-.002.003-.062.096-.002.003-.002.003-.06.096-.003.003-.002.003-.06.096-.001.004-.002.003-.059.096-.002.004-.002.003-.058.097-.002.003-.001.003-.057.098-.002.003-.002.003-.056.098-.002.003-.002.003-.055.098-.002.004-.001.003-.055.098-.001.004-.002.003-.054.099-.001.003-.002.003-.052.1-.002.002-.002.004-.051.1-.002.002-.002.004-.05.1-.002.003-.002.003-.05.1v.003l-.002.004-.05.1V9.5l-.002.004-.048.1-.002.004-.001.003-.047.101-.002.003-.001.004-.013.027-.052.152-.024.16.006.16.037.157.064.148.091.133.114.114.134.09.147.065.157.036.162.006.159-.024.152-.053.14-.08.122-.105.1-.126.066-.117.01-.023.044-.095.045-.095.002-.003.042-.087.048-.097.048-.095v-.001l.048-.092.001-.001.047-.09.05-.093.002-.002.049-.09.052-.092.001-.002.051-.089.001-.002.051-.087.053-.088.001-.002.055-.091.057-.091.057-.09.001-.002.057-.089.055-.083.001-.002.06-.09.06-.088.062-.089.001-.001.06-.084.063-.088.065-.089.017-.023.016-.025.06-.094.059-.09v-.002l.058-.086.057-.086.001-.001.062-.09.062-.088.001-.002.06-.085.002-.002.06-.082.063-.087.064-.084.002-.002.061-.08.065-.084.064-.08v-.001l.067-.083.067-.082.07-.083.069-.08.063-.074.074-.083.068-.077.002-.002.07-.076.07-.075.072-.077.001-.001.067-.07.076-.078.002-.002.07-.07.075-.075.002-.002.072-.07.075-.072.002-.002.073-.069.074-.068.001-.001.08-.073.076-.068.002-.002.072-.063v-.001l.078-.067.079-.068.002-.001.08-.068.002-.002.077-.063.082-.066.001-.001.075-.06.002-.002.006-.004.117-.111.094-.131.068-.146.04-.156.01-.161-.019-.16-.049-.154-.076-.141-.102-.125-.123-.105-.14-.079-.153-.052-.16-.023-.16.007zm24.596 11.088l-.156.04-.146.067-.131.094-.112.117-.087.135-.061.15-.033.157-.004.134.007.142.005.152.004.15.002.149v.153l.001.011v.015l.004.11.002.11v.002l.002.106v.321l-.003.102-.002.106-.004.107-.005.105-.006.106-.006.106-.008.106v.002l-.008.103v.002l-.01.1-.01.105-.01.105-.013.105-.012.099v.002l-.014.108-.014.1-.016.105-.016.103v.002l-.017.099-.018.104-.019.103v.002l-.019.097-.02.104-.022.103v.001l-.022.098-.023.103v.002l-.024.096-.025.103v.002l-.024.096-.027.102v.003l-.026.093v.001l-.029.103v.002l-.03.099-.028.097v.002l-.03.095-.03.096v.001l-.033.1-.031.095v.002l-.035.1v.003l-.034.094v.003l-.035.096v.001l-.034.09v.002l-.038.098-.036.093v.002l-.038.095-.079.194-.08.188-.085.189-.087.19-.09.184-.092.183-.095.184-.05.093-.064.148-.034.158-.005.16.026.16.054.151.082.14.106.12.127.1.143.075.154.046.16.017.161-.013.156-.042.144-.071.13-.096.109-.119.072-.112.053-.099.003-.005.003-.006.102-.195.003-.006.003-.006.098-.196.003-.006.003-.006.096-.197.002-.006.003-.006.093-.2.002-.006.003-.006.09-.2.002-.006.003-.007.086-.202.003-.006.002-.006.084-.203.002-.005.001-.005.04-.102.002-.003.001-.003.04-.103.001-.003.001-.003.04-.103v-.004l.001-.003.039-.103v-.003l.002-.003.037-.104.001-.003.001-.003.037-.104v-.004l.002-.003.035-.104.002-.003v-.004l.035-.104.002-.004v-.003l.034-.105.002-.003v-.003l.034-.105v-.004l.002-.003.032-.106.001-.003.001-.003.031-.106.001-.003.001-.004.031-.106.001-.003.001-.004.03-.106v-.003l.002-.004.028-.107.001-.003.001-.003.028-.107.001-.004.001-.003.027-.107.001-.004v-.003l.027-.108.001-.003v-.004l.026-.108.001-.003v-.004l.025-.108.001-.003v-.004l.025-.108v-.004l.001-.003.023-.109v-.003l.001-.004.022-.109v-.003l.002-.004.02-.109.001-.004v-.003l.02-.11.002-.003v-.004l.02-.11v-.007l.019-.11v-.003l.001-.004.017-.11v-.004l.001-.003.017-.11v-.008l.016-.11v-.004l.001-.004.015-.11v-.008l.015-.111v-.008l.013-.111v-.007l.013-.112v-.007l.011-.112v-.004l.001-.004.01-.112v-.007l.01-.112v-.008l.008-.112v-.008l.007-.113v-.007l.007-.113v-.008l.005-.113v-.007l.005-.114v-.007l.003-.114v-.007l.003-.114v-.129l.001-.114v-.13l-.003-.114V16.5l-.003-.115v-.007l-.003-.102v-.155l-.003-.158v-.01l-.004-.158v-.01l-.006-.158v-.01l-.007-.148-.023-.16-.051-.152-.08-.14-.103-.124-.125-.102-.142-.077-.153-.05-.16-.02-.161.01zm-30.213.66l-.157.034-.149.063-.134.09-.115.113-.092.132-.067.147-.037.156-.009.134.001.11V16.308l.006.22v.012l.01.22v.012l.012.22v.006l.001.006.015.22v.005l.001.006.018.22.001.006v.006l.022.219v.006l.001.006.024.219.001.006v.006l.028.218.001.006v.006l.031.218.001.006.001.006.033.218.001.006.001.005.037.218v.006l.002.005.04.217v.006l.001.006.043.216.001.006.001.006.046.216v.005l.002.006.048.215.002.006.001.006.051.214.002.006v.006l.055.214.002.005.001.006.057.213.002.006.001.005.06.213.002.005.001.006.063.212.002.005.001.006.066.21.002.006.002.006.068.21.002.005.002.005.07.21.003.005.002.005.074.208.002.006.002.005.077.207.002.006.002.005.08.206.002.005.002.006.082.204.002.006.002.005.086.204.002.005.002.006.088.202.002.005.003.006.09.2.003.006.002.005.094.2.002.006.003.005.096.199.002.005.003.005.03.062.086.137.11.118.128.097.145.07.156.043.16.013.16-.017.155-.047.143-.074.127-.1.106-.121.081-.14.055-.15.025-.16-.005-.161-.034-.158-.05-.124-.028-.055-.092-.19-.087-.188-.087-.192-.083-.19-.08-.193-.078-.194-.076-.196-.073-.195-.07-.197-.067-.198-.065-.199-.063-.2-.059-.2-.056-.2-.055-.204-.05-.201-.049-.202-.046-.205-.043-.206-.04-.203-.038-.207-.034-.204-.032-.207-.028-.205-.026-.207-.023-.208-.02-.207-.018-.207-.014-.208-.011-.207-.009-.208-.005-.207-.002-.104-.017-.16-.046-.155-.074-.143-.1-.126-.121-.107-.139-.081-.152-.055-.159-.025-.161.004zm24.585 11.83l-.156.039-.146.068-.11.076-.015.012-.163.129-.166.127-.168.125-.17.124-.17.12-.172.118-.173.115-.176.114-.177.111-.18.11-.178.105-.182.104-.182.101-.184.1-.184.095-.189.095-.186.09-.188.089-.19.086-.19.082-.193.081-.195.078-.191.074-.197.073-.195.07-.196.065-.198.064-.198.061-.2.058-.2.055-.2.052-.2.049-.151.035-.153.05-.141.078-.125.103-.103.124-.078.14-.05.154-.022.16.009.16.038.157.067.147.093.132.116.112.134.089.149.062.158.034.16.003.133-.02.158-.035.006-.002.006-.001.213-.052.006-.002.007-.001.212-.056.006-.001.006-.002.212-.058.006-.002.006-.002.211-.061.006-.002.006-.002.21-.064.006-.002.006-.002.21-.067.005-.002.006-.002.208-.07.006-.002.006-.003.207-.073.006-.002.006-.002.206-.077.006-.002.005-.002.206-.08.005-.001.006-.003.204-.082.006-.002.005-.002.203-.085.006-.003.005-.002.202-.088.006-.002.005-.003.2-.09.006-.003.006-.003.2-.093.005-.003.005-.002.198-.096.006-.003.005-.003.197-.099.005-.002.005-.003.196-.102.005-.002.005-.003.195-.105.005-.002.005-.003.193-.107.005-.003.005-.003.191-.11.005-.003.005-.003.19-.112.005-.003.005-.003.189-.115.005-.003.005-.003.187-.117.005-.003.004-.004.186-.12.005-.003.004-.003.184-.122.005-.003.005-.004.182-.125.004-.003.005-.003.18-.128.005-.003.005-.003.179-.13.004-.003.005-.004.177-.132.004-.004.005-.003.175-.135.005-.003.004-.004.173-.137.005-.003.004-.004.019-.015.115-.113.092-.132.066-.147.038-.157.008-.16-.022-.16-.052-.153-.079-.14-.103-.124-.125-.102-.142-.078-.153-.05-.16-.02-.16.01zm-19.17.054l-.153.051-.14.079-.124.103-.103.125-.077.141-.05.153-.02.16.009.161.04.156.067.147.093.131.095.094.047.04.005.004.005.004.17.14.005.004.005.004.172.137.004.004.005.003.086.067.003.002.003.002.087.067.003.002.003.002.088.066.002.003.003.002.089.065.002.002.003.002.09.065.002.002.003.002.09.064.002.002.003.002.09.063.003.002.003.002.09.063.003.002.003.002.092.062.002.002.003.002.092.061.003.002.003.002.092.06.003.003.003.001.093.06.003.002.003.002.093.06.003.001.003.002.094.058.003.002.003.002.095.058.003.001.003.002.095.057.003.002.003.002.095.056.003.002.003.002.096.055.004.002.003.001.096.055.003.002.003.002.098.053.003.002.003.002.097.053.004.002.003.001.098.053.003.001.003.002.099.052.003.001.003.002.1.05.003.002.003.002.1.05.003.002.003.001.1.05h.003l.004.003.1.048.004.001.003.002.101.048.003.001.004.002.101.046.004.002.003.001.102.046.004.002.003.001.103.045.003.002.003.001.103.045.004.001.003.002.104.043.003.001.004.002.104.042.003.002.004.001.104.042.004.001.003.002.105.04.004.002.003.001.106.04.003.002h.004l.106.04.004.001.003.002.107.038.003.001.004.001.107.038.003.001.004.001.107.037.004.001.004.001.108.036.003.001.004.001.108.035.004.001.003.001.11.034.003.001.004.001.109.033.004.002h.003l.11.033h.004l.003.002.11.031.004.001.004.001.084.023.081.028.004.001.003.001.109.037.003.001.004.001.109.036.003.001.004.001.109.035h.003l.004.002.11.033.003.001.003.001.11.033.003.001.004.001.109.031.004.002h.003l.11.031.003.001.004.001.11.03h.003l.003.001.11.029h.004l.003.002.11.027.003.001.004.001.11.027h.003l.004.001.004.001.16.022.16-.008.157-.038.147-.067.132-.092.112-.116.09-.134.062-.149.034-.157.004-.161-.025-.16-.055-.151-.082-.139-.107-.12-.127-.1-.143-.074-.124-.04h-.003l-.104-.025-.103-.026h-.002l-.095-.026h-.001l-.101-.027h-.002l-.1-.028h-.002l-.103-.03-.104-.032-.097-.03h-.002l-.103-.033-.102-.033-.101-.034-.106-.036-.027-.01-.027-.007-.107-.03-.104-.029-.104-.03h-.002l-.097-.03-.102-.032-.102-.032-.102-.034-.103-.035-.096-.034-.1-.036-.101-.037h-.002l-.094-.036-.096-.037-.097-.04h-.002l-.099-.04-.098-.042h-.002l-.092-.04-.097-.043-.095-.043-.097-.044h-.002l-.09-.043-.094-.045-.094-.046-.093-.047-.09-.046-.096-.05-.088-.047-.002-.001-.09-.049-.094-.052-.002-.002-.087-.049-.087-.05h-.002l-.088-.053h-.001l-.09-.055-.086-.052-.002-.001-.089-.055-.084-.054h-.002l-.09-.059h-.001l-.085-.056-.001-.001-.084-.056-.082-.056h-.001l-.086-.06-.082-.058H7.79l-.086-.062-.002-.002-.08-.058-.081-.06h-.001l-.085-.064-.002-.002-.076-.058-.002-.002-.082-.064-.161-.128-.162-.133-.04-.034-.132-.092-.147-.066-.157-.038-.16-.008-.16.022z"
}));
function _extends$b() {
  return _extends$b = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$b.apply(null, arguments);
}
var StartEventNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$b({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.847.004C9.61-.016 3.624 4.014 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.101 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.268.403-6.228-3.26-12.441-8.87-15.154A15.924 15.924 0 0015.846.004zm.439 1.729c6.105.033 11.856 4.45 13.435 10.359 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.625-4.814-3.84-6.538-10.94-4.067-16.57 2.14-5.206 7.515-8.775 13.147-8.71.097-.001.194-.002.29-.001z"
}));
function _extends$a() {
  return _extends$a = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$a.apply(null, arguments);
}
var StartEventParallelMultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$a({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.847 0C9.61-.02 3.624 4.01 1.257 9.775-1.235 15.485.06 22.577 4.42 27.03c4.193 4.513 11.101 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.268.403-6.228-3.26-12.441-8.87-15.154A15.924 15.924 0 0015.846 0zm.439 1.729c6.105.033 11.856 4.45 13.435 10.359 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.625C2.101 23.17.377 16.07 2.848 10.44c2.134-5.2 7.522-8.78 13.147-8.71.097-.001.194-.002.29-.001zM13.504 9.08v4.427H9.077v4.98h4.427v4.427h4.98v-4.427h4.428v-4.98h-4.427V9.08h-4.98zm.83.83h3.32v4.427h4.428v3.32h-4.427v4.427h-3.32v-4.453H9.906v-3.294h4.427V9.91z"
}));
function _extends$9() {
  return _extends$9 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$9.apply(null, arguments);
}
var StartEventSignalIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$9({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M15.995.005C9.705-.08 3.643 3.968 1.257 9.78-1.235 15.49.06 22.581 4.42 27.034c4.193 4.513 11.102 6.17 16.887 4.058 5.996-2.042 10.423-7.93 10.664-14.269.403-6.227-3.26-12.44-8.87-15.153A15.924 15.924 0 0015.994.005zm0 1.73c6.213-.108 12.122 4.355 13.726 10.357 1.678 5.653-.592 12.198-5.463 15.547-5.06 3.719-12.564 3.45-17.343-.626-4.814-3.838-6.538-10.939-4.067-16.57 2.14-5.205 7.515-8.774 13.147-8.708zm0 6.776L9.19 20.724H22.8L15.995 8.511zm0 1.777l5.332 9.572H10.662l5.333-9.572z"
}));
function _extends$8() {
  return _extends$8 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$8.apply(null, arguments);
}
var StartEventTimerIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$8({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M16 0C7.174 0 0 7.174 0 16s7.174 16 16 16 16-7.174 16-16S24.826 0 16 0zm0 1.73c7.892 0 14.27 6.378 14.27 14.27 0 7.891-6.379 14.27-14.27 14.27S1.73 23.891 1.73 16C1.73 8.108 8.108 1.73 16 1.73zm-.143 6.676c-2.967.02-5.797 1.97-6.89 4.727-1.138 2.695-.51 6.012 1.537 8.102 1.99 2.142 5.268 2.932 8.014 1.928 2.878-.98 4.992-3.827 5.068-6.87.153-2.957-1.624-5.881-4.3-7.137a7.552 7.552 0 00-3.43-.75zm.27 1.383c2.71.012 5.254 2.015 5.886 4.656.704 2.577-.482 5.517-2.791 6.867-2.358 1.48-5.682 1.085-7.618-.918-2.043-1.971-2.407-5.381-.84-7.745 1.11-1.763 3.15-2.88 5.234-2.86h.13zm1.833 1.765l-2.074 3.763c-.64.068-.793 1.04-.202 1.3.39.27.696-.18 1.052-.165h3.17v-.865h-3.181l1.992-3.615-.757-.418z"
}));
function _extends$7() {
  return _extends$7 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$7.apply(null, arguments);
}
var SubprocessCollapsedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$7({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M5.637 3A5.644 5.644 0 000 8.637v15.417a5.644 5.644 0 005.637 5.637h20.726A5.644 5.644 0 0032 24.054V8.637A5.644 5.644 0 0026.363 3H5.637zm0 1.778h20.726a3.83 3.83 0 013.859 3.859v15.417a3.83 3.83 0 01-3.859 3.858h-4.201V16.695H9.838v11.217H5.637a3.83 3.83 0 01-3.859-3.858V8.637a3.83 3.83 0 013.859-3.859zm5.33 13.046h10.066v10.065H10.967V17.824zm4.189 1.431V22.06H12.35v1.689h2.804V26.554h1.69V23.749h2.804V22.06h-2.804V19.255h-1.69z"
}));
function _extends$6() {
  return _extends$6 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$6.apply(null, arguments);
}
var SubprocessExpandedIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$6({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M5.636 3A5.642 5.642 0 000 8.636v15.418a5.643 5.643 0 005.636 5.636h20.728A5.643 5.643 0 0032 24.054V8.636A5.642 5.642 0 0026.364 3H5.636zm0 1.778h20.728a3.83 3.83 0 013.858 3.858v15.418a3.83 3.83 0 01-3.858 3.858h-4.203V16.723H9.84v11.189H5.636a3.83 3.83 0 01-3.858-3.858V8.636a3.83 3.83 0 013.858-3.858zm5.331 13.074h10.066v10.06H10.967v-10.06zm1.336 3.996v1.711h7.394v-1.71h-7.394z"
}));
function _extends$5() {
  return _extends$5 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$5.apply(null, arguments);
}
var TaskNoneIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$5({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M6.494 2.667C2.916 2.667 0 5.57 0 9.142v13.383C0 26.097 2.916 29 6.494 29h19.012C29.084 29 32 26.097 32 22.525V9.142c0-3.572-2.916-6.475-6.494-6.475H6.494zm0 2h19.012c2.509 0 4.494 1.98 4.494 4.475v13.383C30 25.02 28.015 27 25.506 27H6.494C3.985 27 2 25.02 2 22.525V9.142c0-2.495 1.985-4.475 4.494-4.475z"
}));
function _extends$4() {
  return _extends$4 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$4.apply(null, arguments);
}
var TextAnnotationicon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$4({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M22.087 0v31.647H32v-1.788h-8.125V1.788H32V0h-9.913zm-2.924 13.999l-2.737 2.167 2.167 2.738 2.738-2.167-2.168-2.738zm-5.475 4.335L10.95 20.5l2.168 2.738 2.737-2.168-2.167-2.737zm-5.475 4.335l-2.738 2.167 2.168 2.738 2.737-2.168-2.167-2.737zm-5.476 4.335L0 29.17l2.167 2.738 2.738-2.168-2.168-2.737z"
}));
function _extends$3() {
  return _extends$3 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$3.apply(null, arguments);
}
var TransactionIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$3({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  d: "M5.422 3A5.424 5.424 0 000 8.422v15.822a5.424 5.424 0 005.422 5.423h21.156A5.424 5.424 0 0032 24.244V8.422A5.424 5.424 0 0026.578 3H5.422zm0 1.244h21.156a4.155 4.155 0 014.178 4.178v15.822a4.155 4.155 0 01-4.178 4.178H5.422a4.155 4.155 0 01-4.178-4.178V8.422a4.155 4.155 0 014.178-4.178zm1.056 1.778a3.373 3.373 0 00-3.367 3.366v13.89a3.373 3.373 0 003.367 3.366h19.044a3.373 3.373 0 003.367-3.366V9.388a3.373 3.373 0 00-3.367-3.366H6.478zm0 1.245h19.044c1.187 0 2.122.935 2.122 2.121v13.89a2.104 2.104 0 01-2.122 2.122H6.478a2.104 2.104 0 01-2.122-2.122V9.388c0-1.186.935-2.121 2.122-2.121z"
}));
function _extends$2() {
  return _extends$2 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$2.apply(null, arguments);
}
var UserTaskIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$2({
  xmlns: "http://www.w3.org/2000/svg",
  width: "32",
  height: "32"
}, props), /* @__PURE__ */ wn.createElement("path", {
  fillRule: "evenodd",
  d: "M10.263 7.468c-1.698 0-2.912 1.305-2.915 2.791v.001c0 .45.121.924.311 1.352.138.309.308.593.516.82-1.235.423-2.683 1.119-3.414 2.49l-.04.075v4.44h11.083v-4.44l-.04-.074c-.72-1.352-2.136-2.047-3.36-2.471.597-.608.774-1.392.774-2.192-.004-1.487-1.218-2.792-2.915-2.792zm-1.16 1.583c.08 0 .165.003.26.008.757.045 1.012.181 1.207.31.196.13.334.252.851.268.404-.016.598-.087.737-.169.056-.033.103-.067.152-.1.128.275.197.578.198.893 0 .894-.154 1.52-.975 2.034l.08.604c.171.052.348.11.527.171.025.105.054.242.073.387.02.153.029.311.016.43a.422.422 0 01-.056.19c-.417.417-1.157.66-1.908.66-.75 0-1.49-.243-1.908-.66a.422.422 0 01-.056-.19 1.949 1.949 0 01.016-.43c.02-.146.049-.284.074-.388.177-.062.352-.118.521-.17l.048-.648a.616.616 0 00-.126-.118c-.183-.138-.405-.44-.562-.793-.157-.353-.254-.757-.254-1.08 0-.387.105-.758.297-1.079l.11-.04c.143-.046.339-.09.679-.09zm-1.448 4.304l-.002.014c-.025.185-.04.387-.018.589.021.202.074.42.248.593.595.594 1.494.857 2.382.857.889 0 1.788-.263 2.382-.857.174-.174.227-.391.249-.593a2.496 2.496 0 00-.018-.59l-.002-.01c.903.396 1.776.963 2.258 1.81v3.599H13.53v-2.538h-.67v2.538H7.651v-2.538h-.67v2.538H5.39v-3.599c.483-.849 1.359-1.416 2.264-1.813zM6.495 3C2.914 3 0 5.903 0 9.475v13.383c0 3.572 2.916 6.475 6.494 6.475h19.012c3.578 0 6.494-2.903 6.494-6.475V9.475C32 5.903 29.084 3 25.506 3H6.494zm0 2h19.01C28.016 5 30 6.98 30 9.475v13.383c0 2.495-1.985 4.475-4.494 4.475H6.494C3.985 27.333 2 25.353 2 22.858V9.475C2 6.98 3.985 5 6.494 5z"
}));
var iconsByType = {
  "Association": AssociationIcon,
  "BusinessRuleTask": BusinessRuleTaskIcon,
  "CallActivity": CallActivityIcon,
  "Collaboration": CollaborationIcon,
  "ConditionalFlow": ConditionalFlowIcon,
  "SequenceFlow": ConnectionIcon,
  "DataInput": DataInputIcon,
  "DataInputAssociation": DataInputOutputAssociationIcon,
  "DataOutput": DataOutputIcon,
  "DataOutputAssociation": DataInputOutputAssociationIcon,
  "DataObjectReference": DataObjectIcon,
  "DataStoreReference": DataStoreIcon,
  "DefaultFlow": DefaultFlowIcon,
  "CancelEndEvent": EndEventCancelIcon,
  "CompensateEndEvent": EndEventCompensationIcon,
  "ErrorEndEvent": EndEventErrorIcon,
  "EscalationEndEvent": EndEventEscalationIcon,
  "LinkEndEvent": EndEventLinkIcon,
  "MessageEndEvent": EndEventMessageIcon,
  "MultipleEndEvent": EndEventMultipleIcon,
  "EndEvent": EndEventNoneIcon,
  "SignalEndEvent": EndEventSignalIcon,
  "TerminateEndEvent": EndEventTerminateIcon,
  "EventSubProcess": EventSubProcessExpandedIcon,
  "ComplexGateway": GatewayComplexIcon,
  "EventBasedGateway": GatewayEventBasedIcon,
  "ExclusiveGateway": GatewayXorIcon,
  "Gateway": GatewayNoneIcon,
  "InclusiveGateway": GatewayOrIcon,
  "ParallelGateway": GatewayParallelIcon,
  "Group": GroupIcon,
  "CancelIntermediateCatchEvent": IntermediateEventCatchCancelIcon,
  "CompensateIntermediateCatchEvent": IntermediateEventCatchCompensationIcon,
  "ConditionalIntermediateCatchEvent": IntermediateEventCatchConditionIcon,
  "ErrorIntermediateCatchEvent": IntermediateEventCatchErrorIcon,
  "EscalationIntermediateCatchEvent": IntermediateEventCatchEscalationIcon,
  "LinkIntermediateCatchEvent": IntermediateEventCatchLinkIcon,
  "MessageIntermediateCatchEvent": IntermediateEventCatchMessageIcon,
  "MultipleIntermediateCatchEvent": IntermediateEventCatchMultipleIcon,
  "ConditionalIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingConditionIcon,
  "EscalationIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingEscalationIcon,
  "MessageIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingMessageIcon,
  "MultipleIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingMultipleIcon,
  "ParallelIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingParallelIcon,
  "SignalIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingSignalIcon,
  "TimerIntermediateCatchEventNonInterrupting": IntermediateEventCatchNonInterruptingTimerIcon,
  "ParallelMultipleIntermediateCatchEvent": IntermediateEventCatchParallelMultipleIcon,
  "SignalIntermediateCatchEvent": IntermediateEventCatchSignalIcon,
  "TimerIntermediateCatchEvent": IntermediateEventCatchTimerIcon,
  "IntermediateThrowEvent": IntermediateEventNoneIcon,
  "CompensateIntermediateThrowEvent": IntermediateEventThrowCompensationIcon,
  "EscalationIntermediateThrowEvent": IntermediateEventThrowEscalationIcon,
  "LinkIntermediateThrowEvent": IntermediateEventThrowLinkIcon,
  "MessageIntermediateThrowEvent": IntermediateEventThrowMessageIcon,
  "MultipleIntermediateThrowEvent": IntermediateEventThrowMultipleIcon,
  "SignalIntermediateThrowEvent": IntermediateEventThrowSignalIcon,
  "Lane": LaneIcon,
  "ManualTask": ManualTaskIcon,
  "MessageFlow": MessageFlowIcon,
  "Participant": ParticipantIcon,
  "Process": ProcessIcon,
  "ReceiveTask": ReceiveTaskIcon,
  "ScriptTask": ScriptTaskIcon,
  "SendTask": SendTaskIcon,
  "ServiceTask": ServiceTaskIcon,
  "CompensateStartEvent": StartEventCompensationIcon,
  "ConditionalStartEvent": StartEventConditionIcon,
  "ErrorStartEvent": StartEventErrorIcon,
  "EscalationStartEvent": StartEventEscalationIcon,
  "MessageStartEvent": StartEventMessageIcon,
  "MultipleStartEvent": StartEventMultipleIcon,
  "ConditionalStartEventNonInterrupting": StartEventNonInterruptingConditionIcon,
  "EscalationStartEventNonInterrupting": StartEventNonInterruptingEscalationIcon,
  "MessageStartEventNonInterrupting": StartEventNonInterruptingMessageIcon,
  "MultipleStartEventNonInterrupting": StartEventNonInterruptingMultipleIcon,
  "ParallelMultipleStartEventNonInterrupting": StartEventNonInterruptingParallelMultipleIcon,
  "SignalStartEventNonInterrupting": StartEventNonInterruptingSignalIcon,
  "TimerStartEventNonInterrupting": StartEventNonInterruptingTimerIcon,
  "CancelBoundaryEvent": IntermediateEventCatchCancelIcon,
  "CompensateBoundaryEvent": IntermediateEventCatchCompensationIcon,
  "ConditionalBoundaryEvent": IntermediateEventCatchConditionIcon,
  "ErrorBoundaryEvent": IntermediateEventCatchErrorIcon,
  "EscalationBoundaryEvent": IntermediateEventCatchEscalationIcon,
  "LinkBoundaryEvent": IntermediateEventCatchLinkIcon,
  "MessageBoundaryEvent": IntermediateEventCatchMessageIcon,
  "MultipleBoundaryEvent": IntermediateEventCatchMultipleIcon,
  "BoundaryEvent": IntermediateEventNoneIcon,
  "ConditionalBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingConditionIcon,
  "EscalationBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingEscalationIcon,
  "MessageBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingMessageIcon,
  "MultipleBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingMultipleIcon,
  "ParallelBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingParallelIcon,
  "SignalBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingSignalIcon,
  "TimerBoundaryEventNonInterrupting": IntermediateEventCatchNonInterruptingTimerIcon,
  "ParallelMultipleBoundaryEvent": IntermediateEventCatchParallelMultipleIcon,
  "SignalBoundaryEvent": IntermediateEventCatchSignalIcon,
  "TimerBoundaryEvent": IntermediateEventCatchTimerIcon,
  "StartEvent": StartEventNoneIcon,
  "ParallelMultipleStartEvent": StartEventParallelMultipleIcon,
  "SignalStartEvent": StartEventSignalIcon,
  "TimerStartEvent": StartEventTimerIcon,
  "CollapsedSubProcess": SubprocessCollapsedIcon,
  "CollapsedAdHocSubProcess": SubprocessCollapsedIcon,
  "ExpandedSubProcess": SubprocessExpandedIcon,
  "ExpandedAdHocSubProcess": SubprocessExpandedIcon,
  "Task": TaskNoneIcon,
  "TextAnnotation": TextAnnotationicon,
  "Transaction": TransactionIcon,
  "UserTask": UserTaskIcon
};
function getConcreteType(element) {
  const {
    type: elementType
  } = element;
  let type = getRawType(elementType);
  const eventDefinition = getEventDefinition$2(element);
  if (eventDefinition) {
    type = `${getEventDefinitionPrefix(eventDefinition)}${type}`;
    if (is(element, "bpmn:StartEvent") && !isInterrupting(element) || is(element, "bpmn:BoundaryEvent") && !isCancelActivity(element)) {
      type = `${type}NonInterrupting`;
    }
    return type;
  }
  if (is(element, "bpmn:SubProcess") && !is(element, "bpmn:Transaction")) {
    if (isEventSubProcess(element)) {
      type = `Event${type}`;
    } else {
      const expanded = isExpanded(element) && !isPlane2(element);
      type = `${expanded ? "Expanded" : "Collapsed"}${type}`;
    }
  }
  if (isDefaultFlow2(element)) {
    type = "DefaultFlow";
  }
  if (isConditionalFlow(element)) {
    type = "ConditionalFlow";
  }
  return type;
}
var PanelHeaderProvider = (translate4) => {
  if (!translate4) translate4 = (text) => text;
  return {
    getDocumentationRef: (element) => {
      const elementTemplates = getTemplatesService();
      if (elementTemplates) {
        return getTemplateDocumentation(element, elementTemplates);
      }
    },
    getElementLabel: (element) => {
      if (is(element, "bpmn:Process")) {
        return getBusinessObject(element).name;
      }
      return getLabel(element);
    },
    getElementIcon: (element) => {
      const concreteType = getConcreteType(element);
      const config = useService("config.elementTemplateIconRenderer", false);
      const {
        iconProperty = "zeebe:modelerTemplateIcon"
      } = config || {};
      const templateIcon = getBusinessObject(element).get(iconProperty);
      if (templateIcon) {
        return () => u5("img", {
          class: "bio-properties-panel-header-template-icon",
          width: "32",
          height: "32",
          src: templateIcon
        });
      }
      return iconsByType[concreteType];
    },
    getTypeLabel: (element) => {
      const elementTemplates = getTemplatesService();
      if (elementTemplates) {
        const template = getTemplate(element, elementTemplates);
        if (template && template.name) {
          return translate4(template.name);
        }
      }
      const concreteType = getConcreteType(element);
      return translate4(concreteType.replace(/(\B[A-Z])/g, " $1").replace(/(\bNon Interrupting)/g, "($1)"));
    }
  };
};
function isCancelActivity(element) {
  const businessObject = getBusinessObject(element);
  return businessObject && businessObject.cancelActivity !== false;
}
function getEventDefinition$2(element) {
  const businessObject = getBusinessObject(element), eventDefinitions = businessObject.eventDefinitions;
  return eventDefinitions && eventDefinitions[0];
}
function getRawType(type) {
  return type.split(":")[1];
}
function getEventDefinitionPrefix(eventDefinition) {
  const rawType = getRawType(eventDefinition.$type);
  return rawType.replace("EventDefinition", "");
}
function isDefaultFlow2(element) {
  const businessObject = getBusinessObject(element);
  const sourceBusinessObject = getBusinessObject(element.source);
  if (!is(element, "bpmn:SequenceFlow") || !sourceBusinessObject) {
    return false;
  }
  return sourceBusinessObject.default && sourceBusinessObject.default === businessObject && (is(sourceBusinessObject, "bpmn:Gateway") || is(sourceBusinessObject, "bpmn:Activity"));
}
function isConditionalFlow(element) {
  const businessObject = getBusinessObject(element);
  const sourceBusinessObject = getBusinessObject(element.source);
  if (!is(element, "bpmn:SequenceFlow") || !sourceBusinessObject) {
    return false;
  }
  return businessObject.conditionExpression && is(sourceBusinessObject, "bpmn:Activity");
}
function isPlane2(element) {
  const di = element && (element.di || getBusinessObject(element).di);
  return is(di, "bpmndi:BPMNPlane");
}
function getTemplatesService() {
  return useService("elementTemplates", false);
}
function getTemplate(element, elementTemplates) {
  return elementTemplates.get(element);
}
function getTemplateDocumentation(element, elementTemplates) {
  const template = getTemplate(element, elementTemplates);
  return template && template.documentationRef;
}
function _extends$1() {
  return _extends$1 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends$1.apply(null, arguments);
}
var EmptyIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends$1({
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  width: "64",
  height: "64"
}, props), /* @__PURE__ */ wn.createElement("defs", null, /* @__PURE__ */ wn.createElement("rect", {
  id: "a",
  width: "57",
  height: "47",
  x: "3",
  y: "8",
  rx: "7"
}), /* @__PURE__ */ wn.createElement("mask", {
  id: "b",
  width: "57",
  height: "47",
  x: "0",
  y: "0",
  fill: "#fff",
  maskContentUnits: "userSpaceOnUse",
  maskUnits: "objectBoundingBox"
}, /* @__PURE__ */ wn.createElement("use", {
  xlinkHref: "#a"
}))), /* @__PURE__ */ wn.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, /* @__PURE__ */ wn.createElement("path", {
  fill: "#818798",
  d: "M52 11a5 5 0 015 5v31a5 5 0 01-5 5H11a5 5 0 01-5-5V16a5 5 0 015-5h41zm0 2H11a3 3 0 00-2.995 2.824L8 16v31a3 3 0 002.824 2.995L11 50h41a3 3 0 002.995-2.824L55 47V16a3 3 0 00-2.824-2.995L52 13z"
}), /* @__PURE__ */ wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M16 24h31v6H16zM21 33h21v6H21z"
}), /* @__PURE__ */ wn.createElement("use", {
  stroke: "#B9BCC6",
  strokeDasharray: "5 2",
  strokeWidth: "2",
  mask: "url(#b)",
  xlinkHref: "#a"
})));
function _extends2() {
  return _extends2 = Object.assign ? Object.assign.bind() : function(n4) {
    for (var e8 = 1; e8 < arguments.length; e8++) {
      var t7 = arguments[e8];
      for (var r7 in t7) ({}).hasOwnProperty.call(t7, r7) && (n4[r7] = t7[r7]);
    }
    return n4;
  }, _extends2.apply(null, arguments);
}
var MultipleIcon = ({
  styles = {},
  ...props
}) => /* @__PURE__ */ wn.createElement("svg", _extends2({
  xmlns: "http://www.w3.org/2000/svg",
  xmlnsXlink: "http://www.w3.org/1999/xlink",
  width: "128",
  height: "64"
}, props), /* @__PURE__ */ wn.createElement("defs", null, /* @__PURE__ */ wn.createElement("path", {
  id: "a",
  d: "M9 9h110v47H9z"
}), /* @__PURE__ */ wn.createElement("mask", {
  id: "b",
  width: "110",
  height: "47",
  x: "0",
  y: "0",
  fill: "#fff",
  maskContentUnits: "userSpaceOnUse",
  maskUnits: "objectBoundingBox"
}, /* @__PURE__ */ wn.createElement("use", {
  xlinkHref: "#a"
}))), /* @__PURE__ */ wn.createElement("g", {
  fill: "none",
  fillRule: "evenodd"
}, /* @__PURE__ */ wn.createElement("path", {
  fill: "#818798",
  d: "M25 20.272L37.728 33 25 45.728 12.272 33 25 20.272zm0 2.829L15.1 33l9.9 9.9 9.9-9.9-9.9-9.9z"
}), /* @__PURE__ */ wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M17 47h16v6H17z"
}), /* @__PURE__ */ wn.createElement("path", {
  fill: "#818798",
  d: "M35 32h27v2H35z"
}), /* @__PURE__ */ wn.createElement("path", {
  fill: "#818798",
  d: "M60 30v6l6-3z"
}), /* @__PURE__ */ wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M80 34h21v6H80z"
}), /* @__PURE__ */ wn.createElement("g", null, /* @__PURE__ */ wn.createElement("path", {
  fill: "#818798",
  d: "M111 12a5 5 0 015 5v31a5 5 0 01-5 5H70a5 5 0 01-5-5V17a5 5 0 015-5h41zm0 2H70a3 3 0 00-3 3v31a3 3 0 003 3h41a3 3 0 003-3V17a3 3 0 00-3-3z"
}), /* @__PURE__ */ wn.createElement("path", {
  fill: "#D5D7DD",
  d: "M75 25h31v6H75z"
})), /* @__PURE__ */ wn.createElement("use", {
  stroke: "#B9BCC6",
  strokeDasharray: "5 2",
  strokeWidth: "2",
  mask: "url(#b)",
  xlinkHref: "#a"
})));
var PanelPlaceholderProvider = (translate4) => {
  if (!translate4) translate4 = (text) => text;
  return {
    getEmpty: () => {
      return {
        text: translate4("Select an element to edit its properties."),
        icon: EmptyIcon
      };
    },
    getMultiple: () => {
      return {
        text: translate4("Multiple elements are selected. Select a single element to edit its properties."),
        icon: MultipleIcon
      };
    }
  };
};
function BpmnPropertiesPanel(props) {
  const {
    element,
    injector,
    getProviders,
    layoutConfig: initialLayoutConfig,
    descriptionConfig,
    tooltipConfig,
    feelPopupContainer,
    getFeelPopupLinks
  } = props;
  const canvas = injector.get("canvas");
  const elementRegistry = injector.get("elementRegistry");
  const eventBus = injector.get("eventBus");
  const translate4 = injector.get("translate");
  const [state, setState] = h4({
    selectedElement: element
  });
  const selectedElement = state.selectedElement;
  const _update = (element2) => {
    if (!element2) {
      return;
    }
    let newSelectedElement = element2;
    if (newSelectedElement && newSelectedElement.type === "label") {
      newSelectedElement = newSelectedElement.labelTarget;
    }
    setState({
      ...state,
      selectedElement: newSelectedElement
    });
    eventBus.fire("propertiesPanel.updated", {
      element: newSelectedElement
    });
  };
  p4(() => {
    const onSelectionChanged = (e8) => {
      const {
        newSelection = []
      } = e8;
      if (newSelection.length > 1) {
        return _update(newSelection);
      }
      const newElement = newSelection[0];
      const rootElement = canvas.getRootElement();
      if (isImplicitRoot$1(rootElement)) {
        return;
      }
      _update(newElement || rootElement);
    };
    eventBus.on("selection.changed", onSelectionChanged);
    return () => {
      eventBus.off("selection.changed", onSelectionChanged);
    };
  }, []);
  p4(() => {
    const onElementsChanged = (e8) => {
      const elements = e8.elements;
      const updatedElement = findElement(elements, selectedElement);
      if (updatedElement && elementExists(updatedElement, elementRegistry)) {
        _update(updatedElement);
      }
    };
    eventBus.on("elements.changed", onElementsChanged);
    return () => {
      eventBus.off("elements.changed", onElementsChanged);
    };
  }, [selectedElement]);
  p4(() => {
    const onRootAdded = (e8) => {
      const element2 = e8.element;
      _update(element2);
    };
    eventBus.on("root.added", onRootAdded);
    return () => {
      eventBus.off("root.added", onRootAdded);
    };
  }, [selectedElement]);
  p4(() => {
    const onProvidersChanged = () => {
      _update(selectedElement);
    };
    eventBus.on("propertiesPanel.providersChanged", onProvidersChanged);
    return () => {
      eventBus.off("propertiesPanel.providersChanged", onProvidersChanged);
    };
  }, [selectedElement]);
  p4(() => {
    const onTemplatesChanged = () => {
      _update(selectedElement);
    };
    eventBus.on("elementTemplates.changed", onTemplatesChanged);
    return () => {
      eventBus.off("elementTemplates.changed", onTemplatesChanged);
    };
  }, [selectedElement]);
  const bpmnPropertiesPanelContext = {
    selectedElement,
    injector,
    getService(type, strict) {
      return injector.get(type, strict);
    }
  };
  const providers = getProviders(selectedElement);
  const groups = F4(() => {
    return reduce(providers, function(groups2, provider) {
      if (isArray(selectedElement)) {
        return [];
      }
      const updater = provider.getGroups(selectedElement);
      return updater(groups2);
    }, []);
  }, [providers, selectedElement]);
  const [layoutConfig, setLayoutConfig] = h4(initialLayoutConfig || {});
  const onLayoutChanged = T4((newLayout) => {
    eventBus.fire("propertiesPanel.layoutChanged", {
      layout: newLayout
    });
  }, [eventBus]);
  p4(() => {
    const cb = (e8) => {
      const {
        layout
      } = e8;
      setLayoutConfig(layout);
    };
    eventBus.on("propertiesPanel.setLayout", cb);
    return () => eventBus.off("propertiesPanel.setLayout", cb);
  }, [eventBus, setLayoutConfig]);
  const onDescriptionLoaded = (description) => {
    eventBus.fire("propertiesPanel.descriptionLoaded", {
      description
    });
  };
  const onTooltipLoaded = (tooltip) => {
    eventBus.fire("propertiesPanel.tooltipLoaded", {
      tooltip
    });
  };
  return u5(BpmnPropertiesPanelContext.Provider, {
    value: bpmnPropertiesPanelContext,
    children: u5(PropertiesPanel, {
      element: selectedElement,
      headerProvider: PanelHeaderProvider(translate4),
      placeholderProvider: PanelPlaceholderProvider(translate4),
      groups,
      layoutConfig,
      layoutChanged: onLayoutChanged,
      descriptionConfig,
      descriptionLoaded: onDescriptionLoaded,
      tooltipConfig,
      tooltipLoaded: onTooltipLoaded,
      feelPopupContainer,
      getFeelPopupLinks,
      eventBus
    })
  });
}
function isImplicitRoot$1(element) {
  return element && element.isImplicit;
}
function findElement(elements, element) {
  return find(elements, (e8) => e8 === element);
}
function elementExists(element, elementRegistry) {
  return element && elementRegistry.get(element.id);
}
var DEFAULT_PRIORITY8 = 1e3;
var BpmnPropertiesPanelRenderer = class {
  constructor(config, injector, eventBus) {
    const {
      parent,
      layout: layoutConfig,
      description: descriptionConfig,
      tooltip: tooltipConfig,
      feelPopupContainer,
      getFeelPopupLinks
    } = config || {};
    this._eventBus = eventBus;
    this._injector = injector;
    this._layoutConfig = layoutConfig;
    this._descriptionConfig = descriptionConfig;
    this._tooltipConfig = tooltipConfig;
    this._feelPopupContainer = feelPopupContainer;
    this._getFeelPopupLinks = getFeelPopupLinks;
    this._container = domify$1('<div style="height: 100%" tabindex="-1" class="bio-properties-panel-container"></div>');
    var commandStack = injector.get("commandStack", false);
    commandStack && setupKeyboard(this._container, eventBus, commandStack);
    eventBus.on("diagram.init", () => {
      if (parent) {
        this.attachTo(parent);
      }
    });
    eventBus.on("diagram.destroy", () => {
      this.detach();
    });
    eventBus.on("root.added", (event2) => {
      const {
        element
      } = event2;
      this._render(element);
    });
  }
  /**
   * Attach the properties panel to a parent node.
   *
   * @param {HTMLElement} container
   */
  attachTo(container) {
    if (!container) {
      throw new Error("container required");
    }
    if (container.get && container.constructor.prototype.jquery) {
      container = container.get(0);
    }
    if (typeof container === "string") {
      container = query(container);
    }
    this.detach();
    container.appendChild(this._container);
    this._eventBus.fire("propertiesPanel.attach");
  }
  /**
   * Detach the properties panel from its parent node.
   */
  detach() {
    const parentNode = this._container.parentNode;
    if (parentNode) {
      parentNode.removeChild(this._container);
      this._eventBus.fire("propertiesPanel.detach");
    }
  }
  /**
   * Register a new properties provider to the properties panel.
   *
   * @param {Number} [priority]
   * @param {PropertiesProvider} provider
   */
  registerProvider(priority, provider) {
    if (!provider) {
      provider = priority;
      priority = DEFAULT_PRIORITY8;
    }
    if (typeof provider.getGroups !== "function") {
      console.error("Properties provider does not implement #getGroups(element) API");
      return;
    }
    this._eventBus.on("propertiesPanel.getProviders", priority, function(event2) {
      event2.providers.push(provider);
    });
    this._eventBus.fire("propertiesPanel.providersChanged");
  }
  /**
   * Updates the layout of the properties panel.
   * @param {Object} layout
   */
  setLayout(layout) {
    this._eventBus.fire("propertiesPanel.setLayout", {
      layout
    });
  }
  _getProviders() {
    const event2 = this._eventBus.createEvent({
      type: "propertiesPanel.getProviders",
      providers: []
    });
    this._eventBus.fire(event2);
    return event2.providers;
  }
  _render(element) {
    const canvas = this._injector.get("canvas");
    if (!element) {
      element = canvas.getRootElement();
    }
    if (isImplicitRoot(element)) {
      return;
    }
    q3(u5(BpmnPropertiesPanel, {
      element,
      injector: this._injector,
      getProviders: this._getProviders.bind(this),
      layoutConfig: this._layoutConfig,
      descriptionConfig: this._descriptionConfig,
      tooltipConfig: this._tooltipConfig,
      feelPopupContainer: this._feelPopupContainer,
      getFeelPopupLinks: this._getFeelPopupLinks
    }), this._container);
    this._eventBus.fire("propertiesPanel.rendered");
  }
  _destroy() {
    if (this._container) {
      q3(null, this._container);
      this._eventBus.fire("propertiesPanel.destroyed");
    }
  }
};
BpmnPropertiesPanelRenderer.$inject = ["config.propertiesPanel", "injector", "eventBus"];
function isImplicitRoot(element) {
  return element && element.isImplicit;
}
function setupKeyboard(container, eventBus, commandStack) {
  function cancel2(event2) {
    event2.preventDefault();
    event2.stopPropagation();
  }
  function handleKeys(event2) {
    if (isUndo(event2)) {
      commandStack.undo();
      return cancel2(event2);
    }
    if (isRedo(event2)) {
      commandStack.redo();
      return cancel2(event2);
    }
  }
  eventBus.on("keyboard.bind", function() {
    event.bind(container, "keydown", handleKeys);
  });
  eventBus.on("keyboard.unbind", function() {
    event.unbind(container, "keydown", handleKeys);
  });
}
var MultiCommandHandler = class {
  constructor(commandStack) {
    this._commandStack = commandStack;
  }
  preExecute(context) {
    const commandStack = this._commandStack;
    forEach(context, function(command) {
      commandStack.execute(command.cmd, command.context);
    });
  }
};
MultiCommandHandler.$inject = ["commandStack"];
var HANDLERS = {
  "properties-panel.multi-command-executor": MultiCommandHandler
};
function CommandInitializer(eventBus, commandStack) {
  eventBus.on("diagram.init", function() {
    forEach(HANDLERS, function(handler, id) {
      commandStack.registerHandler(id, handler);
    });
  });
}
CommandInitializer.$inject = ["eventBus", "commandStack"];
var Commands = {
  __init__: [CommandInitializer]
};
var index$3 = {
  __depends__: [Commands, index$1, index2],
  __init__: ["propertiesPanel"],
  propertiesPanel: ["type", BpmnPropertiesPanelRenderer]
};
function ReferenceSelectEntry(props) {
  const {
    autoFocusEntry,
    element,
    getOptions
  } = props;
  const options = getOptions(element);
  const prevOptions = usePrevious(options);
  p4(() => {
    if (autoFocusEntry && prevOptions && options.length > prevOptions.length) {
      const entry = query(`[data-entry-id="${autoFocusEntry}"]`);
      const focusableInput = query(".bio-properties-panel-input", entry);
      if (focusableInput) {
        focusableInput.select();
      }
    }
  }, [options]);
  return u5(SelectEntry, {
    ...props
  });
}
function isErrorSupported(element) {
  return isAny(element, ["bpmn:StartEvent", "bpmn:BoundaryEvent", "bpmn:EndEvent"]) && !!getErrorEventDefinition$1(element);
}
function getErrorEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:ErrorEventDefinition");
}
function getTimerEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:TimerEventDefinition");
}
function getError(element) {
  const errorEventDefinition = getErrorEventDefinition$1(element);
  return errorEventDefinition && errorEventDefinition.get("errorRef");
}
function getEventDefinition$1(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return find(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function isMessageSupported(element) {
  return is(element, "bpmn:ReceiveTask") || isAny(element, ["bpmn:StartEvent", "bpmn:EndEvent", "bpmn:IntermediateThrowEvent", "bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent"]) && !!getMessageEventDefinition(element);
}
function getMessageEventDefinition(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return getBusinessObject(element);
  }
  return getEventDefinition$1(element, "bpmn:MessageEventDefinition");
}
function getMessage(element) {
  const messageEventDefinition = getMessageEventDefinition(element);
  return messageEventDefinition && messageEventDefinition.get("messageRef");
}
function getLinkEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:LinkEventDefinition");
}
function getSignalEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:SignalEventDefinition");
}
function isLinkSupported(element) {
  return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:IntermediateCatchEvent"]) && !!getLinkEventDefinition(element);
}
function isSignalSupported$1(element) {
  return is(element, "bpmn:Event") && !!getSignalEventDefinition$1(element);
}
function getSignal$1(element) {
  const signalEventDefinition = getSignalEventDefinition$1(element);
  return signalEventDefinition && signalEventDefinition.get("signalRef");
}
function getEscalationEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:EscalationEventDefinition");
}
function isEscalationSupported(element) {
  return is(element, "bpmn:Event") && !!getEscalationEventDefinition(element);
}
function getEscalation(element) {
  const escalationEventDefinition = getEscalationEventDefinition(element);
  return escalationEventDefinition && escalationEventDefinition.get("escalationRef");
}
function isCompensationSupported(element) {
  return isAny(element, ["bpmn:EndEvent", "bpmn:IntermediateThrowEvent"]) && !!getCompensateEventDefinition$1(element);
}
function getCompensateEventDefinition$1(element) {
  return getEventDefinition$1(element, "bpmn:CompensateEventDefinition");
}
function getCompensateActivity(element) {
  const compensateEventDefinition = getCompensateEventDefinition$1(element);
  return compensateEventDefinition && compensateEventDefinition.get("activityRef");
}
function CompensationProps(props) {
  const {
    element
  } = props;
  if (!isCompensationSupported(element)) {
    return [];
  }
  return [{
    id: "waitForCompletion",
    component: WaitForCompletion,
    isEdited: isEdited$5
  }, {
    id: "activityRef",
    component: ActivityRef,
    isEdited: isEdited$3
  }];
}
function WaitForCompletion(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const compensateEventDefinition = getCompensateEventDefinition$1(element);
  const getValue = () => {
    return compensateEventDefinition.get("waitForCompletion");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: compensateEventDefinition,
      properties: {
        waitForCompletion: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "waitForCompletion",
    label: translate4("Wait for completion"),
    getValue,
    setValue
  });
}
function ActivityRef(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const elementRegistry = useService("elementRegistry");
  const translate4 = useService("translate");
  const compensateEventDefinition = getCompensateEventDefinition$1(element);
  const getValue = () => {
    const activityRef = getCompensateActivity(element);
    return activityRef && activityRef.get("id");
  };
  const setValue = (value) => {
    const activityRef = value ? getBusinessObject(elementRegistry.get(value)) : void 0;
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: compensateEventDefinition,
      properties: {
        activityRef
      }
    });
  };
  const getOptions = () => {
    let options = [{
      value: "",
      label: translate4("<none>")
    }];
    const activities = findActivityRefs(element);
    sortByName$6(activities).forEach(function(activity) {
      options.push({
        value: activity.id,
        label: createOptionLabel(activity)
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "activityRef",
    label: translate4("Activity reference"),
    getValue,
    setValue,
    getOptions
  });
}
function getFlowElements(element, type) {
  const {
    flowElements
  } = element;
  return flowElements.filter(function(flowElement) {
    return is(flowElement, type);
  });
}
function getContainedActivities(element) {
  return getFlowElements(element, "bpmn:Activity");
}
function getContainedBoundaryEvents(element) {
  return getFlowElements(element, "bpmn:BoundaryEvent");
}
function hasCompensationEventAttached(activity, boundaryEvents) {
  const {
    id: activityId
  } = activity;
  return !!find(boundaryEvents, function(boundaryEvent) {
    const {
      attachedToRef
    } = boundaryEvent;
    const compensateEventDefinition = getCompensateEventDefinition$1(boundaryEvent);
    return attachedToRef && compensateEventDefinition && attachedToRef.id === activityId;
  });
}
function canBeCompensated(activity, boundaryEvents) {
  return is(activity, "bpmn:CallActivity") || is(activity, "bpmn:SubProcess") && !activity.triggeredByEvent && !activity.isForCompensation || hasCompensationEventAttached(activity, boundaryEvents);
}
function getActivitiesForCompensation(element) {
  const activities = getContainedActivities(element);
  const boundaryEvents = getContainedBoundaryEvents(element);
  return activities.filter(function(activity) {
    return canBeCompensated(activity, boundaryEvents);
  });
}
function findActivityRefs(element) {
  const businessObject = getBusinessObject(element);
  let parent = businessObject.$parent;
  let activities = getActivitiesForCompensation(parent);
  if (is(parent, "bpmn:SubProcess") && parent.triggeredByEvent) {
    parent = parent.$parent;
    if (parent) {
      activities = [...activities, ...getActivitiesForCompensation(parent)];
    }
  }
  return activities;
}
function createOptionLabel(activity) {
  const {
    id,
    name: name2
  } = activity;
  return `${name2 ? name2 + " " : ""}(id=${id})`;
}
function sortByName$6(elements) {
  return sortBy(elements, (e8) => (e8.name || "").toLowerCase());
}
var DOCUMENTATION_TEXT_FORMAT = "text/plain";
function DocumentationProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "documentation",
    component: ElementDocumentationProperty,
    isEdited: isEdited$1
  }];
  if (hasProcessRef$3(element)) {
    entries.push({
      id: "processDocumentation",
      component: ProcessDocumentationProperty,
      isEdited: isEdited$1
    });
  }
  return entries;
}
function ElementDocumentationProperty(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = getDocumentation(getBusinessObject(element));
  const setValue = setDocumentation(element, getBusinessObject(element), bpmnFactory, commandStack);
  return TextAreaEntry({
    element,
    id: "documentation",
    label: translate4("Element documentation"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ProcessDocumentationProperty(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const processRef = getBusinessObject(element).processRef;
  const getValue = getDocumentation(processRef);
  const setValue = setDocumentation(element, processRef, bpmnFactory, commandStack);
  return TextAreaEntry({
    element,
    id: "processDocumentation",
    label: translate4("Process documentation"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function hasProcessRef$3(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
function findDocumentation(docs) {
  return docs.find(function(d5) {
    return (d5.textFormat || DOCUMENTATION_TEXT_FORMAT) === DOCUMENTATION_TEXT_FORMAT;
  });
}
function getDocumentation(businessObject) {
  return function() {
    const documentation = findDocumentation(businessObject && businessObject.get("documentation"));
    return documentation && documentation.text;
  };
}
function setDocumentation(element, businessObject, bpmnFactory, commandStack) {
  return function(value) {
    let documentation = findDocumentation(businessObject && businessObject.get("documentation"));
    if (documentation) {
      if (value) {
        return commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: documentation,
          properties: {
            text: value
          }
        });
      } else {
        return commandStack.execute("element.updateModdleProperties", {
          element,
          moddleElement: businessObject,
          properties: {
            documentation: without(businessObject.get("documentation"), documentation)
          }
        });
      }
    }
    if (value) {
      documentation = bpmnFactory.create("bpmn:Documentation", {
        text: value
      });
      return commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: businessObject,
        properties: {
          documentation: [...businessObject.get("documentation"), documentation]
        }
      });
    }
  };
}
function createElement(type, properties, parent, bpmnFactory) {
  const element = bpmnFactory.create(type, properties);
  if (parent) {
    element.$parent = parent;
  }
  return element;
}
function nextId(prefix3) {
  const ids3 = new index_esm_default([32, 32, 1]);
  return ids3.nextPrefixed(prefix3);
}
function getRoot(businessObject) {
  let parent = businessObject;
  while (parent.$parent) {
    parent = parent.$parent;
  }
  return parent;
}
function filterElementsByType(objectList, type) {
  const list = objectList || [];
  return list.filter((element) => is(element, type));
}
function findRootElementsByType(businessObject, referencedType) {
  const root = getRoot(businessObject);
  return filterElementsByType(root.get("rootElements"), referencedType);
}
function findRootElementById(businessObject, type, id) {
  const elements = findRootElementsByType(businessObject, type);
  return elements.find((element) => element.id === id);
}
var EMPTY_OPTION$4 = "";
var CREATE_NEW_OPTION$4 = "create-new";
function ErrorProps$2(props) {
  const {
    element
  } = props;
  if (!isErrorSupported(element)) {
    return [];
  }
  const error4 = getError(element);
  let entries = [{
    id: "errorRef",
    component: ErrorRef$1,
    isEdited: isEdited$3
  }];
  if (error4) {
    entries = [...entries, {
      id: "errorName",
      component: ErrorName$1,
      isEdited
    }, {
      id: "errorCode",
      component: ErrorCode$2,
      isEdited
    }];
  }
  return entries;
}
function ErrorRef$1(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const errorEventDefinition = getErrorEventDefinition$1(element);
  const getValue = () => {
    const error4 = getError(element);
    if (error4) {
      return error4.get("id");
    }
    return EMPTY_OPTION$4;
  };
  const setValue = (value) => {
    const root = getRoot(errorEventDefinition);
    const commands = [];
    let error4;
    if (value === CREATE_NEW_OPTION$4) {
      error4 = createElement("bpmn:Error", {
        name: nextId("Error_")
      }, root, bpmnFactory);
      value = error4.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), error4]
          }
        }
      });
    }
    error4 = error4 || findRootElementById(errorEventDefinition, "bpmn:Error", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: errorEventDefinition,
        properties: {
          errorRef: error4
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION$4,
      label: translate4("<none>")
    }, {
      value: CREATE_NEW_OPTION$4,
      label: translate4("Create new ...")
    }];
    const errors = findRootElementsByType(getBusinessObject(element), "bpmn:Error");
    sortByName$5(errors).forEach((error4) => {
      options.push({
        value: error4.get("id"),
        label: error4.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "errorRef",
    label: translate4("Global error reference"),
    autoFocusEntry: "errorName",
    getValue,
    setValue,
    getOptions
  });
}
function ErrorName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const error4 = getError(element);
  const getValue = () => {
    return error4.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorName",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ErrorCode$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const error4 = getError(element);
  const getValue = () => {
    return error4.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorCode",
    label: translate4("Code"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function sortByName$5(elements) {
  return sortBy(elements, (e8) => (e8.name || "").toLowerCase());
}
var CREATE_NEW_OPTION$3 = "create-new";
function EscalationProps$2(props) {
  const {
    element
  } = props;
  if (!isEscalationSupported(element)) {
    return [];
  }
  const escalation = getEscalation(element);
  let entries = [{
    id: "escalationRef",
    component: EscalationRef,
    isEdited: isEdited$3
  }];
  if (escalation) {
    entries = [...entries, {
      id: "escalationName",
      component: EscalationName,
      isEdited
    }, {
      id: "escalationCode",
      component: EscalationCode$1,
      isEdited
    }];
  }
  return entries;
}
function EscalationRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const escalationEventDefinition = getEscalationEventDefinition(element);
  const getValue = () => {
    const escalation = getEscalation(element);
    return escalation && escalation.get("id");
  };
  const setValue = (value) => {
    const root = getRoot(escalationEventDefinition);
    const commands = [];
    let escalation;
    if (value === CREATE_NEW_OPTION$3) {
      const id = nextId("Escalation_");
      escalation = createElement("bpmn:Escalation", {
        id,
        name: id
      }, root, bpmnFactory);
      value = escalation.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), escalation]
          }
        }
      });
    }
    escalation = escalation || findRootElementById(escalationEventDefinition, "bpmn:Escalation", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: escalationEventDefinition,
        properties: {
          escalationRef: escalation
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: "",
      label: translate4("<none>")
    }, {
      value: CREATE_NEW_OPTION$3,
      label: translate4("Create new ...")
    }];
    const escalations = findRootElementsByType(getBusinessObject(element), "bpmn:Escalation");
    sortByName$4(escalations).forEach((escalation) => {
      options.push({
        value: escalation.get("id"),
        label: escalation.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "escalationRef",
    label: translate4("Global escalation reference"),
    autoFocusEntry: "escalationName",
    getValue,
    setValue,
    getOptions
  });
}
function EscalationName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue = () => {
    return escalation.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationName",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function EscalationCode$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue = () => {
    return escalation.get("escalationCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        escalationCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationCode",
    label: translate4("Code"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function sortByName$4(elements) {
  return sortBy(elements, (e8) => (e8.name || "").toLowerCase());
}
function ExecutableProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:Process") && !hasProcessRef$2(element)) {
    return [];
  }
  return [{
    id: "isExecutable",
    component: Executable,
    isEdited: isEdited$5
  }];
}
function Executable(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  let getValue, setValue;
  setValue = (value) => {
    modeling.updateProperties(element, {
      isExecutable: value
    });
  };
  getValue = (element2) => {
    return element2.businessObject.isExecutable;
  };
  if (is(element, "bpmn:Participant")) {
    const process2 = element.businessObject.get("processRef");
    setValue = (value) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: process2,
        properties: {
          isExecutable: value
        }
      });
    };
    getValue = () => {
      return process2.get("isExecutable");
    };
  }
  return CheckboxEntry({
    element,
    id: "isExecutable",
    label: translate4("Executable"),
    getValue,
    setValue
  });
}
function hasProcessRef$2(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var SPACE_REGEX = /\s/;
var QNAME_REGEX = /^([a-z][\w-.]*:)?[a-z_][\w-.]*$/i;
var ID_REGEX = /^[a-z_][\w-.]*$/i;
function isIdValid(element, idValue, translate4) {
  const assigned = element.$model.ids.assigned(idValue);
  const idAlreadyExists = assigned && assigned !== element;
  if (!idValue) {
    return translate4("ID must not be empty.");
  }
  if (idAlreadyExists) {
    return translate4("ID must be unique.");
  }
  return validateId(idValue, translate4);
}
function validateId(idValue, translate4) {
  if (containsSpace(idValue)) {
    return translate4("ID must not contain spaces.");
  }
  if (!ID_REGEX.test(idValue)) {
    if (QNAME_REGEX.test(idValue)) {
      return translate4("ID must not contain prefix.");
    }
    return translate4("ID must be a valid QName.");
  }
}
function containsSpace(value) {
  return SPACE_REGEX.test(value);
}
function IdProps$1() {
  return [{
    id: "id",
    component: Id$4,
    isEdited
  }];
}
function Id$4(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce2 = useService("debounceInput");
  const translate4 = useService("translate");
  const setValue = (value, error4) => {
    if (error4) {
      return;
    }
    modeling.updateProperties(element, {
      id: value
    });
  };
  const getValue = T4((element2) => {
    return getBusinessObject(element2).id;
  }, [element]);
  const validate = T4((value) => {
    const businessObject = getBusinessObject(element);
    return isIdValid(businessObject, value, translate4);
  }, [element, translate4]);
  return TextfieldEntry({
    element,
    id: "id",
    label: translate4(is(element, "bpmn:Participant") ? "Participant ID" : "ID"),
    getValue,
    setValue,
    debounce: debounce2,
    validate
  });
}
function LinkProps(props) {
  const {
    element
  } = props;
  if (!isLinkSupported(element)) {
    return [];
  }
  return [{
    id: "linkName",
    component: LinkName,
    isEdited
  }];
}
function LinkName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const linkEventDefinition = getLinkEventDefinition(element);
  const getValue = () => {
    return linkEventDefinition.get("name");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: linkEventDefinition,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "linkName",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
var EMPTY_OPTION$3 = "";
var CREATE_NEW_OPTION$2 = "create-new";
function MessageProps$1(props) {
  const {
    element
  } = props;
  if (!isMessageSupported(element)) {
    return [];
  }
  const message = getMessage(element);
  let entries = [{
    id: "messageRef",
    component: MessageRef,
    isEdited: isEdited$3
  }];
  if (message) {
    entries = [...entries, {
      id: "messageName",
      component: MessageName$1,
      isEdited
    }];
  }
  return entries;
}
function MessageRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const messageEventDefinition = getMessageEventDefinition(element);
  const getValue = () => {
    const message = getMessage(element);
    if (message) {
      return message.get("id");
    }
    return EMPTY_OPTION$3;
  };
  const setValue = (value) => {
    const root = getRoot(messageEventDefinition);
    const commands = [];
    let message;
    if (value === CREATE_NEW_OPTION$2) {
      const id = nextId("Message_");
      message = createElement("bpmn:Message", {
        id,
        name: id
      }, root, bpmnFactory);
      value = message.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), message]
          }
        }
      });
    }
    message = message || findRootElementById(messageEventDefinition, "bpmn:Message", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: messageEventDefinition,
        properties: {
          messageRef: message
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION$3,
      label: translate4("<none>")
    }, {
      value: CREATE_NEW_OPTION$2,
      label: translate4("Create new ...")
    }];
    const messages = findRootElementsByType(getBusinessObject(element), "bpmn:Message");
    sortByName$3(messages).forEach((message) => {
      options.push({
        value: message.get("id"),
        label: message.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "messageRef",
    label: translate4("Global message reference"),
    autoFocusEntry: "messageName",
    getValue,
    setValue,
    getOptions
  });
}
function MessageName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const message = getMessage(element);
  const getValue = () => {
    return message.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: message,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "messageName",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function sortByName$3(elements) {
  return sortBy(elements, (e8) => (e8.name || "").toLowerCase());
}
function MultiInstanceProps$2(props) {
  const {
    element
  } = props;
  if (!isMultiInstanceSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "loopCardinality",
    component: LoopCardinality,
    isEdited
  }, {
    id: "completionCondition",
    component: CompletionCondition$1,
    isEdited
  }];
  return entries;
}
function LoopCardinality(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getLoopCardinalityValue(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", updateFormalExpression(element, "loopCardinality", value, bpmnFactory));
  };
  return TextfieldEntry({
    element,
    id: "loopCardinality",
    label: translate4("Loop cardinality"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CompletionCondition$1(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getCompletionConditionValue(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", updateFormalExpression(element, "completionCondition", value, bpmnFactory));
  };
  return TextfieldEntry({
    element,
    id: "completionCondition",
    label: translate4("Completion condition"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function isMultiInstanceSupported$1(element) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  return !!loopCharacteristics && is(loopCharacteristics, "bpmn:MultiInstanceLoopCharacteristics");
}
function getBody(expression) {
  return expression && expression.get("body");
}
function getProperty$3(element, propertyName) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName);
}
function getLoopCharacteristics$2(element) {
  const bo = getBusinessObject(element);
  return bo.loopCharacteristics;
}
function createFormalExpression$1(parent, body, bpmnFactory) {
  return createElement("bpmn:FormalExpression", {
    body
  }, parent, bpmnFactory);
}
function updateFormalExpression(element, propertyName, newValue, bpmnFactory) {
  const loopCharacteristics = getLoopCharacteristics$2(element);
  const expressionProps = {};
  if (!newValue) {
    expressionProps[propertyName] = void 0;
    return {
      element,
      moddleElement: loopCharacteristics,
      properties: expressionProps
    };
  }
  const existingExpression = loopCharacteristics.get(propertyName);
  if (!existingExpression) {
    expressionProps[propertyName] = createFormalExpression$1(loopCharacteristics, newValue, bpmnFactory);
    return {
      element,
      moddleElement: loopCharacteristics,
      properties: expressionProps
    };
  }
  return {
    element,
    moddleElement: existingExpression,
    properties: {
      body: newValue
    }
  };
}
function getLoopCardinality(element) {
  return getProperty$3(element, "loopCardinality");
}
function getLoopCardinalityValue(element) {
  const loopCardinality = getLoopCardinality(element);
  return getBody(loopCardinality);
}
function getCompletionCondition$1(element) {
  return getProperty$3(element, "completionCondition");
}
function getCompletionConditionValue(element) {
  const completionCondition = getCompletionCondition$1(element);
  return getBody(completionCondition);
}
function NameProps(props) {
  const {
    element
  } = props;
  if (isAny(element, ["bpmn:Collaboration", "bpmn:DataAssociation", "bpmn:Association"])) {
    return [];
  }
  return [{
    id: "name",
    component: Name$3,
    isEdited: isEdited$1
  }];
}
function Name$3(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce2 = useService("debounceInput");
  const canvas = useService("canvas");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  let options = {
    element,
    id: "name",
    label: translate4("Name"),
    debounce: debounce2,
    setValue: (value) => {
      modeling.updateProperties(element, {
        name: value
      });
    },
    getValue: (element2) => {
      return element2.businessObject.name;
    },
    autoResize: true
  };
  if (is(element, "bpmn:TextAnnotation")) {
    options = {
      ...options,
      setValue: (value) => {
        modeling.updateProperties(element, {
          text: value
        });
      },
      getValue: (element2) => {
        return element2.businessObject.text;
      }
    };
  } else if (is(element, "bpmn:Group")) {
    options = {
      ...options,
      setValue: (value) => {
        const businessObject = getBusinessObject(element), categoryValueRef = businessObject.categoryValueRef;
        if (!categoryValueRef) {
          initializeCategory(businessObject, canvas.getRootElement(), bpmnFactory);
        }
        modeling.updateLabel(element, value);
      },
      getValue: (element2) => {
        const businessObject = getBusinessObject(element2), categoryValueRef = businessObject.categoryValueRef;
        return categoryValueRef && categoryValueRef.value;
      }
    };
  } else if (is(element, "bpmn:Participant")) {
    options.label = translate4("Participant Name");
  }
  return TextAreaEntry(options);
}
function initializeCategory(businessObject, rootElement, bpmnFactory) {
  const definitions = getBusinessObject(rootElement).$parent;
  const categoryValue = createCategoryValue2(definitions, bpmnFactory);
  businessObject.categoryValueRef = categoryValue;
}
function createCategoryValue2(definitions, bpmnFactory) {
  const categoryValue = bpmnFactory.create("bpmn:CategoryValue");
  const category = bpmnFactory.create("bpmn:Category", {
    categoryValue: [categoryValue]
  });
  add2(definitions.get("rootElements"), category);
  getBusinessObject(category).$parent = definitions;
  getBusinessObject(categoryValue).$parent = category;
  return categoryValue;
}
function ProcessProps$1(props) {
  const {
    element
  } = props;
  if (!hasProcessRef$1(element)) {
    return [];
  }
  return [{
    id: "processId",
    component: ProcessId$1,
    isEdited
  }, {
    id: "processName",
    component: ProcessName,
    isEdited
  }];
}
function ProcessName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue = () => {
    return process2.get("name");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "processName",
    label: translate4("Process name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ProcessId$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue = () => {
    return process2.get("id");
  };
  const setValue = (value, error4) => {
    if (error4) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        id: value
      }
    });
  };
  const validate = T4((value) => {
    return isIdValid(process2, value, translate4);
  }, [process2, translate4]);
  return TextfieldEntry({
    element,
    id: "processId",
    label: translate4("Process ID"),
    getValue,
    setValue,
    debounce: debounce2,
    validate
  });
}
function hasProcessRef$1(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var EMPTY_OPTION$2 = "";
var CREATE_NEW_OPTION$1 = "create-new";
function SignalProps$1(props) {
  const {
    element
  } = props;
  if (!isSignalSupported$1(element)) {
    return [];
  }
  const signal = getSignal$1(element);
  let entries = [{
    id: "signalRef",
    component: SignalRef,
    isEdited: isEdited$3
  }];
  if (signal) {
    entries = [...entries, {
      id: "signalName",
      component: SignalName$1,
      isEdited
    }];
  }
  return entries;
}
function SignalRef(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const signalEventDefinition = getSignalEventDefinition$1(element);
  const getValue = () => {
    const signal = getSignal$1(element);
    if (signal) {
      return signal.get("id");
    }
    return EMPTY_OPTION$2;
  };
  const setValue = (value) => {
    const root = getRoot(signalEventDefinition);
    const commands = [];
    let signal;
    if (value === CREATE_NEW_OPTION$1) {
      const id = nextId("Signal_");
      signal = createElement("bpmn:Signal", {
        id,
        name: id
      }, root, bpmnFactory);
      value = signal.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), signal]
          }
        }
      });
    }
    signal = signal || findRootElementById(signalEventDefinition, "bpmn:Signal", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: signalEventDefinition,
        properties: {
          signalRef: signal
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION$2,
      label: translate4("<none>")
    }, {
      value: CREATE_NEW_OPTION$1,
      label: translate4("Create new ...")
    }];
    const signals = findRootElementsByType(getBusinessObject(element), "bpmn:Signal");
    sortByName$2(signals).forEach((signal) => {
      options.push({
        value: signal.get("id"),
        label: signal.get("name")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: "signalRef",
    label: translate4("Global signal reference"),
    autoFocusEntry: "signalName",
    getValue,
    setValue,
    getOptions
  });
}
function SignalName$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const signal = getSignal$1(element);
  const getValue = () => {
    return signal.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: signal,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "signalName",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function sortByName$2(elements) {
  return sortBy(elements, (e8) => (e8.name || "").toLowerCase());
}
function getErrorEventDefinition(element) {
  return getEventDefinition3(element, "bpmn:ErrorEventDefinition");
}
function isTimerSupported(element) {
  return isAny(element, ["bpmn:StartEvent", "bpmn:IntermediateCatchEvent", "bpmn:BoundaryEvent"]) && !!getTimerEventDefinition(element);
}
function getTimerDefinitionType(timer) {
  if (!timer) {
    return;
  }
  const timeDate = timer.get("timeDate");
  if (typeof timeDate !== "undefined") {
    return "timeDate";
  }
  const timeCycle = timer.get("timeCycle");
  if (typeof timeCycle !== "undefined") {
    return "timeCycle";
  }
  const timeDuration = timer.get("timeDuration");
  if (typeof timeDuration !== "undefined") {
    return "timeDuration";
  }
}
function getTimerEventDefinition(element) {
  return getEventDefinition3(element, "bpmn:TimerEventDefinition");
}
function getEventDefinition3(element, eventType) {
  const businessObject = getBusinessObject(element);
  const eventDefinitions = businessObject.get("eventDefinitions") || [];
  return find(eventDefinitions, function(definition) {
    return is(definition, eventType);
  });
}
function getSignalEventDefinition(element) {
  return getEventDefinition3(element, "bpmn:SignalEventDefinition");
}
function isSignalSupported(element) {
  return is(element, "bpmn:Event") && !!getSignalEventDefinition(element);
}
function getSignal(element) {
  const signalEventDefinition = getSignalEventDefinition(element);
  return signalEventDefinition && signalEventDefinition.get("signalRef");
}
function getCompensateEventDefinition(element) {
  return getEventDefinition3(element, "bpmn:CompensateEventDefinition");
}
function TimerProps$2(props) {
  const {
    element,
    idPrefix
  } = props;
  let {
    timerEventDefinition
  } = props;
  if (!timerEventDefinition) {
    const businessObject = getBusinessObject(element);
    timerEventDefinition = getTimerEventDefinition(businessObject);
  }
  const timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element)) {
    return [];
  }
  const entries = [];
  entries.push({
    id: getId$1(idPrefix, "timerEventDefinitionType"),
    component: TimerEventDefinitionType$2,
    isEdited: isEdited$3,
    timerEventDefinition,
    timerEventDefinitionType
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: getId$1(idPrefix, "timerEventDefinitionValue"),
      component: TimerEventDefinitionValue$2,
      isEdited,
      timerEventDefinition,
      timerEventDefinitionType
    });
  }
  return entries;
}
function TimerEventDefinitionType$2(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate");
  const getValue = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
      body: void 0
    });
    formalExpression.$parent = timerEventDefinition;
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate4("<none>")
    }, {
      value: "timeDate",
      label: translate4("Date")
    }, {
      value: "timeDuration",
      label: translate4("Duration")
    }, {
      value: "timeCycle",
      label: translate4("Cycle")
    }];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue$2(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "timerEventDefinitionValue",
    label: translate4("Value"),
    getValue,
    setValue,
    debounce: debounce2,
    tooltip: getTimerEventDefinitionValueDescription$2(timerEventDefinitionType, translate4)
  });
}
function getTimerEventDefinitionValueDescription$2(timerDefinitionType, translate4) {
  switch (timerDefinitionType) {
    case "timeDate":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate4("UTC time")]
          }), u5("li", {
            children: [u5("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate4("UTC plus 2 hours zone offset")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-date",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate4("Documentation: Timer events")
        })]
      });
    case "timeCycle":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A cycle defined as ISO 8601 repeating intervals format.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "R5/PT10S"
            }), " - ", translate4("every 10 seconds, up to 5 times")]
          }), u5("li", {
            children: [u5("code", {
              children: "R/P1D"
            }), " - ", translate4("every day, infinitely")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-cycle",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate4("Documentation: Timer events")
        })]
      });
    case "timeDuration":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A time duration defined as ISO 8601 durations format.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "PT15S"
            }), " - ", translate4("15 seconds")]
          }), u5("li", {
            children: [u5("code", {
              children: "PT1H30M"
            }), " - ", translate4("1 hour and 30 minutes")]
          }), u5("li", {
            children: [u5("code", {
              children: "P14D"
            }), " - ", translate4("14 days")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-duration",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate4("Documentation: Timer events")
        })]
      });
  }
}
function getId$1(idPrefix, id) {
  return idPrefix ? idPrefix + id : id;
}
function GeneralGroup(element, injector) {
  const translate4 = injector.get("translate");
  const entries = [...NameProps({
    element
  }), ...IdProps$1(), ...ProcessProps$1({
    element
  }), ...ExecutableProps({
    element
  })];
  return {
    id: "general",
    label: translate4("General"),
    entries,
    component: Group
  };
}
function CompensationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Compensation"),
    id: "compensation",
    component: Group,
    entries: [...CompensationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function DocumentationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const entries = [...DocumentationProps({
    element
  })];
  return {
    id: "documentation",
    label: translate4("Documentation"),
    entries,
    component: Group
  };
}
function ErrorGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "error",
    label: translate4("Error"),
    component: Group,
    entries: [...ErrorProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function MessageGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "message",
    label: translate4("Message"),
    component: Group,
    entries: [...MessageProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function SignalGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "signal",
    label: translate4("Signal"),
    component: Group,
    entries: [...SignalProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function LinkGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Link"),
    id: "link",
    component: Group,
    entries: [...LinkProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function EscalationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "escalation",
    label: translate4("Escalation"),
    component: Group,
    entries: [...EscalationProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function TimerGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Timer"),
    id: "timer",
    component: Group,
    entries: [...TimerProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function MultiInstanceGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Multi-instance"),
    id: "multiInstance",
    component: Group,
    entries: [...MultiInstanceProps$2({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function getGroups(element, injector) {
  const groups = [GeneralGroup(element, injector), DocumentationGroup(element, injector), CompensationGroup(element, injector), ErrorGroup(element, injector), LinkGroup(element, injector), MessageGroup(element, injector), MultiInstanceGroup(element, injector), SignalGroup(element, injector), EscalationGroup(element, injector), TimerGroup(element, injector)];
  return groups.filter((group) => group !== null);
}
var BpmnPropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(getGroups(element, this._injector));
      return groups;
    };
  }
};
BpmnPropertiesProvider.$inject = ["propertiesPanel", "injector"];
var index$2 = {
  __init__: ["bpmnPropertiesProvider"],
  bpmnPropertiesProvider: ["type", BpmnPropertiesProvider]
};
function withProps(Component2, otherProps) {
  return (props) => {
    return u5(Component2, {
      ...props,
      ...otherProps
    });
  };
}
var fallbackResolver = {
  getVariablesForElement: (bo) => getVariablesForElement(bo)
};
function withVariableContext(Component2) {
  return (props) => {
    const {
      bpmnElement,
      element
    } = props;
    const bo = (bpmnElement || element).businessObject;
    const [variables, setVariables] = h4([]);
    const eventBus = useService("eventBus");
    const variableResolver = useServiceIfAvailable("variableResolver", fallbackResolver);
    p4(() => {
      const extractVariables = async () => {
        const variables2 = await variableResolver.getVariablesForElement(bo, element);
        setVariables(variables2.map((variable) => {
          return {
            ...variable,
            info: variable.info || variable.origin && "Written in " + variable.origin.map((origin) => origin.name || origin.id).join(", ")
          };
        }));
      };
      const callback = () => {
        extractVariables();
      };
      eventBus.on("commandStack.changed", callback);
      callback();
      return () => {
        eventBus.off("commandStack.changed", callback);
      };
    }, [bo]);
    return u5(Component2, {
      ...props,
      variables
    });
  };
}
function useServiceIfAvailable(service, fallback) {
  const resolved = useService(service, false);
  if (!resolved) {
    return fallback;
  }
  return resolved;
}
function withTooltipContainer(Component2) {
  return (props) => {
    const tooltipContainer = F4(() => {
      const config = useService("config");
      return config && config.propertiesPanel && config.propertiesPanel.feelTooltipContainer;
    }, []);
    return u5(Component2, {
      ...props,
      tooltipContainer
    });
  };
}
var FeelEntry2 = withTooltipContainer(FeelEntry);
var FeelEntryWithVariableContext = withVariableContext(FeelEntry2);
function getExtensionElementsList(businessObject, type = void 0) {
  const extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    return [];
  }
  const values2 = extensionElements.get("values");
  if (!values2 || !values2.length) {
    return [];
  }
  if (type) {
    return values2.filter((value) => is(value, type));
  }
  return values2;
}
function addExtensionElements(element, businessObject, extensionElementToAdd, bpmnFactory, commandStack) {
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElements.get("values"), extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function removeExtensionElements(element, businessObject, extensionElementsToRemove, commandStack) {
  if (!isArray(extensionElementsToRemove)) {
    extensionElementsToRemove = [extensionElementsToRemove];
  }
  const extensionElements = businessObject.get("extensionElements"), values2 = extensionElements.get("values").filter((value) => !extensionElementsToRemove.includes(value));
  commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement: extensionElements,
    properties: {
      values: values2
    }
  });
}
function ActiveElementsProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:AdHocSubProcess")) {
    return [];
  }
  const entries = [{
    id: "activeElementsCollection",
    component: ActiveElementsCollection,
    isEdited: isEdited$6
  }];
  return entries;
}
function ActiveElementsCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getProperty$2(element);
  };
  const setValue = (value) => {
    return setProperty$1(element, value, commandStack, bpmnFactory);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "activeElements-activeElementsCollection",
    label: translate4("Active elements collection"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getProperty$2(element) {
  const extensionElement = getExtensionElement(element);
  return extensionElement && extensionElement.get("activeElementsCollection");
}
function setProperty$1(element, value, commandStack, bpmnFactory) {
  const extensionElement = getExtensionElement(element);
  if (!extensionElement) {
    const adHoc = createElement("zeebe:AdHoc", {
      activeElementsCollection: value
    }, void 0, bpmnFactory);
    const businessObject = getBusinessObject(element);
    addExtensionElements(element, businessObject, adHoc, bpmnFactory, commandStack);
  } else {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: extensionElement,
      properties: {
        activeElementsCollection: value
      }
    });
  }
}
function getExtensionElement(element) {
  const businessObject = getBusinessObject(element);
  const extensions = getExtensionElementsList(businessObject, "zeebe:AdHoc");
  return extensions[0];
}
function AssignmentDefinitionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "assignmentDefinitionAssignee",
    component: Assignee$1,
    isEdited: isEdited$6
  }, {
    id: "assignmentDefinitionCandidateGroups",
    component: CandidateGroups$1,
    isEdited: isEdited$6
  }, {
    id: "assignmentDefinitionCandidateUsers",
    component: CandidateUsers$1,
    isEdited: isEdited$6
  }];
}
function Assignee$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getAssignmentDefinition(element) || {}).assignee;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          assignee: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "assignmentDefinitionAssignee",
    label: translate4("Assignee"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CandidateGroups$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getAssignmentDefinition(element) || {}).candidateGroups;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          candidateGroups: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "assignmentDefinitionCandidateGroups",
    label: translate4("Candidate groups"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CandidateUsers$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getAssignmentDefinition(element) || {}).candidateUsers;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let assignmentDefinition = getAssignmentDefinition(element);
    if (!assignmentDefinition) {
      assignmentDefinition = createElement("zeebe:AssignmentDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), assignmentDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: assignmentDefinition,
        properties: {
          candidateUsers: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "assignmentDefinitionCandidateUsers",
    label: translate4("Candidate users"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getAssignmentDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:AssignmentDefinition")[0];
}
function isZeebeServiceTask(element) {
  if (!is(element, "zeebe:ZeebeServiceTask")) return false;
  if (is(element, "bpmn:EndEvent") || is(element, "bpmn:IntermediateThrowEvent")) {
    return !!getMessageEventDefinition(element);
  }
  if (isAny(element, ["bpmn:BusinessRuleTask", "bpmn:ScriptTask"]) && !getTaskDefinition$3(element)) {
    return false;
  }
  return true;
}
function isMessageEndEvent(element) {
  return is(element, "bpmn:EndEvent") && !!getMessageEventDefinition(element);
}
function isMessageThrowEvent(element) {
  return is(element, "bpmn:IntermediateThrowEvent") && !!getMessageEventDefinition(element);
}
function getTaskDefinition$3(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function areHeadersSupported(element) {
  return is(element, "bpmn:UserTask") || isZeebeServiceTask(element);
}
function getTaskHeaders$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskHeaders")[0];
}
function getHeaders(element) {
  const taskHeaders = getTaskHeaders$1(element);
  return taskHeaders ? taskHeaders.get("values") : [];
}
var DMN_IMPLEMENTATION_OPTION = "dmn";
var JOB_WORKER_IMPLEMENTATION_OPTION$2 = "jobWorker";
var DEFAULT_IMPLEMENTATION_OPTION$1 = "";
function BusinessRuleImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:BusinessRuleTask")) {
    return [];
  }
  return [{
    id: "businessRuleImplementation",
    component: BusinessRuleImplementation,
    isEdited: () => isBusinessRuleImplementationEdited(element)
  }];
}
function BusinessRuleImplementation(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    if (getCalledDecision$1(element)) {
      return DMN_IMPLEMENTATION_OPTION;
    }
    if (getTaskDefinition$2(element)) {
      return JOB_WORKER_IMPLEMENTATION_OPTION$2;
    }
    return DEFAULT_IMPLEMENTATION_OPTION$1;
  };
  const setValue = (value) => {
    let extensionElement, extensionElementType;
    if (value === DMN_IMPLEMENTATION_OPTION) {
      extensionElement = getCalledDecision$1(element);
      extensionElementType = "zeebe:CalledDecision";
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION$2) {
      extensionElement = getTaskDefinition$2(element);
      extensionElementType = "zeebe:TaskDefinition";
    } else {
      resetElement$1(element, commandStack);
    }
    if (!extensionElement && extensionElementType) {
      extensionElement = createElement(extensionElementType, {}, null, bpmnFactory);
      updateExtensionElements$1(element, extensionElement, bpmnFactory, commandStack);
    }
  };
  const getOptions = () => {
    const options = [{
      value: DEFAULT_IMPLEMENTATION_OPTION$1,
      label: translate4("<none>")
    }, {
      value: DMN_IMPLEMENTATION_OPTION,
      label: translate4("DMN decision")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION$2,
      label: translate4("Job worker")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id,
    label: translate4("Implementation"),
    getValue,
    setValue,
    getOptions
  });
}
function getTaskDefinition$2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function getCalledDecision$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:CalledDecision")[0];
}
function isBusinessRuleImplementationEdited(element) {
  return getTaskDefinition$2(element) || getCalledDecision$1(element);
}
function resetElement$1(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const toRemove = [getTaskDefinition$2(element), getTaskHeaders$1(element), getCalledDecision$1(element)].filter(Boolean);
  removeExtensionElements(element, businessObject, toRemove, commandStack);
}
function updateExtensionElements$1(element, extensionElementToAdd, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  let extensionElementValues;
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  if (is(extensionElementToAdd, "zeebe:TaskDefinition")) {
    extensionElementValues = without(extensionElements.get("values"), getCalledDecision$1(element));
  } else if (is(extensionElementToAdd, "zeebe:CalledDecision")) {
    extensionElementValues = without(extensionElements.get("values"), getTaskDefinition$2(element));
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElementValues, extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function Binding$2(props) {
  const {
    element,
    type
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate4 = useService("translate");
  const getValue = () => getBindingType(element, type);
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let extensionElement = getExtensionElementsList(businessObject, type)[0];
    if (!extensionElement) {
      extensionElement = createElement(type, {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), extensionElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElement,
        properties: {
          bindingType: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => [{
    value: "latest",
    label: translate4("latest")
  }, {
    value: "deployment",
    label: translate4("deployment")
  }, {
    value: "versionTag",
    label: translate4("version tag")
  }];
  return u5(SelectEntry, {
    element,
    id: "bindingType",
    label: translate4("Binding"),
    getValue,
    setValue,
    getOptions
  });
}
function getBindingType(element, type) {
  const businessObject = getBusinessObject(element);
  const extensionElement = getExtensionElementsList(businessObject, type)[0];
  if (!extensionElement) {
    return "latest";
  }
  return extensionElement.get("bindingType");
}
function VersionTag$3(props) {
  const {
    element,
    type
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), debounce2 = useService("debounceInput"), translate4 = useService("translate");
  const getValue = () => getVersionTag$1(element, type);
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let extensionElement = getExtensionElementsList(businessObject, type)[0];
    if (!extensionElement) {
      extensionElement = createElement(type, {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), extensionElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElement,
        properties: {
          versionTag: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate4("Version tag"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getVersionTag$1(element, type) {
  const businessObject = getBusinessObject(element);
  const extensionElement = getExtensionElementsList(businessObject, type)[0];
  if (!extensionElement) {
    return "";
  }
  return extensionElement.get("versionTag") || "";
}
var CalledDecisionBinding = withProps(Binding$2, {
  type: "zeebe:CalledDecision"
});
var CalledDecisionVersionTag = withProps(VersionTag$3, {
  type: "zeebe:CalledDecision"
});
function CalledDecisionProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:BusinessRuleTask") || !getCalledDecision2(element)) {
    return [];
  }
  const entries = [{
    id: "decisionId",
    component: DecisionID,
    isEdited: isEdited$6
  }, {
    id: "bindingType",
    component: CalledDecisionBinding,
    isEdited: isEdited$3
  }];
  if (getBindingType(element, "zeebe:CalledDecision") === "versionTag") {
    entries.push({
      id: "versionTag",
      component: CalledDecisionVersionTag,
      isEdited
    });
  }
  entries.push({
    id: "resultVariable",
    component: ResultVariable$4,
    isEdited
  });
  return entries;
}
function DecisionID(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getCalledDecision2(element) || {}).decisionId;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledDecision = getCalledDecision2(element);
    if (!calledDecision) {
      calledDecision = createElement("zeebe:CalledDecision", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledDecision]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledDecision,
        properties: {
          decisionId: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id,
    label: translate4("Decision ID"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$4(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getCalledDecision2(element) || {}).resultVariable;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledDecision = getCalledDecision2(element);
    if (!calledDecision) {
      calledDecision = createElement("zeebe:CalledDecision", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledDecision]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledDecision,
        properties: {
          resultVariable: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id,
    label: translate4("Result variable"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getCalledDecision2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:CalledDecision")[0];
}
function ConditionProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:SequenceFlow")) {
    return [];
  }
  const conditionProps = [];
  if (isConditionalSource$1(element.source)) {
    conditionProps.push({
      id: "conditionExpression",
      component: ConditionExpression$1,
      isEdited: isEdited$6
    });
  }
  return conditionProps;
}
function ConditionExpression$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionExpression$1(element);
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    const source = element.source;
    if (source.businessObject.default === businessObject) {
      commands.push({
        cmd: "element.updateProperties",
        context: {
          element: source,
          properties: {
            "default": void 0
          }
        }
      });
    }
    const formalExpressionElement = value && value != "" ? createElement("bpmn:FormalExpression", {
      body: value
    }, businessObject, bpmnFactory) : void 0;
    commands.push({
      cmd: "element.updateProperties",
      context: {
        element,
        properties: {
          conditionExpression: formalExpressionElement
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "conditionExpression",
    label: translate4("Condition expression"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
var CONDITIONAL_SOURCES$1 = ["bpmn:Activity", "bpmn:ExclusiveGateway", "bpmn:InclusiveGateway"];
function isConditionalSource$1(element) {
  return isAny(element, CONDITIONAL_SOURCES$1);
}
function getConditionExpression$1(element) {
  const businessObject = getBusinessObject(element);
  const conditionExpression = businessObject.conditionExpression;
  if (conditionExpression) {
    return conditionExpression.get("body");
  }
}
function ErrorProps$1(props) {
  const {
    element
  } = props;
  const error4 = getError(element);
  const entries = [];
  if (error4 && is(element, "bpmn:ThrowEvent")) {
    entries.push({
      id: "errorCode",
      component: ErrorCode$1,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function ErrorCode$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const error4 = getError(element);
  const getValue = () => {
    return error4.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorCode: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "errorCode",
    label: translate4("Code"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function EscalationProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ThrowEvent")) {
    return [];
  }
  const escalation = getEscalation(element);
  const entries = [];
  if (escalation) {
    entries.push({
      id: "escalationCode",
      component: EscalationCode,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function EscalationCode(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalation = getEscalation(element);
  const getValue = () => {
    return escalation.get("escalationCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalation,
      properties: {
        escalationCode: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "escalationCode",
    label: translate4("Code"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ListenerType$1(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      type: value
    });
  };
  const getValue = () => {
    return listener.get("type");
  };
  return FeelEntryWithVariableContext({
    element,
    id: idPrefix + "-listenerType",
    label: translate4("Listener type"),
    getValue,
    setValue,
    debounce: debounce2,
    feel: "optional"
  });
}
function Retries(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      retries: value
    });
  };
  const getValue = () => {
    return listener.get("retries");
  };
  return FeelEntryWithVariableContext({
    element,
    id: idPrefix + "-retries",
    label: translate4("Retries"),
    getValue,
    setValue,
    debounce: debounce2,
    feel: "optional"
  });
}
var EVENT_TO_LABEL$2 = {
  "start": "Start",
  "end": "End"
};
function ExecutionListenerEntries(props) {
  const {
    element,
    idPrefix,
    listener
  } = props;
  const eventTypes = getEventTypes(element);
  const entries = eventTypes.length > 1 ? [{
    id: idPrefix + "-eventType",
    component: EventType$2,
    idPrefix,
    listener,
    eventTypes
  }] : [];
  entries.push({
    id: idPrefix + "-listenerType",
    component: ListenerType$1,
    idPrefix,
    listener
  }, {
    id: idPrefix + "-retries",
    component: Retries,
    idPrefix,
    listener
  });
  return entries;
}
function EventType$2(props) {
  const {
    idPrefix,
    element,
    listener,
    eventTypes
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const getOptions = () => {
    return eventTypes.map((eventType) => ({
      value: eventType,
      label: translate4(EVENT_TO_LABEL$2[eventType])
    }));
  };
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      eventType: value
    });
  };
  const getValue = () => {
    return listener.get("eventType");
  };
  return SelectEntry({
    element,
    id: idPrefix + "-eventType",
    label: translate4("Event type"),
    getValue,
    setValue,
    getOptions
  });
}
function getEventTypes(element) {
  if (isAny(element, ["bpmn:BoundaryEvent", "bpmn:StartEvent"])) {
    return ["end"];
  }
  if (is(element, "bpmn:EndEvent") && getErrorEventDefinition(element)) {
    return ["start"];
  }
  if (is(element, "bpmn:Gateway")) {
    return ["start"];
  }
  return ["start", "end"];
}
function ExecutionListenersProps({
  element,
  injector
}) {
  let businessObject = getRelevantBusinessObject$2(element);
  if (!businessObject) {
    return;
  }
  const moddle = injector.get("moddle");
  if (!canHaveExecutionListeners(businessObject, moddle)) {
    return;
  }
  const listeners = getListenersList$1(businessObject) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack"), modeling = injector.get("modeling"), translate4 = injector.get("translate");
  const items = listeners.map((listener, index5) => {
    const id = element.id + "-executionListener-" + index5;
    const type = listener.get("type") || "<no type>";
    return {
      id,
      label: translate4(`${EVENT_TO_LABEL$2[listener.get("eventType")]}: {type}`, {
        type
      }),
      entries: ExecutionListenerEntries({
        idPrefix: id,
        element,
        listener
      }),
      autoFocusEntry: id + "-eventType",
      remove: removeFactory$e({
        modeling,
        element,
        listener
      })
    };
  });
  return {
    items,
    add: addFactory$b({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$e({
  modeling,
  element,
  listener
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getRelevantBusinessObject$2(element);
    const container = getExecutionListenersContainer(businessObject);
    if (!container) {
      return;
    }
    const listeners = without(container.get("listeners"), listener);
    modeling.updateModdleProperties(element, container, {
      listeners
    });
  };
}
function addFactory$b({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject$2(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let executionListeners = getExecutionListenersContainer(businessObject);
    if (!executionListeners) {
      const parent = extensionElements;
      executionListeners = createElement("zeebe:ExecutionListeners", {
        listeners: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), executionListeners]
          }
        }
      });
    }
    const executionListener = createElement("zeebe:ExecutionListener", getDefaultListenerProps$1(element), executionListeners, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: executionListeners,
        properties: {
          listeners: [...executionListeners.get("listeners"), executionListener]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject$2(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getExecutionListenersContainer(element) {
  const executionListeners = getExtensionElementsList(element, "zeebe:ExecutionListeners");
  return executionListeners && executionListeners[0];
}
function getListenersList$1(element) {
  const executionListeners = getExecutionListenersContainer(element);
  return executionListeners && executionListeners.get("listeners");
}
function canHaveExecutionListeners(bo, moddle) {
  const executionListenersDescriptor = moddle.getTypeDescriptor("zeebe:ExecutionListeners");
  if (!isAny(bo, executionListenersDescriptor.meta.allowedIn)) {
    return false;
  }
  if (isCompensationBoundaryEvent3(bo)) {
    return false;
  }
  return true;
}
function isCompensationBoundaryEvent3(bo) {
  return is(bo, "bpmn:BoundaryEvent") && getCompensateEventDefinition(bo);
}
function getDefaultListenerProps$1(element) {
  const eventTypes = getEventTypes(element);
  return {
    eventType: eventTypes[0]
  };
}
var FORM_KEY_PREFIX = "camunda-forms:bpmn:";
var USER_TASK_FORM_ID_PREFIX = "UserTaskForm_";
var FORM_TYPES = {
  CAMUNDA_FORM_EMBEDDED: "camunda-form-embedded",
  CAMUNDA_FORM_LINKED: "camunda-form-linked",
  CUSTOM_FORM: "custom-form",
  EXTERNAL_REFERENCE: "external-reference"
};
function getFormDefinition(element) {
  const businessObject = getBusinessObject(element);
  const formDefinitions = getExtensionElementsList(businessObject, "zeebe:FormDefinition");
  return formDefinitions[0];
}
function getUserTaskForm(element, rootElement) {
  rootElement = rootElement || getRootElement$1(element);
  const formDefinition = getFormDefinition(element);
  if (!formDefinition) {
    return;
  }
  const formKey = formDefinition.get("formKey");
  const userTaskForms = getExtensionElementsList(rootElement, "zeebe:UserTaskForm");
  return userTaskForms.find((userTaskForm) => {
    return userTaskFormIdToFormKey(userTaskForm.get("id")) === formKey;
  });
}
function userTaskFormIdToFormKey(userTaskFormId) {
  return `${FORM_KEY_PREFIX}${userTaskFormId}`;
}
function createUserTaskFormId() {
  return nextId(USER_TASK_FORM_ID_PREFIX);
}
function getRootElement$1(element) {
  const businessObject = getBusinessObject(element);
  let parent = businessObject;
  while (parent.$parent && !is(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function getFormType$1(element) {
  const formDefinition = getFormDefinition(element);
  if (!formDefinition) {
    return;
  }
  const formId = formDefinition.get("formId"), formKey = formDefinition.get("formKey"), externalReference = formDefinition.get("externalReference");
  if (isDefined(formId)) {
    return FORM_TYPES.CAMUNDA_FORM_LINKED;
  }
  if (isDefined(externalReference)) {
    return FORM_TYPES.EXTERNAL_REFERENCE;
  }
  if (isDefined(formKey)) {
    if (getUserTaskForm(element)) {
      return FORM_TYPES.CAMUNDA_FORM_EMBEDDED;
    }
    return FORM_TYPES.CUSTOM_FORM;
  }
}
function isZeebeUserTask$1(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "zeebe:UserTask").length > 0;
}
var FormDefinitionBinding = withProps(Binding$2, {
  type: "zeebe:FormDefinition"
});
var FormDefinitionVersionTag = withProps(VersionTag$3, {
  type: "zeebe:FormDefinition"
});
var NONE_VALUE = "none";
function FormProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  const entries = [{
    id: "formType",
    component: FormType$1,
    isEdited: (node2) => node2.value !== NONE_VALUE
  }];
  const formType = getFormType$1(element);
  if (formType === FORM_TYPES.CAMUNDA_FORM_EMBEDDED) {
    entries.push({
      id: "formConfiguration",
      component: FormConfiguration,
      isEdited: isEdited$1
    });
  } else if (formType === FORM_TYPES.CAMUNDA_FORM_LINKED) {
    entries.push({
      id: "formId",
      component: FormId,
      isEdited
    });
  } else if (formType === FORM_TYPES.CUSTOM_FORM) {
    entries.push({
      id: "customFormKey",
      component: CustomForm,
      isEdited
    });
  } else if (formType === FORM_TYPES.EXTERNAL_REFERENCE) {
    entries.push({
      id: "externalReference",
      component: ExternalReference,
      isEdited: isEdited$6
    });
  }
  if (formType === FORM_TYPES.CAMUNDA_FORM_LINKED) {
    entries.push({
      id: "bindingType",
      component: FormDefinitionBinding,
      isEdited: isEdited$3
    });
    if (getBindingType(element, "zeebe:FormDefinition") === "versionTag") {
      entries.push({
        id: "versionTag",
        component: FormDefinitionVersionTag,
        isEdited
      });
    }
  }
  return entries;
}
function FormType$1(props) {
  const {
    element
  } = props;
  const injector = useService("injector"), translate4 = useService("translate");
  const getValue = () => {
    return getFormType$1(element) || NONE_VALUE;
  };
  const setValue = (value) => {
    setFormType(injector, element, value);
  };
  const getOptions = () => {
    return getFormTypeOptions(translate4, element);
  };
  return SelectEntry({
    element,
    id: "formType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function setFormType(injector, element, value) {
  if (value === FORM_TYPES.CAMUNDA_FORM_EMBEDDED) {
    setUserTaskForm(injector, element, "");
  } else if (value === FORM_TYPES.CAMUNDA_FORM_LINKED) {
    setFormId(injector, element, "");
  } else if (value === FORM_TYPES.CUSTOM_FORM) {
    setCustomFormKey(injector, element, "");
  } else if (value === FORM_TYPES.EXTERNAL_REFERENCE) {
    setExternalReference(injector, element, "");
  } else {
    removeFormDefinition(injector, element);
  }
}
function getFormTypeOptions(translate4, element) {
  if (isZeebeUserTask$1(element)) {
    return [{
      value: NONE_VALUE,
      label: translate4("<none>")
    }, {
      value: FORM_TYPES.CAMUNDA_FORM_LINKED,
      label: translate4("Camunda Form")
    }, {
      value: FORM_TYPES.EXTERNAL_REFERENCE,
      label: translate4("External form reference")
    }];
  }
  return [{
    value: NONE_VALUE,
    label: translate4("<none>")
  }, {
    value: FORM_TYPES.CAMUNDA_FORM_LINKED,
    label: translate4("Camunda Form (linked)")
  }, {
    value: FORM_TYPES.CAMUNDA_FORM_EMBEDDED,
    label: translate4("Camunda Form (embedded)")
  }, {
    value: FORM_TYPES.CUSTOM_FORM,
    label: translate4("Custom form key")
  }];
}
function FormConfiguration(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate4 = useService("translate");
  const getValue = () => {
    return getUserTaskForm(element).get("body");
  };
  const setValue = (value) => {
    setUserTaskForm(injector, element, isUndefined(value) ? "" : value);
  };
  return TextAreaEntry({
    element,
    id: "formConfiguration",
    label: translate4("Form JSON configuration"),
    rows: 4,
    getValue,
    setValue,
    debounce: debounce2
  });
}
function FormId(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate4 = useService("translate");
  const getValue = () => {
    return getFormDefinition(element).get("formId");
  };
  const setValue = (value) => {
    setFormId(injector, element, isUndefined(value) ? "" : value);
  };
  return TextfieldEntry({
    element,
    id: "formId",
    label: translate4("Form ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CustomForm(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate4 = useService("translate");
  const getValue = () => {
    const formDefinition = getFormDefinition(element);
    return formDefinition.get("formKey");
  };
  const setValue = (value) => {
    setCustomFormKey(injector, element, isUndefined(value) ? "" : value);
  };
  return TextfieldEntry({
    element,
    id: "customFormKey",
    label: translate4("Custom form key"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ExternalReference(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput"), injector = useService("injector"), translate4 = useService("translate");
  const getValue = () => {
    const formDefinition = getFormDefinition(element);
    return formDefinition.get("externalReference");
  };
  const setValue = (value) => {
    setExternalReference(injector, element, isUndefined(value) ? "" : value);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "externalReference",
    label: translate4("External form reference"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getOrCreateExtensionElements(injector, element, moddleElement) {
  const businessObject = moddleElement || getBusinessObject(element);
  let extensionElements = businessObject.get("extensionElements");
  if (extensionElements) {
    return {
      commands: [],
      extensionElements
    };
  }
  const bpmnFactory = injector.get("bpmnFactory");
  extensionElements = createElement("bpmn:ExtensionElements", {
    values: []
  }, businessObject, bpmnFactory);
  return {
    commands: [createUpdateModdlePropertiesCommand(element, businessObject, {
      extensionElements
    })],
    extensionElements
  };
}
function getOrCreateFormDefintition(injector, element) {
  let formDefinition = getFormDefinition(element);
  if (formDefinition) {
    return {
      commands: [],
      formDefinition
    };
  }
  const {
    extensionElements,
    commands
  } = getOrCreateExtensionElements(injector, element);
  formDefinition = createFormDefinition(injector, {}, extensionElements);
  return {
    commands: [...commands, createUpdateModdlePropertiesCommand(element, extensionElements, {
      values: [...extensionElements.get("values"), formDefinition]
    })],
    formDefinition
  };
}
function getOrCreateUserTaskForm(injector, element) {
  let userTaskForm = getUserTaskForm(element);
  if (userTaskForm) {
    return {
      commands: [],
      formDefinition: getFormDefinition(element),
      userTaskForm
    };
  }
  const rootElement = getRootElement$1(element);
  const {
    extensionElements,
    commands: extensionElementsCommands
  } = getOrCreateExtensionElements(injector, element, rootElement);
  const {
    formDefinition,
    commands: formDefinitionCommands
  } = getOrCreateFormDefintition(injector, element);
  const formId = createUserTaskFormId();
  userTaskForm = createUserTaskForm(injector, {
    id: formId
  }, extensionElements);
  return {
    commands: [...extensionElementsCommands, ...formDefinitionCommands, createUpdateModdlePropertiesCommand(element, extensionElements, {
      values: [...extensionElements.get("values"), userTaskForm]
    }), createUpdateModdlePropertiesCommand(element, formDefinition, {
      formKey: userTaskFormIdToFormKey(formId)
    })],
    formDefinition,
    userTaskForm
  };
}
function setFormId(injector, element, formId) {
  let {
    commands,
    formDefinition
  } = getOrCreateFormDefintition(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, formDefinition, {
    formId
  })]);
}
function setCustomFormKey(injector, element, formKey) {
  let {
    commands,
    formDefinition
  } = getOrCreateFormDefintition(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, formDefinition, {
    formKey
  })]);
}
function setExternalReference(injector, element, externalReference) {
  let {
    commands,
    formDefinition
  } = getOrCreateFormDefintition(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, formDefinition, {
    externalReference
  })]);
}
function setUserTaskForm(injector, element, body) {
  let {
    commands,
    userTaskForm
  } = getOrCreateUserTaskForm(injector, element);
  const commandStack = injector.get("commandStack");
  commandStack.execute("properties-panel.multi-command-executor", [...commands, createUpdateModdlePropertiesCommand(element, userTaskForm, {
    body
  })]);
}
function removeFormDefinition(injector, element) {
  const formDefinition = getFormDefinition(element);
  const modeling = injector.get("modeling");
  if (formDefinition) {
    const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
    modeling.updateModdleProperties(element, extensionElements, {
      values: without(extensionElements.get("values"), formDefinition)
    });
  }
}
function createFormDefinition(injector, properties, parent) {
  const bpmnFactory = injector.get("bpmnFactory");
  return createElement("zeebe:FormDefinition", properties, parent, bpmnFactory);
}
function createUserTaskForm(injector, properties, parent) {
  const bpmnFactory = injector.get("bpmnFactory");
  return createElement("zeebe:UserTaskForm", properties, parent, bpmnFactory);
}
function createUpdateModdlePropertiesCommand(element, moddleElement, properties) {
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement,
      properties
    }
  };
}
function Header2(props) {
  const {
    idPrefix,
    header
  } = props;
  const entries = [{
    id: idPrefix + "-key",
    component: KeyProperty,
    header,
    idPrefix
  }, {
    id: idPrefix + "-value",
    component: ValueProperty$2,
    header,
    idPrefix
  }];
  return entries;
}
function KeyProperty(props) {
  const {
    idPrefix,
    element,
    header
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: header,
      properties: {
        key: value
      }
    });
  };
  const getValue = (header2) => {
    return header2.key;
  };
  return TextfieldEntry({
    element: header,
    id: idPrefix + "-key",
    label: translate4("Key"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ValueProperty$2(props) {
  const {
    idPrefix,
    element,
    header
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: header,
      properties: {
        value
      }
    });
  };
  const getValue = (header2) => {
    return header2.value;
  };
  return TextAreaEntry({
    element: header,
    id: idPrefix + "-value",
    label: translate4("Value"),
    getValue,
    setValue,
    debounce: debounce2,
    autoResize: true
  });
}
function HeaderProps({
  element,
  injector
}) {
  if (!areHeadersSupported(element)) {
    return null;
  }
  const headers = getHeaders(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = headers.map((header, index5) => {
    const id = element.id + "-header-" + index5;
    return {
      id,
      label: header.get("key") || "",
      entries: Header2({
        idPrefix: id,
        element,
        header
      }),
      autoFocusEntry: id + "-key",
      remove: removeFactory$d({
        commandStack,
        element,
        header
      })
    };
  });
  return {
    items,
    add: addFactory$a({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$d({
  commandStack,
  element,
  header
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const taskHeaders = getTaskHeaders$1(element);
    if (!taskHeaders) {
      return;
    }
    const newTaskHeaders = without(taskHeaders.get("values"), header);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: newTaskHeaders
        }
      }
    });
    if (!newTaskHeaders.length) {
      const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: without(extensionElements.get("values"), taskHeaders)
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$a({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskHeaders = getTaskHeaders$1(element);
    if (!taskHeaders) {
      const parent = extensionElements;
      taskHeaders = createElement("zeebe:TaskHeaders", {
        values: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskHeaders]
          }
        }
      });
    }
    const header = createElement("zeebe:Header", {}, taskHeaders, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskHeaders,
        properties: {
          values: [...taskHeaders.get("values"), header]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getProcessId(element) {
  const calledElement = getCalledElement(element);
  return calledElement ? calledElement.get("processId") : "";
}
function getCalledElement(element) {
  const calledElements = getCalledElements(element);
  return calledElements[0];
}
function getCalledElements(element) {
  const bo = getBusinessObject(element);
  const extElements = getExtensionElementsList(bo, "zeebe:CalledElement");
  return extElements;
}
function InputPropagationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  return [{
    id: "propagateAllParentVariables",
    component: PropagateAllParentVariables,
    isEdited: isEdited$8
  }];
}
function PropagateAllParentVariables(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate");
  const propagateAllParentVariables = isPropagateAllParentVariables(element);
  const getValue = () => {
    return propagateAllParentVariables;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          propagateAllParentVariables: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return ToggleSwitchEntry({
    id: "propagateAllParentVariables",
    label: translate4("Propagate all parent process variables"),
    switcherLabel: propagateAllParentVariables ? translate4("On") : translate4("Off"),
    tooltip: u5("div", {
      children: [u5("p", {
        children: translate4("If turned on, all variables from the parent process instance will be propagated to the child process instance.")
      }), u5("p", {
        children: translate4("Otherwise, only variables defined via input mappings will be propagated.")
      })]
    }),
    getValue,
    setValue
  });
}
function isPropagateAllParentVariables(element) {
  if (!is(element, "bpmn:CallActivity")) {
    return void 0;
  }
  const bo = getBusinessObject(element), calledElement = getCalledElement(bo);
  return calledElement && has(calledElement, "propagateAllParentVariables") ? calledElement.get("propagateAllParentVariables") : (
    /* default value */
    true
  );
}
function InputOutputParameter$1(props) {
  const {
    idPrefix,
    parameter
  } = props;
  const entries = [{
    id: idPrefix + "-target",
    component: TargetProperty,
    idPrefix,
    parameter
  }, {
    id: idPrefix + "-source",
    component: SourceProperty,
    idPrefix,
    parameter
  }];
  return entries;
}
function TargetProperty(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        target: value
      }
    });
  };
  const getValue = (parameter2) => {
    return parameter2.target;
  };
  return TextfieldEntry({
    element: parameter,
    id: idPrefix + "-target",
    label: translate4(is(parameter, "zeebe:Input") ? "Local variable name" : "Process variable name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function SourceProperty(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        source: value
      }
    });
  };
  const getValue = (parameter2) => {
    return parameter2.source;
  };
  return FeelEntryWithVariableContext({
    bpmnElement: element,
    element: parameter,
    id: idPrefix + "-source",
    label: translate4("Variable assignment value"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getElements$1(bo, type, prop) {
  const elems = getExtensionElementsList(bo, type);
  return !prop ? elems : (elems[0] || {})[prop] || [];
}
function getParameters$1(element, prop) {
  const ioMapping = getIoMapping(element);
  return ioMapping && ioMapping.get(prop) || [];
}
function getIoMapping(element) {
  const bo = getBusinessObject(element);
  return (getElements$1(bo, "zeebe:IoMapping") || [])[0];
}
function getInputParameters$1(element) {
  return getParameters$1.apply(this, [element, "inputParameters"]);
}
function getOutputParameters$1(element) {
  return getParameters$1.apply(this, [element, "outputParameters"]);
}
function areInputParametersSupported$1(element) {
  return isAny(element, ["bpmn:UserTask", "bpmn:SubProcess", "bpmn:CallActivity", "bpmn:BusinessRuleTask", "bpmn:ScriptTask"]) || isZeebeServiceTask(element) || isSignalThrowEvent(element);
}
function areOutputParametersSupported$1(element) {
  if (is(element, "bpmn:EndEvent") && (getErrorEventDefinition$1(element) || getTerminateEventDefinition(element))) {
    return false;
  }
  return isAny(element, ["zeebe:ZeebeServiceTask", "bpmn:UserTask", "bpmn:SubProcess", "bpmn:ReceiveTask", "bpmn:CallActivity", "bpmn:Event", "bpmn:BusinessRuleTask"]);
}
function getTerminateEventDefinition(element) {
  return getEventDefinition$1(element, "bpmn:TerminateEventDefinition");
}
function createIOMapping(properties, parent, bpmnFactory) {
  return createElement("zeebe:IoMapping", properties, parent, bpmnFactory);
}
function isSignalThrowEvent(element) {
  if (!isAny(element, ["bpmn:EndEvent", "bpmn:IntermediateThrowEvent"])) {
    return false;
  }
  return !!getEventDefinition$1(element, "bpmn:SignalEventDefinition");
}
function InputProps$1({
  element,
  injector
}) {
  if (!areInputParametersSupported$1(element)) {
    return null;
  }
  const inputParameters = getInputParameters$1(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = inputParameters.map((parameter, index5) => {
    const id = element.id + "-input-" + index5;
    return {
      id,
      label: parameter.get("target") || "",
      entries: InputOutputParameter$1({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$c({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory$9({
      element,
      bpmnFactory,
      commandStack
    })
  };
}
function removeFactory$c({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const ioMapping = getIoMapping(element);
    if (!ioMapping) {
      return;
    }
    const inputParameters = without(ioMapping.get("inputParameters"), parameter);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters
        }
      }
    });
    const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements"), values2 = without(extensionElements.get("values"), ioMapping);
    if (!inputParameters.length && !ioMapping.get("outputParameters").length) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: values2
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$9({
  element,
  bpmnFactory,
  commandStack
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let ioMapping = getIoMapping(element);
    if (!ioMapping) {
      ioMapping = createIOMapping({
        inputParameters: [],
        outputParameters: []
      }, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    const newParameter = createElement("zeebe:Input", {
      target: nextId("InputVariable_")
    }, ioMapping, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          inputParameters: [...ioMapping.get("inputParameters"), newParameter]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function MessageProps(props) {
  const {
    element
  } = props;
  const message = getMessage(element);
  const entries = [];
  if (message) {
    entries.push({
      id: "messageName",
      component: MessageName,
      isEdited: isEdited$6
    });
  }
  if (message && canHaveSubscriptionCorrelationKey(element)) {
    entries.push({
      id: "messageSubscriptionCorrelationKey",
      component: SubscriptionCorrelationKey,
      isEdited: isEdited$6
    });
  }
  return entries;
}
function MessageName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const message = getMessage(element);
  const getValue = () => {
    return message.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: message,
      properties: {
        name: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "messageName",
    label: translate4("Name"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function SubscriptionCorrelationKey(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getCorrelationKey(element);
  };
  const setValue = (value) => {
    const commands = [];
    const properties = {
      correlationKey: value
    };
    const message = getMessage(element);
    let extensionElements = message.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, message, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: message,
          properties: {
            extensionElements
          }
        }
      });
    }
    let subscription = getSubscription(element);
    if (!subscription) {
      subscription = createElement("zeebe:Subscription", properties, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), subscription]
          }
        }
      });
    } else {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          properties,
          moddleElement: subscription
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "messageSubscriptionCorrelationKey",
    label: translate4("Subscription correlation key"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function canHaveSubscriptionCorrelationKey(element) {
  if (is(element, "bpmn:ReceiveTask")) {
    return true;
  }
  if (!is(element, "bpmn:StartEvent")) {
    return true;
  }
  if (is(element, "bpmn:StartEvent") && isEventSubProcess(element.parent)) {
    return true;
  }
  return false;
}
function getCorrelationKey(element) {
  const subscription = getSubscription(element);
  return subscription ? subscription.get("correlationKey") : "";
}
function getSubscription(element) {
  const message = getMessage(element);
  const subscriptions = getSubscriptions(message);
  return subscriptions[0];
}
function getSubscriptions(message) {
  const extensionElements = getExtensionElementsList(message, "zeebe:Subscription");
  return extensionElements;
}
function MultiInstanceProps$1(props) {
  const {
    element
  } = props;
  if (!supportsMultiInstances(element)) {
    return [];
  }
  return [{
    id: "multiInstance-inputCollection",
    component: InputCollection,
    isEdited: isEdited$6
  }, {
    id: "multiInstance-inputElement",
    component: InputElement,
    isEdited
  }, {
    id: "multiInstance-outputCollection",
    component: OutputCollection,
    isEdited
  }, {
    id: "multiInstance-outputElement",
    component: OutputElement,
    isEdited: isEdited$6
  }, {
    id: "multiInstance-completionCondition",
    component: CompletionCondition,
    isEdited: isEdited$6
  }];
}
function InputCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getProperty$1(element, "inputCollection");
  };
  const setValue = (value) => {
    return setProperty(element, "inputCollection", value, commandStack, bpmnFactory);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "multiInstance-inputCollection",
    label: translate4("Input collection"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function InputElement(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getProperty$1(element, "inputElement");
  };
  const setValue = (value) => {
    return setProperty(element, "inputElement", value, commandStack, bpmnFactory);
  };
  return TextfieldEntry({
    element,
    id: "multiInstance-inputElement",
    label: translate4("Input element"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function OutputCollection(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getProperty$1(element, "outputCollection");
  };
  const setValue = (value) => {
    return setProperty(element, "outputCollection", value, commandStack, bpmnFactory);
  };
  return TextfieldEntry({
    element,
    id: "multiInstance-outputCollection",
    label: translate4("Output collection"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function OutputElement(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getProperty$1(element, "outputElement");
  };
  const setValue = (value) => {
    return setProperty(element, "outputElement", value, commandStack, bpmnFactory);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "multiInstance-outputElement",
    label: translate4("Output element"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CompletionCondition(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    const completionCondition = getCompletionCondition(element);
    return completionCondition && completionCondition.get("body");
  };
  const setValue = (value) => {
    if (value && value !== "") {
      const loopCharacteristics = getLoopCharacteristics$1(element);
      const completionCondition = createElement("bpmn:FormalExpression", {
        body: value
      }, loopCharacteristics, bpmnFactory);
      setCompletionCondition(element, commandStack, completionCondition);
    } else {
      setCompletionCondition(element, commandStack, void 0);
    }
  };
  return FeelEntryWithVariableContext({
    element,
    id: "multiInstance-completionCondition",
    label: translate4("Completion condition"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getLoopCharacteristics$1(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("loopCharacteristics");
}
function getZeebeLoopCharacteristics(loopCharacteristics) {
  const extensionElements = getExtensionElementsList(loopCharacteristics, "zeebe:LoopCharacteristics");
  return extensionElements && extensionElements[0];
}
function supportsMultiInstances(element) {
  return !!getLoopCharacteristics$1(element);
}
function getCompletionCondition(element) {
  return getLoopCharacteristics$1(element).get("completionCondition");
}
function setCompletionCondition(element, commandStack, completionCondition = void 0) {
  commandStack.execute("element.updateModdleProperties", {
    element,
    moddleElement: getLoopCharacteristics$1(element),
    properties: {
      completionCondition
    }
  });
}
function getProperty$1(element, propertyName) {
  const loopCharacteristics = getLoopCharacteristics$1(element), zeebeLoopCharacteristics = getZeebeLoopCharacteristics(loopCharacteristics);
  return zeebeLoopCharacteristics && zeebeLoopCharacteristics.get(propertyName);
}
function setProperty(element, propertyName, value, commandStack, bpmnFactory) {
  const loopCharacteristics = getLoopCharacteristics$1(element);
  const commands = [];
  let extensionElements = loopCharacteristics.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, loopCharacteristics, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: loopCharacteristics,
        properties: {
          extensionElements
        }
      }
    });
  }
  let zeebeLoopCharacteristics = getZeebeLoopCharacteristics(loopCharacteristics);
  if (!zeebeLoopCharacteristics) {
    zeebeLoopCharacteristics = createElement("zeebe:LoopCharacteristics", {}, extensionElements, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), zeebeLoopCharacteristics]
        }
      }
    });
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: zeebeLoopCharacteristics,
      properties: {
        [propertyName]: value
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function OutputPropagationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  return [{
    id: "propagateAllChildVariables",
    component: PropagateAllChildVariables,
    isEdited: isEdited$8
  }];
}
function PropagateAllChildVariables(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate");
  const propagateAllChildVariables = isPropagateAllChildVariables(element);
  const getValue = () => {
    return propagateAllChildVariables;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          propagateAllChildVariables: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return ToggleSwitchEntry({
    id: "propagateAllChildVariables",
    label: translate4("Propagate all child process variables"),
    switcherLabel: propagateAllChildVariables ? translate4("On") : translate4("Off"),
    tooltip: u5("div", {
      children: [u5("p", {
        children: translate4("If turned on, all variables from the child process instance will be propagated to the parent process instance.")
      }), u5("p", {
        children: translate4("Otherwise, only variables defined via output mappings will be propagated.")
      })]
    }),
    getValue,
    setValue
  });
}
function determinePropAllChildVariablesDefault(element) {
  const outputParameters = getOutputParameters$1(element);
  if (outputParameters) {
    return outputParameters.length > 0 ? false : true;
  }
}
function isPropagateAllChildVariables(element) {
  if (!is(element, "bpmn:CallActivity")) {
    return void 0;
  }
  const bo = getBusinessObject(element), calledElement = getCalledElement(bo);
  return calledElement && has(calledElement, "propagateAllChildVariables") ? calledElement.get("propagateAllChildVariables") : determinePropAllChildVariablesDefault(element);
}
function OutputProps$1({
  element,
  injector
}) {
  if (!areOutputParametersSupported$1(element)) {
    return null;
  }
  const outputParameters = getOutputParameters$1(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = outputParameters.map((parameter, index5) => {
    const id = element.id + "-output-" + index5;
    return {
      id,
      label: parameter.get("target") || "",
      entries: InputOutputParameter$1({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$b({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory$8({
      element,
      bpmnFactory,
      commandStack
    })
  };
}
function removeFactory$b({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const ioMapping = getIoMapping(element);
    if (!ioMapping) {
      return;
    }
    const outputParameters = without(ioMapping.get("outputParameters"), parameter);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters
        }
      }
    });
    if (!ioMapping.get("inputParameters").length && !outputParameters.length) {
      const businessObject = getBusinessObject(element), extensionElements = businessObject.get("extensionElements"), values2 = without(extensionElements.get("values"), ioMapping);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: values2
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$8({
  element,
  bpmnFactory,
  commandStack
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let ioMapping = getIoMapping(element);
    if (!ioMapping) {
      const parent = extensionElements;
      ioMapping = createIOMapping({
        inputParameters: [],
        outputParameters: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), ioMapping]
          }
        }
      });
    }
    const newParameter = createElement("zeebe:Output", {
      target: nextId("OutputVariable_")
    }, ioMapping, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: ioMapping,
        properties: {
          outputParameters: [...ioMapping.get("outputParameters"), newParameter]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function PriorityDefinitionProps(props) {
  const {
    element
  } = props;
  if (!isZeebeUserTask(element)) {
    return [];
  }
  return [{
    id: "priorityDefinitionPriority",
    component: Priority$1,
    isEdited: isEdited$6
  }];
}
function Priority$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getPriorityDefinition(element) || {}).priority;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    let priorityDefinition = getPriorityDefinition(element);
    const isNullValue = value === null || value === "" || value === void 0;
    if (priorityDefinition && isNullValue) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: extensionElements.get("values").filter((v5) => v5 !== priorityDefinition)
          }
        }
      });
    } else if (priorityDefinition && !isNullValue) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: priorityDefinition,
          properties: {
            priority: value
          }
        }
      });
    } else if (!priorityDefinition && !isNullValue) {
      priorityDefinition = createElement("zeebe:PriorityDefinition", {
        priority: value
      }, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), priorityDefinition]
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "priorityDefinitionPriority",
    label: translate4("Priority"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getPriorityDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:PriorityDefinition")[0];
}
function isZeebeUserTask(element) {
  const businessObject = getBusinessObject(element);
  return is(element, "bpmn:UserTask") && !!getExtensionElementsList(businessObject, "zeebe:UserTask")[0];
}
var SCRIPT_IMPLEMENTATION_OPTION = "script";
var JOB_WORKER_IMPLEMENTATION_OPTION$1 = "jobWorker";
var DEFAULT_IMPLEMENTATION_OPTION = "";
function ScriptImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask")) {
    return [];
  }
  return [{
    id: "scriptImplementation",
    component: ScriptImplementation,
    isEdited: () => isScriptImplementationEdited(element)
  }];
}
function ScriptImplementation(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    if (getScript$1(element)) {
      return SCRIPT_IMPLEMENTATION_OPTION;
    }
    if (getTaskDefinition$1(element)) {
      return JOB_WORKER_IMPLEMENTATION_OPTION$1;
    }
    return DEFAULT_IMPLEMENTATION_OPTION;
  };
  const setValue = (value) => {
    let extensionElement, extensionElementType;
    if (value === SCRIPT_IMPLEMENTATION_OPTION) {
      extensionElement = getScript$1(element);
      extensionElementType = "zeebe:Script";
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION$1) {
      extensionElement = getTaskDefinition$1(element);
      extensionElementType = "zeebe:TaskDefinition";
    } else {
      resetElement(element, commandStack);
    }
    if (!extensionElement && extensionElementType) {
      extensionElement = createElement(extensionElementType, {}, null, bpmnFactory);
      updateExtensionElements(element, extensionElement, bpmnFactory, commandStack);
    }
  };
  const getOptions = () => {
    const options = [{
      value: DEFAULT_IMPLEMENTATION_OPTION,
      label: translate4("<none>")
    }, {
      value: SCRIPT_IMPLEMENTATION_OPTION,
      label: translate4("FEEL expression")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION$1,
      label: translate4("Job worker")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id,
    label: translate4("Implementation"),
    getValue,
    setValue,
    getOptions
  });
}
function getTaskDefinition$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
function getScript$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:Script")[0];
}
function getTaskHeaders(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskHeaders");
}
function isScriptImplementationEdited(element) {
  return getTaskDefinition$1(element) || getScript$1(element);
}
function resetElement(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const taskDefinition = getTaskDefinition$1(element);
  const taskHeaders = getTaskHeaders(element);
  const script = getScript$1(element);
  if (taskDefinition) {
    const removed = [taskDefinition, taskHeaders].filter(Boolean);
    removeExtensionElements(element, businessObject, removed, commandStack);
    return;
  }
  if (script) {
    removeExtensionElements(element, businessObject, script, commandStack);
  }
}
function updateExtensionElements(element, extensionElementToAdd, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const commands = [];
  let extensionElements = businessObject.get("extensionElements");
  let extensionElementValues;
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  extensionElementToAdd.$parent = extensionElements;
  if (is(extensionElementToAdd, "zeebe:TaskDefinition")) {
    extensionElementValues = without(extensionElements.get("values"), getScript$1(element));
  } else if (is(extensionElementToAdd, "zeebe:Script")) {
    const matcher = (extension) => isAny(extension, ["zeebe:TaskDefinition", "zeebe:TaskHeaders"]);
    extensionElementValues = without(extensionElements.get("values"), matcher);
  }
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: extensionElements,
      properties: {
        values: [...extensionElementValues, extensionElementToAdd]
      }
    }
  });
  commandStack.execute("properties-panel.multi-command-executor", commands);
}
function ScriptProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask") || !getScript2(element)) {
    return [];
  }
  return [{
    id: "resultVariable",
    component: ResultVariable$3,
    isEdited
  }, {
    id: "scriptExpression",
    component: Expression$2,
    isEdited: isEdited$6
  }];
}
function Expression$2(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getScript2(element) || {}).get("expression");
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let script = getScript2(element);
    if (!script) {
      script = createElement("zeebe:Script", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), script]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: script,
        properties: {
          expression: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id,
    label: translate4("FEEL expression"),
    feel: "required",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$3(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getScript2(element) || {}).resultVariable;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let script = getScript2(element);
    if (!script) {
      script = createElement("zeebe:Script", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), script]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: script,
        properties: {
          resultVariable: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id,
    label: translate4("Result variable"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getScript2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:Script")[0];
}
function SignalProps(props) {
  const {
    element
  } = props;
  if (!isSignalSupported(element)) {
    return [];
  }
  const signal = getSignal(element);
  let entries = [];
  if (signal) {
    entries = [...entries, {
      id: "signalName",
      component: SignalName,
      isEdited: isEdited$6
    }];
  }
  return entries;
}
function SignalName(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const signal = getSignal(element);
  const getValue = () => {
    return signal.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: signal,
      properties: {
        name: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "signalName",
    label: translate4("Name"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
var CalledElementBinding$1 = withProps(Binding$2, {
  type: "zeebe:CalledElement"
});
var CalledElementVersionTag$1 = withProps(VersionTag$3, {
  type: "zeebe:CalledElement"
});
function TargetProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  const entries = [{
    id: "targetProcessId",
    component: TargetProcessId,
    isEdited: isEdited$6
  }, {
    id: "bindingType",
    component: CalledElementBinding$1,
    isEdited: isEdited$3
  }];
  if (getBindingType(element, "zeebe:CalledElement") === "versionTag") {
    entries.push({
      id: "versionTag",
      component: CalledElementVersionTag$1,
      isEdited
    });
  }
  return entries;
}
function TargetProcessId(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const getValue = () => {
    return getProcessId(element);
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let calledElement = getCalledElement(businessObject);
    if (!calledElement) {
      calledElement = createElement("zeebe:CalledElement", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), calledElement]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: calledElement,
        properties: {
          processId: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id,
    label: translate4("Process ID"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function TaskDefinitionProps(props) {
  const {
    element
  } = props;
  if (!isZeebeServiceTask(element)) {
    return [];
  }
  return [{
    id: "taskDefinitionType",
    component: TaskDefinitionType,
    isEdited: isEdited$6
  }, {
    id: "taskDefinitionRetries",
    component: TaskDefinitionRetries,
    isEdited: isEdited$6
  }];
}
function TaskDefinitionType(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getTaskDefinition(element) || {}).type;
  };
  const setValue = (value) => {
    const commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskDefinition = getTaskDefinition(element);
    if (!taskDefinition) {
      taskDefinition = createElement("zeebe:TaskDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskDefinition,
        properties: {
          type: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id,
    label: translate4("Job type"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function TaskDefinitionRetries(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return (getTaskDefinition(element) || {}).retries;
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskDefinition = getTaskDefinition(element);
    if (!taskDefinition) {
      taskDefinition = createElement("zeebe:TaskDefinition", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskDefinition]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskDefinition,
        properties: {
          retries: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id,
    label: translate4("Retries"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getTaskDefinition(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskDefinition")[0];
}
var EVENT_TYPE = ["assigning", "updating", "completing"];
var EVENT_TO_LABEL$1 = {
  assigning: "Assigning",
  updating: "Updating",
  completing: "Completing"
};
function TaskListenerEntries(props) {
  const {
    idPrefix,
    listener
  } = props;
  return [{
    id: idPrefix + "-eventType",
    component: EventType$1,
    idPrefix,
    listener,
    eventTypes: EVENT_TYPE
  }, {
    id: idPrefix + "-listenerType",
    component: ListenerType$1,
    idPrefix,
    listener
  }, {
    id: idPrefix + "-retries",
    component: Retries,
    idPrefix,
    listener
  }];
}
function EventType$1(props) {
  const {
    idPrefix,
    element,
    listener,
    eventTypes
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const getOptions = () => {
    return eventTypes.map((eventType) => ({
      value: eventType,
      label: translate4(EVENT_TO_LABEL$1[eventType])
    }));
  };
  const setValue = (value) => {
    modeling.updateModdleProperties(element, listener, {
      eventType: value
    });
  };
  const getValue = () => {
    return listener.get("eventType");
  };
  return SelectEntry({
    element,
    id: idPrefix + "-eventType",
    label: translate4("Event type"),
    getValue,
    setValue,
    getOptions
  });
}
function TaskListenersProps({
  element,
  injector
}) {
  let businessObject = getRelevantBusinessObject$1(element);
  if (!businessObject) {
    return;
  }
  if (!isZeebeUserTask$1(element)) {
    return;
  }
  const moddle = injector.get("moddle");
  if (!canHaveTaskListeners(businessObject, moddle)) {
    return;
  }
  const listeners = getListenersList(businessObject) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack"), modeling = injector.get("modeling"), translate4 = injector.get("translate");
  const items = listeners.map((listener, index5) => {
    const id = element.id + "-taskListener-" + index5;
    const type = listener.get("type") || "<no type>";
    const eventType = listener.get("eventType");
    const label = translate4("{eventType}: {type}", {
      eventType: EVENT_TO_LABEL$1[eventType] || eventType,
      type
    });
    return {
      id,
      label,
      entries: TaskListenerEntries({
        idPrefix: id,
        listener
      }),
      autoFocusEntry: id + "-eventType",
      remove: removeFactory$a({
        modeling,
        element,
        listener
      })
    };
  });
  return {
    items,
    add: addFactory$7({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$a({
  modeling,
  element,
  listener
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getRelevantBusinessObject$1(element);
    const container = getTaskListenersContainer(businessObject);
    if (!container) {
      return;
    }
    const listeners = without(container.get("listeners"), listener);
    modeling.updateModdleProperties(element, container, {
      listeners
    });
  };
}
function addFactory$7({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject$1(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskListeners = getTaskListenersContainer(businessObject);
    if (!taskListeners) {
      const parent = extensionElements;
      taskListeners = createElement("zeebe:TaskListeners", {
        listeners: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskListeners]
          }
        }
      });
    }
    const TaskListener2 = createElement("zeebe:TaskListener", getDefaultListenerProps(), taskListeners, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskListeners,
        properties: {
          listeners: [...taskListeners.get("listeners"), TaskListener2]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject$1(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getTaskListenersContainer(element) {
  const TaskListeners = getExtensionElementsList(element, "zeebe:TaskListeners");
  return TaskListeners && TaskListeners[0];
}
function getListenersList(element) {
  const TaskListeners = getTaskListenersContainer(element);
  return TaskListeners && TaskListeners.get("listeners");
}
function canHaveTaskListeners(bo, moddle) {
  const TaskListenersDescriptor = moddle.getTypeDescriptor("zeebe:TaskListeners");
  return isAny(bo, TaskListenersDescriptor.meta.allowedIn);
}
function getDefaultListenerProps() {
  return {
    eventType: EVENT_TYPE[0]
  };
}
function TaskScheduleProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "taskScheduleDueDate",
    component: DueDate$1,
    isEdited: isEdited$6
  }, {
    id: "taskScheduleFollowUpDate",
    component: FollowUpDate$1,
    isEdited: isEdited$6
  }];
}
function DueDate$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    const taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      return;
    }
    return taskSchedule.get("dueDate");
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      taskSchedule = createElement("zeebe:TaskSchedule", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskSchedule]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskSchedule,
        properties: {
          dueDate: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "taskScheduleDueDate",
    label: translate4("Due date"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function FollowUpDate$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    const taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      return;
    }
    return taskSchedule.get("followUpDate");
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let taskSchedule = getTaskSchedule(element);
    if (!taskSchedule) {
      taskSchedule = createElement("zeebe:TaskSchedule", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), taskSchedule]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: taskSchedule,
        properties: {
          followUpDate: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return FeelEntryWithVariableContext({
    element,
    id: "taskScheduleFollowUpDate",
    label: translate4("Follow up date"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getTaskSchedule(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:TaskSchedule")[0];
}
function isTimerExpressionTypeSupported(type, element) {
  const businessObject = getBusinessObject(element);
  switch (type) {
    case "timeDate":
      return isAny(element, ["bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent", "bpmn:StartEvent"]);
    case "timeCycle":
      if (is(element, "bpmn:StartEvent") && !hasParentEventSubProcess(businessObject) || !isInterrupting2(businessObject)) {
        return true;
      }
      if (is(element, "bpmn:BoundaryEvent") && !isInterrupting2(businessObject)) {
        return true;
      }
      return false;
    case "timeDuration":
      if (isAny(element, ["bpmn:BoundaryEvent", "bpmn:IntermediateCatchEvent"])) {
        return true;
      }
      if (is(element, "bpmn:StartEvent") && hasParentEventSubProcess(businessObject)) {
        return true;
      }
      return false;
    default:
      return false;
  }
}
function isInterrupting2(businessObject) {
  if (is(businessObject, "bpmn:BoundaryEvent")) {
    return businessObject.get("cancelActivity") !== false;
  }
  return businessObject.get("isInterrupting") !== false;
}
function hasParentEventSubProcess(businessObject) {
  const parent = businessObject.$parent;
  return parent && is(parent, "bpmn:SubProcess") && parent.get("triggeredByEvent");
}
function TimerProps$1(props) {
  const {
    element,
    injector
  } = props;
  const translate4 = injector.get("translate");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element)) {
    return [];
  }
  const timerOptions = getTimerOptions(element, translate4);
  const entries = [];
  entries.push({
    id: "timerEventDefinitionType",
    component: TimerEventDefinitionType$1,
    isEdited: isEdited$3,
    options: timerOptions
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: "timerEventDefinitionValue",
      component: TimerEventDefinitionValue$1,
      isEdited: isEdited$6,
      timerEventDefinitionType: timerEventDefinitionType || timerOptions[0].value
    });
  }
  return entries;
}
function getTimerOptions(element, translate4) {
  const options = [];
  if (isTimerExpressionTypeSupported("timeDate", element)) {
    options.push({
      value: "timeDate",
      label: translate4("Date")
    });
  }
  if (isTimerExpressionTypeSupported("timeDuration", element)) {
    options.push({
      value: "timeDuration",
      label: translate4("Duration")
    });
  }
  if (isTimerExpressionTypeSupported("timeCycle", element)) {
    options.push({
      value: "timeCycle",
      label: translate4("Cycle")
    });
  }
  return options;
}
function TimerEventDefinitionType$1(props) {
  const {
    element,
    options
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  const getValue = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = createTimerFormalExpression(bpmnFactory, timerEventDefinition);
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate4("<none>")
    }, ...options];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue$1(props) {
  const {
    element,
    label,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput"), bpmnFactory = useService("bpmnFactory");
  const businessObject = getBusinessObject(element), timerEventDefinition = getTimerEventDefinition(businessObject), timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    if (!timerEventFormalExpression) {
      const expression = createTimerFormalExpression(bpmnFactory, timerEventDefinition);
      expression.set("body", value);
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: timerEventDefinition,
        properties: {
          [timerEventDefinitionType]: expression
        }
      });
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return FeelEntryWithVariableContext({
    element,
    id: "timerEventDefinitionValue",
    label: label || translate4("Value"),
    feel: "optional",
    getValue,
    setValue,
    debounce: debounce2,
    tooltip: getTimerEventDefinitionValueDescription$1(timerEventDefinitionType, translate4)
  });
}
function createTimerFormalExpression(bpmnFactory, eventDefinition) {
  const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
    body: void 0
  });
  formalExpression.$parent = eventDefinition;
  return formalExpression;
}
function getTimerEventDefinitionValueDescription$1(timerDefinitionType, translate4) {
  switch (timerDefinitionType) {
    case "timeDate":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate4("UTC time")]
          }), u5("li", {
            children: [u5("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate4("UTC plus 2 hours zone offset")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-date",
          target: "_blank",
          rel: "noopener noreferrer",
          title: translate4("Timer documentation"),
          children: translate4("How to configure a timer")
        })]
      });
    case "timeCycle":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A cycle defined as ISO 8601 repeating intervals format, or a cron expression.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "R5/PT10S"
            }), " - ", translate4("every 10 seconds, up to 5 times")]
          }), u5("li", {
            children: [u5("code", {
              children: "R/P1D"
            }), " - ", translate4("every day, infinitely")]
          }), u5("li", {
            children: [u5("code", {
              children: "0 0 9-17 * * MON-FRI"
            }), " - ", translate4("every hour on the hour from 9-5 p.m. UTC Monday-Friday")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-cycle",
          target: "_blank",
          rel: "noopener noreferrer",
          title: translate4("Timer documentation"),
          children: translate4("How to configure a timer")
        })]
      });
    case "timeDuration":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A time duration defined as ISO 8601 durations format.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "PT15S"
            }), " - ", translate4("15 seconds")]
          }), u5("li", {
            children: [u5("code", {
              children: "PT1H30M"
            }), " - ", translate4("1 hour and 30 minutes")]
          }), u5("li", {
            children: [u5("code", {
              children: "P14D"
            }), " - ", translate4("14 days")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.io/docs/reference/bpmn-processes/timer-events/timer-events#time-duration",
          target: "_blank",
          rel: "noopener noreferrer",
          title: translate4("Timer documentation"),
          children: translate4("How to configure a timer")
        })]
      });
  }
}
var ZEEBE_USER_TASK_IMPLEMENTATION_OPTION = "zeebeUserTask";
var JOB_WORKER_IMPLEMENTATION_OPTION = "jobWorker";
function UserTaskImplementationProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:UserTask")) {
    return [];
  }
  return [{
    id: "userTaskImplementation",
    component: UserTaskImplementation,
    isEdited: () => isUserTaskImplementationEdited(element)
  }];
}
function UserTaskImplementation(props) {
  const {
    element,
    id
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    if (getZeebeUserTask(element)) {
      return ZEEBE_USER_TASK_IMPLEMENTATION_OPTION;
    }
    return JOB_WORKER_IMPLEMENTATION_OPTION;
  };
  const setValue = (value) => {
    if (value === ZEEBE_USER_TASK_IMPLEMENTATION_OPTION) {
      createZeebeUserTask(element, bpmnFactory, commandStack);
    } else if (value === JOB_WORKER_IMPLEMENTATION_OPTION) {
      removeZeebeUserTask(element, commandStack);
    }
  };
  const getOptions = () => {
    const options = [{
      value: ZEEBE_USER_TASK_IMPLEMENTATION_OPTION,
      label: translate4("Camunda user task")
    }, {
      value: JOB_WORKER_IMPLEMENTATION_OPTION,
      label: translate4("Job worker")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id,
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function createZeebeUserTask(element, bpmnFactory, commandStack) {
  const businessObject = getBusinessObject(element);
  const zeebeUserTask = createElement("zeebe:UserTask", {}, businessObject, bpmnFactory);
  addExtensionElements(element, businessObject, zeebeUserTask, bpmnFactory, commandStack);
}
function removeZeebeUserTask(element, commandStack) {
  const zeebeUserTask = getZeebeUserTask(element);
  removeExtensionElements(element, getBusinessObject(element), zeebeUserTask, commandStack);
}
function isUserTaskImplementationEdited(element) {
  return getZeebeUserTask(element);
}
function getZeebeUserTask(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "zeebe:UserTask")[0];
}
function VersionTagProps$1(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "versionTag",
    component: VersionTag$2,
    isEdited
  }];
}
function VersionTag$2(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const debounce2 = useService("debounceInput");
  const translate4 = useService("translate");
  const getValue = () => {
    const versionTag = getVersionTag(element);
    if (versionTag) {
      return versionTag.get("value");
    }
  };
  const setValue = (value) => {
    let commands = [];
    const businessObject = getProcess$4(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let versionTag = getVersionTag(element);
    if (!versionTag) {
      versionTag = createElement("zeebe:VersionTag", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), versionTag]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: versionTag,
        properties: {
          value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate4("Version tag"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getProcess$4(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function getVersionTag(element) {
  const businessObject = getProcess$4(element);
  return getExtensionElementsList(businessObject, "zeebe:VersionTag")[0];
}
function ExtensionProperty(props) {
  const {
    idPrefix,
    property
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: NameProperty$1,
    idPrefix,
    property
  }, {
    id: idPrefix + "-value",
    component: ValueProperty$1,
    idPrefix,
    property
  }];
  return entries;
}
function NameProperty$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        name: value
      }
    });
  };
  const getValue = () => {
    return property.name;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-name",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ValueProperty$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        value
      }
    });
  };
  const getValue = () => {
    return property.value;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-value",
    label: translate4("Value"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ExtensionPropertiesProps({
  element,
  injector,
  namespace = "camunda"
}) {
  let businessObject = getRelevantBusinessObject(element);
  if (!businessObject) {
    return;
  }
  const properties = getPropertiesList(businessObject, namespace) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = properties.map((property, index5) => {
    const id = element.id + "-extensionProperty-" + index5;
    return {
      id,
      label: property.get("name") || "",
      entries: ExtensionProperty({
        idPrefix: id,
        element,
        property
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$9({
        commandStack,
        element,
        property,
        namespace
      })
    };
  });
  return {
    items,
    add: addFactory$6({
      bpmnFactory,
      commandStack,
      element,
      namespace
    })
  };
}
function removeFactory$9({
  commandStack,
  element,
  property,
  namespace
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const businessObject = getRelevantBusinessObject(element);
    const extensionElements = businessObject.get("extensionElements");
    const properties = getProperties2(businessObject, namespace);
    if (!properties) {
      return;
    }
    const propertyName = getPropertyName(namespace);
    const values2 = without(properties.get(propertyName), property);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          [propertyName]: values2
        }
      }
    });
    if (!values2.length) {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: without(extensionElements.get("values"), properties)
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function addFactory$6({
  bpmnFactory,
  commandStack,
  element,
  namespace
}) {
  return function(event2) {
    event2.stopPropagation();
    let commands = [];
    const businessObject = getRelevantBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    const propertyName = getPropertyName(namespace);
    let properties = getProperties2(businessObject, namespace);
    if (!properties) {
      const parent = extensionElements;
      properties = createElement(`${namespace}:Properties`, {
        [propertyName]: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), properties]
          }
        }
      });
    }
    const property = createElement(`${namespace}:Property`, {}, properties, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          [propertyName]: [...properties.get(propertyName), property]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function getRelevantBusinessObject(element) {
  let businessObject = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return businessObject.get("processRef");
  }
  return businessObject;
}
function getPropertyName(namespace = "camunda") {
  if (namespace === "zeebe") {
    return "properties";
  }
  return "values";
}
function getProperties2(element, namespace = "camunda") {
  const businessObject = getRelevantBusinessObject(element);
  return getExtensionElementsList(businessObject, `${namespace}:Properties`)[0];
}
function getPropertiesList(element, namespace = "camunda") {
  const businessObject = getRelevantBusinessObject(element);
  const properties = getProperties2(businessObject, namespace);
  return properties && properties.get(getPropertyName(namespace));
}
var LOW_PRIORITY$1 = 500;
var ZEEBE_GROUPS = [BusinessRuleImplementationGroup, CalledDecisionGroup, ScriptImplementationGroup, ScriptGroup$1, UserTaskImplementationGroup, TaskDefinitionGroup, AssignmentDefinitionGroup, ActiveElementsGroup, FormGroup$1, ConditionGroup$1, TargetGroup, InputPropagationGroup, InputGroup$1, OutputPropagationGroup, OutputGroup$1, HeaderGroup, TaskListenersGroup, ExecutionListenersGroup, ExtensionPropertiesGroup$1];
var ZeebePropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOW_PRIORITY$1, this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(this._getGroups(element));
      updateGeneralGroup$1(groups, element);
      updateErrorGroup$1(groups, element);
      updateEscalationGroup$1(groups, element);
      updateMessageGroup(groups, element);
      updateSignalGroup(groups, element);
      updateTimerGroup$1(groups, element, this._injector);
      updateMultiInstanceGroup$1(groups, element);
      groups = removeMessageGroup(groups, element);
      return groups;
    };
  }
  _getGroups(element) {
    const groups = ZEEBE_GROUPS.map((createGroup2) => createGroup2(element, this._injector));
    return groups.filter((group) => group !== null);
  }
};
ZeebePropertiesProvider.$inject = ["propertiesPanel", "injector"];
function CalledDecisionGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "calledDecision",
    label: translate4("Called decision"),
    entries: [...CalledDecisionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ScriptGroup$1(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "script",
    label: translate4("Script"),
    entries: [...ScriptProps$1({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function TaskDefinitionGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "taskDefinition",
    label: translate4("Task definition"),
    entries: [...TaskDefinitionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function InputGroup$1(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "inputs",
    label: translate4("Inputs"),
    component: ListGroup,
    ...InputProps$1({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function OutputGroup$1(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "outputs",
    label: translate4("Outputs"),
    component: ListGroup,
    ...OutputProps$1({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function ConditionGroup$1(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "condition",
    label: translate4("Condition"),
    entries: [...ConditionProps$1({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function FormGroup$1(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "form",
    label: translate4("Form"),
    entries: [...FormProps$1({
      element,
      injector
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function TargetGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "calledElement",
    label: translate4("Called element"),
    entries: [...TargetProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function HeaderGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "headers",
    label: translate4("Headers"),
    component: ListGroup,
    ...HeaderProps({
      element,
      injector
    })
  };
  return group.items ? group : null;
}
function OutputPropagationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "outputPropagation",
    label: translate4("Output propagation"),
    entries: [...OutputPropagationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function InputPropagationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "inputPropagation",
    label: translate4("Input propagation"),
    entries: [...InputPropagationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function BusinessRuleImplementationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "businessRuleImplementation",
    label: translate4("Implementation"),
    entries: [...BusinessRuleImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ScriptImplementationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "scriptImplementation",
    label: translate4("Implementation"),
    entries: [...ScriptImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function UserTaskImplementationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "userTaskImplementation",
    label: translate4("Implementation"),
    entries: [...UserTaskImplementationProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function AssignmentDefinitionGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "assignmentDefinition",
    label: translate4("Assignment"),
    entries: [...AssignmentDefinitionProps({
      element
    }), ...TaskScheduleProps({
      element
    }), ...PriorityDefinitionProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ActiveElementsGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    id: "activeElements",
    label: translate4("Active elements"),
    entries: [...ActiveElementsProps({
      element
    })],
    component: Group
  };
  return group.entries.length ? group : null;
}
function ExecutionListenersGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Execution listeners"),
    id: "Zeebe__ExecutionListeners",
    component: ListGroup,
    ...ExecutionListenersProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function TaskListenersGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Task listeners"),
    id: "Zeebe__TaskListeners",
    component: ListGroup,
    ...TaskListenersProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ExtensionPropertiesGroup$1(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Extension properties"),
    id: "Zeebe__ExtensionProperties",
    component: ListGroup,
    ...ExtensionPropertiesProps({
      element,
      injector,
      namespace: "zeebe"
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function updateGeneralGroup$1(groups, element) {
  const generalGroup = findGroup$1(groups, "general");
  if (!generalGroup) {
    return;
  }
  const {
    entries
  } = generalGroup;
  const executableEntry = findIndex(entries, (entry) => entry.id === "isExecutable");
  const insertIndex = executableEntry >= 0 ? executableEntry : entries.length;
  entries.splice(insertIndex, 0, ...VersionTagProps$1({
    element
  }));
}
function updateErrorGroup$1(groups, element) {
  const errorGroup = findGroup$1(groups, "error");
  if (!errorGroup) {
    return;
  }
  errorGroup.entries = replaceEntries(errorGroup.entries, ErrorProps$1({
    element
  }));
}
function updateEscalationGroup$1(groups, element) {
  const escalationGroup = findGroup$1(groups, "escalation");
  if (!escalationGroup) {
    return;
  }
  escalationGroup.entries = replaceEntries(escalationGroup.entries, EscalationProps$1({
    element
  }));
}
function updateSignalGroup(groups, element) {
  const signalGroup = findGroup$1(groups, "signal");
  if (!signalGroup) {
    return;
  }
  signalGroup.entries = replaceEntries(signalGroup.entries, SignalProps({
    element
  }));
}
function updateMessageGroup(groups, element) {
  const messageGroup = findGroup$1(groups, "message");
  if (!messageGroup) {
    return;
  }
  messageGroup.entries = replaceEntries(messageGroup.entries, MessageProps({
    element
  }));
}
function updateTimerGroup$1(groups, element, injector) {
  const timerEventGroup = findGroup$1(groups, "timer");
  if (!timerEventGroup) {
    return;
  }
  timerEventGroup.entries = [...TimerProps$1({
    element,
    injector
  })];
}
function updateMultiInstanceGroup$1(groups, element) {
  const multiInstanceGroup = findGroup$1(groups, "multiInstance");
  if (!multiInstanceGroup) {
    return;
  }
  multiInstanceGroup.entries = [...MultiInstanceProps$1({
    element
  })];
}
function removeMessageGroup(groups, element) {
  const messageGroup = findGroup$1(groups, "message");
  if (isMessageEndEvent(element) || isMessageThrowEvent(element)) {
    groups = groups.filter((g6) => g6 != messageGroup);
  }
  return groups;
}
function findGroup$1(groups, id) {
  return groups.find((g6) => g6.id === id);
}
function replaceEntries(oldEntries, newEntries) {
  const filteredEntries = oldEntries.filter((oldEntry) => !newEntries.find((newEntry) => newEntry.id === oldEntry.id));
  return [...filteredEntries, ...newEntries];
}
function AsynchronousContinuationsProps(props) {
  const {
    element
  } = props;
  const checkboxIsEditedInverted2 = (node2) => {
    return node2 && !node2.checked;
  };
  const businessObject = getBusinessObject(element);
  const entries = [];
  if (is(element, "camunda:AsyncCapable")) {
    entries.push({
      id: "asynchronousContinuationBefore",
      component: AsynchronousContinuationBefore,
      isEdited: isEdited$5
    }, {
      id: "asynchronousContinuationAfter",
      component: AsynchronousContinuationAfter,
      isEdited: isEdited$5
    });
    if (isAsyncBefore$2(businessObject) || isAsyncAfter$2(businessObject)) {
      entries.push({
        id: "exclusive",
        component: Exclusive,
        isEdited: checkboxIsEditedInverted2
      });
    }
  }
  return entries;
}
function AsynchronousContinuationBefore(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return isAsyncBefore$2(businessObject);
  };
  const setValue = (value) => {
    const props2 = {
      "camunda:asyncBefore": value,
      "camunda:async": void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: props2
    });
  };
  return CheckboxEntry({
    element,
    id: "asynchronousContinuationBefore",
    label: translate4("Before"),
    getValue,
    setValue
  });
}
function AsynchronousContinuationAfter(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return isAsyncAfter$2(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:asyncAfter": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "asynchronousContinuationAfter",
    label: translate4("After"),
    getValue,
    setValue
  });
}
function Exclusive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return isExclusive$1(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:exclusive": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "exclusive",
    label: translate4("Exclusive"),
    getValue,
    setValue
  });
}
function isAsyncBefore$2(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter$2(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isExclusive$1(bo) {
  return !!bo.get("camunda:exclusive");
}
var EMPTY_OPTION$1 = "";
function BusinessKeyProps$1(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:StartEvent") || !hasFormFields(element)) {
    return [];
  }
  return [{
    id: "businessKey",
    component: BusinessKey$1,
    isEdited: isEdited$3
  }];
}
function BusinessKey$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const formData = getFormData$2(element);
  const getValue = () => {
    return formData.get("camunda:businessKey") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formData,
      properties: {
        "camunda:businessKey": value
      }
    });
  };
  const getOptions = () => {
    const options = [{
      value: EMPTY_OPTION$1,
      label: translate4("<none>")
    }];
    const fields = formData.get("fields");
    fields.forEach((field) => {
      const id = field.get("camunda:id");
      if (id) {
        options.push({
          value: id,
          label: id
        });
      }
    });
    return options;
  };
  return SelectEntry({
    element,
    id: "businessKey",
    label: translate4("Key"),
    getValue,
    setValue,
    getOptions
  });
}
function getFormData$2(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "camunda:FormData")[0];
}
function hasFormFields(element) {
  const businessObject = getBusinessObject(element);
  const formData = getFormData$2(businessObject);
  return formData && formData.get("camunda:fields").length;
}
function CalledBpmnProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElement",
    component: CalledElement,
    isEdited
  }, {
    id: "calledElementBinding",
    component: CalledElementBinding,
    isEdited: isEdited$3
  }, {
    id: "calledElementTenantId",
    component: CalledElementTenantId,
    isEdited
  }];
  const binding = getBusinessObject(element).get("camunda:calledElementBinding");
  if (binding === "version") {
    entries.splice(-1, 0, {
      id: "calledElementVersion",
      component: CalledElementVersion,
      isEdited
    });
  } else if (binding === "versionTag") {
    entries.splice(-1, 0, {
      id: "calledElementVersionTag",
      component: CalledElementVersionTag,
      isEdited
    });
  }
  return entries;
}
function CalledElement(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("calledElement");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElement: value || ""
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElement",
    label: translate4("Called element"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CalledElementBinding(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:calledElementBinding") || "latest";
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementBinding: value === "latest" ? void 0 : value,
      calledElementVersion: void 0,
      calledElementVersionTag: void 0
    });
  };
  const getOptions = () => [{
    value: "latest",
    label: translate4("latest")
  }, {
    value: "deployment",
    label: translate4("deployment")
  }, {
    value: "version",
    label: translate4("version")
  }, {
    value: "versionTag",
    label: translate4("version tag")
  }];
  return u5(SelectEntry, {
    element,
    id: "calledElementBinding",
    label: translate4("Binding"),
    getValue,
    setValue,
    getOptions
  });
}
function CalledElementVersion(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:calledElementVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementVersion: value
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementVersion",
    label: translate4("Version"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CalledElementVersionTag(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:calledElementVersionTag");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementVersionTag: value
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementVersionTag",
    label: translate4("Version tag"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CalledElementTenantId(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:calledElementTenantId");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      calledElementTenantId: value
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementTenantId",
    label: translate4("Tenant ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CalledCmmnProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementCaseRef",
    component: CaseRef,
    isEdited
  }, {
    id: "calledElementCaseBinding",
    component: CaseBinding,
    isEdited: isEdited$3
  }, {
    id: "calledElementCaseTenantId",
    component: CaseTenantId,
    isEdited
  }];
  if (getBusinessObject(element).get("camunda:caseBinding") === "version") {
    entries.splice(-1, 0, {
      id: "calledElementCaseVersion",
      component: CaseVersion,
      isEdited
    });
  }
  return entries;
}
function CaseRef(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:caseRef");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseRef: value || ""
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementCaseRef",
    label: translate4("Case ref"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CaseBinding(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:caseBinding") || "latest";
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseBinding: value === "latest" ? void 0 : value,
      caseVersion: void 0
    });
  };
  const getOptions = () => [{
    value: "latest",
    label: translate4("latest")
  }, {
    value: "deployment",
    label: translate4("deployment")
  }, {
    value: "version",
    label: translate4("version")
  }];
  return u5(SelectEntry, {
    element,
    id: "calledElementCaseBinding",
    label: translate4("Binding"),
    getValue,
    setValue,
    getOptions
  });
}
function CaseVersion(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:caseVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseVersion: value
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementCaseVersion",
    label: translate4("Version"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CaseTenantId(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:caseTenantId");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      caseTenantId: value
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementCaseTenantId",
    label: translate4("Tenant ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function DelegateVariableMappingProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementDelegateVariableMappingType",
    component: DelegateVariableMappingType,
    isEdited: isEdited$3
  }];
  const type = getDelegateVariableMappingType(element);
  if (type === "class") {
    entries.push({
      id: "calledElementVariableMappingClass",
      component: VariableMappingClass,
      isEdited
    });
  } else if (type === "delegateExpression") {
    entries.push({
      id: "calledElementVariableMappingDelegateExpression",
      component: VariableMappingDelegateExpression,
      isEdited
    });
  }
  return entries;
}
var DEFAULT_PROPS$5 = {
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0
};
function DelegateVariableMappingType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getDelegateVariableMappingType(element);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$5
    };
    if (value === "class") {
      properties["camunda:variableMappingClass"] = "";
    } else if (value === "delegateExpression") {
      properties["camunda:variableMappingDelegateExpression"] = "";
    }
    commandStack.execute("element.updateProperties", {
      element,
      properties
    });
  };
  const getOptions = () => [{
    value: "none",
    label: translate4("<none>")
  }, {
    value: "class",
    label: translate4("Class")
  }, {
    value: "delegateExpression",
    label: translate4("Delegate expression")
  }];
  return u5(SelectEntry, {
    element,
    id: "calledElementDelegateVariableMappingType",
    label: translate4("Delegate Variable Mapping"),
    getValue,
    setValue,
    getOptions
  });
}
function VariableMappingDelegateExpression(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:variableMappingDelegateExpression");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      variableMappingDelegateExpression: value || "",
      variableMappingClass: void 0
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementVariableMappingDelegateExpression",
    label: translate4("Delegate Expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function VariableMappingClass(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getBusinessObject(element).get("camunda:variableMappingClass");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      variableMappingDelegateExpression: void 0,
      variableMappingClass: value || ""
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementVariableMappingClass",
    label: translate4("Delegate Class"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getDelegateVariableMappingType(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject.get("camunda:variableMappingClass") !== void 0) {
    return "class";
  } else if (businessObject.get("camunda:variableMappingDelegateExpression") !== void 0) {
    return "delegateExpression";
  }
  return "none";
}
function CallActivityProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:CallActivity")) {
    return [];
  }
  const entries = [];
  entries.push({
    id: "calledElementType",
    component: CalledElementType,
    isEdited: isEdited$3
  });
  const calledElementType = getCalledElementType(element);
  if (calledElementType === "bpmn") {
    entries.push(...CalledBpmnProps({
      element
    }), ...BusinessKeyProps({
      element
    }), ...DelegateVariableMappingProps({
      element
    }));
  } else if (calledElementType === "cmmn") {
    entries.push(...CalledCmmnProps({
      element
    }), ...BusinessKeyProps({
      element
    }));
  } else {
    entries.push(...BusinessKeyProps({
      element
    }));
  }
  return entries;
}
var DEFAULT_PROPS$4 = {
  calledElement: void 0,
  "camunda:calledElementBinding": void 0,
  "camunda:calledElementVersion": void 0,
  "camunda:calledElementTenantId": void 0,
  "camunda:variableMappingClass": void 0,
  "camunda:variableMappingDelegateExpression": void 0,
  "camunda:caseRef": void 0,
  "camunda:caseBinding": void 0,
  "camunda:caseVersion": void 0,
  "camunda:caseTenantId": void 0
};
var DEFAULT_BUSINESS_KEY = "#{execution.processBusinessKey}";
function CalledElementType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getCalledElementType(element);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$4
    };
    if (value === "bpmn") {
      properties["calledElement"] = "";
    } else if (value === "cmmn") {
      properties["camunda:caseRef"] = "";
    }
    commandStack.execute("element.updateProperties", {
      element,
      properties
    });
  };
  const getOptions = () => [{
    value: "",
    label: translate4("<none>")
  }, {
    value: "bpmn",
    label: translate4("BPMN")
  }, {
    value: "cmmn",
    label: translate4("CMMN")
  }];
  return u5(SelectEntry, {
    element,
    id: "calledElementType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function BusinessKeyProps(props) {
  const {
    element
  } = props;
  const entries = [{
    id: "calledElementBusinessKey",
    component: BusinessKey,
    isEdited: isEdited$5
  }];
  if (hasBusinessKey(element)) {
    entries.push({
      id: "calledElementBusinessKeyExpression",
      component: BusinessKeyExpression,
      isEdited
    });
  }
  return entries;
}
function BusinessKey(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const modeling = useService("modeling");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    return hasBusinessKey(element);
  };
  const setValue = (value) => {
    if (value) {
      addBusinessKey();
    } else {
      removeBusinessKey();
    }
  };
  function addBusinessKey() {
    const businessObject = getBusinessObject(element);
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {}, businessObject, bpmnFactory);
      const businessKeyItem = createBusinessKey(extensionElements);
      extensionElements.set("values", [businessKeyItem]);
      modeling.updateProperties(element, {
        extensionElements
      });
    } else {
      const businessKeyItem = createBusinessKey(extensionElements);
      addExtensionElements(element, businessObject, businessKeyItem, bpmnFactory, commandStack);
    }
  }
  function createBusinessKey(parent) {
    return createElement("camunda:In", {
      businessKey: DEFAULT_BUSINESS_KEY
    }, parent, bpmnFactory);
  }
  function removeBusinessKey() {
    const businessObject = getBusinessObject(element);
    const camundaInList = getExtensionElementsList(businessObject, "camunda:In");
    const businessKeyItems = camundaInList.filter((camundaIn) => camundaIn.get("businessKey") !== void 0);
    removeExtensionElements(element, businessObject, businessKeyItems, commandStack);
  }
  return u5(CheckboxEntry, {
    element,
    id: "calledElementBusinessKey",
    label: translate4("Business key"),
    getValue,
    setValue
  });
}
function BusinessKeyExpression(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => getBusinessKey(element);
  const setValue = (value) => {
    const camundaIn = findCamundaInWithBusinessKey(element);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: camundaIn,
      properties: {
        businessKey: value || ""
      }
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "calledElementBusinessKeyExpression",
    label: translate4("Business key expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getCalledElementType(element) {
  const businessObject = getBusinessObject(element);
  if (businessObject.get("calledElement") !== void 0) {
    return "bpmn";
  } else if (businessObject.get("camunda:caseRef") !== void 0) {
    return "cmmn";
  }
  return "";
}
function hasBusinessKey(element) {
  return getBusinessKey(element) !== void 0;
}
function getBusinessKey(element) {
  const camundaIn = findCamundaInWithBusinessKey(element);
  if (camundaIn) {
    return camundaIn.get("businessKey");
  }
}
function findCamundaInWithBusinessKey(element) {
  const businessObject = getBusinessObject(element);
  const camundaInList = getExtensionElementsList(businessObject, "camunda:In");
  for (const camundaIn of camundaInList) {
    const businessKey = camundaIn.get("businessKey");
    if (businessKey !== void 0) {
      return camundaIn;
    }
  }
}
function CandidateStarterProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "candidateStarterGroups",
    component: CandidateStarterGroups,
    isEdited
  }, {
    id: "candidateStarterUsers",
    component: CandidateStarterUsers,
    isEdited
  }];
}
function CandidateStarterGroups(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const process2 = getProcess$3(element);
  const getValue = () => {
    return process2.get("camunda:candidateStarterGroups") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:candidateStarterGroups": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateStarterGroups",
    label: translate4("Candidate starter groups"),
    description: translate4("Specify more than one group as a comma separated list."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CandidateStarterUsers(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const process2 = getProcess$3(element);
  const getValue = () => {
    return process2.get("camunda:candidateStarterUsers") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:candidateStarterUsers": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateStarterUsers",
    label: translate4("Candidate starter users"),
    description: translate4("Specify more than one user as a comma separated list."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getProcess$3(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function ConditionProps(props) {
  const {
    element
  } = props;
  if (!(is(element, "bpmn:SequenceFlow") && isConditionalSource(element.source)) && !getConditionalEventDefinition(element)) {
    return [];
  }
  const entries = [];
  if (getConditionalEventDefinition(element)) {
    entries.push(...VariableEventProps({
      element
    }));
  }
  entries.push({
    id: "conditionType",
    component: ConditionType,
    isEdited: isEdited$3
  });
  const conditionType = getConditionType(element);
  if (conditionType === "script") {
    entries.push(...ConditionScriptProps({
      element
    }));
  } else if (conditionType === "expression") {
    entries.push({
      id: "conditionExpression",
      component: ConditionExpression,
      isEdited
    });
  }
  return entries;
}
function ConditionType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    return getConditionType(element);
  };
  const setValue = (value) => {
    if (value === "") {
      updateCondition(element, commandStack, void 0);
    } else {
      const attributes = {
        body: "",
        language: value === "script" ? "" : void 0
      };
      const formalExpressionElement = createFormalExpression(element, attributes, bpmnFactory);
      updateCondition(element, commandStack, formalExpressionElement);
    }
  };
  const getOptions = () => [{
    value: "",
    label: translate4("<none>")
  }, {
    value: "script",
    label: translate4("Script")
  }, {
    value: "expression",
    label: translate4("Expression")
  }];
  return u5(SelectEntry, {
    element,
    id: "conditionType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function ConditionExpression(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionExpression(element).get("body");
  };
  const setValue = (value) => {
    const conditionExpression = createFormalExpression(element, {
      body: value
    }, bpmnFactory);
    updateCondition(element, commandStack, conditionExpression);
  };
  return u5(TextfieldEntry, {
    element,
    id: "conditionExpression",
    label: translate4("Condition Expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ConditionScriptProps(props) {
  const {
    element
  } = props;
  const entries = [];
  const scriptType = getScriptType$1(element);
  entries.push({
    id: "conditionScriptLanguage",
    component: Language,
    isEdited
  });
  entries.push({
    id: "conditionScriptType",
    component: ScriptType,
    isEdited: isEdited$3
  });
  if (scriptType === "script") {
    entries.push({
      id: "conditionScriptValue",
      component: Script$1,
      isEdited: isEdited$1
    });
  } else if (scriptType === "resource") {
    entries.push({
      id: "conditionScriptResource",
      component: Resource$1,
      isEdited
    });
  }
  return entries;
}
function Language(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionExpression(element).get("language");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        language: value || ""
      }
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "conditionScriptLanguage",
    label: translate4("Format"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ScriptType(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getScriptType$1(element);
  };
  const setValue = (value) => {
    const updatedProperties = {
      "body": value === "script" ? "" : void 0,
      "camunda:resource": value === "resource" ? "" : void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: updatedProperties
    });
  };
  const getOptions = () => {
    const options = [{
      value: "resource",
      label: translate4("External resource")
    }, {
      value: "script",
      label: translate4("Inline script")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "conditionScriptType",
    label: translate4("Script type"),
    getValue,
    setValue,
    getOptions
  });
}
function Script$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionExpression(element).get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        "body": value || ""
      }
    });
  };
  return u5(TextAreaEntry, {
    element,
    id: "conditionScriptValue",
    label: translate4("Script"),
    getValue,
    setValue,
    debounce: debounce2,
    monospace: true
  });
}
function Resource$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionExpression(element).get("camunda:resource");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionExpression(element),
      properties: {
        "camunda:resource": value || ""
      }
    });
  };
  return u5(TextfieldEntry, {
    element: true,
    id: "conditionScriptResource",
    label: translate4("Resource"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function VariableEventProps(props) {
  const {
    element
  } = props;
  const entries = [];
  entries.push({
    id: "conditionVariableName",
    component: VariableName2,
    isEdited
  });
  if (!is(element, "bpmn:StartEvent") || isInEventSubProcess(element)) {
    entries.push({
      id: "conditionVariableEvents",
      component: VariableEvents,
      isEdited
    });
  }
  return entries;
}
function VariableName2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionalEventDefinition(element).get("variableName");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        variableName: value || ""
      }
    });
  };
  return u5(TextfieldEntry, {
    element,
    id: "conditionVariableName",
    label: translate4("Variable name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function VariableEvents(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return getConditionalEventDefinition(element).get("variableEvents");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        variableEvents: value || ""
      }
    });
  };
  const tooltip = u5("div", {
    children: [u5("p", {
      children: translate4("Specify more than one variable change event as a comma separated list. Variable change events are:")
    }), u5("ul", {
      children: [u5("li", {
        children: u5("code", {
          children: "create"
        })
      }), u5("li", {
        children: u5("code", {
          children: "update"
        })
      }), u5("li", {
        children: u5("code", {
          children: "delete"
        })
      })]
    }), u5("a", {
      href: "https://docs.camunda.org/manual/latest/reference/bpmn20/custom-extensions/extension-attributes/#variableevents",
      target: "_blank",
      rel: "noopener noreferrer",
      children: translate4("Documentation: Variable events")
    })]
  });
  return u5(TextfieldEntry, {
    element,
    id: "conditionVariableEvents",
    label: translate4("Variable events"),
    getValue,
    setValue,
    debounce: debounce2,
    tooltip
  });
}
var CONDITIONAL_SOURCES = ["bpmn:Activity", "bpmn:ExclusiveGateway", "bpmn:InclusiveGateway", "bpmn:ComplexGateway"];
function isConditionalSource(element) {
  return isAny(element, CONDITIONAL_SOURCES);
}
function getConditionalEventDefinition(element) {
  if (!is(element, "bpmn:Event")) {
    return false;
  }
  return getEventDefinition$1(element, "bpmn:ConditionalEventDefinition");
}
function getConditionType(element) {
  const conditionExpression = getConditionExpression(element);
  if (!conditionExpression) {
    return "";
  } else {
    return conditionExpression.get("language") === void 0 ? "expression" : "script";
  }
}
function getConditionExpression(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:SequenceFlow")) {
    return businessObject.get("conditionExpression");
  } else if (getConditionalEventDefinition(businessObject)) {
    return getConditionalEventDefinition(businessObject).get("condition");
  }
}
function getScriptType$1(element) {
  const conditionExpression = getConditionExpression(element);
  const resource = conditionExpression.get("camunda:resource");
  if (typeof resource !== "undefined") {
    return "resource";
  } else {
    return "script";
  }
}
function updateCondition(element, commandStack, condition = void 0) {
  if (is(element, "bpmn:SequenceFlow")) {
    commandStack.execute("element.updateProperties", {
      element,
      properties: {
        conditionExpression: condition
      }
    });
  } else {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: getConditionalEventDefinition(element),
      properties: {
        condition
      }
    });
  }
}
function createFormalExpression(parent, attributes, bpmnFactory) {
  return createElement("bpmn:FormalExpression", attributes, is(parent, "bpmn:SequenceFlow") ? getBusinessObject(parent) : getConditionalEventDefinition(parent), bpmnFactory);
}
function isInEventSubProcess(element) {
  const bo = getBusinessObject(element), parent = bo.$parent;
  return is(parent, "bpmn:SubProcess") && parent.triggeredByEvent;
}
function ScriptProps(props) {
  const {
    element,
    script,
    prefix: prefix3
  } = props;
  const entries = [];
  const scriptType = getScriptType(script || element);
  const idPrefix = prefix3 || "";
  entries.push({
    id: idPrefix + "scriptFormat",
    component: Format,
    isEdited,
    idPrefix,
    script
  });
  entries.push({
    id: idPrefix + "scriptType",
    component: Type$3,
    isEdited: isEdited$3,
    idPrefix,
    script
  });
  if (scriptType === "script") {
    entries.push({
      id: idPrefix + "scriptValue",
      component: Script,
      isEdited: isEdited$1,
      idPrefix,
      script
    });
  }
  if (scriptType === "resource") {
    entries.push({
      id: idPrefix + "scriptResource",
      component: Resource,
      isEdited,
      idPrefix,
      script
    });
  }
  return entries;
}
function Format(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("scriptFormat");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        scriptFormat: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "scriptFormat",
    label: translate4("Format"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Type$3(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const businessObject = script || getBusinessObject(element);
  const scriptProperty = getScriptProperty(businessObject);
  const getValue = () => {
    return getScriptType(businessObject);
  };
  const setValue = (value) => {
    const properties = {
      [scriptProperty]: value === "script" ? "" : void 0,
      "camunda:resource": value === "resource" ? "" : void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties
    });
  };
  const getOptions = () => {
    const options = [{
      value: "",
      label: translate4("<none>")
    }, {
      value: "resource",
      label: translate4("External resource")
    }, {
      value: "script",
      label: translate4("Inline script")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: idPrefix + "scriptType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function Script(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const scriptProperty = getScriptProperty(businessObject);
  const getValue = () => {
    return getScriptValue(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        [scriptProperty]: value || ""
      }
    });
  };
  return TextAreaEntry({
    element,
    id: idPrefix + "scriptValue",
    label: translate4("Script"),
    getValue,
    setValue,
    debounce: debounce2,
    monospace: true
  });
}
function Resource(props) {
  const {
    element,
    idPrefix,
    script
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = script || getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:resource");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resource": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "scriptResource",
    label: translate4("Resource"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getScriptType(element) {
  const businessObject = getBusinessObject(element);
  const scriptValue = getScriptValue(businessObject);
  if (typeof scriptValue !== "undefined") {
    return "script";
  }
  const resource = businessObject.get("camunda:resource");
  if (typeof resource !== "undefined") {
    return "resource";
  }
}
function getScriptValue(businessObject) {
  return businessObject.get(getScriptProperty(businessObject));
}
function isScript$2(element) {
  return is(element, "camunda:Script");
}
function getScriptProperty(businessObject) {
  return isScript$2(businessObject) ? "value" : "script";
}
function getElements3(businessObject, type, property) {
  const elements = getExtensionElementsList(businessObject, type);
  return !property ? elements : (elements[0] || {})[property] || [];
}
function getParameters3(element, prop) {
  const inputOutput = getInputOutput3(element);
  return inputOutput && inputOutput.get(prop) || [];
}
function getInputOutput3(element) {
  if (is(element, "camunda:Connector")) {
    return element.get("inputOutput");
  }
  const businessObject = getBusinessObject(element);
  return (getElements3(businessObject, "camunda:InputOutput") || [])[0];
}
function getInputParameters3(element) {
  return getParameters3(element, "inputParameters");
}
function getOutputParameters2(element) {
  return getParameters3(element, "outputParameters");
}
function isInputOutputSupported(element) {
  const businessObject = getBusinessObject(element);
  return is(businessObject, "bpmn:FlowNode") && !(isAny(businessObject, ["bpmn:StartEvent", "bpmn:BoundaryEvent", "bpmn:Gateway"]) || is(businessObject, "bpmn:SubProcess") && businessObject.get("triggeredByEvent"));
}
function areInputParametersSupported(element) {
  return isInputOutputSupported(element);
}
function areOutputParametersSupported(element) {
  const businessObject = getBusinessObject(element);
  return isInputOutputSupported(element) && !is(businessObject, "bpmn:EndEvent") && !businessObject.loopCharacteristics;
}
function getInputOutputType(parameter) {
  const definitionTypes = {
    "camunda:Map": "map",
    "camunda:List": "list",
    "camunda:Script": "script"
  };
  let type = "stringOrExpression";
  const definition = parameter.get("definition");
  if (typeof definition !== "undefined") {
    type = definitionTypes[definition.$type];
  }
  return type;
}
function CreateParameterCmd(element, type, parent, bpmnFactory) {
  const isInput4 = type === "camunda:InputParameter";
  const newParameter = createElement(type, {
    name: nextId(isInput4 ? "Input_" : "Output_")
  }, parent, bpmnFactory);
  const propertyName = isInput4 ? "inputParameters" : "outputParameters";
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: parent,
      properties: {
        [propertyName]: [...parent.get(propertyName), newParameter]
      }
    }
  };
}
function AddParameterCmd(element, type, bpmnFactory) {
  const commands = [];
  const businessObject = getBusinessObject(element);
  let extensionElements = businessObject.get("extensionElements");
  if (!extensionElements) {
    extensionElements = createElement("bpmn:ExtensionElements", {
      values: []
    }, businessObject, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: businessObject,
        properties: {
          extensionElements
        }
      }
    });
  }
  let inputOutput = getInputOutput3(element);
  if (!inputOutput) {
    const parent = extensionElements;
    inputOutput = createElement("camunda:InputOutput", {
      inputParameters: [],
      outputParameters: []
    }, parent, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: [...extensionElements.get("values"), inputOutput]
        }
      }
    });
  }
  commands.push(CreateParameterCmd(element, type, inputOutput, bpmnFactory));
  return commands;
}
function ListProp(props) {
  const {
    element,
    id: idPrefix,
    index: index5,
    item
  } = props;
  const id = `${idPrefix}-listItem-${index5}`;
  return u5(ListItem2, {
    idPrefix: id,
    element,
    item
  });
}
function ListProps(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const list = parameter.get("definition");
  const items = list.get("items");
  function addItem() {
    const value = createElement("camunda:Value", {}, parameter, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: list,
      properties: {
        items: [...list.get("items"), value]
      }
    });
  }
  function removeItem(item) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: list,
      properties: {
        items: without(list.get("items"), item)
      }
    });
  }
  return List2({
    element,
    autoFocusEntry: true,
    id: idPrefix + "-list",
    items,
    label: translate4("List values"),
    onAdd: addItem,
    onRemove: removeItem,
    component: ListProp
  });
}
function ListItem2(props) {
  const {
    idPrefix,
    element,
    item
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const definitionLabels = {
    "camunda:Map": translate4("Map"),
    "camunda:List": translate4("List"),
    "camunda:Script": translate4("Script")
  };
  const getValue = () => {
    if (isDefinitionType$1(item)) {
      return definitionLabels[item.$type];
    }
    return item.get("value");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: item,
      properties: {
        value
      }
    });
  };
  return ListValue({
    id: idPrefix + "-value",
    disabled: isDefinitionType$1(item),
    getValue,
    setValue
  });
}
function ListValue(props) {
  const {
    id,
    disabled,
    getValue,
    setValue
  } = props;
  const debounce2 = useService("debounceInput", true);
  return u5(Simple, {
    id,
    getValue,
    setValue,
    disabled,
    debounce: debounce2
  });
}
function isScript$1(element) {
  return is(element, "camunda:Script");
}
function isList$1(element) {
  return is(element, "camunda:List");
}
function isMap$1(element) {
  return is(element, "camunda:Map");
}
function isDefinitionType$1(element) {
  return isScript$1(element) || isList$1(element) || isMap$1(element);
}
function MapProp(props) {
  const {
    element,
    id: idPrefix,
    index: index5,
    item: entry,
    open: open3
  } = props;
  const id = `${idPrefix}-mapEntry-${index5}`;
  const translate4 = useService("translate");
  return u5(CollapsibleEntry, {
    id,
    element,
    entries: MapEntry({
      element,
      entry,
      idPrefix: id
    }),
    label: entry.get("key") || translate4("<empty>"),
    open: open3
  });
}
function MapProps(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const id = idPrefix + "-map";
  const map4 = parameter.get("definition");
  const entries = map4.get("entries");
  function addEntry() {
    const entry = createElement("camunda:Entry", {}, parameter, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: map4,
      properties: {
        entries: [...map4.get("entries"), entry]
      }
    });
  }
  function removeEntry(entry) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: map4,
      properties: {
        entries: without(map4.get("entries"), entry)
      }
    });
  }
  return List2({
    element,
    autoFocusEntry: `[data-entry-id="${id}-mapEntry-${entries.length - 1}"] input`,
    id: idPrefix + "-map",
    items: entries,
    label: translate4("Map entries"),
    onAdd: addEntry,
    onRemove: removeEntry,
    component: MapProp
  });
}
function MapEntry(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const entries = [{
    id: idPrefix + "-key",
    component: MapKey,
    entry,
    idPrefix,
    element
  }, {
    id: idPrefix + "-value",
    component: MapValue,
    entry,
    idPrefix,
    element
  }];
  return entries;
}
function MapKey(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: entry,
      properties: {
        key: value
      }
    });
  };
  const getValue = () => {
    return entry.get("key");
  };
  return TextfieldEntry({
    element: entry,
    id: idPrefix + "-key",
    label: translate4("Key"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function MapValue(props) {
  const {
    element,
    entry,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const definition = entry.get("definition");
  const definitionLabels = {
    "camunda:Map": translate4("Map"),
    "camunda:List": translate4("List"),
    "camunda:Script": translate4("Script")
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: entry,
      properties: {
        value
      }
    });
  };
  const getValue = () => {
    if (isDefinitionType(definition)) {
      return definitionLabels[definition.$type];
    }
    return entry.get("value");
  };
  return TextfieldEntry({
    element: entry,
    id: idPrefix + "-value",
    label: translate4("Value"),
    getValue,
    setValue,
    disabled: isDefinitionType(definition),
    debounce: debounce2
  });
}
function isScript(element) {
  return is(element, "camunda:Script");
}
function isList(element) {
  return is(element, "camunda:List");
}
function isMap(element) {
  return is(element, "camunda:Map");
}
function isDefinitionType(element) {
  return isScript(element) || isList(element) || isMap(element);
}
var DEFAULT_PROPS$3 = {
  value: void 0,
  definition: void 0
};
function InputOutputParameter(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const inputOutputType = getInputOutputType(parameter);
  let entries = [{
    id: idPrefix + "-name",
    component: Name$2,
    isEdited,
    idPrefix,
    parameter
  }, {
    id: idPrefix + "-type",
    component: Type$2,
    isEdited: isEdited$3,
    idPrefix,
    parameter
  }];
  if (inputOutputType === "stringOrExpression") {
    entries.push({
      id: idPrefix + "-stringOrExpression",
      component: StringOrExpression,
      isEdited: isEdited$1,
      idPrefix,
      parameter
    });
  } else if (inputOutputType === "script") {
    const script = parameter.get("definition");
    entries = [...entries, ...ScriptProps({
      element,
      prefix: idPrefix + "-",
      script
    })];
  } else if (inputOutputType === "list") {
    entries.push({
      id: `${idPrefix}-list`,
      component: ListProps,
      idPrefix,
      parameter
    });
  } else if (inputOutputType === "map") {
    entries.push({
      id: `${idPrefix}-map`,
      component: MapProps,
      idPrefix,
      parameter
    });
  }
  return entries;
}
function Name$2(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        name: value
      }
    });
  };
  const getValue = (parameter2) => {
    return parameter2.get("name");
  };
  return TextfieldEntry({
    element: parameter,
    id: idPrefix + "-name",
    label: translate4(isInput3(parameter) ? "Local variable name" : "Process variable name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Type$2(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const createDefinitionElement = (type) => {
    return createElement(type, {}, parameter, bpmnFactory);
  };
  const getValue = (mapping) => {
    return getInputOutputType(mapping);
  };
  const setValue = (value) => {
    let properties = {
      ...DEFAULT_PROPS$3
    };
    if (value === "script") {
      properties.definition = createDefinitionElement("camunda:Script");
    } else if (value === "list") {
      properties.definition = createDefinitionElement("camunda:List");
    } else if (value === "map") {
      properties.definition = createDefinitionElement("camunda:Map");
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties
    });
  };
  const getOptions = () => {
    const options = [{
      label: translate4("List"),
      value: "list"
    }, {
      label: translate4("Map"),
      value: "map"
    }, {
      label: translate4("Script"),
      value: "script"
    }, {
      label: translate4("String or expression"),
      value: "stringOrExpression"
    }];
    return options;
  };
  return SelectEntry({
    element: parameter,
    id: idPrefix + "-type",
    label: translate4("Assignment type"),
    getValue,
    setValue,
    getOptions
  });
}
function StringOrExpression(props) {
  const {
    idPrefix,
    element,
    parameter
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: parameter,
      properties: {
        value
      }
    });
  };
  const getValue = (parameter2) => {
    return parameter2.get("value");
  };
  return TextAreaEntry({
    element: parameter,
    id: idPrefix + "-stringOrExpression",
    label: translate4("Value"),
    description: translate4('Start typing "${}" to create an expression.'),
    getValue,
    setValue,
    rows: 1,
    debounce: debounce2
  });
}
function isInput3(parameter) {
  return is(parameter, "camunda:InputParameter");
}
function isServiceTaskLike(element) {
  return is(element, "camunda:ServiceTaskLike");
}
function isDmnCapable(element) {
  return is(element, "camunda:DmnCapable");
}
function isExternalCapable(element) {
  return is(element, "camunda:ExternalCapable");
}
function getServiceTaskLikeBusinessObject(element) {
  if (is(element, "bpmn:IntermediateThrowEvent") || is(element, "bpmn:EndEvent")) {
    const messageEventDefinition = getMessageEventDefinition(element);
    if (messageEventDefinition) {
      element = messageEventDefinition;
    }
  }
  return isServiceTaskLike(element) && getBusinessObject(element);
}
function getImplementationType(element) {
  const businessObject = getListenerBusinessObject(element) || getServiceTaskLikeBusinessObject(element);
  if (!businessObject) {
    return;
  }
  if (isDmnCapable(businessObject)) {
    const decisionRef = businessObject.get("camunda:decisionRef");
    if (typeof decisionRef !== "undefined") {
      return "dmn";
    }
  }
  if (isServiceTaskLike(businessObject)) {
    const connectors = getExtensionElementsList(businessObject, "camunda:Connector");
    if (connectors.length) {
      return "connector";
    }
  }
  if (isExternalCapable(businessObject)) {
    const type = businessObject.get("camunda:type");
    if (type === "external") {
      return "external";
    }
  }
  const cls = businessObject.get("camunda:class");
  if (typeof cls !== "undefined") {
    return "class";
  }
  const expression = businessObject.get("camunda:expression");
  if (typeof expression !== "undefined") {
    return "expression";
  }
  const delegateExpression = businessObject.get("camunda:delegateExpression");
  if (typeof delegateExpression !== "undefined") {
    return "delegateExpression";
  }
  const script = businessObject.get("script");
  if (typeof script !== "undefined") {
    return "script";
  }
}
function getListenerBusinessObject(businessObject) {
  if (isAny(businessObject, ["camunda:ExecutionListener", "camunda:TaskListener"])) {
    return businessObject;
  }
}
function areConnectorsSupported(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  return businessObject && getImplementationType(businessObject) === "connector";
}
function getConnectors$2(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function getConnector$1(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const connectors = getConnectors$2(businessObject);
  return connectors[0];
}
function ConnectorInputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areConnectorsSupported(element)) {
    return null;
  }
  const connector = getConnector$1(element);
  const commandStack = injector.get("commandStack"), bpmnFactory = injector.get("bpmnFactory");
  const inputParameters = getInputParameters3(connector) || [];
  const items = inputParameters.map((parameter, index5) => {
    const id = element.id + "-connector-inputParameter-" + index5;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        element,
        idPrefix: id,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$8({
        connector,
        element,
        parameter,
        commandStack
      })
    };
  });
  function add5(event2) {
    event2.stopPropagation();
    const commands = [];
    let inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      inputOutput = createElement("camunda:InputOutput", {
        inputParameters: [],
        outputParameters: []
      }, connector, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: connector,
          properties: {
            inputOutput
          }
        }
      });
    }
    commands.push(CreateParameterCmd(element, "camunda:InputParameter", inputOutput, bpmnFactory));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  return {
    items,
    add: add5
  };
}
function removeFactory$8(props) {
  const {
    commandStack,
    connector,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        inputParameters: without(inputOutput.get("inputParameters"), parameter)
      }
    });
  };
}
function ConnectorOutputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areConnectorsSupported(element)) {
    return null;
  }
  const connector = getConnector$1(element);
  const commandStack = injector.get("commandStack"), bpmnFactory = injector.get("bpmnFactory");
  const outputParameters = getOutputParameters2(connector) || [];
  const items = outputParameters.map((parameter, index5) => {
    const id = element.id + "-connector-outputParameter-" + index5;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$7({
        connector,
        element,
        commandStack,
        parameter
      })
    };
  });
  function add5(event2) {
    event2.stopPropagation();
    const commands = [];
    let inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      inputOutput = createElement("camunda:InputOutput", {
        inputParameters: [],
        outputParameters: []
      }, connector, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: connector,
          properties: {
            inputOutput
          }
        }
      });
    }
    commands.push(CreateParameterCmd(element, "camunda:OutputParameter", inputOutput, bpmnFactory));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  return {
    items,
    add: add5
  };
}
function removeFactory$7(props) {
  const {
    commandStack,
    connector,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(connector);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        outputParameters: without(inputOutput.get("outputParameters"), parameter)
      }
    });
  };
}
function ErrorProps(props) {
  const {
    element,
    entries
  } = props;
  if (!isErrorSupported(element)) {
    return entries;
  }
  const error4 = getError(element);
  if (error4) {
    const idx = findPlaceToInsert(entries, "errorCode");
    entries.splice(idx, 0, {
      id: "errorMessage",
      component: ErrorMessage$1,
      isEdited
    });
  }
  if (!canHaveErrorVariables(element)) {
    return entries;
  }
  entries.push({
    id: "errorCodeVariable",
    component: ErrorCodeVariable,
    isEdited
  }, {
    id: "errorMessageVariable",
    component: ErrorMessageVariable,
    isEdited
  });
  return entries;
}
function ErrorMessage$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const error4 = getError(element);
  const getValue = () => {
    return error4.get("camunda:errorMessage");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        "camunda:errorMessage": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorMessage",
    label: translate4("Message"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ErrorCodeVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const errorEventDefinition = getErrorEventDefinition$1(element);
  const getValue = () => {
    return errorEventDefinition.get("camunda:errorCodeVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:errorCodeVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorCodeVariable",
    label: translate4("Code variable"),
    description: translate4("Define the name of the variable that will contain the error code."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ErrorMessageVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const errorEventDefinition = getErrorEventDefinition$1(element);
  const getValue = () => {
    return errorEventDefinition.get("camunda:errorMessageVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:errorMessageVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "errorMessageVariable",
    label: translate4("Message variable"),
    description: translate4("Define the name of the variable that will contain the error message."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function canHaveErrorVariables(element) {
  return is(element, "bpmn:StartEvent") || is(element, "bpmn:BoundaryEvent");
}
function findPlaceToInsert(entries, idx) {
  const entryIndex = findIndex(entries, (entry) => entry.id === idx);
  return entryIndex >= 0 ? entryIndex + 1 : entries.length;
}
var EMPTY_OPTION = "";
var CREATE_NEW_OPTION = "create-new";
function Error$1(props) {
  const {
    idPrefix,
    errorEventDefinition
  } = props;
  let entries = [{
    id: idPrefix + "-errorRef",
    component: ErrorRef,
    isEdited: isEdited$3,
    errorEventDefinition,
    idPrefix
  }];
  const error4 = errorEventDefinition.get("errorRef");
  if (error4) {
    entries = [...entries, {
      id: idPrefix + "-errorName",
      component: ErrorName,
      isEdited,
      error: error4,
      errorEventDefinition,
      idPrefix
    }, {
      id: idPrefix + "-errorCode",
      component: ErrorCode,
      isEdited,
      error: error4,
      errorEventDefinition,
      idPrefix
    }, {
      id: idPrefix + "-errorMessage",
      component: ErrorMessage,
      isEdited,
      error: error4,
      errorEventDefinition,
      idPrefix
    }];
  }
  entries.push({
    id: idPrefix + "-expression",
    component: Expression$1,
    errorEventDefinition,
    idPrefix
  });
  return entries;
}
function ErrorRef(props) {
  const {
    element,
    errorEventDefinition,
    idPrefix
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    const error4 = errorEventDefinition.get("errorRef");
    if (error4) {
      return error4.get("id");
    }
    return EMPTY_OPTION;
  };
  const setValue = (value) => {
    const root = getRoot(businessObject);
    const commands = [];
    let error4;
    if (value === CREATE_NEW_OPTION) {
      error4 = createElement("bpmn:Error", {
        name: nextId("Error_")
      }, root, bpmnFactory);
      value = error4.get("id");
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: root,
          properties: {
            rootElements: [...root.get("rootElements"), error4]
          }
        }
      });
    }
    error4 = error4 || findRootElementById(businessObject, "bpmn:Error", value);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: errorEventDefinition,
        properties: {
          errorRef: error4
        }
      }
    });
    return commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    let options = [{
      value: EMPTY_OPTION,
      label: translate4("<none>")
    }, {
      value: CREATE_NEW_OPTION,
      label: translate4("Create new ...")
    }];
    const errors = findRootElementsByType(getBusinessObject(element), "bpmn:Error");
    sortByName$1(errors).forEach((error4) => {
      options.push({
        value: error4.get("id"),
        label: error4.get("name") || error4.get("id")
      });
    });
    return options;
  };
  return ReferenceSelectEntry({
    element,
    id: idPrefix + "-errorRef",
    label: translate4("Global error reference"),
    autoFocusEntry: idPrefix + "-errorName",
    getValue,
    setValue,
    getOptions
  });
}
function ErrorName(props) {
  const {
    element,
    error: error4,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return error4.get("name");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        name: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorName",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ErrorCode(props) {
  const {
    element,
    error: error4,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return error4.get("errorCode");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorCode: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorCode",
    label: translate4("Code"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ErrorMessage(props) {
  const {
    element,
    error: error4,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return error4.get("errorMessage");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: error4,
      properties: {
        errorMessage: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: idPrefix + "-errorMessage",
    label: translate4("Message"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Expression$1(props) {
  const {
    element,
    errorEventDefinition,
    idPrefix
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: errorEventDefinition,
      properties: {
        "camunda:expression": value
      }
    });
  };
  const getValue = () => {
    return errorEventDefinition.get("camunda:expression");
  };
  return TextfieldEntry({
    element: errorEventDefinition,
    id: idPrefix + "-expression",
    label: translate4("Throw expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function sortByName$1(elements) {
  return sortBy(elements, (e8) => (e8.name || "").toLowerCase());
}
function ErrorsProps({
  element,
  injector
}) {
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:ServiceTask") || getImplementationType(element) !== "external") {
    return null;
  }
  const errorEventDefinitions = getExtensionElementsList(businessObject, "camunda:ErrorEventDefinition");
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = errorEventDefinitions.map((errorEventDefinition, index5) => {
    const id = element.id + "-error-" + index5;
    return {
      id,
      label: getErrorLabel(errorEventDefinition),
      entries: Error$1({
        idPrefix: id,
        element,
        errorEventDefinition
      }),
      autoFocusEntry: id + "-errorRef",
      remove: removeFactory$6({
        commandStack,
        element,
        errorEventDefinition
      })
    };
  });
  return {
    items,
    add: addFactory$5({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$6({
  commandStack,
  element,
  errorEventDefinition
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    removeExtensionElements(element, businessObject, errorEventDefinition, commandStack);
  };
}
function addFactory$5({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    const error4 = createElement("camunda:ErrorEventDefinition", {}, void 0, bpmnFactory);
    addExtensionElements(element, businessObject, error4, bpmnFactory, commandStack);
  };
}
function getErrorLabel(errorEventDefinition) {
  const error4 = errorEventDefinition.get("errorRef");
  if (!error4) {
    return "<no reference>";
  }
  const errorCode = error4.get("errorCode"), name2 = error4.get("name") || "<unnamed>";
  if (errorCode) {
    return `${name2} (code = ${errorCode})`;
  }
  return name2;
}
function EscalationProps(props) {
  const {
    element,
    entries
  } = props;
  if (!(isEscalationSupported(element) && canHaveEscalationVariables(element))) {
    return entries;
  }
  entries.push({
    id: "escalationCodeVariable",
    component: EscalationCodeVariable,
    isEdited
  });
  return entries;
}
function EscalationCodeVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const escalationEventDefinition = getEscalationEventDefinition(element);
  const getValue = () => {
    return escalationEventDefinition.get("camunda:escalationCodeVariable");
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: escalationEventDefinition,
      properties: {
        "camunda:escalationCodeVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "escalationCodeVariable",
    label: translate4("Code variable"),
    description: translate4("Define the name of the variable that will contain the escalation code."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function canHaveEscalationVariables(element) {
  return is(element, "bpmn:StartEvent") || is(element, "bpmn:BoundaryEvent");
}
function ExternalTaskPriorityProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef")) && !isExternalTaskLike(element)) {
    return [];
  }
  return [{
    id: "externalTaskPriority",
    component: ExternalTaskPriority,
    isEdited
  }];
}
function ExternalTaskPriority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  let businessObject;
  if (is(element, "bpmn:Participant")) {
    businessObject = getBusinessObject(element).get("processRef");
  } else if (isExternalTaskLike(element)) {
    businessObject = getServiceTaskLikeBusinessObject(element);
  } else {
    businessObject = getBusinessObject(element);
  }
  const getValue = () => {
    return businessObject.get("camunda:taskPriority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:taskPriority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "externalTaskPriority",
    label: translate4("Priority"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function isExternalTaskLike(element) {
  const bo = getServiceTaskLikeBusinessObject(element), type = bo && bo.get("camunda:type");
  return is(bo, "camunda:ServiceTaskLike") && type && type === "external";
}
var DEFAULT_PROPS$2 = {
  "stringValue": void 0,
  "string": void 0,
  "expression": void 0
};
function FieldInjection(props) {
  const {
    element,
    idPrefix,
    field
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: NameProperty,
    field,
    idPrefix,
    element
  }, {
    id: idPrefix + "-type",
    component: TypeProperty,
    field,
    idPrefix,
    element
  }, {
    id: idPrefix + "-value",
    component: ValueProperty,
    field,
    idPrefix,
    element
  }];
  return entries;
}
function NameProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties: {
        name: value
      }
    });
  };
  const getValue = (field2) => {
    return field2.name;
  };
  return TextfieldEntry({
    element: field,
    id: idPrefix + "-name",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function TypeProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate");
  const getValue = (field2) => {
    return determineType(field2);
  };
  const setValue = (value) => {
    const properties = Object.assign({}, DEFAULT_PROPS$2);
    properties[value] = "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties
    });
  };
  const getOptions = (element2) => {
    const options = [{
      value: "string",
      label: translate4("String")
    }, {
      value: "expression",
      label: translate4("Expression")
    }];
    return options;
  };
  return SelectEntry({
    element: field,
    id: idPrefix + "-type",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function ValueProperty(props) {
  const {
    idPrefix,
    element,
    field
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    const type = determineType(field);
    const properties = Object.assign({}, DEFAULT_PROPS$2);
    properties[type] = value || "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: field,
      properties
    });
  };
  const getValue = (field2) => {
    return field2.string || field2.stringValue || field2.expression;
  };
  return TextAreaEntry({
    element: field,
    id: idPrefix + "-value",
    label: translate4("Value"),
    getValue,
    setValue,
    debounce: debounce2,
    autoResize: true
  });
}
function determineType(field) {
  return "string" in field && "string" || "expression" in field && "expression" || "stringValue" in field && "string" || "string";
}
function FieldInjectionProps({
  element,
  injector
}) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  if (!businessObject) {
    return null;
  }
  const fieldInjections = getExtensionElementsList(businessObject, "camunda:Field");
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = fieldInjections.map((field, index5) => {
    const id = element.id + "-fieldInjection-" + index5;
    return {
      id,
      label: getFieldLabel(field),
      entries: FieldInjection({
        idPrefix: id,
        element,
        field
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$5({
        commandStack,
        element,
        field
      })
    };
  });
  return {
    items,
    add: addFactory$4({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$5({
  commandStack,
  element,
  field
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getServiceTaskLikeBusinessObject(element);
    removeExtensionElements(element, businessObject, field, commandStack);
  };
}
function addFactory$4({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const fieldInjection = createElement("camunda:Field", {
      name: void 0,
      string: "",
      // string is the default type
      stringValue: void 0
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, fieldInjection, bpmnFactory, commandStack);
  };
}
function getFieldLabel(field) {
  return field.name || "<empty>";
}
function FormFieldConstraint(props) {
  const {
    constraint,
    element,
    idPrefix
  } = props;
  const entries = [{
    id: idPrefix + "-name",
    component: Name$1,
    constraint,
    idPrefix,
    element
  }, {
    id: idPrefix + "-config",
    component: Config,
    constraint,
    idPrefix,
    element
  }];
  return entries;
}
function Name$1(props) {
  const {
    idPrefix,
    element,
    constraint
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: constraint,
      properties: {
        name: value
      }
    });
  };
  const getValue = () => {
    return constraint.name;
  };
  return TextfieldEntry({
    element: constraint,
    id: idPrefix + "-name",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Config(props) {
  const {
    idPrefix,
    element,
    constraint
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: constraint,
      properties: {
        config: value
      }
    });
  };
  const getValue = () => {
    return constraint.config;
  };
  return TextfieldEntry({
    element: constraint,
    id: idPrefix + "-config",
    label: translate4("Config"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function FormFieldProperty(props) {
  const {
    element,
    idPrefix,
    property
  } = props;
  const entries = [{
    id: idPrefix + "-id",
    component: Id$3,
    idPrefix,
    property,
    element
  }, {
    id: idPrefix + "-value",
    component: Value$1,
    idPrefix,
    property,
    element
  }];
  return entries;
}
function Id$3(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        id: value
      }
    });
  };
  const getValue = () => {
    return property.id;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-id",
    label: translate4("ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Value$1(props) {
  const {
    idPrefix,
    element,
    property
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: property,
      properties: {
        value
      }
    });
  };
  const getValue = () => {
    return property.value;
  };
  return TextfieldEntry({
    element: property,
    id: idPrefix + "-value",
    label: translate4("Value"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function FormFieldValue(props) {
  const {
    element,
    idPrefix,
    value
  } = props;
  const entries = [{
    id: idPrefix + "-id",
    component: Id$2,
    idPrefix,
    value,
    element
  }, {
    id: idPrefix + "-name",
    component: Name2,
    idPrefix,
    value,
    element
  }];
  return entries;
}
function Id$2(props) {
  const {
    idPrefix,
    element,
    value
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (val) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: value,
      properties: {
        id: val
      }
    });
  };
  const getValue = () => {
    return value.id;
  };
  return TextfieldEntry({
    element: value,
    id: idPrefix + "-id",
    label: translate4("ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Name2(props) {
  const {
    idPrefix,
    element,
    value
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const setValue = (val) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: value,
      properties: {
        name: val
      }
    });
  };
  const getValue = () => {
    return value.name;
  };
  return TextfieldEntry({
    element: value,
    id: idPrefix + "-name",
    label: translate4("Name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
var CUSTOM_TYPE_VALUE = "";
var DEFINED_TYPE_VALUES = ["boolean", "date", "enum", "long", "string", void 0];
function FormField(props) {
  const {
    idPrefix,
    formField
  } = props;
  const entries = [{
    id: idPrefix + "-formFieldID",
    component: Id$1,
    idPrefix,
    formField
  }, {
    id: idPrefix + "-formFieldLabel",
    component: Label,
    idPrefix,
    formField
  }, {
    id: idPrefix + "-formFieldType",
    component: Type$1,
    idPrefix,
    formField
  }];
  if (!DEFINED_TYPE_VALUES.includes(formField.get("type"))) {
    entries.push({
      id: idPrefix + "-formFieldCustomType",
      component: CustomType,
      idPrefix,
      formField
    });
  }
  entries.push({
    id: idPrefix + "-formFieldDefaultValue",
    component: DefaultValue,
    idPrefix,
    formField
  });
  if (formField.get("type") === "enum") {
    entries.push({
      id: idPrefix + "-formFieldValues",
      component: ValueList,
      formField,
      idPrefix
    });
  }
  entries.push({
    id: idPrefix + "-formFieldConstraints",
    component: ConstraintList,
    formField,
    idPrefix
  }, {
    id: idPrefix + "-formFieldProperties",
    component: PropertiesList,
    formField,
    idPrefix
  });
  return entries;
}
function Id$1(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        id: value
      }
    });
  };
  const getValue = () => {
    return formField.get("id");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldID",
    label: translate4("ID"),
    description: translate4("Refers to the process variable name"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Label(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        label: value
      }
    });
  };
  const getValue = () => {
    return formField.get("label");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldLabel",
    label: translate4("Label"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Type$1(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        type: value
      }
    });
  };
  const getValue = () => {
    const type = formField.get("type");
    return DEFINED_TYPE_VALUES.includes(type) ? type : CUSTOM_TYPE_VALUE;
  };
  const getOptions = () => {
    const options = [{
      label: translate4("boolean"),
      value: "boolean"
    }, {
      label: translate4("date"),
      value: "date"
    }, {
      label: translate4("enum"),
      value: "enum"
    }, {
      label: translate4("long"),
      value: "long"
    }, {
      label: translate4("string"),
      value: "string"
    }, {
      label: translate4("<custom type>"),
      value: CUSTOM_TYPE_VALUE
    }];
    if (formField.get("type") === void 0) {
      options.unshift({
        label: translate4("<none>"),
        value: ""
      });
    }
    return options;
  };
  return SelectEntry({
    element: formField,
    id: idPrefix + "-formFieldType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function CustomType(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    const type = value || "";
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        type
      }
    });
  };
  const getValue = () => {
    return formField.get("type");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldCustomType",
    label: translate4("Custom type"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function DefaultValue(props) {
  const {
    idPrefix,
    element,
    formField
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        defaultValue: value
      }
    });
  };
  const getValue = () => {
    return formField.get("defaultValue");
  };
  return TextfieldEntry({
    element: formField,
    id: idPrefix + "-formFieldDefaultValue",
    label: translate4("Default value"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Value(props) {
  const {
    element,
    id: idPrefix,
    index: index5,
    item: value,
    open: open3
  } = props;
  const translate4 = useService("translate");
  const id = `${idPrefix}-value-${index5}`;
  return u5(CollapsibleEntry, {
    id,
    element,
    entries: FormFieldValue({
      idPrefix: id,
      element,
      value
    }),
    label: value.get("id") || translate4("<empty>"),
    open: open3
  });
}
function ValueList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id = `${idPrefix}-formFieldValues`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const values2 = formField.get("values") || [];
  function addValue() {
    const value = createElement("camunda:Value", {
      id: void 0,
      name: void 0
    }, formField, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        values: [...formField.get("values"), value]
      }
    });
  }
  function removeValue(value) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formField,
      properties: {
        values: without(formField.get("values"), value)
      }
    });
  }
  return u5(List2, {
    element,
    autoFocusEntry: `[data-entry-id="${id}-value-${values2.length - 1}"] input`,
    id,
    label: translate4("Values"),
    items: values2,
    component: Value,
    onAdd: addValue,
    onRemove: removeValue
  });
}
function Constraint(props) {
  const {
    element,
    id: idPrefix,
    index: index5,
    item: constraint,
    open: open3
  } = props;
  const translate4 = useService("translate");
  const id = `${idPrefix}-constraint-${index5}`;
  return u5(CollapsibleEntry, {
    id,
    element,
    entries: FormFieldConstraint({
      constraint,
      element,
      idPrefix: id
    }),
    label: constraint.get("name") || translate4("<empty>"),
    open: open3
  });
}
function ConstraintList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id = `${idPrefix}-formFieldConstraints`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  let validation = formField.get("validation");
  const constraints = validation && validation.get("constraints") || [];
  function addConstraint() {
    const commands = [];
    if (!validation) {
      validation = createElement("camunda:Validation", {}, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: formField,
          properties: {
            validation
          }
        }
      });
    }
    const constraint = createElement("camunda:Constraint", {
      name: void 0,
      config: void 0
    }, validation, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: validation,
        properties: {
          constraints: [...validation.get("constraints"), constraint]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function removeConstraint(constraint) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: validation,
      properties: {
        constraints: without(validation.get("constraints"), constraint)
      }
    });
  }
  return u5(List2, {
    element,
    autoFocusEntry: `[data-entry-id="${id}-constraint-${constraints.length - 1}"] input`,
    id,
    label: translate4("Constraints"),
    items: constraints,
    component: Constraint,
    onAdd: addConstraint,
    onRemove: removeConstraint
  });
}
function Property(props) {
  const {
    element,
    id: idPrefix,
    index: index5,
    item: property,
    open: open3
  } = props;
  const translate4 = useService("translate");
  const id = `${idPrefix}-property-${index5}`;
  return u5(CollapsibleEntry, {
    id,
    element,
    entries: FormFieldProperty({
      element,
      idPrefix: id,
      property
    }),
    label: property.get("id") || translate4("<empty>"),
    open: open3
  });
}
function PropertiesList(props) {
  const {
    element,
    formField,
    idPrefix
  } = props;
  const id = `${idPrefix}-formFieldProperties`;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  let properties = formField.get("properties");
  const propertyEntries = properties && properties.get("values") || [];
  function addProperty() {
    const commands = [];
    if (!properties) {
      properties = createElement("camunda:Properties", {}, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: formField,
          properties: {
            properties
          }
        }
      });
    }
    const property = createElement("camunda:Property", {
      id: void 0,
      value: void 0
    }, properties, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: properties,
        properties: {
          values: [...properties.get("values"), property]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  }
  function removeProperty(property) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: properties,
      properties: {
        values: without(properties.get("values"), property)
      }
    });
  }
  return u5(List2, {
    element,
    autoFocusEntry: `[data-entry-id="${id}-property-${propertyEntries.length - 1}"] input`,
    id,
    label: translate4("Properties"),
    items: propertyEntries,
    component: Property,
    onAdd: addProperty,
    onRemove: removeProperty
  });
}
function FormDataProps({
  element,
  injector
}) {
  if (!isFormDataSupported(element)) {
    return;
  }
  const formFields = getFormFieldsList(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = formFields.map((formField, index5) => {
    const id = element.id + "-formField-" + index5;
    return {
      id,
      label: formField.get("id") || "",
      entries: FormField({
        idPrefix: id,
        element,
        formField
      }),
      autoFocusEntry: id + "-formFieldID",
      remove: removeFactory$4({
        commandStack,
        element,
        formField
      })
    };
  });
  return {
    items,
    add: addFactory$3({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function addFactory$3({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const commands = [];
    const formData = getFormData$1(element);
    const formField = createElement("camunda:FormField", {}, formData, bpmnFactory);
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: formData,
        properties: {
          fields: [...formData.get("fields"), formField]
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
}
function removeFactory$4({
  commandStack,
  element,
  formField
}) {
  return function(event2) {
    event2.stopPropagation();
    const formData = getFormData$1(element), formFields = getFormFieldsList(element);
    if (!formFields || !formFields.length) {
      return;
    }
    const fields = without(formData.get("fields"), formField);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: formData,
      properties: {
        fields
      }
    });
  };
}
function isFormDataSupported(element) {
  const formData = getFormData$1(element);
  return (is(element, "bpmn:StartEvent") && !is(element.parent, "bpmn:SubProcess") || is(element, "bpmn:UserTask")) && formData;
}
function getFormData$1(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "camunda:FormData")[0];
}
function getFormFieldsList(element) {
  const businessObject = getBusinessObject(element);
  const formData = getFormData$1(businessObject);
  return formData && formData.fields;
}
var FORM_KEY_PROPS = {
  "camunda:formRef": void 0,
  "camunda:formRefBinding": void 0,
  "camunda:formRefVersion": void 0
};
var FORM_REF_PROPS = {
  "camunda:formKey": void 0
};
function FormTypeProps(props) {
  return [{
    id: "formType",
    component: FormType,
    isEdited: isEdited$3
  }];
}
function FormType(props) {
  const {
    element
  } = props;
  const translate4 = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  const businessObject = getBusinessObject(element);
  const commandStack = useService("commandStack");
  let extensionElements = businessObject.get("extensionElements");
  const getValue = () => {
    if (isDefined(businessObject.get("camunda:formKey"))) {
      return "formKey";
    } else if (isDefined(businessObject.get("camunda:formRef"))) {
      return "formRef";
    } else if (getFormData2(element)) {
      return "formData";
    }
    return "";
  };
  const setValue = (value) => {
    const commands = removePropertiesCommands(element);
    if (value === "formData") {
      if (!extensionElements) {
        extensionElements = createElement("bpmn:ExtensionElements", {
          values: []
        }, businessObject, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: businessObject,
            properties: {
              extensionElements
            }
          }
        });
      }
      const parent = extensionElements;
      const formData = createElement("camunda:FormData", {
        fields: []
      }, parent, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), formData]
          }
        }
      });
    } else if (value === "formKey") {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            "camunda:formKey": ""
          }
        }
      });
    } else if (value === "formRef") {
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            "camunda:formRef": ""
          }
        }
      });
    }
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    return [{
      value: "",
      label: translate4("<none>")
    }, {
      value: "formRef",
      label: translate4("Camunda Forms")
    }, {
      value: "formKey",
      label: translate4("Embedded or External Task Forms")
    }, {
      value: "formData",
      label: translate4("Generated Task Forms")
    }];
  };
  return SelectEntry({
    element,
    id: "formType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function getFormData2(element) {
  const bo = getBusinessObject(element);
  return getExtensionElementsList(bo, "camunda:FormData")[0];
}
function removePropertiesCommands(element, commandStack) {
  const businessObject = getBusinessObject(element);
  const extensionElements = businessObject.get("extensionElements");
  const commands = [];
  commands.push({
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: {
        ...FORM_KEY_PROPS,
        ...FORM_REF_PROPS
      }
    }
  });
  if (extensionElements && getFormData2(element)) {
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: extensionElements,
        properties: {
          values: without(extensionElements.get("values"), getFormData2(element))
        }
      }
    });
  }
  return commands;
}
function getFormRefBinding(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:formRefBinding") || "latest";
}
function getFormType(element) {
  const businessObject = getBusinessObject(element);
  if (isDefined(businessObject.get("camunda:formKey"))) {
    return "formKey";
  } else if (isDefined(businessObject.get("camunda:formRef"))) {
    return "formRef";
  }
}
function isFormSupported(element) {
  return is(element, "bpmn:StartEvent") && !is(element.parent, "bpmn:SubProcess") || is(element, "bpmn:UserTask");
}
function FormProps(props) {
  const {
    element
  } = props;
  if (!isFormSupported(element)) {
    return [];
  }
  const formType = getFormType(element), bindingType = getFormRefBinding(element);
  const entries = [...FormTypeProps()];
  if (formType === "formKey") {
    entries.push({
      id: "formKey",
      component: FormKey,
      isEdited
    });
  } else if (formType === "formRef") {
    entries.push({
      id: "formRef",
      component: FormRef,
      isEdited
    }, {
      id: "formRefBinding",
      component: Binding$1,
      isEdited: isEdited$3
    });
    if (bindingType === "version") {
      entries.push({
        id: "formRefVersion",
        component: Version$1,
        isEdited
      });
    }
  }
  return entries;
}
function FormKey(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:formKey");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formKey": isUndefined(value) ? "" : value
    });
  };
  return TextfieldEntry({
    element,
    id: "formKey",
    label: translate4("Form key"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function FormRef(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:formRef");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRef": isUndefined(value) ? "" : value
    });
  };
  return TextfieldEntry({
    element,
    id: "formRef",
    label: translate4("Form reference"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Binding$1(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const getValue = () => {
    return getFormRefBinding(element);
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRefBinding": value
    });
  };
  const getOptions = () => {
    const options = [{
      value: "deployment",
      label: translate4("deployment")
    }, {
      value: "latest",
      label: translate4("latest")
    }, {
      value: "version",
      label: translate4("version")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "formRefBinding",
    label: translate4("Binding"),
    getValue,
    setValue,
    getOptions
  });
}
function Version$1(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:formRefVersion");
  };
  const setValue = (value) => {
    modeling.updateProperties(element, {
      "camunda:formRefVersion": value
    });
  };
  return TextfieldEntry({
    element,
    id: "formRefVersion",
    label: translate4("Version"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function HistoryCleanupProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "historyTimeToLive",
    component: HistoryTimeToLive,
    isEdited
  }];
}
function HistoryTimeToLive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = getProcess$2(element);
  const getValue = () => {
    return process2.get("camunda:historyTimeToLive") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:historyTimeToLive": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "historyTimeToLive",
    label: translate4("Time to live"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getProcess$2(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function DmnImplementationProps(props) {
  const {
    element
  } = props;
  const entries = [];
  const implementationType = getImplementationType(element);
  const bindingType = getDecisionRefBinding(element);
  if (implementationType !== "dmn") {
    return entries;
  }
  entries.push({
    id: "decisionRef",
    component: DecisionRef,
    isEdited
  });
  entries.push({
    id: "decisionRefBinding",
    component: Binding,
    isEdited: isEdited$3
  });
  if (bindingType === "version") {
    entries.push({
      id: "decisionRefVersion",
      component: Version,
      isEdited
    });
  }
  if (bindingType === "versionTag") {
    entries.push({
      id: "decisionRefVersionTag",
      component: VersionTag$1,
      isEdited
    });
  }
  entries.push({
    id: "decisionRefTenantId",
    component: TenantId,
    isEdited
  });
  entries.push({
    id: "decisionRefResultVariable",
    component: ResultVariable$2,
    isEdited
  });
  if (getResultVariable2(element)) {
    entries.push({
      id: "mapDecisionResult",
      component: MapDecisionResult,
      isEdited: isEdited$3
    });
  }
  return entries;
}
function DecisionRef(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:decisionRef");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRef": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRef",
    label: translate4("Decision reference"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Binding(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getDecisionRefBinding(element);
  };
  const setValue = (value) => {
    const businessObject = getBusinessObject(element);
    const updatedProperties = {
      "camunda:decisionRefVersion": void 0,
      "camunda:decisionRefVersionTag": void 0,
      "camunda:decisionRefBinding": value
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: updatedProperties
    });
  };
  const getOptions = () => {
    const options = [{
      value: "deployment",
      label: translate4("deployment")
    }, {
      value: "latest",
      label: translate4("latest")
    }, {
      value: "version",
      label: translate4("version")
    }, {
      value: "versionTag",
      label: translate4("versionTag")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "decisionRefBinding",
    label: translate4("Binding"),
    getValue,
    setValue,
    getOptions
  });
}
function Version(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:decisionRefVersion");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefVersion": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefVersion",
    label: translate4("Version"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function VersionTag$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:decisionRefVersionTag");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefVersionTag": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefVersionTag",
    label: translate4("Version tag"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function TenantId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:decisionRefTenantId");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:decisionRefTenantId": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefTenantId",
    label: translate4("Tenant ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return getResultVariable2(businessObject);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "decisionRefResultVariable",
    label: translate4("Result variable"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function MapDecisionResult(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:mapDecisionResult") || "resultList";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:mapDecisionResult": value
      }
    });
  };
  const getOptions = () => {
    const options = [{
      value: "collectEntries",
      label: translate4("collectEntries (List<Object>)")
    }, {
      value: "resultList",
      label: translate4("resultList (List<Map<String, Object>>)")
    }, {
      value: "singleEntry",
      label: translate4("singleEntry (TypedValue)")
    }, {
      value: "singleResult",
      label: translate4("singleResult (Map<String, Object>)")
    }];
    return options;
  };
  return SelectEntry({
    element,
    id: "mapDecisionResult",
    label: translate4("Map decision result"),
    getValue,
    setValue,
    getOptions
  });
}
function getDecisionRefBinding(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:decisionRefBinding") || "latest";
}
function getResultVariable2(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("camunda:resultVariable");
}
var DELEGATE_PROPS = {
  "camunda:class": void 0,
  "camunda:expression": void 0,
  "camunda:delegateExpression": void 0,
  "camunda:resultVariable": void 0
};
var DMN_CAPABLE_PROPS = {
  "camunda:decisionRef": void 0,
  "camunda:decisionRefBinding": "latest",
  "camunda:decisionRefVersion": void 0,
  "camunda:mapDecisionResult": "resultList",
  "camunda:decisionRefTenantId": void 0
};
var EXTERNAL_CAPABLE_PROPS = {
  "camunda:type": void 0,
  "camunda:topic": void 0
};
var IMPLEMENTATION_TYPE_NONE_LABEL = "<none>";
var IMPLEMENTATION_TYPE_JAVA_LABEL = "Java class";
var IMPLEMENTATION_TYPE_EXPRESSION_LABEL = "Expression";
var IMPLEMENTATION_TYPE_DELEGATE_LABEL = "Delegate expression";
var IMPLEMENTATION_TYPE_DMN_LABEL = "DMN";
var IMPLEMENTATION_TYPE_EXTERNAL_LABEL = "External";
var IMPLEMENTATION_TYPE_CONNECTOR_LABEL = "Connector";
function ImplementationTypeProps(props) {
  return [{
    id: "implementationType",
    component: ImplementationType,
    isEdited: isEdited$3
  }];
}
function ImplementationType(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return getImplementationType(element) || "";
  };
  const setValue = (value) => {
    const oldType = getImplementationType(element);
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const commands = [];
    let updatedProperties = DELEGATE_PROPS;
    let extensionElements = businessObject.get("extensionElements");
    if (isDelegateType(value)) {
      updatedProperties = {
        ...updatedProperties,
        [value]: isDelegateType(oldType) ? businessObject.get(`camunda:${oldType}`) : ""
      };
    }
    if (isDmnCapable(businessObject)) {
      updatedProperties = {
        ...updatedProperties,
        ...DMN_CAPABLE_PROPS
      };
      if (value === "dmn") {
        updatedProperties = {
          ...updatedProperties,
          "camunda:decisionRef": ""
        };
      }
    }
    if (isExternalCapable(businessObject)) {
      updatedProperties = {
        ...updatedProperties,
        ...EXTERNAL_CAPABLE_PROPS
      };
      if (value === "external") {
        updatedProperties = {
          ...updatedProperties,
          "camunda:type": "external",
          "camunda:topic": ""
        };
      }
    }
    if (isServiceTaskLike(businessObject)) {
      const connectors = getConnectors$1(businessObject);
      if (connectors.length) {
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: without(extensionElements.get("values"), (value2) => connectors.includes(value2))
            }
          }
        });
      }
      if (value === "connector") {
        if (!extensionElements) {
          extensionElements = createElement("bpmn:ExtensionElements", {
            values: []
          }, businessObject, bpmnFactory);
          commands.push(UpdateModdlePropertiesCommand(element, businessObject, {
            extensionElements
          }));
        }
        const connector = createElement("camunda:Connector", {}, extensionElements, bpmnFactory);
        commands.push({
          cmd: "element.updateModdleProperties",
          context: {
            element,
            moddleElement: extensionElements,
            properties: {
              values: [...extensionElements.get("values"), connector]
            }
          }
        });
      }
    }
    commands.push(UpdateModdlePropertiesCommand(element, businessObject, updatedProperties));
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  const getOptions = () => {
    const businessObject = getServiceTaskLikeBusinessObject(element);
    const options = [{
      value: "",
      label: translate4(IMPLEMENTATION_TYPE_NONE_LABEL)
    }, {
      value: "class",
      label: translate4(IMPLEMENTATION_TYPE_JAVA_LABEL)
    }, {
      value: "expression",
      label: translate4(IMPLEMENTATION_TYPE_EXPRESSION_LABEL)
    }, {
      value: "delegateExpression",
      label: translate4(IMPLEMENTATION_TYPE_DELEGATE_LABEL)
    }];
    if (isDmnCapable(businessObject)) {
      options.push({
        value: "dmn",
        label: translate4(IMPLEMENTATION_TYPE_DMN_LABEL)
      });
    }
    if (isExternalCapable(businessObject)) {
      options.push({
        value: "external",
        label: translate4(IMPLEMENTATION_TYPE_EXTERNAL_LABEL)
      });
    }
    if (isServiceTaskLike(businessObject)) {
      options.push({
        value: "connector",
        label: translate4(IMPLEMENTATION_TYPE_CONNECTOR_LABEL)
      });
    }
    return sortByPriority(options);
  };
  return SelectEntry({
    element,
    id: "implementationType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function isDelegateType(type) {
  return ["class", "expression", "delegateExpression"].includes(type);
}
function getConnectors$1(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function UpdateModdlePropertiesCommand(element, businessObject, newProperties) {
  return {
    cmd: "element.updateModdleProperties",
    context: {
      element,
      moddleElement: businessObject,
      properties: newProperties
    }
  };
}
function sortByPriority(options) {
  const priorities = {
    [IMPLEMENTATION_TYPE_NONE_LABEL]: 0,
    [IMPLEMENTATION_TYPE_JAVA_LABEL]: 3,
    [IMPLEMENTATION_TYPE_EXPRESSION_LABEL]: 4,
    [IMPLEMENTATION_TYPE_DELEGATE_LABEL]: 5,
    [IMPLEMENTATION_TYPE_DMN_LABEL]: 1,
    [IMPLEMENTATION_TYPE_EXTERNAL_LABEL]: 2,
    [IMPLEMENTATION_TYPE_CONNECTOR_LABEL]: 6
  };
  return sortBy(options, (o5) => priorities[o5.label]);
}
function ImplementationProps(props) {
  const {
    element
  } = props;
  if (!getServiceTaskLikeBusinessObject(element)) {
    return [];
  }
  const implementationType = getImplementationType(element);
  const entries = [...ImplementationTypeProps()];
  if (implementationType === "class") {
    entries.push({
      id: "javaClass",
      component: JavaClass,
      isEdited
    });
  } else if (implementationType === "expression") {
    entries.push({
      id: "expression",
      component: Expression,
      isEdited
    }, {
      id: "expressionResultVariable",
      component: ResultVariable$1,
      isEdited
    });
  } else if (implementationType === "delegateExpression") {
    entries.push({
      id: "delegateExpression",
      component: DelegateExpression,
      isEdited
    });
  } else if (implementationType === "dmn") {
    entries.push(...DmnImplementationProps({
      element
    }));
  } else if (implementationType === "external") {
    entries.push({
      id: "externalTopic",
      component: Topic,
      isEdited
    });
  } else if (implementationType === "connector") {
    entries.push({
      id: "connectorId",
      component: ConnectorId,
      isEdited
    });
  }
  return entries;
}
function JavaClass(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id = "javaClass"
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return businessObject.get("camunda:class");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:class": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id,
    label: translate4("Java class"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Expression(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id = "expression"
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return businessObject.get("camunda:expression");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:expression": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id,
    label: translate4("Expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ResultVariable$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:resultVariable");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "expressionResultVariable",
    label: translate4("Result variable"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function DelegateExpression(props) {
  const {
    element,
    businessObject = getServiceTaskLikeBusinessObject(element),
    id = "delegateExpression"
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const getValue = () => {
    return businessObject.get("camunda:delegateExpression");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:delegateExpression": value || ""
      }
    });
  };
  return TextfieldEntry({
    element,
    id,
    label: translate4("Delegate expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Topic(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:topic");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:topic": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "externalTopic",
    label: translate4("Topic"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ConnectorId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const connector = getConnector(element);
  const getValue = () => {
    return connector.get("camunda:connectorId");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: connector,
      properties: {
        "camunda:connectorId": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "connectorId",
    label: translate4("Connector ID"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getConnectors(businessObject) {
  return getExtensionElementsList(businessObject, "camunda:Connector");
}
function getConnector(element) {
  const businessObject = getServiceTaskLikeBusinessObject(element);
  const connectors = getConnectors(businessObject);
  return connectors[0];
}
function InitiatorProps(props) {
  const {
    element
  } = props;
  if (!isInitiator(element)) {
    return [];
  }
  return [{
    id: "initiator",
    component: Initiator,
    isEdited
  }];
}
function Initiator(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:initiator");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:initiator": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "initiator",
    label: translate4("Initiator"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function isInitiator(element) {
  return is(element, "camunda:Initiator") && !is(element.parent, "bpmn:SubProcess");
}
function InMappingPropagationProps(props) {
  const {
    element
  } = props;
  if (!areInMappingsSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "inMapping-propagation",
    component: PropagateAll$1,
    isEdited: isEdited$5
  }];
  if (isPropagateAll$1(element)) {
    entries.push({
      id: "inMapping-propagation-local",
      component: Local$2,
      isEdited: isEdited$5
    });
  }
  return entries;
}
function PropagateAll$1(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    return isPropagateAll$1(element);
  };
  const setValue = (value) => {
    if (value) {
      addInMapping();
    } else {
      removeInMapping();
    }
  };
  function addInMapping() {
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    const mapping = createElement("camunda:In", {
      variables: "all"
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, mapping, bpmnFactory, commandStack);
  }
  function removeInMapping() {
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    const mappings = findRelevantInMappings(element);
    removeExtensionElements(element, businessObject, mappings, commandStack);
  }
  return CheckboxEntry({
    id: "inMapping-propagation",
    label: translate4("Propagate all variables"),
    getValue,
    setValue
  });
}
function Local$2(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const mapping = findRelevantInMappings(element)[0];
  const getValue = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "inMapping-propagation-local",
    label: translate4("Local"),
    getValue,
    setValue
  });
}
function areInMappingsSupported$1(element) {
  const signalEventDefinition = getSignalEventDefinition$1(element);
  if (signalEventDefinition) {
    return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:EndEvent"]);
  }
  return is(element, "bpmn:CallActivity");
}
function getInMappings$1(element) {
  const businessObject = getBusinessObject(element);
  const signalEventDefinition = getSignalEventDefinition$1(businessObject);
  return getExtensionElementsList(signalEventDefinition || businessObject, "camunda:In");
}
function findRelevantInMappings(element) {
  const inMappings = getInMappings$1(element);
  return filter(inMappings, function(mapping) {
    const variables = mapping.get("variables");
    return variables && variables === "all";
  });
}
function isPropagateAll$1(element) {
  const mappings = findRelevantInMappings(element);
  return !!mappings.length;
}
var DEFAULT_PROPS$1 = {
  "source": void 0,
  "sourceExpression": void 0
};
function InOutMapping(props) {
  const {
    idPrefix,
    mapping
  } = props;
  const type = getInOutType(mapping);
  const entries = [];
  entries.push({
    id: idPrefix + "-type",
    component: Type2,
    idPrefix,
    mapping
  });
  if (type === "source") {
    entries.push({
      id: idPrefix + "-source",
      component: Source,
      idPrefix,
      mapping
    });
  }
  if (type === "sourceExpression") {
    entries.push({
      id: idPrefix + "-sourceExpression",
      component: SourceExpression,
      idPrefix,
      mapping
    });
  }
  entries.push({
    id: idPrefix + "-target",
    component: Target,
    idPrefix,
    mapping
  });
  entries.push({
    id: idPrefix + "-local",
    component: Local$1,
    idPrefix,
    mapping
  });
  return entries;
}
function Type2(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = (mapping2) => {
    return getInOutType(mapping2);
  };
  const setValue = (value) => {
    const properties = {
      ...DEFAULT_PROPS$1,
      [value]: ""
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties
    });
  };
  const getOptions = () => {
    const options = [{
      label: translate4("Source"),
      value: "source"
    }, {
      label: translate4("Source expression"),
      value: "sourceExpression"
    }];
    return options;
  };
  return SelectEntry({
    element: mapping,
    id: idPrefix + "-type",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function Source(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        source: value
      }
    });
  };
  const getValue = (mapping2) => {
    return mapping2.get("camunda:source");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-source",
    label: translate4("Source"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function SourceExpression(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        sourceExpression: value
      }
    });
  };
  const getValue = (mapping2) => {
    return mapping2.get("camunda:sourceExpression");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-sourceExpression",
    label: translate4("Source expression"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Target(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        target: value
      }
    });
  };
  const getValue = (mapping2) => {
    return mapping2.get("camunda:target");
  };
  return TextfieldEntry({
    element: mapping,
    id: idPrefix + "-target",
    label: translate4("Target"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Local$1(props) {
  const {
    idPrefix,
    element,
    mapping
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const getValue = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: idPrefix + "-local",
    label: translate4("Local"),
    getValue,
    setValue
  });
}
function getInOutType(mapping) {
  let inOutType = "";
  if (typeof mapping.source !== "undefined") {
    inOutType = "source";
  } else if (typeof mapping.sourceExpression !== "undefined") {
    inOutType = "sourceExpression";
  }
  return inOutType;
}
function InMappingProps({
  element,
  injector
}) {
  if (!areInMappingsSupported(element)) {
    return null;
  }
  const variableMappings = getInMappings2(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = variableMappings.map((mapping, index5) => {
    const id = element.id + "-inMapping-" + index5;
    return {
      id,
      label: mapping.get("target") || "",
      entries: InOutMapping({
        idPrefix: id,
        element,
        mapping
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$3({
        commandStack,
        element,
        mapping
      })
    };
  });
  return {
    items,
    add: addFactory$2({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$3({
  commandStack,
  element,
  mapping
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    removeExtensionElements(element, businessObject, mapping, commandStack);
  };
}
function addFactory$2({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getSignalEventDefinition$1(element) || getBusinessObject(element);
    const newMapping = createElement("camunda:In", {
      source: ""
      // source is the default type
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, newMapping, bpmnFactory, commandStack);
  };
}
function getInMappings2(element) {
  const businessObject = getBusinessObject(element);
  const signalEventDefinition = getSignalEventDefinition$1(businessObject);
  const mappings = getExtensionElementsList(signalEventDefinition || businessObject, "camunda:In");
  return filter(mappings, function(mapping) {
    return !mapping.businessKey && !(mapping.variables && mapping.variables === "all");
  });
}
function areInMappingsSupported(element) {
  const signalEventDefinition = getSignalEventDefinition$1(element);
  if (signalEventDefinition) {
    return isAny(element, ["bpmn:IntermediateThrowEvent", "bpmn:EndEvent"]);
  }
  return is(element, "bpmn:CallActivity");
}
function InputProps(props) {
  const {
    element,
    injector
  } = props;
  if (!areInputParametersSupported(element)) {
    return null;
  }
  const inputParameters = getInputParameters3(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = inputParameters.map((parameter, index5) => {
    const id = element.id + "-inputParameter-" + index5;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory$2({
        element,
        commandStack,
        parameter
      })
    };
  });
  function add5(event2) {
    event2.stopPropagation();
    commandStack.execute("properties-panel.multi-command-executor", AddParameterCmd(element, "camunda:InputParameter", bpmnFactory));
  }
  return {
    items,
    add: add5
  };
}
function removeFactory$2(props) {
  const {
    commandStack,
    element,
    parameter
  } = props;
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(element);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        inputParameters: without(inputOutput.get("inputParameters"), parameter)
      }
    });
  };
}
function JobExecutionProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  const entries = [];
  if (is(element, "camunda:AsyncCapable") && isAsync$1(businessObject) || isTimerEvent(element)) {
    entries.push({
      id: "retryTimeCycle",
      component: RetryTimeCycle,
      isEdited
    });
  }
  if (is(element, "camunda:JobPriorized") && isAsync$1(businessObject) || is(element, "bpmn:Process") || is(element, "bpmn:Participant") && businessObject.get("processRef") || isTimerEvent(element)) {
    entries.push({
      id: "jobPriority",
      component: JobPriority,
      isEdited
    });
  }
  return entries;
}
function JobPriority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const businessObject = is(element, "bpmn:Participant") ? getBusinessObject(element).get("processRef") : getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:jobPriority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:jobPriority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "jobPriority",
    label: translate4("Priority"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function RetryTimeCycle(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    const failedJobRetryTimeCycle = getExtensionElementsList(businessObject, "camunda:FailedJobRetryTimeCycle")[0];
    return failedJobRetryTimeCycle && failedJobRetryTimeCycle.body;
  };
  const setValue = (value) => {
    const commands = [];
    let extensionElements = businessObject.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, businessObject, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: businessObject,
          properties: {
            extensionElements
          }
        }
      });
    }
    let failedJobRetryTimeCycle = getExtensionElementsList(businessObject, "camunda:FailedJobRetryTimeCycle")[0];
    if (!failedJobRetryTimeCycle) {
      failedJobRetryTimeCycle = createElement("camunda:FailedJobRetryTimeCycle", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), failedJobRetryTimeCycle]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: failedJobRetryTimeCycle,
        properties: {
          body: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "retryTimeCycle",
    label: translate4("Retry time cycle"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function isAsyncBefore$1(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter$1(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isAsync$1(bo) {
  return isAsyncAfter$1(bo) || isAsyncBefore$1(bo);
}
function isTimerEvent(element) {
  return is(element, "bpmn:Event") && getTimerEventDefinition$1(element);
}
function MultiInstanceProps(props) {
  const {
    element
  } = props;
  const loopCharacteristics = getLoopCharacteristics(element);
  let entries = props.entries || [];
  if (!isMultiInstanceSupported(element)) {
    return entries;
  }
  entries.push({
    id: "collection",
    component: Collection,
    isEdited
  }, {
    id: "elementVariable",
    component: ElementVariable,
    isEdited
  }, {
    id: "multiInstanceAsynchronousBefore",
    component: MultiInstanceAsynchronousBefore,
    isEdited: isEdited$5
  }, {
    id: "multiInstanceAsynchronousAfter",
    component: MultiInstanceAsynchronousAfter,
    isEdited: isEdited$5
  });
  if (isAsync(loopCharacteristics)) {
    entries.push({
      id: "multiInstanceExclusive",
      component: MultiInstanceExclusive,
      isEdited: checkboxIsEditedInverted
    }, {
      id: "multiInstanceRetryTimeCycle",
      component: MultiInstanceRetryTimeCycle,
      isEdited
    });
  }
  return entries;
}
function Collection(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue = () => {
    return getCollection(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:collection": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "collection",
    label: translate4("Collection"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function ElementVariable(props) {
  const {
    element
  } = props;
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue = () => {
    return getElementVariable(element);
  };
  const setValue = (value) => {
    return commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:elementVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "elementVariable",
    label: translate4("Element variable"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function MultiInstanceAsynchronousBefore(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue = () => {
    return isAsyncBefore(loopCharacteristics);
  };
  const setValue = (value) => {
    const properties = {
      "camunda:asyncBefore": value,
      "camunda:async": void 0
    };
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceAsynchronousBefore",
    label: translate4("Asynchronous before"),
    getValue,
    setValue
  });
}
function MultiInstanceAsynchronousAfter(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue = () => {
    return isAsyncAfter(loopCharacteristics);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:asyncAfter": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceAsynchronousAfter",
    label: translate4("Asynchronous after"),
    getValue,
    setValue
  });
}
function MultiInstanceExclusive(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue = () => {
    return isExclusive(loopCharacteristics);
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: loopCharacteristics,
      properties: {
        "camunda:exclusive": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "multiInstanceExclusive",
    label: translate4("Exclusive"),
    getValue,
    setValue
  });
}
function MultiInstanceRetryTimeCycle(props) {
  const {
    element
  } = props;
  const bpmnFactory = useService("bpmnFactory"), commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const loopCharacteristics = getLoopCharacteristics(element);
  const getValue = () => {
    const failedJobRetryTimeCycle = getExtensionElementsList(loopCharacteristics, "camunda:FailedJobRetryTimeCycle")[0];
    return failedJobRetryTimeCycle && failedJobRetryTimeCycle.body;
  };
  const setValue = (value) => {
    const commands = [];
    let extensionElements = loopCharacteristics.get("extensionElements");
    if (!extensionElements) {
      extensionElements = createElement("bpmn:ExtensionElements", {
        values: []
      }, loopCharacteristics, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element,
          moddleElement: loopCharacteristics,
          properties: {
            extensionElements
          }
        }
      });
    }
    let failedJobRetryTimeCycle = getExtensionElementsList(loopCharacteristics, "camunda:FailedJobRetryTimeCycle")[0];
    if (!failedJobRetryTimeCycle) {
      failedJobRetryTimeCycle = createElement("camunda:FailedJobRetryTimeCycle", {}, extensionElements, bpmnFactory);
      commands.push({
        cmd: "element.updateModdleProperties",
        context: {
          element: loopCharacteristics,
          moddleElement: extensionElements,
          properties: {
            values: [...extensionElements.get("values"), failedJobRetryTimeCycle]
          }
        }
      });
    }
    commands.push({
      cmd: "element.updateModdleProperties",
      context: {
        element,
        moddleElement: failedJobRetryTimeCycle,
        properties: {
          body: value
        }
      }
    });
    commandStack.execute("properties-panel.multi-command-executor", commands);
  };
  return TextfieldEntry({
    element,
    id: "multiInstanceRetryTimeCycle",
    label: translate4("Retry time cycle"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function isMultiInstanceSupported(element) {
  const loopCharacteristics = getLoopCharacteristics(element);
  return !!loopCharacteristics && is(loopCharacteristics, "camunda:Collectable");
}
function getProperty(element, propertyName) {
  var loopCharacteristics = getLoopCharacteristics(element);
  return loopCharacteristics && loopCharacteristics.get(propertyName);
}
function getLoopCharacteristics(element) {
  const bo = getBusinessObject(element);
  return bo.loopCharacteristics;
}
function getCollection(element) {
  return getProperty(element, "camunda:collection");
}
function getElementVariable(element) {
  return getProperty(element, "camunda:elementVariable");
}
function isAsyncBefore(bo) {
  return !!(bo.get("camunda:asyncBefore") || bo.get("camunda:async"));
}
function isAsyncAfter(bo) {
  return !!bo.get("camunda:asyncAfter");
}
function isExclusive(bo) {
  return !!bo.get("camunda:exclusive");
}
function isAsync(bo) {
  return isAsyncAfter(bo) || isAsyncBefore(bo);
}
function checkboxIsEditedInverted(node2) {
  return node2 && !node2.checked;
}
function OutMappingPropagationProps(props) {
  const {
    element
  } = props;
  if (!areOutMappingsSupported$1(element)) {
    return [];
  }
  const entries = [{
    id: "outMapping-propagation",
    component: PropagateAll,
    isEdited: isEdited$5
  }];
  if (isPropagateAll(element)) {
    entries.push({
      id: "outMapping-propagation-local",
      component: Local,
      isEdited: isEdited$5
    });
  }
  return entries;
}
function PropagateAll(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const bpmnFactory = useService("bpmnFactory");
  const translate4 = useService("translate");
  const getValue = () => {
    return isPropagateAll(element);
  };
  const setValue = (value) => {
    if (value) {
      addOutMapping();
    } else {
      removeOutMapping();
    }
  };
  function addOutMapping() {
    const businessObject = getBusinessObject(element);
    const mapping = createElement("camunda:Out", {
      variables: "all"
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, mapping, bpmnFactory, commandStack);
  }
  function removeOutMapping() {
    const businessObject = getBusinessObject(element);
    const mappings = findRelevantOutMappings(element);
    removeExtensionElements(element, businessObject, mappings, commandStack);
  }
  return CheckboxEntry({
    id: "outMapping-propagation",
    label: translate4("Propagate all variables"),
    getValue,
    setValue
  });
}
function Local(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const mapping = findRelevantOutMappings(element)[0];
  const getValue = () => {
    return mapping.get("camunda:local");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: mapping,
      properties: {
        local: value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "outMapping-propagation-local",
    label: translate4("Local"),
    getValue,
    setValue
  });
}
function areOutMappingsSupported$1(element) {
  return is(element, "bpmn:CallActivity");
}
function getOutMappings$1(element) {
  const businessObject = getBusinessObject(element);
  return getExtensionElementsList(businessObject, "camunda:Out");
}
function findRelevantOutMappings(element) {
  const inMappings = getOutMappings$1(element);
  return filter(inMappings, function(mapping) {
    const variables = mapping.get("variables");
    return variables && variables === "all";
  });
}
function isPropagateAll(element) {
  const mappings = findRelevantOutMappings(element);
  return !!mappings.length;
}
function OutMappingProps({
  element,
  injector
}) {
  if (!areOutMappingsSupported(element)) {
    return null;
  }
  const variableMappings = getOutMappings3(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = variableMappings.map((mapping, index5) => {
    const id = element.id + "-outMapping-" + index5;
    return {
      id,
      label: mapping.get("target") || "",
      entries: InOutMapping({
        idPrefix: id,
        element,
        mapping
      }),
      autoFocusEntry: id + "-target",
      remove: removeFactory$1({
        commandStack,
        element,
        mapping
      })
    };
  });
  return {
    items,
    add: addFactory$1({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory$1({
  commandStack,
  element,
  mapping
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    removeExtensionElements(element, businessObject, mapping, commandStack);
  };
}
function addFactory$1({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    const businessObject = getBusinessObject(element);
    const newMapping = createElement("camunda:Out", {
      source: ""
      // source is the default type
    }, null, bpmnFactory);
    addExtensionElements(element, businessObject, newMapping, bpmnFactory, commandStack);
  };
}
function getOutMappings3(element) {
  const businessObject = getBusinessObject(element);
  const mappings = getExtensionElementsList(businessObject, "camunda:Out");
  return filter(mappings, function(mapping) {
    return !mapping.businessKey && !(mapping.variables && mapping.variables === "all");
  });
}
function areOutMappingsSupported(element) {
  return is(element, "bpmn:CallActivity");
}
function OutputProps({
  element,
  injector
}) {
  if (!areOutputParametersSupported(element)) {
    return null;
  }
  const outputParameters = getOutputParameters2(element) || [];
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const items = outputParameters.map((parameter, index5) => {
    const id = element.id + "-outputParameter-" + index5;
    return {
      id,
      label: parameter.get("name") || "",
      entries: InputOutputParameter({
        idPrefix: id,
        element,
        parameter
      }),
      autoFocusEntry: id + "-name",
      remove: removeFactory({
        commandStack,
        element,
        parameter
      })
    };
  });
  return {
    items,
    add: addFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function removeFactory({
  commandStack,
  element,
  parameter
}) {
  return function(event2) {
    event2.stopPropagation();
    const inputOutput = getInputOutput3(element);
    if (!inputOutput) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: inputOutput,
      properties: {
        outputParameters: without(inputOutput.get("outputParameters"), parameter)
      }
    });
  };
}
function addFactory({
  bpmnFactory,
  commandStack,
  element
}) {
  return function(event2) {
    event2.stopPropagation();
    commandStack.execute("properties-panel.multi-command-executor", AddParameterCmd(element, "camunda:OutputParameter", bpmnFactory));
  };
}
function TimerProps(props) {
  const {
    element,
    listener,
    idPrefix
  } = props;
  let {
    timerEventDefinition
  } = props;
  if (!timerEventDefinition) {
    const businessObject = getBusinessObject(element);
    timerEventDefinition = getTimerEventDefinition(businessObject);
  }
  const timerEventDefinitionType = getTimerDefinitionType(timerEventDefinition);
  if (!isTimerSupported(element) && !isTimerSupportedOnListener(listener)) {
    return [];
  }
  const entries = [];
  entries.push({
    id: getId(idPrefix, "timerEventDefinitionType"),
    component: TimerEventDefinitionType,
    isEdited: isEdited$3,
    timerEventDefinition,
    timerEventDefinitionType
  });
  if (timerEventDefinitionType) {
    entries.push({
      id: getId(idPrefix, "timerEventDefinitionValue"),
      component: TimerEventDefinitionValue,
      isEdited,
      timerEventDefinition,
      timerEventDefinitionType
    });
  }
  return entries;
}
function TimerEventDefinitionType(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), bpmnFactory = useService("bpmnFactory"), translate4 = useService("translate");
  const getValue = () => {
    return timerEventDefinitionType || "";
  };
  const setValue = (value) => {
    if (value === timerEventDefinitionType) {
      return;
    }
    const formalExpression = bpmnFactory.create("bpmn:FormalExpression", {
      body: void 0
    });
    formalExpression.$parent = timerEventDefinition;
    const newProps = {
      timeDuration: void 0,
      timeDate: void 0,
      timeCycle: void 0
    };
    if (value !== "") {
      newProps[value] = formalExpression;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventDefinition,
      properties: newProps
    });
  };
  const getOptions = (element2) => {
    return [{
      value: "",
      label: translate4("<none>")
    }, {
      value: "timeDate",
      label: translate4("Date")
    }, {
      value: "timeDuration",
      label: translate4("Duration")
    }, {
      value: "timeCycle",
      label: translate4("Cycle")
    }];
  };
  return SelectEntry({
    element,
    id: "timerEventDefinitionType",
    label: translate4("Type"),
    getValue,
    setValue,
    getOptions
  });
}
function TimerEventDefinitionValue(props) {
  const {
    element,
    timerEventDefinition,
    timerEventDefinitionType
  } = props;
  const commandStack = useService("commandStack"), translate4 = useService("translate"), debounce2 = useService("debounceInput");
  const timerEventFormalExpression = timerEventDefinition.get(timerEventDefinitionType);
  const getValue = () => {
    return timerEventFormalExpression && timerEventFormalExpression.get("body");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: timerEventFormalExpression,
      properties: {
        body: value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "timerEventDefinitionValue",
    label: translate4("Value"),
    getValue,
    setValue,
    debounce: debounce2,
    tooltip: getTimerEventDefinitionValueDescription(timerEventDefinitionType, translate4)
  });
}
function getTimerEventDefinitionValueDescription(timerDefinitionType, translate4) {
  switch (timerDefinitionType) {
    case "timeDate":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A specific point in time defined as ISO 8601 combined date and time representation.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "2019-10-01T12:00:00Z"
            }), " - ", translate4("UTC time")]
          }), u5("li", {
            children: [u5("code", {
              children: "2019-10-02T08:09:40+02:00"
            }), " - ", translate4("UTC plus 2 hours zone offset")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-date",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate4("Documentation: Timer events")
        })]
      });
    case "timeCycle":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A cycle defined as ISO 8601 repeating intervals format, or a cron expression.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "R5/PT10S"
            }), " - ", translate4("every 10 seconds, up to 5 times")]
          }), u5("li", {
            children: [u5("code", {
              children: "R/P1D"
            }), " - ", translate4("every day, infinitely")]
          }), u5("li", {
            children: [u5("code", {
              children: "0 0 9-17 * * MON-FRI"
            }), " - ", translate4("every hour on the hour from 9-5 p.m. UTC Monday-Friday")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-cycle",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate4("Documentation: Timer events")
        })]
      });
    case "timeDuration":
      return u5("div", {
        children: [u5("p", {
          children: translate4("A time duration defined as ISO 8601 durations format.")
        }), u5("ul", {
          children: [u5("li", {
            children: [u5("code", {
              children: "PT15S"
            }), " - ", translate4("15 seconds")]
          }), u5("li", {
            children: [u5("code", {
              children: "PT1H30M"
            }), " - ", translate4("1 hour and 30 minutes")]
          }), u5("li", {
            children: [u5("code", {
              children: "P14D"
            }), " - ", translate4("14 days")]
          })]
        }), u5("a", {
          href: "https://docs.camunda.org/manual/latest/reference/bpmn20/events/timer-events/#time-duration",
          target: "_blank",
          rel: "noopener noreferrer",
          children: translate4("Documentation: Timer events")
        })]
      });
  }
}
function isTimerSupportedOnListener(listener) {
  return listener && is(listener, "camunda:TaskListener") && getTimerEventDefinition(listener);
}
function getId(idPrefix, id) {
  return idPrefix ? idPrefix + id : id;
}
var LISTENER_ALLOWED_TYPES = ["bpmn:Activity", "bpmn:Event", "bpmn:Gateway", "bpmn:SequenceFlow", "bpmn:Process", "bpmn:Participant"];
var SCRIPT_PROPS = {
  "script": void 0,
  "resource": void 0,
  "scriptFormat": void 0
};
var CLASS_PROPS = {
  "class": void 0
};
var EXPRESSION_PROPS = {
  "expression": void 0
};
var DELEGATE_EXPRESSION_PROPS = {
  "delegateExpression": void 0
};
var DEFAULT_PROPS = {
  ...SCRIPT_PROPS,
  ...CLASS_PROPS,
  ...EXPRESSION_PROPS,
  ...DELEGATE_EXPRESSION_PROPS
};
var DEFAULT_EVENT_PROPS = {
  "eventDefinitions": void 0,
  "event": void 0
};
var IMPLEMENTATION_TYPE_TO_LABEL = {
  class: "Java class",
  expression: "Expression",
  delegateExpression: "Delegate expression",
  script: "Script"
};
var EVENT_TO_LABEL = {
  start: "Start",
  end: "End",
  take: "Take",
  create: "Create",
  assignment: "Assignment",
  complete: "Complete",
  delete: "Delete",
  update: "Update",
  timeout: "Timeout"
};
function ExecutionListenerProps({
  element,
  injector
}) {
  if (!isAny(element, LISTENER_ALLOWED_TYPES)) {
    return;
  }
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  if (is(element, "bpmn:Participant") && !element.businessObject.processRef) {
    return;
  }
  const businessObject = getListenersContainer(element);
  const listeners = getExtensionElementsList(businessObject, "camunda:ExecutionListener");
  return {
    items: listeners.map((listener, index5) => {
      const id = `${element.id}-executionListener-${index5}`;
      return {
        id,
        label: getListenerLabel(listener),
        entries: ExecutionListener({
          idPrefix: id,
          element,
          listener
        }),
        autoFocusEntry: id + "-javaClass",
        remove: removeListenerFactory({
          element,
          listener,
          commandStack
        })
      };
    }),
    add: addExecutionListenerFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function ExecutionListener(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  return [{
    id: `${idPrefix}-eventType`,
    component: EventType,
    listener
  }, {
    id: `${idPrefix}-listenerType`,
    component: ListenerType,
    listener
  }, ...ImplementationDetails({
    idPrefix,
    element,
    listener
  }), {
    id: `${idPrefix}-fields`,
    component: Fields,
    listener
  }];
}
function TaskListenerProps({
  element,
  injector
}) {
  if (!is(element, "bpmn:UserTask")) {
    return;
  }
  const bpmnFactory = injector.get("bpmnFactory"), commandStack = injector.get("commandStack");
  const businessObject = getListenersContainer(element);
  const listeners = getExtensionElementsList(businessObject, "camunda:TaskListener");
  return {
    items: listeners.map((listener, index5) => {
      const id = `${element.id}-taskListener-${index5}`;
      return {
        id,
        label: getListenerLabel(listener),
        entries: TaskListener({
          idPrefix: id,
          element,
          listener
        }),
        autoFocusEntry: id + "-listenerId",
        remove: removeListenerFactory({
          element,
          listener,
          commandStack
        })
      };
    }),
    add: addTaskListenerFactory({
      bpmnFactory,
      commandStack,
      element
    })
  };
}
function TaskListener(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  return [{
    id: `${idPrefix}-eventType`,
    component: EventType,
    listener
  }, {
    id: `${idPrefix}-listenerId`,
    component: ListenerId,
    listener
  }, {
    id: `${idPrefix}-listenerType`,
    component: ListenerType,
    listener
  }, ...ImplementationDetails({
    idPrefix,
    element,
    listener
  }), ...EventTypeDetails({
    idPrefix,
    element,
    listener
  }), {
    id: `${idPrefix}-fields`,
    component: Fields,
    listener
  }];
}
function removeListenerFactory({
  element,
  listener,
  commandStack
}) {
  return function removeListener(event2) {
    event2.stopPropagation();
    removeExtensionElements(element, getListenersContainer(element), listener, commandStack);
  };
}
function EventType({
  id,
  element,
  listener
}) {
  const translate4 = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  function getValue() {
    return listener.get("event");
  }
  function setValue(value) {
    const properties = getDefaultEventTypeProperties(value, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties
    });
  }
  function getOptions() {
    if (is(listener, "camunda:TaskListener")) {
      return [{
        value: "create",
        label: translate4("create")
      }, {
        value: "assignment",
        label: translate4("assignment")
      }, {
        value: "complete",
        label: translate4("complete")
      }, {
        value: "delete",
        label: translate4("delete")
      }, {
        value: "update",
        label: translate4("update")
      }, {
        value: "timeout",
        label: translate4("timeout")
      }];
    }
    if (is(element, "bpmn:SequenceFlow")) {
      return [{
        value: "take",
        label: translate4("take")
      }];
    }
    return [{
      value: "start",
      label: translate4("start")
    }, {
      value: "end",
      label: translate4("end")
    }];
  }
  return u5(SelectEntry, {
    id,
    label: translate4("Event type"),
    getValue,
    setValue,
    getOptions
  });
}
function ListenerId({
  id,
  element,
  listener
}) {
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const commandStack = useService("commandStack");
  let options = {
    element,
    id,
    label: translate4("Listener ID"),
    debounce: debounce2,
    isEdited,
    setValue: (value) => {
      commandStack.execute("element.updateModdleProperties", {
        element,
        moddleElement: listener,
        properties: {
          "camunda:id": value
        }
      });
    },
    getValue: () => {
      return listener.get("camunda:id");
    }
  };
  return TextfieldEntry(options);
}
function ListenerType({
  id,
  element,
  listener
}) {
  const modeling = useService("modeling");
  const translate4 = useService("translate");
  const bpmnFactory = useService("bpmnFactory");
  function getValue() {
    return getListenerType(listener);
  }
  function setValue(value) {
    const properties = getDefaultImplementationProperties(value, bpmnFactory);
    modeling.updateModdleProperties(element, listener, properties);
  }
  function getOptions() {
    return getListenerTypeOptions(translate4);
  }
  return u5(SelectEntry, {
    id,
    label: translate4("Listener type"),
    getValue,
    setValue,
    getOptions
  });
}
function ImplementationDetails(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const type = getListenerType(listener);
  if (type === "class") {
    return [{
      id: getPrefixedId(idPrefix, "javaClass"),
      component: JavaClass,
      businessObject: listener
    }];
  } else if (type === "expression") {
    return [{
      id: getPrefixedId(idPrefix, "expression"),
      component: Expression,
      businessObject: listener
    }];
  } else if (type === "delegateExpression") {
    return [{
      id: getPrefixedId(idPrefix, "delegateExpression"),
      component: DelegateExpression,
      businessObject: listener
    }];
  } else if (type === "script") {
    return ScriptProps({
      element,
      script: listener.get("script"),
      prefix: idPrefix
    });
  }
  return [];
}
function EventTypeDetails(props) {
  const {
    idPrefix,
    element,
    listener
  } = props;
  const type = listener.get("event");
  if (type === "timeout") {
    return TimerProps({
      element,
      listener,
      timerEventDefinition: getTimerEventDefinition$1(listener),
      idPrefix
    });
  }
  return [];
}
function Field(props) {
  const {
    element,
    id: idPrefix,
    index: index5,
    item: field,
    open: open3
  } = props;
  const fieldId = `${idPrefix}-field-${index5}`;
  return u5(CollapsibleEntry, {
    id: fieldId,
    element,
    entries: FieldInjection({
      element,
      field,
      idPrefix: fieldId
    }),
    label: field.get("name") || "<empty>",
    open: open3
  });
}
function Fields(props) {
  const {
    id,
    element,
    listener
  } = props;
  const bpmnFactory = useService("bpmnFactory");
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const fields = listener.get("fields");
  function addField() {
    const field = createElement("camunda:Field", {}, listener, bpmnFactory);
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties: {
        fields: [...listener.get("fields"), field]
      }
    });
  }
  function removeField(field) {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: listener,
      properties: {
        fields: without(listener.get("fields"), field)
      }
    });
  }
  return u5(List2, {
    id,
    element,
    label: translate4("Field injection"),
    items: fields,
    component: Field,
    onAdd: addField,
    onRemove: removeField,
    autoFocusEntry: `[data-entry-id="${id}-field-${fields.length - 1}"] input`
  });
}
function addListenerFactory({
  bpmnFactory,
  commandStack,
  element,
  listenerGroup
}) {
  return function(event2) {
    event2.stopPropagation();
    const listener = bpmnFactory.create(listenerGroup, {
      event: getDefaultEvent(element, listenerGroup),
      class: ""
    });
    const businessObject = getListenersContainer(element);
    addExtensionElements(element, businessObject, listener, bpmnFactory, commandStack);
  };
}
function addTaskListenerFactory(props) {
  return addListenerFactory({
    ...props,
    listenerGroup: "camunda:TaskListener"
  });
}
function addExecutionListenerFactory(props) {
  return addListenerFactory({
    ...props,
    listenerGroup: "camunda:ExecutionListener"
  });
}
function getListenerLabel(listener, translate4 = (value) => value) {
  const event2 = listener.get("event");
  const implementationType = getListenerType(listener);
  return `${translate4(EVENT_TO_LABEL[event2])}: ${translate4(IMPLEMENTATION_TYPE_TO_LABEL[implementationType])}`;
}
function getListenerTypeOptions(translate4) {
  return Object.entries(IMPLEMENTATION_TYPE_TO_LABEL).map(([value, label]) => ({
    value,
    label: translate4(label)
  }));
}
function getListenerType(listener) {
  return getImplementationType(listener);
}
function getDefaultEvent(element, listenerGroup) {
  if (listenerGroup === "camunda:TaskListener") return "create";
  return is(element, "bpmn:SequenceFlow") ? "take" : "start";
}
function getDefaultImplementationProperties(type, bpmnFactory) {
  switch (type) {
    case "class":
      return {
        ...DEFAULT_PROPS,
        "class": ""
      };
    case "expression":
      return {
        ...DEFAULT_PROPS,
        "expression": ""
      };
    case "delegateExpression":
      return {
        ...DEFAULT_PROPS,
        "delegateExpression": ""
      };
    case "script":
      return {
        ...DEFAULT_PROPS,
        "script": bpmnFactory.create("camunda:Script")
      };
  }
}
function getDefaultEventTypeProperties(type, bpmnFactory) {
  switch (type) {
    case "timeout":
      return {
        ...DEFAULT_EVENT_PROPS,
        eventDefinitions: [bpmnFactory.create("bpmn:TimerEventDefinition")],
        event: type
      };
    default:
      return {
        ...DEFAULT_EVENT_PROPS,
        event: type
      };
  }
}
function getPrefixedId(prefix3, id) {
  return `${prefix3}-${id}`;
}
function getListenersContainer(element) {
  const businessObject = getBusinessObject(element);
  return businessObject.get("processRef") || businessObject;
}
function ProcessVariablesEntry(props) {
  const {
    element
  } = props;
  const [variables, setVariables] = h4([]);
  p4(async () => {
    const businessObject = getBusinessObject(element);
    const rootElement = getRootElement3(businessObject);
    const scope = getScope3(element);
    const rawVariables = await getVariablesForScope2(scope, rootElement);
    const withName = populateElementNames(sortByName(rawVariables));
    setVariables(withName);
  }, [element]);
  if (!variables.length) {
    return null;
  }
  const byScope = groupByScope(variables);
  const multiScope = isMultiScope(byScope);
  let variableItems = [];
  if (multiScope) {
    const reversed = map(reverse(keys(byScope)), (scopeKey) => byScope[scopeKey]);
    variableItems = flatten(reversed);
  } else {
    variableItems = variables;
  }
  const items = variableItems.map((variable, index5) => {
    const id = element.id + "-variable-" + index5;
    return {
      id,
      label: variable.name,
      entries: [...ProcessVariableItem({
        idPrefix: id,
        multiScope,
        variable
      })]
    };
  });
  return u5(ListGroup, {
    ...props,
    items
  });
}
function ProcessVariablesProps(props) {
  const {
    element
  } = props;
  if (!canHaveProcessVariables(element)) {
    return null;
  }
  return {
    component: ProcessVariablesEntry
  };
}
function ProcessVariableItem(props) {
  const {
    idPrefix,
    multiScope,
    variable
  } = props;
  let entries = [];
  if (multiScope) {
    entries.push({
      id: idPrefix + "-scope",
      component: Scope,
      idPrefix,
      variable
    });
  }
  entries.push({
    id: idPrefix + "-createdIn",
    component: CreatedIn,
    idPrefix,
    variable
  });
  return entries;
}
function Scope(props) {
  const {
    idPrefix,
    variable
  } = props;
  const translate4 = useService("translate");
  const id = idPrefix + "-scope";
  return u5("div", {
    "data-entry-id": id,
    class: "bio-properties-panel-entry",
    children: [u5("b", {
      style: "font-weight: bold",
      class: "bio-properties-panel-label",
      children: translate4("Scope")
    }), u5("label", {
      id: prefixId2(id),
      class: "bio-properties-panel-label",
      children: variable.scope
    })]
  });
}
function CreatedIn(props) {
  const {
    idPrefix,
    variable
  } = props;
  const translate4 = useService("translate");
  const id = idPrefix + "-createdIn";
  const origin = variable.origin.join(", ");
  return u5("div", {
    "data-entry-id": id,
    class: "bio-properties-panel-entry",
    children: [u5("b", {
      style: "font-weight: bold",
      class: "bio-properties-panel-label",
      children: translate4("Created in")
    }), u5("label", {
      id: prefixId2(id),
      class: "bio-properties-panel-label",
      children: origin
    })]
  });
}
function canHaveProcessVariables(element) {
  const businessObject = getBusinessObject(element);
  return isAny(element, ["bpmn:Process", "bpmn:SubProcess"]) || is(element, "bpmn:Participant") && businessObject.get("processRef");
}
function getRootElement3(element) {
  const businessObject = getBusinessObject(element);
  if (is(businessObject, "bpmn:Participant")) {
    return businessObject.processRef;
  }
  if (is(businessObject, "bpmn:Process")) {
    return businessObject;
  }
  let parent = businessObject;
  while (parent.$parent && !is(parent, "bpmn:Process")) {
    parent = parent.$parent;
  }
  return parent;
}
function getScope3(element) {
  const bo = getBusinessObject(element);
  if (is(element, "bpmn:Participant")) {
    return bo.processRef.id;
  }
  return bo.id;
}
function sortByName(variables) {
  return sortBy(variables, function(variable) {
    return variable.name;
  });
}
function groupByScope(variables) {
  return groupBy(variables, "scope");
}
function populateElementNames(variables) {
  forEach(variables, function(variable) {
    const names = map(variable.origin, function(element) {
      return element.name || element.id;
    });
    variable.origin = names;
    variable.scope = variable.scope.name || variable.scope.id;
  });
  return variables;
}
function isMultiScope(scopedVariables) {
  return keys(scopedVariables).length > 1;
}
function reverse(array) {
  return map(array, function(a6, i7) {
    return array[array.length - 1 - i7];
  });
}
function prefixId2(id) {
  return `bio-properties-panel-${id}`;
}
function ScriptTaskProps(props) {
  const {
    element
  } = props;
  if (!is(element, "bpmn:ScriptTask")) {
    return [];
  }
  const entries = [...ScriptProps({
    element
  })];
  entries.push({
    id: "scriptResultVariable",
    component: ResultVariable,
    isEdited
  });
  return entries;
}
function ResultVariable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:resultVariable");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:resultVariable": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "scriptResultVariable",
    label: translate4("Result variable"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function TasklistProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  const isEdited2 = (node2) => {
    return node2 && !node2.checked;
  };
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "isStartableInTasklist",
    component: Startable,
    isEdited: isEdited2
  }];
}
function Startable(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const process2 = getProcess$1(element);
  const getValue = () => {
    return process2.get("camunda:isStartableInTasklist");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:isStartableInTasklist": value
      }
    });
  };
  return CheckboxEntry({
    element,
    id: "isStartableInTasklist",
    label: translate4("Startable"),
    getValue,
    setValue
  });
}
function getProcess$1(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function UserAssignmentProps(props) {
  const {
    element
  } = props;
  if (!is(element, "camunda:Assignable")) {
    return [];
  }
  return [{
    id: "assignee",
    component: Assignee,
    isEdited
  }, {
    id: "candidateGroups",
    component: CandidateGroups,
    isEdited
  }, {
    id: "candidateUsers",
    component: CandidateUsers,
    isEdited
  }, {
    id: "dueDate",
    component: DueDate,
    isEdited
  }, {
    id: "followUpDate",
    component: FollowUpDate,
    isEdited
  }, {
    id: "priority",
    component: Priority,
    isEdited
  }];
}
function Assignee(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:assignee");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:assignee": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "assignee",
    label: translate4("Assignee"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CandidateUsers(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:candidateUsers");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:candidateUsers": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateUsers",
    label: translate4("Candidate users"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function CandidateGroups(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:candidateGroups");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:candidateGroups": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "candidateGroups",
    label: translate4("Candidate groups"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function DueDate(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:dueDate");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:dueDate": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "dueDate",
    label: translate4("Due date"),
    description: translate4("The due date as an EL expression (e.g. ${someDate}) or an ISO date (e.g. 2015-06-26T09:54:00)."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function FollowUpDate(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:followUpDate");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:followUpDate": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "followUpDate",
    label: translate4("Follow up date"),
    description: translate4("The follow up date as an EL expression (e.g. ${someDate}) or an ISO date (e.g. 2015-06-26T09:54:00)."),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function Priority(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const businessObject = getBusinessObject(element);
  const getValue = () => {
    return businessObject.get("camunda:priority");
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: businessObject,
      properties: {
        "camunda:priority": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "priority",
    label: translate4("Priority"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function VersionTagProps(props) {
  const {
    element
  } = props;
  const businessObject = getBusinessObject(element);
  if (!is(element, "bpmn:Process") && !(is(element, "bpmn:Participant") && businessObject.get("processRef"))) {
    return [];
  }
  return [{
    id: "versionTag",
    component: VersionTag,
    isEdited
  }];
}
function VersionTag(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = getProcess(element);
  const getValue = () => {
    return process2.get("camunda:versionTag") || "";
  };
  const setValue = (value) => {
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        "camunda:versionTag": value
      }
    });
  };
  return TextfieldEntry({
    element,
    id: "versionTag",
    label: translate4("Version tag"),
    getValue,
    setValue,
    debounce: debounce2
  });
}
function getProcess(element) {
  return is(element, "bpmn:Process") ? getBusinessObject(element) : getBusinessObject(element).get("processRef");
}
function IdProps() {
  return [{
    id: "id",
    component: Id,
    isEdited
  }];
}
function Id(props) {
  const {
    element
  } = props;
  const modeling = useService("modeling");
  const debounce2 = useService("debounceInput");
  const translate4 = useService("translate");
  const setValue = (value, error4) => {
    if (error4) {
      return;
    }
    modeling.updateProperties(element, {
      id: value
    });
  };
  const getValue = T4((element2) => {
    return getBusinessObject(element2).id;
  }, [element]);
  const validate = T4((value) => {
    const businessObject = getBusinessObject(element);
    return isIdValid(businessObject, value, translate4);
  }, [element, translate4]);
  const description = is(element, "bpmn:Process") ? translate4("This maps to the process definition key.") : null;
  return TextfieldEntry({
    element,
    id: "id",
    label: translate4(is(element, "bpmn:Participant") ? "Participant ID" : "ID"),
    getValue,
    setValue,
    debounce: debounce2,
    validate,
    description
  });
}
function ProcessProps(props) {
  const {
    element
  } = props;
  if (!hasProcessRef(element)) {
    return [];
  }
  return [{
    id: "processId",
    component: ProcessId,
    isEdited
  }];
}
function ProcessId(props) {
  const {
    element
  } = props;
  const commandStack = useService("commandStack");
  const translate4 = useService("translate");
  const debounce2 = useService("debounceInput");
  const process2 = element.businessObject.get("processRef");
  const getValue = () => {
    return process2.get("id");
  };
  const setValue = (value, error4) => {
    if (error4) {
      return;
    }
    commandStack.execute("element.updateModdleProperties", {
      element,
      moddleElement: process2,
      properties: {
        id: value
      }
    });
  };
  const validate = T4((value) => {
    return isIdValid(process2, value, translate4);
  }, [process2, translate4]);
  const description = is(element, "bpmn:Participant") ? translate4("This maps to the process definition key.") : null;
  return TextfieldEntry({
    element,
    id: "processId",
    label: translate4("Process ID"),
    getValue,
    setValue,
    debounce: debounce2,
    validate,
    description
  });
}
function hasProcessRef(element) {
  return is(element, "bpmn:Participant") && element.businessObject.get("processRef");
}
var LOW_PRIORITY28 = 500;
var CAMUNDA_PLATFORM_GROUPS = [HistoryCleanupGroup, TasklistGroup, CandidateStarterGroup, ImplementationGroup, ExternalTaskGroup, ProcessVariablesGroup, ErrorsGroup, UserAssignmentGroup, FormGroup, FormDataGroup, TaskListenerGroup, StartInitiatorGroup, ScriptGroup, ConditionGroup, CallActivityGroup, AsynchronousContinuationsGroup, JobExecutionGroup, InMappingPropagationGroup, InMappingGroup, InputGroup, ConnectorInputGroup, OutMappingPropagationGroup, OutMappingGroup, OutputGroup, ConnectorOutputGroup, ExecutionListenerGroup, ExtensionPropertiesGroup, FieldInjectionGroup, BusinessKeyGroup];
var CamundaPlatformPropertiesProvider = class {
  constructor(propertiesPanel, injector) {
    propertiesPanel.registerProvider(LOW_PRIORITY28, this);
    this._injector = injector;
  }
  getGroups(element) {
    return (groups) => {
      groups = groups.concat(this._getGroups(element));
      updateGeneralGroup(groups, element);
      updateErrorGroup(groups, element);
      updateEscalationGroup(groups, element);
      updateMultiInstanceGroup(groups, element);
      updateTimerGroup(groups, element);
      moveImplementationGroup(groups);
      return groups;
    };
  }
  _getGroups(element) {
    const groups = CAMUNDA_PLATFORM_GROUPS.map((createGroup2) => createGroup2(element, this._injector));
    return groups.filter((group) => group !== null);
  }
};
CamundaPlatformPropertiesProvider.$inject = ["propertiesPanel", "injector"];
function moveImplementationGroup(groups) {
  const documentationGroupIdx = findGroupIndex(groups, "documentation");
  if (documentationGroupIdx < 0) {
    return;
  }
  return moveGroup(groups, "CamundaPlatform__Implementation", documentationGroupIdx + 1);
}
function updateGeneralGroup(groups, element) {
  const generalGroup = findGroup(groups, "general");
  if (!generalGroup) {
    return;
  }
  const {
    entries
  } = generalGroup;
  const idIndex = findIndex(entries, (entry) => entry.id === "id");
  entries.splice(idIndex, 1, ...IdProps());
  const processIdIndex = findIndex(entries, (entry) => entry.id === "processId");
  if (processIdIndex && processIdIndex >= 0) {
    entries.splice(processIdIndex, 1, ...ProcessProps({
      element
    }));
  }
  const executableEntry = findIndex(entries, (entry) => entry.id === "isExecutable");
  const insertIndex = executableEntry >= 0 ? executableEntry : entries.length;
  entries.splice(insertIndex, 0, ...VersionTagProps({
    element
  }));
}
function updateErrorGroup(groups, element) {
  const errorGroup = findGroup(groups, "error");
  if (!errorGroup) {
    return;
  }
  const {
    entries
  } = errorGroup;
  ErrorProps({
    element,
    entries
  });
}
function updateMultiInstanceGroup(groups, element) {
  const multiInstanceGroup = findGroup(groups, "multiInstance");
  if (!multiInstanceGroup) {
    return;
  }
  const {
    entries
  } = multiInstanceGroup;
  MultiInstanceProps({
    element,
    entries
  });
}
function updateEscalationGroup(groups, element) {
  const escalationGroup = findGroup(groups, "escalation");
  if (!escalationGroup) {
    return;
  }
  const {
    entries
  } = escalationGroup;
  EscalationProps({
    element,
    entries
  });
}
function updateTimerGroup(groups, element) {
  const timerEventGroup = findGroup(groups, "timer");
  if (!timerEventGroup) {
    return;
  }
  timerEventGroup.entries = [...TimerProps({
    element
  })];
}
function ImplementationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Implementation"),
    id: "CamundaPlatform__Implementation",
    component: Group,
    entries: [...ImplementationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ErrorsGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Errors"),
    id: "CamundaPlatform__Errors",
    component: ListGroup,
    ...ErrorsProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function UserAssignmentGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("User assignment"),
    id: "CamundaPlatform__UserAssignment",
    component: Group,
    entries: [...UserAssignmentProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ScriptGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Script"),
    id: "CamundaPlatform__Script",
    component: Group,
    entries: [...ScriptTaskProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function CallActivityGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Called element"),
    id: "CamundaPlatform__CallActivity",
    component: Group,
    entries: [...CallActivityProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ConditionGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Condition"),
    id: "CamundaPlatform__Condition",
    component: Group,
    entries: [...ConditionProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function StartInitiatorGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Start initiator"),
    id: "CamundaPlatform__StartInitiator",
    component: Group,
    entries: [...InitiatorProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ExternalTaskGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("External task"),
    id: "CamundaPlatform__ExternalTask",
    component: Group,
    entries: [...ExternalTaskPriorityProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function AsynchronousContinuationsGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Asynchronous continuations"),
    id: "CamundaPlatform__AsynchronousContinuations",
    component: Group,
    entries: [...AsynchronousContinuationsProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function JobExecutionGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Job execution"),
    id: "CamundaPlatform__JobExecution",
    component: Group,
    entries: [...JobExecutionProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function CandidateStarterGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Candidate starter"),
    id: "CamundaPlatform__CandidateStarter",
    component: Group,
    entries: [...CandidateStarterProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function FieldInjectionGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Field injections"),
    id: "CamundaPlatform__FieldInjection",
    component: ListGroup,
    ...FieldInjectionProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function HistoryCleanupGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("History cleanup"),
    id: "CamundaPlatform__HistoryCleanup",
    component: Group,
    entries: [...HistoryCleanupProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function TasklistGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Tasklist"),
    id: "CamundaPlatform__Tasklist",
    component: Group,
    entries: [...TasklistProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function InMappingGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("In mappings"),
    id: "CamundaPlatform__InMapping",
    component: ListGroup,
    ...InMappingProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function InMappingPropagationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("In mapping propagation"),
    id: "CamundaPlatform__InMappingPropagation",
    component: Group,
    entries: [...InMappingPropagationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function OutMappingGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Out mappings"),
    id: "CamundaPlatform__OutMapping",
    component: ListGroup,
    ...OutMappingProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function OutMappingPropagationGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Out mapping propagation"),
    id: "CamundaPlatform__OutMappingPropagation",
    component: Group,
    entries: [...OutMappingPropagationProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ProcessVariablesGroup(element, injector) {
  const translate4 = injector.get("translate");
  const variableProps = ProcessVariablesProps({
    element,
    injector
  });
  if (!variableProps) {
    return null;
  }
  const group = {
    label: translate4("Process variables"),
    id: "CamundaPlatform__ProcessVariables",
    ...variableProps
  };
  return group;
}
function FormDataGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Form fields"),
    id: "CamundaPlatform__FormData",
    component: ListGroup,
    ...FormDataProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function BusinessKeyGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Business key"),
    id: "CamundaPlatform__BusinessKey",
    component: Group,
    entries: [...BusinessKeyProps$1({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function FormGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Forms"),
    id: "CamundaPlatform__Form",
    component: Group,
    entries: [...FormProps({
      element
    })]
  };
  if (group.entries.length) {
    return group;
  }
  return null;
}
function ExecutionListenerGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Execution listeners"),
    id: "CamundaPlatform__ExecutionListener",
    component: ListGroup,
    ...ExecutionListenerProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function TaskListenerGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Task listeners"),
    id: "CamundaPlatform__TaskListener",
    component: ListGroup,
    ...TaskListenerProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function InputGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Inputs"),
    id: "CamundaPlatform__Input",
    component: ListGroup,
    ...InputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function OutputGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Outputs"),
    id: "CamundaPlatform__Output",
    component: ListGroup,
    ...OutputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ConnectorInputGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Connector inputs"),
    id: "CamundaPlatform__ConnectorInput",
    component: ListGroup,
    ...ConnectorInputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ConnectorOutputGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Connector outputs"),
    id: "CamundaPlatform__ConnectorOutput",
    component: ListGroup,
    ...ConnectorOutputProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function ExtensionPropertiesGroup(element, injector) {
  const translate4 = injector.get("translate");
  const group = {
    label: translate4("Extension properties"),
    id: "CamundaPlatform__ExtensionProperties",
    component: ListGroup,
    ...ExtensionPropertiesProps({
      element,
      injector
    })
  };
  if (group.items) {
    return group;
  }
  return null;
}
function findGroup(groups, id) {
  return groups.find((g6) => g6.id === id);
}
function findGroupIndex(groups, id) {
  return findIndex(groups, (g6) => g6.id === id);
}
function moveGroup(groups, id, position) {
  const groupIndex = findGroupIndex(groups, id);
  if (position < 0 || groupIndex < 0) {
    return;
  }
  return arrayMoveMutable(groups, groupIndex, position);
}

// src/bpmnModeler.ts
var import_obsidian2 = require("obsidian");

// node_modules/bpmn-js-token-simulation/lib/simulator/ScopeTraits.js
var ACTIVATED = 1;
var RUNNING = 1 << 1;
var ENDING = 1 << 2;
var ENDED = 1 << 3;
var DESTROYED = 1 << 4;
var FAILED = 1 << 5;
var TERMINATED = 1 << 6;
var CANCELED = 1 << 7;
var COMPLETED = 1 << 8;
var COMPENSABLE = 1 << 9;
var ACTIVE = ACTIVATED | RUNNING | ENDING;
var NOT_DEAD = ACTIVATED | ENDED;
var ScopeTraits = Object.freeze({
  ACTIVATED,
  RUNNING,
  ENDING,
  ENDED,
  DESTROYED,
  FAILED,
  TERMINATED,
  CANCELED,
  COMPLETED,
  COMPENSABLE,
  ACTIVE,
  NOT_DEAD
});

// node_modules/bpmn-js-token-simulation/lib/simulator/ScopeStates.js
var SELF = {};
function illegalTransition(state, target) {
  throw new Error(`illegal transition: ${state.name} -> ${target}`);
}
function orSelf(state, self2) {
  if (state === SELF) {
    return self2;
  }
  return state;
}
var ScopeState = class {
  /**
   * @param {string} name
   * @param {number} traits
   * @param {object} [transitions]
   * @param {ScopeState} [transitions.start]
   * @param {ScopeState} [transitions.cancel]
   * @param {ScopeState} [transitions.complete]
   * @param {ScopeState} [transitions.destroy]
   * @param {ScopeState} [transitions.fail]
   * @param {ScopeState} [transitions.terminate]
   * @param {ScopeState} [transitions.compensable]
   */
  constructor(name2, traits, {
    start,
    cancel: cancel2,
    complete,
    destroy,
    fail,
    terminate,
    compensable
  } = {}) {
    this.name = name2;
    this.traits = traits;
    this._start = orSelf(start, this);
    this._compensable = orSelf(compensable, this);
    this._cancel = orSelf(cancel2, this);
    this._complete = orSelf(complete, this);
    this._destroy = orSelf(destroy, this);
    this._fail = orSelf(fail, this);
    this._terminate = orSelf(terminate, this);
  }
  /**
   * @param {number} trait
   * @return {boolean}
   */
  hasTrait(trait) {
    return (this.traits & trait) !== 0;
  }
  /**
   * @return {ScopeState}
   */
  complete() {
    return this._complete || illegalTransition(this, "complete");
  }
  /**
   * @return {ScopeState}
   */
  destroy() {
    return this._destroy || illegalTransition(this, "destroy");
  }
  /**
   * @return {ScopeState}
   */
  cancel() {
    return this._cancel || illegalTransition(this, "cancel");
  }
  /**
   * @return {ScopeState}
   */
  fail() {
    return this._fail || illegalTransition(this, "fail");
  }
  /**
   * @return {ScopeState}
   */
  terminate() {
    return this._terminate || illegalTransition(this, "terminate");
  }
  /**
   * @return {ScopeState}
   */
  compensable() {
    return this._compensable || illegalTransition(this, "compensable");
  }
  /**
   * @return {ScopeState}
   */
  start() {
    return this._start || illegalTransition(this, "start");
  }
};
var FAILED2 = new ScopeState("failed", ScopeTraits.DESTROYED | ScopeTraits.FAILED);
var TERMINATED2 = new ScopeState("terminated", ScopeTraits.DESTROYED | ScopeTraits.TERMINATED);
var COMPLETED2 = new ScopeState("completed", ScopeTraits.DESTROYED | ScopeTraits.COMPLETED);
var TERMINATING = new ScopeState("terminating", ScopeTraits.ENDING | ScopeTraits.TERMINATED, {
  destroy: TERMINATED2
});
var CANCELING = new ScopeState("canceling", ScopeTraits.ENDING | ScopeTraits.FAILED | ScopeTraits.CANCELED, {
  destroy: FAILED2,
  complete: SELF,
  terminate: TERMINATING
});
var COMPLETING = new ScopeState("completing", ScopeTraits.ENDING | ScopeTraits.COMPLETED, {
  destroy: COMPLETED2,
  cancel: CANCELING,
  terminate: TERMINATING
});
var FAILING = new ScopeState("failing", ScopeTraits.ENDING | ScopeTraits.FAILED, {
  cancel: CANCELING,
  complete: COMPLETING,
  destroy: FAILED2,
  terminate: TERMINATING
});
var COMPENSABLE_FAILING = new ScopeState("compensable:failing", ScopeTraits.ENDING | ScopeTraits.FAILED, {
  complete: SELF,
  terminate: TERMINATING,
  destroy: FAILED2
});
var COMPENSABLE_COMPLETED = new ScopeState("compensable:completed", ScopeTraits.ENDED | ScopeTraits.COMPLETED, {
  cancel: CANCELING,
  fail: COMPENSABLE_FAILING,
  destroy: COMPLETED2,
  compensable: SELF
});
var COMPENSABLE_COMPLETING = new ScopeState("compensable:completing", ScopeTraits.ENDING | ScopeTraits.COMPLETED, {
  destroy: COMPENSABLE_COMPLETED,
  terminate: TERMINATING,
  compensable: SELF
});
var COMPENSABLE_RUNNING = new ScopeState("compensable:running", ScopeTraits.RUNNING | ScopeTraits.COMPENSABLE, {
  cancel: CANCELING,
  complete: COMPENSABLE_COMPLETING,
  compensable: SELF,
  destroy: COMPENSABLE_COMPLETED,
  fail: FAILING,
  terminate: TERMINATING
});
var RUNNING2 = new ScopeState("running", ScopeTraits.RUNNING, {
  cancel: CANCELING,
  complete: COMPLETING,
  compensable: COMPENSABLE_RUNNING,
  destroy: TERMINATED2,
  fail: FAILING,
  terminate: TERMINATING
});
var ACTIVATED2 = new ScopeState("activated", ScopeTraits.ACTIVATED, {
  start: RUNNING2,
  destroy: TERMINATED2
});
var ScopeStates = Object.freeze({
  ACTIVATED: ACTIVATED2,
  RUNNING: RUNNING2,
  CANCELING,
  COMPLETING,
  COMPLETED: COMPLETED2,
  FAILING,
  FAILED: FAILED2,
  TERMINATING,
  TERMINATED: TERMINATED2
});

// node_modules/bpmn-js-token-simulation/lib/simulator/Scope.js
var Scope2 = class {
  /**
   * @param {string} id
   * @param {Element} element
   * @param {Scope} parent
   * @param {Scope} initiator
   *
   * @constructor
   */
  constructor(id, element, parent = null, initiator = null) {
    this.id = id;
    this.element = element;
    this.parent = parent;
    this.initiator = initiator;
    this.subscriptions = /* @__PURE__ */ new Set();
    this.children = [];
    this.state = ScopeStates.ACTIVATED;
  }
  /**
   * @return {boolean}
   */
  get running() {
    return this.hasTrait(ScopeTraits.RUNNING);
  }
  /**
   * @return {boolean}
   */
  get destroyed() {
    return this.hasTrait(ScopeTraits.DESTROYED);
  }
  /**
   * @return {boolean}
   */
  get completed() {
    return this.hasTrait(ScopeTraits.COMPLETED);
  }
  /**
   * @return {boolean}
   */
  get canceled() {
    return this.hasTrait(ScopeTraits.CANCELED);
  }
  /**
   * @return {boolean}
   */
  get failed() {
    return this.hasTrait(ScopeTraits.FAILED);
  }
  /**
   * @param {number} phase
   * @return {boolean}
   */
  hasTrait(trait) {
    return this.state.hasTrait(trait);
  }
  /**
   * Start the scope
   *
   * @return {Scope}
   */
  start() {
    this.state = this.state.start();
    return this;
  }
  /**
   * Make this scope compensable.
   *
   * @return {Scope}
   */
  compensable() {
    this.state = this.state.compensable();
    return this;
  }
  /**
   * @param {Scope} initiator
   *
   * @return {Scope}
   */
  fail(initiator) {
    if (!this.failed) {
      this.state = this.state.fail();
      this.failInitiator = initiator;
    }
    return this;
  }
  cancel(initiator) {
    if (!this.canceled) {
      this.state = this.state.cancel();
      this.cancelInitiator = initiator;
    }
    return this;
  }
  /**
   * @param {Scope} initiator
   *
   * @return {Scope}
   */
  terminate(initiator) {
    this.state = this.state.terminate();
    this.terminateInitiator = initiator;
    return this;
  }
  /**
   * @return {Scope}
   */
  complete() {
    this.state = this.state.complete();
    return this;
  }
  /**
   * Destroy the scope
   *
   * @param {Scope} initiator
   *
   * @return {Scope}
   */
  destroy(initiator) {
    this.state = this.state.destroy();
    this.destroyInitiator = initiator;
    return this;
  }
  /**
   * @return {number}
   */
  getTokens() {
    return this.children.filter((c5) => !c5.destroyed).length;
  }
  /**
   * @param {Element} element
   *
   * @return {number}
   */
  getTokensByElement(element) {
    return this.children.filter((c5) => !c5.destroyed && c5.element === element).length;
  }
};

// node_modules/bpmn-js-token-simulation/lib/simulator/util/SetUtil.js
function filterSet(set4, matchFn) {
  const matched = [];
  for (const el of set4) {
    if (matchFn(el)) {
      matched.push(el);
    }
  }
  return matched;
}
function findSet(set4, matchFn) {
  for (const el of set4) {
    if (matchFn(el)) {
      return el;
    }
  }
  return null;
}

// node_modules/bpmn-js-token-simulation/lib/simulator/util/EventsUtil.js
function eventsMatch(a6, b4) {
  const attrMatch = ["type", "name", "iref"].every((attr3) => !(attr3 in a6) || a6[attr3] === b4[attr3]);
  const catchAllMatch = !b4.ref && (b4.type === "error" || b4.type === "escalation");
  return attrMatch && (catchAllMatch || refsMatch(a6, b4));
}
function refsMatch(a6, b4) {
  const attr3 = "ref";
  return !(attr3 in a6) || a6[attr3] === b4[attr3];
}

// node_modules/bpmn-js-token-simulation/lib/simulator/util/ModelUtil.js
function filterSequenceFlows(flows) {
  return flows.filter((f6) => is(f6, "bpmn:SequenceFlow"));
}
function isMessageFlow(element) {
  return is(element, "bpmn:MessageFlow");
}
function isSequenceFlow2(element) {
  return is(element, "bpmn:SequenceFlow");
}
function isLinkCatch(element) {
  return isCatchEvent(element) && isTypedEvent3(element, "bpmn:LinkEventDefinition");
}
function isCompensationEvent(element) {
  return isCatchEvent(element) && isTypedEvent3(element, "bpmn:CompensateEventDefinition");
}
function isCompensationActivity(element) {
  return is(element, "bpmn:Activity") && element.businessObject.isForCompensation;
}
function isCatchEvent(element) {
  return (is(element, "bpmn:CatchEvent") || is(element, "bpmn:ReceiveTask")) && !isLabel2(element);
}
function isBoundaryEvent2(element) {
  return is(element, "bpmn:BoundaryEvent") && !isLabel2(element);
}
function isNoneStartEvent(element) {
  return isStartEvent(element) && !isTypedEvent3(element);
}
function isImplicitStartEvent(element) {
  if (isLabel2(element)) {
    return false;
  }
  if (!isAny2(element, [
    "bpmn:Activity",
    "bpmn:IntermediateCatchEvent",
    "bpmn:IntermediateThrowEvent",
    "bpmn:Gateway",
    "bpmn:EndEvent"
  ])) {
    return false;
  }
  if (isLinkCatch(element)) {
    return false;
  }
  const incoming = element.incoming.find(isSequenceFlow2);
  if (incoming) {
    return false;
  }
  if (isCompensationActivity(element)) {
    return false;
  }
  if (isEventSubProcess3(element)) {
    return false;
  }
  return true;
}
function isStartEvent(element) {
  return is(element, "bpmn:StartEvent") && !isLabel2(element);
}
function isLabel2(element) {
  return !!element.labelTarget;
}
function isEventSubProcess3(element) {
  return getBusinessObject(element).triggeredByEvent;
}
function isInterrupting3(element) {
  return is(element, "bpmn:StartEvent") && getBusinessObject(element).isInterrupting || is(element, "bpmn:BoundaryEvent") && getBusinessObject(element).cancelActivity;
}
function isAny2(element, types3) {
  return types3.some((type) => is(element, type));
}
function isTypedEvent3(event2, eventDefinitionType) {
  return some(getBusinessObject(event2).eventDefinitions, (definition) => {
    return eventDefinitionType ? is(definition, eventDefinitionType) : true;
  });
}
function getChildren3(element, elementRegistry) {
  if (element.children && element.children.length !== 0) {
    return element.children;
  }
  if (is(element, "bpmn:SubProcess") && !element.di.isExpanded) {
    return elementRegistry.get(getPlaneIdFromShape(element)).children;
  }
  return [];
}

// node_modules/bpmn-js-token-simulation/lib/simulator/Simulator.js
function Simulator(injector, eventBus, elementRegistry) {
  const ids3 = injector.get("scopeIds", false) || new index_esm_default([32, 36]);
  const configuration = {};
  const behaviors = {};
  const noopBehavior = new NoopBehavior();
  const changedElements = /* @__PURE__ */ new Set();
  const jobs = [];
  const scopes = /* @__PURE__ */ new Set();
  const subscriptions = /* @__PURE__ */ new Set();
  on2("tick", function() {
    for (const element of changedElements) {
      emit("elementChanged", {
        element
      });
    }
    changedElements.clear();
  });
  function queue(scope, task) {
    jobs.push([task, scope]);
    if (jobs.length !== 1) {
      return;
    }
    let next;
    while (next = jobs[0]) {
      const [task2, scope2] = next;
      if (!scope2.destroyed) {
        task2();
      }
      jobs.shift();
    }
    emit("tick");
  }
  function getBehavior(element) {
    return behaviors[element.type] || noopBehavior;
  }
  function signal(context) {
    const {
      element,
      parentScope,
      initiator = null,
      scope = initializeScope({
        element,
        parent: parentScope,
        initiator
      })
    } = context;
    queue(scope, function() {
      if (!scope.running) {
        scope.start();
      }
      trace("signal", {
        ...context,
        scope
      });
      getBehavior(element).signal({
        ...context,
        scope
      });
      if (scope.parent) {
        scopeChanged(scope.parent);
      }
    });
    return scope;
  }
  function enter(context) {
    const {
      element,
      scope: parentScope,
      initiator = parentScope
    } = context;
    const scope = initializeScope({
      element,
      parent: parentScope,
      initiator
    });
    queue(scope, function() {
      if (!scope.running) {
        scope.start();
      }
      trace("enter", context);
      getBehavior(element).enter({
        ...context,
        initiator,
        scope
      });
      if (scope.parent) {
        scopeChanged(scope.parent);
      }
    });
    return scope;
  }
  function exit(context) {
    const {
      element,
      scope,
      initiator = scope
    } = context;
    queue(scope, function() {
      trace("exit", context);
      getBehavior(element).exit({
        ...context,
        initiator
      });
      if (scope.running) {
        scope.complete();
      }
      destroyScope(scope, initiator);
      scope.parent && scopeChanged(scope.parent);
    });
  }
  function trigger(context) {
    const {
      event: _event,
      initiator,
      scope
    } = context;
    const event2 = getEvent(_event);
    const subscriptions2 = scope.subscriptions;
    let matchingSubscriptions = filterSet(
      subscriptions2,
      (subscription) => eventsMatch(event2, subscription.event)
    );
    if (event2.type === "error" || event2.type === "escalation") {
      const referenceSubscriptions = filterSet(
        matchingSubscriptions,
        (subscription) => refsMatch(event2, subscription.event)
      );
      if (matchingSubscriptions.every((subscription) => subscription.event.boundary) && referenceSubscriptions.some((subscription) => subscription.event.boundary) || referenceSubscriptions.some((subscription) => !subscription.event.boundary)) {
        matchingSubscriptions = referenceSubscriptions;
      }
    }
    const nonInterrupting = matchingSubscriptions.filter(
      (subscription) => !subscription.event.interrupting
    );
    const interrupting = matchingSubscriptions.filter(
      (subscription) => subscription.event.interrupting
    );
    if (!interrupting.length) {
      return nonInterrupting.map(
        (subscription) => subscription.triggerFn(initiator)
      ).flat();
    }
    const interrupt = interrupting.find((subscription) => !subscription.event.boundary) || interrupting[0];
    const remainingSubscriptions = filterSet(
      subscriptions2,
      (subscription) => subscription.event.persistent || isRethrow(subscription.event, interrupt.event)
    );
    subscriptions2.forEach((subscription) => {
      if (!remainingSubscriptions.includes(subscription)) {
        subscription.remove();
      }
    });
    return [interrupt.triggerFn(initiator)].flat().filter((s5) => s5);
  }
  function subscribe(scope, event2, triggerFn) {
    event2 = getEvent(event2);
    const element = event2.element;
    const subscription = {
      scope,
      event: event2,
      element,
      triggerFn,
      remove() {
        unsubscribe(subscription);
      }
    };
    subscriptions.add(subscription);
    scope.subscriptions.add(subscription);
    if (element) {
      elementChanged(element);
    }
    return subscription;
  }
  function unsubscribe(subscription) {
    const {
      scope,
      event: event2
    } = subscription;
    subscriptions.delete(subscription);
    scope.subscriptions.delete(subscription);
    if (event2.element) {
      elementChanged(event2.element);
    }
  }
  function createInternalRef(element) {
    if (is(element, "bpmn:StartEvent") || is(element, "bpmn:IntermediateCatchEvent") || is(element, "bpmn:ReceiveTask") || isSpecialBoundaryEvent(element)) {
      return getBusinessObject(element).name || element.id;
    }
    return null;
  }
  function getNoneEvent(element) {
    return {
      element,
      interrupting: false,
      boundary: false,
      iref: element.id,
      type: "none"
    };
  }
  function getEvent(element) {
    if (!element.businessObject) {
      return element;
    }
    const interrupting = isInterrupting3(element);
    const boundary = isBoundaryEvent2(element);
    const iref = createInternalRef(element);
    const baseEvent = {
      element,
      interrupting,
      boundary,
      ...iref ? { iref } : {}
    };
    const eventDefinition = getEventDefinitions2(element)[0];
    if (!eventDefinition) {
      return {
        ...baseEvent,
        type: isImplicitMessageCatch(element) ? "message" : "none"
      };
    }
    if (is(eventDefinition, "bpmn:LinkEventDefinition")) {
      return {
        ...baseEvent,
        type: "link",
        name: eventDefinition.name
      };
    }
    if (is(eventDefinition, "bpmn:SignalEventDefinition")) {
      return {
        ...baseEvent,
        type: "signal",
        ref: eventDefinition.signalRef
      };
    }
    if (is(eventDefinition, "bpmn:TimerEventDefinition")) {
      return {
        ...baseEvent,
        type: "timer"
      };
    }
    if (is(eventDefinition, "bpmn:ConditionalEventDefinition")) {
      return {
        ...baseEvent,
        type: "condition"
      };
    }
    if (is(eventDefinition, "bpmn:EscalationEventDefinition")) {
      return {
        ...baseEvent,
        type: "escalation",
        ref: eventDefinition.escalationRef
      };
    }
    if (is(eventDefinition, "bpmn:CancelEventDefinition")) {
      return {
        ...baseEvent,
        type: "cancel"
      };
    }
    if (is(eventDefinition, "bpmn:ErrorEventDefinition")) {
      return {
        ...baseEvent,
        type: "error",
        ref: eventDefinition.errorRef
      };
    }
    if (is(eventDefinition, "bpmn:MessageEventDefinition")) {
      return {
        ...baseEvent,
        type: "message",
        ref: eventDefinition.messageRef
      };
    }
    if (is(eventDefinition, "bpmn:CompensateEventDefinition")) {
      let ref = eventDefinition.activityRef && elementRegistry.get(eventDefinition.activityRef.id);
      if (!ref) {
        if (isStartEvent(element) && isEventSubProcess3(element.parent)) {
          ref = element.parent.parent;
        } else if (isBoundaryEvent2(element)) {
          ref = element.host;
        } else {
          ref = element.parent;
        }
      }
      return {
        ...baseEvent,
        type: "compensate",
        ref,
        persistent: true
      };
    }
    throw new Error("unknown event definition", eventDefinition);
  }
  function createScope(context, emitEvent = true) {
    const {
      element,
      parent: parentScope,
      initiator
    } = context;
    emitEvent && trace("createScope", {
      element,
      scope: parentScope
    });
    const scope = new Scope2(ids3.next(), element, parentScope, initiator);
    if (parentScope) {
      parentScope.children.push(scope);
    }
    scopes.add(scope);
    emitEvent && emit("createScope", {
      scope
    });
    elementChanged(element);
    if (parentScope) {
      elementChanged(parentScope.element);
    }
    return scope;
  }
  function subscriptionFilter(filter2) {
    if (typeof filter2 === "function") {
      return filter2;
    }
    const {
      event: _event,
      element,
      scope
    } = filter2;
    const elements = filter2.elements || element && [element];
    const event2 = _event && getEvent(_event);
    return (subscription) => (!event2 || eventsMatch(event2, subscription.event)) && (!elements || elements.includes(subscription.element)) && (!scope || scope === subscription.scope);
  }
  function scopeSubscriptionFilter(event2) {
    const matchesSubscription = event2 === "function" ? event2 : subscriptionFilter(event2);
    return (scope) => Array.from(scope.subscriptions).some(matchesSubscription);
  }
  function scopeFilter(filter2) {
    if (typeof filter2 === "function") {
      return filter2;
    }
    const {
      element,
      waitsOnElement,
      parent,
      trait = ScopeTraits.RUNNING,
      subscribedTo
    } = filter2;
    const isSubscribed = subscribedTo ? scopeSubscriptionFilter(subscribedTo) : () => true;
    return (scope) => (!element || scope.element === element) && (!parent || scope.parent === parent) && (!waitsOnElement || scope.getTokensByElement(waitsOnElement) > 0) && scope.hasTrait(trait) && isSubscribed(scope);
  }
  function findSubscriptions(filter2) {
    return filterSet(subscriptions, subscriptionFilter(filter2));
  }
  function findSubscription(filter2) {
    return findSet(subscriptions, subscriptionFilter(filter2));
  }
  function findScopes(filter2) {
    return filterSet(scopes, scopeFilter(filter2));
  }
  function findScope(filter2) {
    return findSet(scopes, scopeFilter(filter2));
  }
  function destroyScope(scope, initiator = null) {
    if (scope.destroyed) {
      return;
    }
    scope.destroy(initiator);
    for (const subscription of scope.subscriptions) {
      const trait = subscription.event.traits || ScopeTraits.ACTIVE;
      if (!scope.hasTrait(trait)) {
        unsubscribe(subscription);
      }
    }
    if (scope.destroyed) {
      for (const childScope of scope.children) {
        if (!childScope.destroyed) {
          destroyScope(childScope, initiator);
        }
      }
      trace("destroyScope", {
        element: scope.element,
        scope
      });
      scopes.delete(scope);
      emit("destroyScope", {
        scope
      });
    }
    elementChanged(scope.element);
    if (scope.parent) {
      elementChanged(scope.parent.element);
    }
  }
  function trace(action, context) {
    emit("trace", {
      ...context,
      action
    });
  }
  function elementChanged(element) {
    changedElements.add(element);
    if (!jobs.length) {
      emit("tick");
    }
  }
  function scopeChanged(scope) {
    emit("scopeChanged", {
      scope
    });
  }
  function emit(event2, payload = {}) {
    return eventBus.fire(`tokenSimulation.simulator.${event2}`, payload);
  }
  function on2(event2, callback) {
    eventBus.on("tokenSimulation.simulator." + event2, callback);
  }
  function off(event2, callback) {
    eventBus.off("tokenSimulation.simulator." + event2, callback);
  }
  function setConfig(element, updatedConfig) {
    const existingConfig = getConfig(element);
    configuration[element.id || element] = {
      ...existingConfig,
      ...updatedConfig
    };
    elementChanged(element);
  }
  function initializeRootScopes() {
    const rootScopes = [];
    elementRegistry.forEach((element) => {
      if (!isAny2(element, ["bpmn:Process", "bpmn:Participant"])) {
        return;
      }
      const scope = createScope({
        element
      }, false);
      rootScopes.push(scope);
      const startEvents = element.children.filter(isStartEvent);
      const implicitStartEvents = element.children.filter(isImplicitStartEvent);
      for (const startEvent of startEvents) {
        const event2 = {
          ...getEvent(startEvent),
          interrupting: false
        };
        subscribe(scope, event2, (initiator) => signal({
          element,
          startEvent,
          initiator
        }));
      }
      if (!startEvents.length) {
        for (const implicitStartEvent of implicitStartEvents) {
          const event2 = getNoneEvent(implicitStartEvent);
          subscribe(scope, event2, (initiator) => signal({
            element,
            initiator
          }));
        }
      }
    });
    return rootScopes;
  }
  function initializeScope(context) {
    const {
      element
    } = context;
    const scope = createScope(context);
    const {
      attachers = []
    } = element;
    const children = getChildren3(element, elementRegistry);
    for (const childElement of children) {
      if (isEventSubProcess3(childElement)) {
        const startEvents = getChildren3(childElement, elementRegistry).filter(
          (element2) => isStartEvent(element2) && !isCompensationEvent(element2)
        );
        for (const startEvent of startEvents) {
          subscribe(scope, startEvent, (initiator) => {
            return signal({
              element: childElement,
              parentScope: scope,
              startEvent,
              initiator
            });
          });
        }
      }
    }
    for (const attacher of attachers) {
      if (isBoundaryEvent2(attacher) && !isCompensationEvent(attacher)) {
        subscribe(scope, attacher, (initiator) => {
          return signal({
            element: attacher,
            parentScope: scope.parent,
            hostScope: scope,
            initiator
          });
        });
      }
    }
    return scope;
  }
  function getConfig(element) {
    return configuration[element.id || element] || {};
  }
  function waitForScopes(scope, scopes2) {
    if (!scopes2.length) {
      return;
    }
    const event2 = {
      type: "all-completed",
      persistent: false
    };
    const remainingScopes = new Set(scopes2);
    const destroyListener = (destroyEvent) => {
      remainingScopes.delete(destroyEvent.scope);
      if (remainingScopes.size === 0) {
        off("destroyScope", destroyListener);
        trigger({
          scope,
          event: event2
        });
      }
    };
    on2("destroyScope", destroyListener);
    return event2;
  }
  function waitAtElement(element, wait = true) {
    setConfig(element, {
      wait
    });
  }
  function reset2() {
    for (const scope of scopes) {
      destroyScope(scope);
    }
    for (const rootScope of initializeRootScopes()) {
      scopes.add(rootScope);
    }
    emit("tick");
    emit("reset");
  }
  this.createScope = createScope;
  this.destroyScope = destroyScope;
  this.findScope = findScope;
  this.findScopes = findScopes;
  this.findSubscription = findSubscription;
  this.findSubscriptions = findSubscriptions;
  this.waitAtElement = waitAtElement;
  this.waitForScopes = waitForScopes;
  this.setConfig = setConfig;
  this.getConfig = getConfig;
  this.signal = signal;
  this.enter = enter;
  this.exit = exit;
  this.subscribe = subscribe;
  this.trigger = trigger;
  this.reset = reset2;
  this.on = on2;
  this.off = off;
  this.registerBehavior = function(element, behavior) {
    behaviors[element] = behavior;
  };
}
Simulator.$inject = [
  "injector",
  "eventBus",
  "elementRegistry"
];
function NoopBehavior() {
  this.signal = function(context) {
    console.log("ignored #exit", context.element);
  };
  this.exit = function(context) {
    console.log("ignored #exit", context.element);
  };
  this.enter = function(context) {
    console.log("ignored #enter", context.element);
  };
}
function isRethrow(event2, interrupt) {
  return event2.type === interrupt.type && event2.boundary && !interrupt.boundary;
}
function isImplicitMessageCatch(element) {
  return is(element, "bpmn:ReceiveTask") || element.incoming.some((element2) => is(element2, "bpmn:MessageFlow"));
}
function isSpecialBoundaryEvent(element) {
  if (!isBoundaryEvent2(element)) {
    return false;
  }
  const eventDefinitions = getEventDefinitions2(element);
  return !eventDefinitions[0] || isAny2(eventDefinitions[0], [
    "bpmn:ConditionalEventDefinition",
    "bpmn:TimerEventDefinition"
  ]);
}
function getEventDefinitions2(element) {
  return element.businessObject.get("eventDefinitions") || [];
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/StartEventBehavior.js
function StartEventBehavior(simulator, activityBehavior) {
  this._simulator = simulator;
  this._activityBehavior = activityBehavior;
  simulator.registerBehavior("bpmn:StartEvent", this);
}
StartEventBehavior.prototype.signal = function(context) {
  this._simulator.exit(context);
};
StartEventBehavior.prototype.exit = function(context) {
  this._activityBehavior.exit(context);
};
StartEventBehavior.$inject = [
  "simulator",
  "activityBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/EndEventBehavior.js
function EndEventBehavior(simulator, scopeBehavior, intermediateThrowEventBehavior) {
  this._intermediateThrowEventBehavior = intermediateThrowEventBehavior;
  this._scopeBehavior = scopeBehavior;
  simulator.registerBehavior("bpmn:EndEvent", this);
}
EndEventBehavior.$inject = [
  "simulator",
  "scopeBehavior",
  "intermediateThrowEventBehavior"
];
EndEventBehavior.prototype.enter = function(context) {
  this._intermediateThrowEventBehavior.enter(context);
};
EndEventBehavior.prototype.signal = function(context) {
  this._intermediateThrowEventBehavior.signal(context);
};
EndEventBehavior.prototype.exit = function(context) {
  const {
    scope
  } = context;
  this._scopeBehavior.tryExit(scope.parent, scope);
};

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/BoundaryEventBehavior.js
function BoundaryEventBehavior2(simulator, activityBehavior, scopeBehavior) {
  this._simulator = simulator;
  this._activityBehavior = activityBehavior;
  this._scopeBehavior = scopeBehavior;
  simulator.registerBehavior("bpmn:BoundaryEvent", this);
}
BoundaryEventBehavior2.prototype.signal = function(context) {
  const {
    element,
    scope,
    hostScope = this._simulator.findScope({
      parent: scope.parent,
      element: element.host
    })
  } = context;
  if (!hostScope) {
    throw new Error("host scope not found");
  }
  const cancelActivity = getBusinessObject(element).cancelActivity;
  if (cancelActivity) {
    this._scopeBehavior.interrupt(hostScope, scope);
    const event2 = this._scopeBehavior.tryExit(hostScope, scope);
    if (event2) {
      const subscription = this._simulator.subscribe(hostScope, event2, (initiator) => {
        subscription.remove();
        return this._simulator.exit(context);
      });
      return;
    }
  }
  this._simulator.exit(context);
};
BoundaryEventBehavior2.prototype.exit = function(context) {
  this._activityBehavior.exit(context);
};
BoundaryEventBehavior2.$inject = [
  "simulator",
  "activityBehavior",
  "scopeBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/IntermediateCatchEventBehavior.js
function IntermediateCatchEventBehavior(simulator, activityBehavior) {
  this._activityBehavior = activityBehavior;
  this._simulator = simulator;
  simulator.registerBehavior("bpmn:IntermediateCatchEvent", this);
  simulator.registerBehavior("bpmn:ReceiveTask", this);
}
IntermediateCatchEventBehavior.$inject = [
  "simulator",
  "activityBehavior"
];
IntermediateCatchEventBehavior.prototype.signal = function(context) {
  return this._simulator.exit(context);
};
IntermediateCatchEventBehavior.prototype.enter = function(context) {
  const {
    element
  } = context;
  return this._activityBehavior.signalOnEvent(context, element);
};
IntermediateCatchEventBehavior.prototype.exit = function(context) {
  this._activityBehavior.exit(context);
};

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/IntermediateThrowEventBehavior.js
function IntermediateThrowEventBehavior(simulator, activityBehavior, eventBehaviors) {
  this._simulator = simulator;
  this._activityBehavior = activityBehavior;
  this._eventBehaviors = eventBehaviors;
  simulator.registerBehavior("bpmn:IntermediateThrowEvent", this);
  simulator.registerBehavior("bpmn:SendTask", this);
}
IntermediateThrowEventBehavior.prototype.enter = function(context) {
  const {
    element
  } = context;
  const eventBehavior = this._eventBehaviors.get(element);
  if (eventBehavior) {
    const event2 = eventBehavior(context);
    if (event2) {
      return this._activityBehavior.signalOnEvent(context, event2);
    }
  }
  this._activityBehavior.enter(context);
};
IntermediateThrowEventBehavior.prototype.signal = function(context) {
  this._activityBehavior.signal(context);
};
IntermediateThrowEventBehavior.prototype.exit = function(context) {
  this._activityBehavior.exit(context);
};
IntermediateThrowEventBehavior.$inject = [
  "simulator",
  "activityBehavior",
  "eventBehaviors"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/ExclusiveGatewayBehavior.js
function ExclusiveGatewayBehavior(simulator, scopeBehavior) {
  this._scopeBehavior = scopeBehavior;
  this._simulator = simulator;
  simulator.registerBehavior("bpmn:ExclusiveGateway", this);
}
ExclusiveGatewayBehavior.prototype.enter = function(context) {
  this._simulator.exit(context);
};
ExclusiveGatewayBehavior.prototype.exit = function(context) {
  const {
    element,
    scope
  } = context;
  const outgoings = filterSequenceFlows(element.outgoing);
  if (outgoings.length === 1) {
    return this._simulator.enter({
      element: outgoings[0],
      scope: scope.parent
    });
  }
  const {
    activeOutgoing
  } = this._simulator.getConfig(element);
  const outgoing = outgoings.find((o5) => o5 === activeOutgoing);
  if (!outgoing) {
    return this._scopeBehavior.tryExit(scope.parent, scope);
  }
  return this._simulator.enter({
    element: outgoing,
    scope: scope.parent
  });
};
ExclusiveGatewayBehavior.$inject = [
  "simulator",
  "scopeBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/ParallelGatewayBehavior.js
function ParallelGatewayBehavior(simulator, activityBehavior) {
  this._simulator = simulator;
  this._activityBehavior = activityBehavior;
  simulator.registerBehavior("bpmn:ParallelGateway", this);
}
ParallelGatewayBehavior.prototype.enter = function(context) {
  const {
    scope
  } = context;
  const joiningScopes = this._findJoiningScopes(context);
  if (joiningScopes.length) {
    for (const childScope of joiningScopes) {
      if (childScope !== scope) {
        this._simulator.destroyScope(childScope.complete(), scope);
      }
    }
    this._simulator.exit(context);
  }
};
ParallelGatewayBehavior.prototype._findJoiningScopes = function(enterContext) {
  const {
    scope,
    element
  } = enterContext;
  const sequenceFlows = filterSequenceFlows(element.incoming);
  const {
    parent: parentScope
  } = scope;
  const elementScopes = this._simulator.findScopes({
    parent: parentScope,
    element
  });
  const matchingScopes = sequenceFlows.map(
    (flow) => elementScopes.find((scope2) => scope2.initiator.element === flow)
  ).filter((scope2) => scope2);
  if (matchingScopes.length === sequenceFlows.length) {
    return matchingScopes;
  } else {
    return [];
  }
};
ParallelGatewayBehavior.prototype.exit = function(context) {
  this._activityBehavior.exit(context);
};
ParallelGatewayBehavior.$inject = [
  "simulator",
  "activityBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/EventBasedGatewayBehavior.js
function EventBasedGatewayBehavior2(simulator) {
  this._simulator = simulator;
  simulator.registerBehavior("bpmn:EventBasedGateway", this);
}
EventBasedGatewayBehavior2.$inject = [
  "simulator"
];
EventBasedGatewayBehavior2.prototype.enter = function(context) {
  const {
    element,
    scope
  } = context;
  const parentScope = scope.parent;
  const triggerElements = getTriggers(element);
  const subscriptions = triggerElements.map(
    (triggerElement) => this._simulator.subscribe(parentScope, triggerElement, (initiator) => {
      subscriptions.forEach((subscription) => subscription.remove());
      this._simulator.destroyScope(scope, initiator);
      return this._simulator.signal({
        element: triggerElement,
        parentScope,
        initiator
      });
    })
  );
};
function getTriggers(element) {
  return element.outgoing.map(
    (outgoing) => outgoing.target
  ).filter((activity) => isAny2(activity, [
    "bpmn:IntermediateCatchEvent",
    "bpmn:ReceiveTask"
  ]));
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/InclusiveGatewayBehavior.js
function InclusiveGatewayBehavior(simulator, activityBehavior) {
  this._simulator = simulator;
  this._activityBehavior = activityBehavior;
  simulator.registerBehavior("bpmn:InclusiveGateway", this);
}
InclusiveGatewayBehavior.prototype.enter = function(context) {
  this._tryJoin(context);
};
InclusiveGatewayBehavior.prototype.exit = function(context) {
  const {
    element,
    scope
  } = context;
  const outgoings = filterSequenceFlows(element.outgoing);
  if (outgoings.length > 1) {
    const {
      activeOutgoing = []
    } = this._simulator.getConfig(element);
    if (!activeOutgoing.length) {
      throw new Error("no outgoing configured");
    }
    for (const outgoing of activeOutgoing) {
      this._simulator.enter({
        element: outgoing,
        scope: scope.parent
      });
    }
  } else {
    this._activityBehavior.exit(context);
  }
};
InclusiveGatewayBehavior.prototype._tryJoin = function(context) {
  const remainingScopes = this._getRemainingScopes(context);
  const remainingElements = remainingScopes.map((scope2) => scope2.element);
  if (!this._canReachAnyElement(remainingElements, context.element)) {
    return this._join(context);
  }
  const elementScopes = this._getElementScopes(context);
  const {
    scope
  } = context;
  if (elementScopes[0] !== scope) {
    return;
  }
  const event2 = this._simulator.waitForScopes(scope, remainingScopes);
  const subscription = this._simulator.subscribe(scope, event2, () => {
    subscription.remove();
    this._tryJoin(context);
  });
};
InclusiveGatewayBehavior.prototype._getRemainingScopes = function(context) {
  const {
    scope,
    element
  } = context;
  const {
    parent: parentScope
  } = scope;
  return this._simulator.findScopes(
    (scope2) => scope2.parent === parentScope && scope2.element !== element
  );
};
InclusiveGatewayBehavior.prototype._join = function(context) {
  const elementScopes = this._getElementScopes(context);
  for (const childScope of elementScopes) {
    if (childScope !== context.scope) {
      this._simulator.destroyScope(childScope.complete(), context.scope);
    }
  }
  this._simulator.exit(context);
};
InclusiveGatewayBehavior.prototype._getElementScopes = function(context) {
  const {
    element,
    scope
  } = context;
  return this._simulator.findScopes({
    parent: scope.parent,
    element
  });
};
InclusiveGatewayBehavior.prototype._canReachAnyElement = function(elements, currentElement, traversed = /* @__PURE__ */ new Set()) {
  if (!elements.length) {
    return false;
  }
  if (traversed.has(currentElement)) {
    return false;
  }
  traversed.add(currentElement);
  if (elements.some((e8) => e8 === currentElement)) {
    return true;
  }
  if (isSequenceFlow2(currentElement)) {
    return this._canReachAnyElement(elements, currentElement.source, traversed);
  }
  const incomingFlows = filterSequenceFlows(currentElement.incoming);
  for (const flow of incomingFlows) {
    if (this._canReachAnyElement(elements, flow, traversed)) {
      return true;
    }
  }
  return false;
};
InclusiveGatewayBehavior.$inject = [
  "simulator",
  "activityBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/ActivityBehavior.js
function ActivityBehavior(simulator, scopeBehavior, transactionBehavior) {
  this._simulator = simulator;
  this._scopeBehavior = scopeBehavior;
  this._transactionBehavior = transactionBehavior;
  const elements = [
    "bpmn:BusinessRuleTask",
    "bpmn:CallActivity",
    "bpmn:ManualTask",
    "bpmn:ScriptTask",
    "bpmn:ServiceTask",
    "bpmn:Task",
    "bpmn:UserTask"
  ];
  for (const element of elements) {
    simulator.registerBehavior(element, this);
  }
}
ActivityBehavior.$inject = [
  "simulator",
  "scopeBehavior",
  "transactionBehavior"
];
ActivityBehavior.prototype.signal = function(context) {
  const event2 = this._triggerMessages(context);
  if (event2) {
    return this.signalOnEvent(context, event2);
  }
  this._simulator.exit(context);
};
ActivityBehavior.prototype.enter = function(context) {
  const {
    element
  } = context;
  const continueEvent = this.waitAtElement(element);
  if (continueEvent) {
    return this.signalOnEvent(context, continueEvent);
  }
  const event2 = this._triggerMessages(context);
  if (event2) {
    return this.signalOnEvent(context, event2);
  }
  this._simulator.exit(context);
};
ActivityBehavior.prototype.exit = function(context) {
  const {
    element,
    scope
  } = context;
  const parentScope = scope.parent;
  const complete = !scope.failed;
  if (complete && !isEventSubProcess3(element)) {
    this._transactionBehavior.registerCompensation(scope);
  }
  const activatedFlows = complete ? element.outgoing.filter(isSequenceFlow2) : [];
  activatedFlows.forEach(
    (element2) => this._simulator.enter({
      element: element2,
      scope: parentScope
    })
  );
  if (activatedFlows.length === 0) {
    this._scopeBehavior.tryExit(parentScope, scope);
  }
};
ActivityBehavior.prototype.signalOnEvent = function(context, event2) {
  const {
    scope,
    element
  } = context;
  const subscription = this._simulator.subscribe(scope, event2, (initiator) => {
    subscription.remove();
    return this._simulator.signal({
      scope,
      element,
      initiator
    });
  });
};
ActivityBehavior.prototype.waitAtElement = function(element) {
  const wait = this._simulator.getConfig(element).wait;
  return wait && {
    element,
    type: "continue",
    interrupting: false,
    boundary: false
  };
};
ActivityBehavior.prototype._getMessageContexts = function(element, after = null) {
  const filterAfter = after ? (ctx) => ctx.referencePoint.x > after.x : () => true;
  const sortByReference = (a6, b4) => a6.referencePoint.x - b4.referencePoint.x;
  return [
    ...element.incoming.filter(isMessageFlow).map((flow) => ({
      incoming: flow,
      referencePoint: last3(flow.waypoints)
    })),
    ...element.outgoing.filter(isMessageFlow).map((flow) => ({
      outgoing: flow,
      referencePoint: first(flow.waypoints)
    }))
  ].sort(sortByReference).filter(filterAfter);
};
ActivityBehavior.prototype._triggerMessages = function(context) {
  const {
    element,
    initiator,
    scope
  } = context;
  let messageContexts = scope.messageContexts;
  if (!messageContexts) {
    messageContexts = scope.messageContexts = this._getMessageContexts(element);
  }
  const initiatingFlow = initiator && initiator.element;
  if (isMessageFlow(initiatingFlow)) {
    if (scope.expectedIncoming !== initiatingFlow) {
      console.debug("Simulator :: ActivityBehavior :: ignoring out-of-bounds message");
      return;
    }
  }
  while (messageContexts.length) {
    const {
      incoming,
      outgoing
    } = messageContexts.shift();
    if (incoming) {
      if (!initiator) {
        continue;
      }
      scope.expectedIncoming = incoming;
      return {
        element,
        type: "message",
        name: incoming.id,
        interrupting: false,
        boundary: false
      };
    }
    this._simulator.signal({
      element: outgoing
    });
  }
};
function first(arr) {
  return arr && arr[0];
}
function last3(arr) {
  return arr && arr[arr.length - 1];
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/SubProcessBehavior.js
function SubProcessBehavior(simulator, activityBehavior, scopeBehavior, transactionBehavior, elementRegistry) {
  this._simulator = simulator;
  this._activityBehavior = activityBehavior;
  this._scopeBehavior = scopeBehavior;
  this._transactionBehavior = transactionBehavior;
  this._elementRegistry = elementRegistry;
  simulator.registerBehavior("bpmn:SubProcess", this);
  simulator.registerBehavior("bpmn:Transaction", this);
  simulator.registerBehavior("bpmn:AdHocSubProcess", this);
}
SubProcessBehavior.$inject = [
  "simulator",
  "activityBehavior",
  "scopeBehavior",
  "transactionBehavior",
  "elementRegistry"
];
SubProcessBehavior.prototype.signal = function(context) {
  this._start(context);
};
SubProcessBehavior.prototype.enter = function(context) {
  const {
    element
  } = context;
  const continueEvent = this._activityBehavior.waitAtElement(element);
  if (continueEvent) {
    return this._activityBehavior.signalOnEvent(context, continueEvent);
  }
  this._start(context);
};
SubProcessBehavior.prototype.exit = function(context) {
  const {
    scope
  } = context;
  const parentScope = scope.parent;
  if (parentScope.failInitiator === scope) {
    parentScope.complete();
  }
  this._activityBehavior.exit(context);
};
SubProcessBehavior.prototype._start = function(context) {
  const {
    element,
    startEvent,
    scope
  } = context;
  const targetScope = scope.parent;
  if (isEventSubProcess3(element)) {
    if (!startEvent) {
      throw new Error("missing <startEvent>: required for event sub-process");
    }
  } else {
    if (startEvent) {
      throw new Error("unexpected <startEvent>: not allowed for sub-process");
    }
  }
  if (targetScope.destroyed) {
    throw new Error(`target scope <${targetScope.id}> destroyed`);
  }
  if (isTransaction(element)) {
    this._transactionBehavior.setup(context);
  }
  if (startEvent && isInterrupting3(startEvent)) {
    this._scopeBehavior.interrupt(targetScope, scope);
  }
  const startNodes = this._findStarts(element, startEvent);
  for (const element2 of startNodes) {
    if (isStartEvent(element2)) {
      this._simulator.signal({
        element: element2,
        parentScope: scope,
        initiator: scope
      });
    } else {
      this._simulator.enter({
        element: element2,
        scope,
        initiator: scope
      });
    }
  }
  if (!startNodes.length) {
    this._simulator.exit(context);
  }
};
SubProcessBehavior.prototype._findStarts = function(element, startEvent) {
  const isStartEvent2 = startEvent ? (node2) => startEvent === node2 : (node2) => isNoneStartEvent(node2);
  return getChildren3(element, this._elementRegistry).filter(
    (node2) => isStartEvent2(node2) || isImplicitStartEvent(node2)
  );
};
function isTransaction(element) {
  return is(element, "bpmn:Transaction");
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/TransactionBehavior.js
var CANCEL_EVENT = {
  type: "cancel",
  interrupting: true,
  boundary: false,
  persistent: true
};
function TransactionBehavior(simulator, scopeBehavior, elementRegistry) {
  this._simulator = simulator;
  this._scopeBehavior = scopeBehavior;
  this._elementRegistry = elementRegistry;
}
TransactionBehavior.$inject = [
  "simulator",
  "scopeBehavior",
  "elementRegistry"
];
TransactionBehavior.prototype.setup = function(context) {
  const {
    scope
  } = context;
  const cancelSubscription = this._simulator.subscribe(scope, CANCEL_EVENT, (initiator) => {
    cancelSubscription.remove();
    return this.cancel({
      scope,
      initiator
    });
  });
  const compensateEvent = {
    type: "compensate",
    ref: scope.element,
    persistent: true,
    traits: ScopeTraits.NOT_DEAD
  };
  const compensateSubscription = this._simulator.subscribe(scope, compensateEvent, (initiator) => {
    if (!scope.canceled) {
      return this._simulator.trigger({
        event: CANCEL_EVENT,
        scope
      });
    }
    compensateSubscription.remove();
    return this.compensate({
      scope,
      element: scope.element,
      initiator
    });
  });
};
TransactionBehavior.prototype.cancel = function(context) {
  const {
    scope,
    initiator
  } = context;
  if (scope.destroyed) {
    return;
  }
  scope.cancel(initiator);
  this._simulator.trigger({
    event: {
      type: "compensate",
      ref: scope.element
    },
    initiator,
    scope
  });
  return this._simulator.trigger({
    scope,
    initiator,
    event: CANCEL_EVENT
  });
};
TransactionBehavior.prototype.registerCompensation = function(scope) {
  const {
    element
  } = scope;
  const children = getChildren3(element, this._elementRegistry);
  const compensateStartEvents = children.filter(
    isEventSubProcess3
  ).map(
    (element2) => getChildren3(element2, this._elementRegistry).find(
      (element3) => isStartEvent(element3) && isCompensationEvent(element3)
    )
  ).filter((s5) => s5);
  const compensateBoundaryEvents = element.attachers.filter(isCompensationEvent);
  if (!compensateStartEvents.length && !compensateBoundaryEvents.length) {
    return;
  }
  const transactionScope = this.findTransactionScope(scope);
  if (!is(transactionScope.element, "bpmn:Transaction")) {
    this.makeCompensable(transactionScope);
  }
  for (const startEvent of compensateStartEvents) {
    const compensationEvent = {
      element: startEvent,
      type: "compensate",
      persistent: true,
      interrupting: true,
      ref: element,
      traits: ScopeTraits.NOT_DEAD
    };
    const compensateEventSub = startEvent.parent;
    const subscription = this._simulator.subscribe(scope, compensationEvent, (initiator) => {
      subscription.remove();
      return this._simulator.signal({
        initiator,
        element: compensateEventSub,
        startEvent,
        parentScope: scope
      });
    });
  }
  for (const boundaryEvent of compensateBoundaryEvents) {
    const compensationEvent = {
      element: boundaryEvent,
      type: "compensate",
      persistent: true,
      ref: element,
      traits: ScopeTraits.NOT_DEAD
    };
    const compensateActivity = boundaryEvent.outgoing.map(
      (outgoing) => outgoing.target
    ).find(
      isCompensationActivity
    );
    if (!compensateActivity) {
      continue;
    }
    const subscription = this._simulator.subscribe(transactionScope, compensationEvent, (initiator) => {
      subscription.remove();
      return this._simulator.enter({
        initiator,
        element: compensateActivity,
        scope: transactionScope
      });
    });
  }
};
TransactionBehavior.prototype.makeCompensable = function(scope) {
  if (scope.hasTrait(ScopeTraits.COMPENSABLE) || !scope.parent) {
    return;
  }
  const compensateEvent = {
    type: "compensate",
    ref: scope.element,
    interrupting: true,
    persistent: true,
    traits: ScopeTraits.NOT_DEAD
  };
  scope.compensable();
  const scopeSub = this._simulator.subscribe(scope, compensateEvent, (initiator) => {
    scopeSub.remove();
    scope.fail(initiator);
    this.compensate({
      scope,
      element: scope.element,
      initiator
    });
    this._scopeBehavior.tryExit(scope, initiator);
    return scope;
  });
  const parentScope = scope.parent;
  if (!parentScope) {
    return;
  }
  const parentSub = this._simulator.subscribe(parentScope, compensateEvent, (initiator) => {
    parentSub.remove();
    return this._simulator.trigger({
      scope,
      event: compensateEvent,
      initiator
    });
  });
  this.makeCompensable(parentScope);
};
TransactionBehavior.prototype.findTransactionScope = function(scope) {
  let parentScope = scope;
  while (parentScope) {
    const element = parentScope.element;
    if (is(element, "bpmn:SubProcess") && !isEventSubProcess3(element)) {
      return parentScope;
    }
    if (isAny2(element, [
      "bpmn:Transaction",
      "bpmn:Process",
      "bpmn:Participant"
    ])) {
      return parentScope;
    }
    parentScope = parentScope.parent;
  }
  throw noTransactionContext(scope);
};
TransactionBehavior.prototype.compensate = function(context) {
  const {
    scope,
    element
  } = context;
  const compensateSubscriptions = filterSet(
    scope.subscriptions,
    (subscription) => eventsMatch({ type: "compensate" }, subscription.event)
  );
  const localSubscriptions = compensateSubscriptions.filter((subscription) => subscription.event.ref === element);
  const otherSubscriptions = compensateSubscriptions.filter((subscription) => subscription.event.ref !== element);
  for (const subscription of localSubscriptions) {
    this._scopeBehavior.preExit(scope, (initiator) => {
      return this._simulator.trigger(subscription);
    });
  }
  for (const subscription of otherSubscriptions.reverse()) {
    this._scopeBehavior.preExit(scope, (initiator) => {
      return this._simulator.trigger(subscription);
    });
  }
};
function noTransactionContext(scope) {
  throw new Error(`no transaction context for <${scope.id}>`);
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/SequenceFlowBehavior.js
function SequenceFlowBehavior(simulator, scopeBehavior) {
  this._simulator = simulator;
  this._scopeBehavior = scopeBehavior;
  simulator.registerBehavior("bpmn:SequenceFlow", this);
}
SequenceFlowBehavior.prototype.enter = function(context) {
  this._simulator.exit(context);
};
SequenceFlowBehavior.prototype.exit = function(context) {
  const {
    element,
    scope
  } = context;
  this._simulator.enter({
    initiator: scope,
    element: element.target,
    scope: scope.parent
  });
};
SequenceFlowBehavior.$inject = [
  "simulator",
  "scopeBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/MessageFlowBehavior.js
function MessageFlowBehavior2(simulator) {
  this._simulator = simulator;
  simulator.registerBehavior("bpmn:MessageFlow", this);
}
MessageFlowBehavior2.$inject = ["simulator"];
MessageFlowBehavior2.prototype.signal = function(context) {
  this._simulator.exit(context);
};
MessageFlowBehavior2.prototype.exit = function(context) {
  const {
    element,
    scope: initiator
  } = context;
  const target = element.target;
  const event2 = isCatchEvent(target) ? target : {
    type: "message",
    element,
    name: element.id
  };
  const subscription = this._simulator.findSubscription({
    event: event2,
    elements: [target, target.parent]
  });
  if (subscription) {
    this._simulator.trigger({
      event: event2,
      initiator,
      scope: subscription.scope
    });
  }
};

// node_modules/bpmn-js-token-simulation/lib/util/ElementHelper.js
function getEventDefinition4(event2, eventDefinitionType) {
  return find(getBusinessObject(event2).eventDefinitions, (definition) => {
    return is(definition, eventDefinitionType);
  });
}
function isTypedEvent4(event2, eventDefinitionType) {
  return some(getBusinessObject(event2).eventDefinitions, (definition) => {
    return is(definition, eventDefinitionType);
  });
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/EventBehaviors.js
function EventBehaviors(simulator, elementRegistry, scopeBehavior) {
  this._simulator = simulator;
  this._elementRegistry = elementRegistry;
  this._scopeBehavior = scopeBehavior;
}
EventBehaviors.$inject = [
  "simulator",
  "elementRegistry",
  "scopeBehavior"
];
EventBehaviors.prototype.get = function(element) {
  const behaviors = {
    "bpmn:LinkEventDefinition": (context) => {
      const {
        element: element2,
        scope
      } = context;
      const link = getLinkDefinition(element2);
      const parentScope = scope.parent;
      const parentElement = parentScope.element;
      const children = getChildren3(parentElement, this._elementRegistry);
      const linkTargets = children.filter(
        (element3) => isLinkCatch(element3) && getLinkDefinition(element3).name === link.name
      );
      for (const linkTarget of linkTargets) {
        this._simulator.signal({
          element: linkTarget,
          parentScope,
          initiator: scope
        });
      }
    },
    "bpmn:SignalEventDefinition": (context) => {
      const {
        element: element2,
        scope
      } = context;
      const subscriptions = this._simulator.findSubscriptions({
        event: element2
      });
      const signaledScopes = /* @__PURE__ */ new Set();
      for (const subscription of subscriptions) {
        const signaledScope = subscription.scope;
        if (signaledScopes.has(signaledScope)) {
          continue;
        }
        signaledScopes.add(signaledScope);
        this._simulator.trigger({
          event: element2,
          scope: signaledScope,
          initiator: scope
        });
      }
    },
    "bpmn:EscalationEventDefinition": (context) => {
      const {
        element: element2,
        scope
      } = context;
      const scopes = this._simulator.findScopes({
        subscribedTo: {
          event: element2
        },
        trait: ScopeTraits.ACTIVE
      });
      let triggerScope = scope;
      while (triggerScope = triggerScope.parent) {
        if (scopes.includes(triggerScope)) {
          this._simulator.trigger({
            event: element2,
            scope: triggerScope,
            initiator: scope
          });
          break;
        }
      }
    },
    "bpmn:ErrorEventDefinition": (context) => {
      const {
        element: element2,
        scope
      } = context;
      const scopes = this._simulator.findScopes({
        subscribedTo: {
          event: element2
        },
        trait: ScopeTraits.ACTIVE
      });
      let triggerScope = scope;
      while (triggerScope = triggerScope.parent) {
        if (scopes.includes(triggerScope)) {
          this._simulator.trigger({
            event: element2,
            scope: triggerScope,
            initiator: scope
          });
          break;
        }
      }
    },
    "bpmn:TerminateEventDefinition": (context) => {
      const {
        scope
      } = context;
      this._scopeBehavior.terminate(scope.parent, scope);
    },
    "bpmn:CancelEventDefinition": (context) => {
      const {
        scope,
        element: element2
      } = context;
      this._simulator.trigger({
        event: element2,
        initiator: scope,
        scope: findSubscriptionScope(scope)
      });
    },
    "bpmn:CompensateEventDefinition": (context) => {
      const {
        scope,
        element: element2
      } = context;
      return this._simulator.waitForScopes(
        scope,
        this._simulator.trigger({
          event: element2,
          scope: findSubscriptionScope(scope)
        })
      );
    }
  };
  const entry = Object.entries(behaviors).find(
    (entry2) => isTypedEvent4(element, entry2[0])
  );
  return entry && entry[1];
};
function getLinkDefinition(element) {
  return getEventDefinition4(element, "bpmn:LinkEventDefinition");
}
function findSubscriptionScope(scope) {
  while (isEventSubProcess3(scope.parent.element)) {
    scope = scope.parent;
  }
  return scope.parent;
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/ScopeBehavior.js
var PRE_EXIT_EVENT = {
  type: "pre-exit",
  persistent: true,
  interrupting: true,
  boundary: false
};
var EXIT_EVENT = {
  type: "exit",
  interrupting: true,
  boundary: false,
  persistent: true
};
function ScopeBehavior(simulator) {
  this._simulator = simulator;
}
ScopeBehavior.$inject = [
  "simulator"
];
ScopeBehavior.prototype.isFinished = function(scope, excludeScope = null) {
  excludeScope = matchScope(excludeScope);
  return scope.children.every((c5) => c5.destroyed || c5.completed || excludeScope(c5));
};
ScopeBehavior.prototype.destroyChildren = function(scope, initiator, excludeScope = null) {
  excludeScope = matchScope(excludeScope);
  scope.children.filter((c5) => !c5.destroyed && !excludeScope(c5)).map((c5) => {
    this._simulator.destroyScope(c5, initiator);
  });
};
ScopeBehavior.prototype.terminate = function(scope, initiator) {
  this.destroyChildren(scope, initiator);
  scope.terminate(initiator);
  this.tryExit(scope, initiator);
};
ScopeBehavior.prototype.interrupt = function(scope, initiator) {
  this.destroyChildren(scope, initiator, initiator);
  scope.fail(initiator);
};
ScopeBehavior.prototype.tryExit = function(scope, initiator) {
  if (!scope) {
    throw new Error("missing <scope>");
  }
  if (!initiator) {
    initiator = scope;
  }
  if (!this.isFinished(scope, initiator)) {
    return EXIT_EVENT;
  }
  const preExitSubscriptions = this._simulator.findSubscriptions({
    event: PRE_EXIT_EVENT,
    scope
  });
  for (const subscription of preExitSubscriptions) {
    const {
      event: event2,
      scope: scope2
    } = subscription;
    const scopes = this._simulator.trigger({
      event: event2,
      scope: scope2,
      initiator
    });
    if (scopes.length) {
      return EXIT_EVENT;
    }
  }
  this._simulator.trigger({
    event: EXIT_EVENT,
    scope,
    initiator
  });
  this.exit({
    scope,
    initiator
  });
};
ScopeBehavior.prototype.exit = function(context) {
  const {
    scope,
    initiator
  } = context;
  if (!initiator) {
    throw new Error("missing <initiator>");
  }
  this._simulator.exit({
    element: scope.element,
    scope,
    initiator
  });
};
ScopeBehavior.prototype.preExit = function(scope, triggerFn) {
  const subscription = this._simulator.subscribe(scope, PRE_EXIT_EVENT, (initiator) => {
    subscription.remove();
    return triggerFn(initiator);
  });
  return subscription;
};
function matchScope(fnOrScope) {
  if (typeof fnOrScope === "function") {
    return fnOrScope;
  }
  return (scope) => scope === fnOrScope;
}

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/ProcessBehavior.js
function ProcessBehavior(simulator, scopeBehavior) {
  this._simulator = simulator;
  this._scopeBehavior = scopeBehavior;
  simulator.registerBehavior("bpmn:Process", this);
  simulator.registerBehavior("bpmn:Participant", this);
}
ProcessBehavior.prototype.signal = function(context) {
  const {
    element,
    startEvent,
    startNodes = this._findStarts(element, startEvent),
    scope
  } = context;
  if (!startNodes.length) {
    throw new Error("missing <startNodes> or <startEvent>");
  }
  for (const startNode of startNodes) {
    if (isStartEvent(startNode)) {
      this._simulator.signal({
        element: startNode,
        parentScope: scope
      });
    } else {
      this._simulator.enter({
        element: startNode,
        scope
      });
    }
  }
};
ProcessBehavior.prototype.exit = function(context) {
  const {
    scope,
    initiator
  } = context;
  this._scopeBehavior.destroyChildren(scope, initiator);
};
ProcessBehavior.prototype._findStarts = function(element, startEvent) {
  const isStartEvent2 = startEvent ? (node2) => startEvent === node2 : (node2) => isNoneStartEvent(node2);
  return element.children.filter(
    (node2) => isStartEvent2(node2) || isImplicitStartEvent(node2)
  );
};
ProcessBehavior.$inject = [
  "simulator",
  "scopeBehavior"
];

// node_modules/bpmn-js-token-simulation/lib/simulator/behaviors/index.js
var behaviors_default = {
  __init__: [
    "startEventBehavior",
    "endEventBehavior",
    "boundaryEventBehavior",
    "intermediateCatchEventBehavior",
    "intermediateThrowEventBehavior",
    "exclusiveGatewayBehavior",
    "parallelGatewayBehavior",
    "eventBasedGatewayBehavior",
    "inclusiveGatewayBehavior",
    "subProcessBehavior",
    "sequenceFlowBehavior",
    "messageFlowBehavior",
    "processBehavior"
  ],
  startEventBehavior: ["type", StartEventBehavior],
  endEventBehavior: ["type", EndEventBehavior],
  boundaryEventBehavior: ["type", BoundaryEventBehavior2],
  intermediateCatchEventBehavior: ["type", IntermediateCatchEventBehavior],
  intermediateThrowEventBehavior: ["type", IntermediateThrowEventBehavior],
  exclusiveGatewayBehavior: ["type", ExclusiveGatewayBehavior],
  parallelGatewayBehavior: ["type", ParallelGatewayBehavior],
  eventBasedGatewayBehavior: ["type", EventBasedGatewayBehavior2],
  inclusiveGatewayBehavior: ["type", InclusiveGatewayBehavior],
  activityBehavior: ["type", ActivityBehavior],
  subProcessBehavior: ["type", SubProcessBehavior],
  sequenceFlowBehavior: ["type", SequenceFlowBehavior],
  messageFlowBehavior: ["type", MessageFlowBehavior2],
  eventBehaviors: ["type", EventBehaviors],
  scopeBehavior: ["type", ScopeBehavior],
  processBehavior: ["type", ProcessBehavior],
  transactionBehavior: ["type", TransactionBehavior]
};

// node_modules/bpmn-js-token-simulation/lib/simulator/index.js
var HIGH_PRIORITY21 = 5e3;
var simulator_default = {
  __depends__: [
    behaviors_default
  ],
  __init__: [
    ["eventBus", "simulator", function(eventBus, simulator) {
      eventBus.on([
        "tokenSimulation.toggleMode",
        "tokenSimulation.resetSimulation"
      ], HIGH_PRIORITY21, (event2) => {
        simulator.reset();
      });
    }]
  ],
  simulator: ["type", Simulator]
};

// node_modules/bpmn-js-token-simulation/lib/animation/behaviors/AnimatedMessageFlowBehavior.js
function AnimatedMessageFlowBehavior(injector, animation) {
  injector.invoke(MessageFlowBehavior2, this);
  this._animation = animation;
}
e(AnimatedMessageFlowBehavior, MessageFlowBehavior2);
AnimatedMessageFlowBehavior.$inject = [
  "injector",
  "animation"
];
AnimatedMessageFlowBehavior.prototype.signal = function(context) {
  const {
    element,
    scope
  } = context;
  this._animation.animate(element, scope, () => {
    MessageFlowBehavior2.prototype.signal.call(this, context);
  });
};

// node_modules/bpmn-js-token-simulation/lib/animation/behaviors/AnimatedSequenceFlowBehavior.js
function AnimatedSequenceFlowBehavior(injector, animation) {
  injector.invoke(SequenceFlowBehavior, this);
  this._animation = animation;
}
e(AnimatedSequenceFlowBehavior, SequenceFlowBehavior);
AnimatedSequenceFlowBehavior.$inject = [
  "injector",
  "animation"
];
AnimatedSequenceFlowBehavior.prototype.enter = function(context) {
  const {
    element,
    scope
  } = context;
  this._animation.animate(element, scope, () => {
    SequenceFlowBehavior.prototype.enter.call(this, context);
  });
};

// node_modules/bpmn-js-token-simulation/lib/animation/behaviors/index.js
var behaviors_default2 = {
  sequenceFlowBehavior: ["type", AnimatedSequenceFlowBehavior],
  messageFlowBehavior: ["type", AnimatedMessageFlowBehavior]
};

// node_modules/bpmn-js-token-simulation/lib/util/EventHelper.js
var EventHelper_exports = {};
__export(EventHelper_exports, {
  ANIMATION_CREATED_EVENT: () => ANIMATION_CREATED_EVENT,
  ANIMATION_SPEED_CHANGED_EVENT: () => ANIMATION_SPEED_CHANGED_EVENT,
  ELEMENT_CHANGED_EVENT: () => ELEMENT_CHANGED_EVENT,
  PAUSE_SIMULATION_EVENT: () => PAUSE_SIMULATION_EVENT,
  PLAY_SIMULATION_EVENT: () => PLAY_SIMULATION_EVENT,
  RESET_SIMULATION_EVENT: () => RESET_SIMULATION_EVENT,
  SCOPE_CHANGED_EVENT: () => SCOPE_CHANGED_EVENT,
  SCOPE_CREATE_EVENT: () => SCOPE_CREATE_EVENT,
  SCOPE_DESTROYED_EVENT: () => SCOPE_DESTROYED_EVENT,
  SCOPE_FILTER_CHANGED_EVENT: () => SCOPE_FILTER_CHANGED_EVENT,
  TOGGLE_MODE_EVENT: () => TOGGLE_MODE_EVENT,
  TRACE_EVENT: () => TRACE_EVENT
});
var TOGGLE_MODE_EVENT = "tokenSimulation.toggleMode";
var PLAY_SIMULATION_EVENT = "tokenSimulation.playSimulation";
var PAUSE_SIMULATION_EVENT = "tokenSimulation.pauseSimulation";
var RESET_SIMULATION_EVENT = "tokenSimulation.resetSimulation";
var ANIMATION_CREATED_EVENT = "tokenSimulation.animationCreated";
var ANIMATION_SPEED_CHANGED_EVENT = "tokenSimulation.animationSpeedChanged";
var ELEMENT_CHANGED_EVENT = "tokenSimulation.simulator.elementChanged";
var SCOPE_DESTROYED_EVENT = "tokenSimulation.simulator.destroyScope";
var SCOPE_CHANGED_EVENT = "tokenSimulation.simulator.scopeChanged";
var SCOPE_CREATE_EVENT = "tokenSimulation.simulator.createScope";
var SCOPE_FILTER_CHANGED_EVENT = "tokenSimulation.scopeFilterChanged";
var TRACE_EVENT = "tokenSimulation.simulator.trace";

// node_modules/bpmn-js-token-simulation/lib/features/scope-filter/ScopeFilter.js
var DEFAULT_SCOPE_FILTER = (s5) => true;
function ScopeFilter(eventBus, simulator) {
  this._eventBus = eventBus;
  this._simulator = simulator;
  this._filter = DEFAULT_SCOPE_FILTER;
  eventBus.on([
    TOGGLE_MODE_EVENT,
    RESET_SIMULATION_EVENT
  ], () => {
    this._filter = DEFAULT_SCOPE_FILTER;
  });
  eventBus.on(SCOPE_DESTROYED_EVENT, (event2) => {
    const {
      scope
    } = event2;
    if (this._scope === scope && scope.parent) {
      this.toggle(scope.parent);
    }
  });
  eventBus.on(SCOPE_CREATE_EVENT, (event2) => {
    const {
      scope
    } = event2;
    if (!scope.parent && this._scope && !isAncestor(this._scope, scope)) {
      this.toggle(null);
    }
  });
}
ScopeFilter.prototype.toggle = function(scope) {
  const setFilter = this._scope !== scope;
  this._scope = setFilter ? scope : null;
  this._filter = this._scope ? (s5) => isAncestor(this._scope, s5) : (s5) => true;
  this._eventBus.fire(SCOPE_FILTER_CHANGED_EVENT, {
    filter: this._filter,
    scope: this._scope
  });
};
ScopeFilter.prototype.isShown = function(scope) {
  if (typeof scope === "string") {
    scope = this._simulator.findScope((s5) => s5.id === scope);
  }
  return scope && this._filter(scope);
};
ScopeFilter.prototype.isFocused = function(scope) {
  var _a;
  const id = scope.id || scope;
  return ((_a = this._scope) == null ? void 0 : _a.id) === id;
};
ScopeFilter.prototype.findScope = function(options) {
  return this._simulator.findScopes(options).filter((s5) => this.isShown(s5))[0];
};
ScopeFilter.$inject = [
  "eventBus",
  "simulator"
];
function isAncestor(parent, scope) {
  do {
    if (parent === scope) {
      return true;
    }
  } while (scope = scope.parent);
  return false;
}

// node_modules/bpmn-js-token-simulation/lib/features/scope-filter/index.js
var scope_filter_default = {
  scopeFilter: ["type", ScopeFilter]
};

// node_modules/bpmn-js-token-simulation/lib/animation/Animation.js
var STYLE = getComputedStyle(document.documentElement);
var DEFAULT_PRIMARY_COLOR = STYLE.getPropertyValue("--token-simulation-green-base-44");
var DEFAULT_AUXILIARY_COLOR = STYLE.getPropertyValue("--token-simulation-white");
function noop() {
}
function getSegmentEasing(index5, waypoints) {
  if (waypoints.length === 2) {
    return EASE_IN_OUT;
  }
  if (index5 === 1) {
    return EASE_IN;
  }
  if (index5 === waypoints.length - 1) {
    return EASE_OUT;
  }
  return EASE_LINEAR;
}
var EASE_LINEAR = function(pos) {
  return pos;
};
var EASE_IN = function(pos) {
  return -Math.cos(pos * Math.PI / 2) + 1;
};
var EASE_OUT = function(pos) {
  return Math.sin(pos * Math.PI / 2);
};
var EASE_IN_OUT = function(pos) {
  return -Math.cos(pos * Math.PI) / 2 + 0.5;
};
var TOKEN_SIZE = 20;
function Animation(config, canvas, eventBus, scopeFilter) {
  this._eventBus = eventBus;
  this._scopeFilter = scopeFilter;
  this._canvas = canvas;
  this._randomize = config && config.randomize !== false;
  this._animations = /* @__PURE__ */ new Set();
  this._speed = 1;
  eventBus.on([
    "diagram.destroy",
    RESET_SIMULATION_EVENT
  ], () => {
    this.clearAnimations();
  });
  eventBus.on(PAUSE_SIMULATION_EVENT, () => {
    this.pause();
  });
  eventBus.on(PLAY_SIMULATION_EVENT, () => {
    this.play();
  });
  eventBus.on(SCOPE_FILTER_CHANGED_EVENT, (event2) => {
    this.each((animation) => {
      if (this._scopeFilter.isShown(animation.scope)) {
        animation.show();
      } else {
        animation.hide();
      }
    });
  });
  eventBus.on(SCOPE_DESTROYED_EVENT, (event2) => {
    const {
      scope
    } = event2;
    this.clearAnimations(scope);
  });
}
Animation.prototype.animate = function(connection, scope, done) {
  this.createAnimation(connection, scope, done);
};
Animation.prototype.pause = function() {
  this.each((animation) => animation.pause());
};
Animation.prototype.play = function() {
  this.each((animation) => animation.play());
};
Animation.prototype.each = function(fn2) {
  this._animations.forEach(fn2);
};
Animation.prototype.createAnimation = function(connection, scope, done = noop) {
  const group = this._getGroup(scope);
  if (!group) {
    return;
  }
  const tokenGfx = this._createTokenGfx(group, scope);
  const animation = new TokenAnimation(tokenGfx, connection.waypoints, this._randomize, () => {
    this._clearAnimation(animation);
    done();
  });
  animation.setSpeed(this.getAnimationSpeed());
  if (!this._scopeFilter.isShown(scope)) {
    animation.hide();
  }
  animation.scope = scope;
  animation.element = connection;
  this._animations.add(animation);
  this._eventBus.fire(ANIMATION_CREATED_EVENT, {
    animation
  });
  animation.play();
  return animation;
};
Animation.prototype.setAnimationSpeed = function(speed) {
  this._speed = speed;
  this.each((animation) => animation.setSpeed(speed));
  this._eventBus.fire(ANIMATION_SPEED_CHANGED_EVENT, {
    speed
  });
};
Animation.prototype.getAnimationSpeed = function() {
  return this._speed;
};
Animation.prototype.clearAnimations = function(scope) {
  this.each((animation) => {
    if (!scope || animation.scope === scope) {
      this._clearAnimation(animation);
    }
  });
};
Animation.prototype._clearAnimation = function(animation) {
  animation.remove();
  this._animations.delete(animation);
};
Animation.prototype._createTokenGfx = function(group, scope) {
  const parent = create(this._getTokenSVG(scope).trim());
  return appendTo(parent, group);
};
Animation.prototype._getTokenSVG = function(scope) {
  const colors2 = scope.colors || {
    primary: DEFAULT_PRIMARY_COLOR,
    auxiliary: DEFAULT_AUXILIARY_COLOR
  };
  return `
    <g class="bts-token">
      <circle
        class="bts-circle"
        r="${TOKEN_SIZE / 2}"
        cx="${TOKEN_SIZE / 2}"
        cy="${TOKEN_SIZE / 2}"
        fill="${colors2.primary}"
      />
      <text
        class="bts-text"
        transform="translate(10, 14)"
        text-anchor="middle"
        fill="${colors2.auxiliary}"
      >1</text>
    </g>
  `;
};
Animation.prototype._getGroup = function(scope) {
  var canvas = this._canvas;
  var layer, root;
  if ("findRoot" in canvas) {
    root = canvas.findRoot(scope.element);
    layer = canvas._findPlaneForRoot(root).layer;
  } else {
    layer = query(".viewport", canvas._svg);
  }
  var group = query(".bts-animation-tokens", layer);
  if (!group) {
    group = create('<g class="bts-animation-tokens" />');
    appendTo(
      group,
      layer
    );
  }
  return group;
};
Animation.$inject = [
  "config.animation",
  "canvas",
  "eventBus",
  "scopeFilter"
];
function TokenAnimation(gfx, waypoints, randomize, done) {
  this.gfx = gfx;
  this.waypoints = waypoints;
  this.done = done;
  this.randomize = randomize;
  this._paused = true;
  this._t = 0;
  this._parts = [];
  this.create();
}
TokenAnimation.prototype.pause = function() {
  this._paused = true;
};
TokenAnimation.prototype.play = function() {
  if (this._paused) {
    this._paused = false;
    this.tick(0);
  }
  this.schedule();
};
TokenAnimation.prototype.schedule = function() {
  if (this._paused) {
    return;
  }
  if (this._scheduled) {
    return;
  }
  const last4 = Date.now();
  this._scheduled = true;
  requestAnimationFrame(() => {
    this._scheduled = false;
    if (this._paused) {
      return;
    }
    this.tick((Date.now() - last4) * this._speed);
    this.schedule();
  });
};
TokenAnimation.prototype.tick = function(tElapsed) {
  const t7 = this._t = this._t + tElapsed;
  const part = this._parts.find(
    (p5) => p5.startTime <= t7 && p5.endTime > t7
  );
  if (!part) {
    return this.completed();
  }
  const segmentTime = t7 - part.startTime;
  const segmentLength = part.length * part.easing(segmentTime / part.duration);
  const currentLength = part.startLength + segmentLength;
  const point = this._path.getPointAtLength(currentLength);
  this.move(point.x, point.y);
};
TokenAnimation.prototype.move = function(x6, y5) {
  attr(this.gfx, "transform", `translate(${x6}, ${y5})`);
};
TokenAnimation.prototype.create = function() {
  const waypoints = this.waypoints;
  const parts = waypoints.reduce((parts2, point, index5) => {
    const lastPoint = waypoints[index5 - 1];
    if (lastPoint) {
      const lastPart = parts2[parts2.length - 1];
      const startLength = lastPart && lastPart.endLength || 0;
      const length2 = distance3(lastPoint, point);
      parts2.push({
        startLength,
        endLength: startLength + length2,
        length: length2,
        easing: getSegmentEasing(index5, waypoints)
      });
    }
    return parts2;
  }, []);
  const totalLength = parts.reduce(function(length2, part) {
    return length2 + part.length;
  }, 0);
  const d5 = waypoints.reduce((d6, waypoint, index5) => {
    const x6 = waypoint.x - TOKEN_SIZE / 2, y5 = waypoint.y - TOKEN_SIZE / 2;
    d6.push([index5 > 0 ? "L" : "M", x6, y5]);
    return d6;
  }, []).flat().join(" ");
  const totalDuration = getAnimationDuration(totalLength, this._randomize);
  this._parts = parts.reduce((parts2, part, index5) => {
    const duration = totalDuration / totalLength * part.length;
    const startTime = index5 > 0 ? parts2[index5 - 1].endTime : 0;
    const endTime = startTime + duration;
    return [
      ...parts2,
      {
        ...part,
        startTime,
        endTime,
        duration
      }
    ];
  }, []);
  this._path = create(`<path d="${d5}" />`);
  this._t = 0;
};
TokenAnimation.prototype.show = function() {
  attr(this.gfx, "display", "");
};
TokenAnimation.prototype.hide = function() {
  attr(this.gfx, "display", "none");
};
TokenAnimation.prototype.completed = function() {
  this.done();
};
TokenAnimation.prototype.remove = function() {
  this.pause();
  remove(this.gfx);
};
TokenAnimation.prototype.setSpeed = function(speed) {
  this._speed = speed;
};
function getAnimationDuration(length2, randomize = false) {
  return Math.log(length2) * (randomize ? randomBetween(250, 300) : 250);
}
function randomBetween(min5, max8) {
  return min5 + Math.floor(Math.random() * (max8 - min5));
}
function distance3(a6, b4) {
  return Math.sqrt(Math.pow(a6.x - b4.x, 2) + Math.pow(a6.y - b4.y, 2));
}

// node_modules/bpmn-js-token-simulation/lib/animation/index.js
var animation_default = {
  __depends__: [
    simulator_default,
    behaviors_default2,
    scope_filter_default
  ],
  animation: ["type", Animation]
};

// node_modules/bpmn-js-token-simulation/lib/features/colored-scopes/ColoredScopes.js
var import_randomcolor = __toESM(require_randomColor());
var HIGH_PRIORITY22 = 1500;
function ColoredScopes(eventBus) {
  const colors2 = (0, import_randomcolor.default)({
    count: 60
  }).filter((c5) => getContrastYIQ(c5.substring(1)) < 200);
  function getContrastYIQ(hexcolor) {
    var r7 = parseInt(hexcolor.substr(0, 2), 16);
    var g6 = parseInt(hexcolor.substr(2, 2), 16);
    var b4 = parseInt(hexcolor.substr(4, 2), 16);
    var yiq = (r7 * 299 + g6 * 587 + b4 * 114) / 1e3;
    return yiq;
  }
  let colorsIdx = 0;
  function getColors(scope) {
    const {
      element
    } = scope;
    if (element && element.type === "bpmn:MessageFlow") {
      return {
        primary: "#999",
        auxiliary: "#FFF"
      };
    }
    if (scope.parent) {
      return scope.parent.colors;
    }
    const primary = colors2[colorsIdx++ % colors2.length];
    return {
      primary,
      auxiliary: getContrastYIQ(primary) >= 128 ? "#111" : "#fff"
    };
  }
  eventBus.on(SCOPE_CREATE_EVENT, HIGH_PRIORITY22, (event2) => {
    const {
      scope
    } = event2;
    scope.colors = getColors(scope);
  });
}
ColoredScopes.$inject = [
  "eventBus"
];

// node_modules/bpmn-js-token-simulation/lib/features/colored-scopes/index.js
var colored_scopes_default = {
  __init__: [
    "coloredScopes"
  ],
  coloredScopes: ["type", ColoredScopes]
};

// node_modules/bpmn-js-token-simulation/lib/icons/index.js
var LogSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M12.83 352h262.34A12.82 12.82 0 0 0 288 339.17v-38.34A12.82 12.82 0 0 0 275.17 288H12.83A12.82 12.82 0 0 0 0 300.83v38.34A12.82 12.82 0 0 0 12.83 352zm0-256h262.34A12.82 12.82 0 0 0 288 83.17V44.83A12.82 12.82 0 0 0 275.17 32H12.83A12.82 12.82 0 0 0 0 44.83v38.34A12.82 12.82 0 0 0 12.83 96zM432 160H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16zm0 256H16a16 16 0 0 0-16 16v32a16 16 0 0 0 16 16h416a16 16 0 0 0 16-16v-32a16 16 0 0 0-16-16z"/></svg>';
var AngleRightSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg>';
var CheckCircleSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M504 256c0 136.967-111.033 248-248 248S8 392.967 8 256 119.033 8 256 8s248 111.033 248 248zM227.314 387.314l184-184c6.248-6.248 6.248-16.379 0-22.627l-22.627-22.627c-6.248-6.249-16.379-6.249-22.628 0L216 308.118l-70.059-70.059c-6.248-6.248-16.379-6.248-22.628 0l-22.627 22.627c-6.248 6.248-6.248 16.379 0 22.627l104 104c6.249 6.249 16.379 6.249 22.628.001z"/></svg>';
var ForkSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 384 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M384 144c0-44.2-35.8-80-80-80s-80 35.8-80 80c0 36.4 24.3 67.1 57.5 76.8-.6 16.1-4.2 28.5-11 36.9-15.4 19.2-49.3 22.4-85.2 25.7-28.2 2.6-57.4 5.4-81.3 16.9v-144c32.5-10.2 56-40.5 56-76.3 0-44.2-35.8-80-80-80S0 35.8 0 80c0 35.8 23.5 66.1 56 76.3v199.3C23.5 365.9 0 396.2 0 432c0 44.2 35.8 80 80 80s80-35.8 80-80c0-34-21.2-63.1-51.2-74.6 3.1-5.2 7.8-9.8 14.9-13.4 16.2-8.2 40.4-10.4 66.1-12.8 42.2-3.9 90-8.4 118.2-43.4 14-17.4 21.1-39.8 21.6-67.9 31.6-10.8 54.4-40.7 54.4-75.9zM80 64c8.8 0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16zm0 384c-8.8 0-16-7.2-16-16s7.2-16 16-16 16 7.2 16 16-7.2 16-16 16zm224-320c8.8 0 16 7.2 16 16s-7.2 16-16 16-16-7.2-16-16 7.2-16 16-16z"/></svg>';
var ExclamationTriangleSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></svg>';
var InfoSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 192 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M20 424.229h20V279.771H20c-11.046 0-20-8.954-20-20V212c0-11.046 8.954-20 20-20h112c11.046 0 20 8.954 20 20v212.229h20c11.046 0 20 8.954 20 20V492c0 11.046-8.954 20-20 20H20c-11.046 0-20-8.954-20-20v-47.771c0-11.046 8.954-20 20-20zM96 0C56.235 0 24 32.235 24 72s32.235 72 72 72 72-32.235 72-72S135.764 0 96 0z"/></svg>';
var PauseSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M144 479H48c-26.5 0-48-21.5-48-48V79c0-26.5 21.5-48 48-48h96c26.5 0 48 21.5 48 48v352c0 26.5-21.5 48-48 48zm304-48V79c0-26.5-21.5-48-48-48h-96c-26.5 0-48 21.5-48 48v352c0 26.5 21.5 48 48 48h96c26.5 0 48-21.5 48-48z"/></svg>';
var RemovePauseSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 580.5 448">\n  <path fill="currentColor" d="M112 0C85 0 64 22 64 48v196l192-89V48c0-26-22-48-48-48zm256 0c-27 0-48 22-48 48v77l190-89c-5-21-24-36-46-36Zm144 105-192 89v70l192-89zM256 224 64 314v70l192-90zm256 21-192 89v66c0 27 21 48 48 48h96c26 0 48-21 48-48zM256 364 89 442c7 4 14 6 23 6h96c26 0 48-21 48-48z"/>\n  <rect fill="currentColor" width="63.3" height="618.2" x="311.5" y="-469.4" transform="rotate(65)" rx="10"/>\n</svg>\n';
var PlaySVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 448 512"><!-- Adapted from Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M424.4 214.7L72.4 6.6C43.8-10.3 0 6.1 0 47.9V464c0 37.5 40.7 60.1 72.4 41.3l352-208c31.4-18.5 31.5-64.1 0-82.6z"/></svg>';
var ResetSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M440.65 12.57l4 82.77A247.16 247.16 0 0 0 255.83 8C134.73 8 33.91 94.92 12.29 209.82A12 12 0 0 0 24.09 224h49.05a12 12 0 0 0 11.67-9.26 175.91 175.91 0 0 1 317-56.94l-101.46-4.86a12 12 0 0 0-12.57 12v47.41a12 12 0 0 0 12 12H500a12 12 0 0 0 12-12V12a12 12 0 0 0-12-12h-47.37a12 12 0 0 0-11.98 12.57zM255.83 432a175.61 175.61 0 0 1-146-77.8l101.8 4.87a12 12 0 0 0 12.57-12v-47.4a12 12 0 0 0-12-12H12a12 12 0 0 0-12 12V500a12 12 0 0 0 12 12h47.35a12 12 0 0 0 12-12.6l-4.15-82.57A247.17 247.17 0 0 0 255.83 504c121.11 0 221.93-86.92 243.55-201.82a12 12 0 0 0-11.8-14.18h-49.05a12 12 0 0 0-11.67 9.26A175.86 175.86 0 0 1 255.83 432z"/></svg>';
var TachometerSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M288 32C128.94 32 0 160.94 0 320c0 52.8 14.25 102.26 39.06 144.8 5.61 9.62 16.3 15.2 27.44 15.2h443c11.14 0 21.83-5.58 27.44-15.2C561.75 422.26 576 372.8 576 320c0-159.06-128.94-288-288-288zm0 64c14.71 0 26.58 10.13 30.32 23.65-1.11 2.26-2.64 4.23-3.45 6.67l-9.22 27.67c-5.13 3.49-10.97 6.01-17.64 6.01-17.67 0-32-14.33-32-32S270.33 96 288 96zM96 384c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm48-160c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32zm246.77-72.41l-61.33 184C343.13 347.33 352 364.54 352 384c0 11.72-3.38 22.55-8.88 32H232.88c-5.5-9.45-8.88-20.28-8.88-32 0-33.94 26.5-61.43 59.9-63.59l61.34-184.01c4.17-12.56 17.73-19.45 30.36-15.17 12.57 4.19 19.35 17.79 15.17 30.36zm14.66 57.2l15.52-46.55c3.47-1.29 7.13-2.23 11.05-2.23 17.67 0 32 14.33 32 32s-14.33 32-32 32c-11.38-.01-20.89-6.28-26.57-15.22zM480 384c-17.67 0-32-14.33-32-32s14.33-32 32-32 32 14.33 32 32-14.33 32-32 32z"/></svg>';
var TimesCircleSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M256 8C119 8 8 119 8 256s111 248 248 248 248-111 248-248S393 8 256 8zm121.6 313.1c4.7 4.7 4.7 12.3 0 17L338 377.6c-4.7 4.7-12.3 4.7-17 0L256 312l-65.1 65.6c-4.7 4.7-12.3 4.7-17 0L134.4 338c-4.7-4.7-4.7-12.3 0-17l65.6-65-65.6-65.1c-4.7-4.7-4.7-12.3 0-17l39.6-39.6c4.7-4.7 12.3-4.7 17 0l65 65.7 65.1-65.6c4.7-4.7 12.3-4.7 17 0l39.6 39.6c4.7 4.7 4.7 12.3 0 17L312 256l65.6 65.1z"/></svg>';
var TimesSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 352 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M242.72 256l100.07-100.07c12.28-12.28 12.28-32.19 0-44.48l-22.24-22.24c-12.28-12.28-32.19-12.28-44.48 0L176 189.28 75.93 89.21c-12.28-12.28-32.19-12.28-44.48 0L9.21 111.45c-12.28 12.28-12.28 32.19 0 44.48L109.28 256 9.21 356.07c-12.28 12.28-12.28 32.19 0 44.48l22.24 22.24c12.28 12.28 32.2 12.28 44.48 0L176 322.72l100.07 100.07c12.28 12.28 32.2 12.28 44.48 0l22.24-22.24c12.28-12.28 12.28-32.19 0-44.48L242.72 256z"/></svg>';
var ToggleOffSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M384 64H192C85.961 64 0 149.961 0 256s85.961 192 192 192h192c106.039 0 192-85.961 192-192S490.039 64 384 64zM64 256c0-70.741 57.249-128 128-128 70.741 0 128 57.249 128 128 0 70.741-57.249 128-128 128-70.741 0-128-57.249-128-128zm320 128h-48.905c65.217-72.858 65.236-183.12 0-256H384c70.741 0 128 57.249 128 128 0 70.74-57.249 128-128 128z"/></svg>';
var ToggleOnSVG = '<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path fill="currentColor" d="M384 64H192C86 64 0 150 0 256s86 192 192 192h192c106 0 192-86 192-192S490 64 384 64zm0 320c-70.8 0-128-57.3-128-128 0-70.8 57.3-128 128-128 70.8 0 128 57.3 128 128 0 70.8-57.3 128-128 128z"/></svg>';
function createIcon(svg) {
  return function Icon(className = "") {
    return `<span class="bts-icon ${className}">${svg}</span>`;
  };
}
var LogIcon = createIcon(LogSVG);
var AngleRightIcon = createIcon(AngleRightSVG);
var CheckCircleIcon = createIcon(CheckCircleSVG);
var RemovePauseIcon = createIcon(RemovePauseSVG);
var ForkIcon = createIcon(ForkSVG);
var ExclamationTriangleIcon = createIcon(ExclamationTriangleSVG);
var InfoIcon = createIcon(InfoSVG);
var PauseIcon = createIcon(PauseSVG);
var PlayIcon = createIcon(PlaySVG);
var ResetIcon = createIcon(ResetSVG);
var TachometerIcon = createIcon(TachometerSVG);
var TimesCircleIcon = createIcon(TimesCircleSVG);
var TimesIcon = createIcon(TimesSVG);
var ToggleOffIcon = createIcon(ToggleOffSVG);
var ToggleOnIcon = createIcon(ToggleOnSVG);

// node_modules/bpmn-js-token-simulation/lib/features/context-pads/handler/ExclusiveGatewayHandler.js
function ExclusiveGatewayHandler(exclusiveGatewaySettings) {
  this._exclusiveGatewaySettings = exclusiveGatewaySettings;
}
ExclusiveGatewayHandler.prototype.createContextPads = function(element) {
  const outgoingFlows = element.outgoing.filter(function(outgoing) {
    return is(outgoing, "bpmn:SequenceFlow");
  });
  if (outgoingFlows.length < 2) {
    return;
  }
  const html = `
    <div class="bts-context-pad" title="Set Sequence Flow">
      ${ForkIcon()}
    </div>
  `;
  const action = () => {
    this._exclusiveGatewaySettings.setSequenceFlow(element);
  };
  return [
    {
      action,
      element,
      html
    }
  ];
};
ExclusiveGatewayHandler.$inject = [
  "exclusiveGatewaySettings"
];

// node_modules/bpmn-js-token-simulation/lib/features/context-pads/handler/InclusiveGatewayHandler.js
function InclusiveGatewayHandler(inclusiveGatewaySettings) {
  this._inclusiveGatewaySettings = inclusiveGatewaySettings;
}
InclusiveGatewayHandler.prototype.createContextPads = function(element) {
  const outgoingFlows = element.outgoing.filter(isSequenceFlow2);
  if (outgoingFlows.length < 2) {
    return;
  }
  const nonDefaultFlows = outgoingFlows.filter((outgoing) => {
    const flowBo = getBusinessObject(outgoing), gatewayBo = getBusinessObject(element);
    return gatewayBo.default !== flowBo;
  });
  const html = `
    <div class="bts-context-pad" title="Set Sequence Flow">
      ${ForkIcon()}
    </div>
  `;
  return nonDefaultFlows.map((sequenceFlow) => {
    const action = () => {
      this._inclusiveGatewaySettings.toggleSequenceFlow(element, sequenceFlow);
    };
    return {
      action,
      element: sequenceFlow,
      html
    };
  });
};
InclusiveGatewayHandler.$inject = [
  "inclusiveGatewaySettings"
];

// node_modules/bpmn-js-token-simulation/lib/features/context-pads/handler/PauseHandler.js
function PauseHandler(simulator) {
  this._simulator = simulator;
}
PauseHandler.prototype.createContextPads = function(element) {
  if (is(element, "bpmn:ReceiveTask") || is(element, "bpmn:SubProcess") && getBusinessObject(element).triggeredByEvent) {
    return [];
  }
  return [
    this.createPauseContextPad(element)
  ];
};
PauseHandler.prototype.createPauseContextPad = function(element) {
  const contexts = () => this._findSubscriptions({
    element
  });
  const wait = this._isPaused(element);
  const html = `
    <div class="bts-context-pad ${wait ? "" : "show-hover"}" title="${wait ? "Remove" : "Add"} pause point">
      ${(wait ? RemovePauseIcon : PauseIcon)("show-hover")}
      ${PauseIcon("hide-hover")}
    </div>
  `;
  const action = () => {
    this._togglePaused(element);
  };
  return {
    action,
    element,
    hideContexts: contexts,
    html
  };
};
PauseHandler.prototype._isPaused = function(element) {
  const {
    wait
  } = this._simulator.getConfig(element);
  return wait;
};
PauseHandler.prototype._togglePaused = function(element) {
  const wait = !this._isPaused(element);
  this._simulator.waitAtElement(element, wait);
};
PauseHandler.prototype._findSubscriptions = function(options) {
  return this._simulator.findSubscriptions(options);
};
PauseHandler.$inject = [
  "simulator"
];

// node_modules/bpmn-js-token-simulation/lib/features/context-pads/handler/TriggerHandler.js
function TriggerHandler(simulator) {
  this._simulator = simulator;
}
TriggerHandler.$inject = [
  "simulator"
];
TriggerHandler.prototype.createContextPads = function(element) {
  return [
    this.createTriggerContextPad(element)
  ];
};
TriggerHandler.prototype.createTriggerContextPad = function(element) {
  const contexts = () => {
    const subscriptions = this._findSubscriptions({
      element
    });
    const sortedSubscriptions = subscriptions.slice().sort((a6, b4) => {
      return a6.event.type === "none" ? 1 : -1;
    });
    return sortedSubscriptions;
  };
  const html = `
    <div class="bts-context-pad" title="Trigger Event">
      ${PlayIcon()}
    </div>
  `;
  const action = (subscriptions) => {
    const {
      event: event2,
      scope
    } = subscriptions[0];
    return this._simulator.trigger({
      event: event2,
      scope
    });
  };
  return {
    action,
    element,
    html,
    contexts
  };
};
TriggerHandler.prototype._findSubscriptions = function(options) {
  return this._simulator.findSubscriptions(options);
};

// node_modules/bpmn-js-token-simulation/lib/features/context-pads/ContextPads.js
var LOW_PRIORITY29 = 500;
var OFFSET_TOP = -15;
var OFFSET_LEFT = -15;
function ContextPads(eventBus, elementRegistry, overlays, injector, canvas, scopeFilter) {
  this._elementRegistry = elementRegistry;
  this._overlays = overlays;
  this._injector = injector;
  this._canvas = canvas;
  this._scopeFilter = scopeFilter;
  this._overlayCache = /* @__PURE__ */ new Map();
  this._handlerIdx = 0;
  this._handlers = [];
  this.registerHandler("bpmn:ExclusiveGateway", ExclusiveGatewayHandler);
  this.registerHandler("bpmn:InclusiveGateway", InclusiveGatewayHandler);
  this.registerHandler("bpmn:Activity", PauseHandler);
  this.registerHandler("bpmn:Event", TriggerHandler);
  this.registerHandler("bpmn:Gateway", TriggerHandler);
  this.registerHandler("bpmn:Activity", TriggerHandler);
  eventBus.on(TOGGLE_MODE_EVENT, LOW_PRIORITY29, (context) => {
    const active = context.active;
    if (active) {
      this.openContextPads();
    } else {
      this.closeContextPads();
    }
  });
  eventBus.on(RESET_SIMULATION_EVENT, LOW_PRIORITY29, () => {
    this.closeContextPads();
    this.openContextPads();
  });
  eventBus.on(SCOPE_FILTER_CHANGED_EVENT, (event2) => {
    const showElements = all(
      ".djs-overlay-bts-context-menu [data-scope-ids]",
      overlays._overlayRoot
    );
    for (const element of showElements) {
      const scopeIds = element.dataset.scopeIds.split(",");
      const shown = scopeIds.some((id) => scopeFilter.isShown(id));
      classes2(element).toggle("hidden", !shown);
    }
    const hideElements = all(
      ".djs-overlay-bts-context-menu [data-hide-scope-ids]",
      overlays._overlayRoot
    );
    for (const element of hideElements) {
      const scopeIds = element.dataset.hideScopeIds.split(",");
      const shown = scopeIds.some((id) => scopeFilter.isShown(id));
      classes2(element).toggle("hidden", shown);
    }
  });
  eventBus.on(ELEMENT_CHANGED_EVENT, LOW_PRIORITY29, (event2) => {
    const {
      element
    } = event2;
    this.updateElementContextPads(element);
  });
}
ContextPads.prototype.registerHandler = function(type, handlerCls) {
  const handler = this._injector.instantiate(handlerCls);
  handler.hash = String(this._handlerIdx++);
  this._handlers.push({ handler, type });
};
ContextPads.prototype.getHandlers = function(element) {
  return this._handlers.filter(
    ({ type }) => is(element, type)
  ).map(
    ({ handler }) => handler
  );
};
ContextPads.prototype.openContextPads = function(parent) {
  if (!parent) {
    parent = this._canvas.getRootElement();
  }
  this._elementRegistry.forEach((element) => {
    if (isAncestor2(parent, element)) {
      this.updateElementContextPads(element);
    }
  });
};
ContextPads.prototype._getOverlays = function(hash) {
  return this._overlayCache.get(hash) || [];
};
ContextPads.prototype._addOverlay = function(element, options) {
  const {
    handlerHash
  } = options;
  if (!handlerHash) {
    throw new Error("<handlerHash> required");
  }
  const overlayId = this._overlays.add(element, "bts-context-menu", {
    ...options,
    position: {
      top: OFFSET_TOP,
      left: OFFSET_LEFT
    },
    show: {
      minZoom: 0.5
    }
  });
  const overlay = this._overlays.get(overlayId);
  const overlayCache = this._overlayCache;
  if (!overlayCache.has(handlerHash)) {
    overlayCache.set(handlerHash, []);
  }
  overlayCache.get(handlerHash).push(overlay);
};
ContextPads.prototype._removeOverlay = function(overlay) {
  const {
    id,
    handlerHash
  } = overlay;
  this._overlays.remove(id);
  const overlays = this._overlayCache.get(handlerHash) || [];
  const idx = overlays.indexOf(overlay);
  if (idx !== -1) {
    overlays.splice(idx, 1);
  }
};
ContextPads.prototype.updateElementContextPads = function(element) {
  for (const handler of this.getHandlers(element)) {
    this._updateElementContextPads(element, handler);
  }
};
ContextPads.prototype._updateElementContextPads = function(element, handler) {
  const canvas = this._canvas;
  const contextPads = (handler.createContextPads(element) || []).filter((p5) => p5);
  const handlerHash = `${element.id}------${handler.hash}`;
  const existingOverlays = this._getOverlays(handlerHash);
  const updatedOverlays = [];
  for (const contextPad of contextPads) {
    const {
      element: element2,
      contexts: _contexts,
      hideContexts: _hideContexts,
      action: _action,
      html: _html
    } = contextPad;
    const hash = `${contextPad.element.id}-------${_html}`;
    let existingOverlay = existingOverlays.find(
      (o5) => o5.hash === hash
    );
    const html = existingOverlay && existingOverlay.html || domify$1(_html);
    if (_contexts) {
      const contexts = _contexts();
      html.dataset.scopeIds = contexts.map((c5) => c5.scope.id).join(",");
      const shownScopes = contexts.filter((c5) => this._scopeFilter.isShown(c5.scope));
      classes2(html).toggle("hidden", shownScopes.length === 0);
    }
    if (_hideContexts) {
      const contexts = _hideContexts();
      html.dataset.hideScopeIds = contexts.map((c5) => c5.scope.id).join(",");
      const shownScopes = contexts.filter((c5) => this._scopeFilter.isShown(c5.scope));
      classes2(html).toggle("hidden", shownScopes.length > 0);
    }
    if (existingOverlay) {
      updatedOverlays.push(existingOverlay);
      continue;
    }
    if (_action) {
      event.bind(html, "click", (event2) => {
        event2.preventDefault();
        const contexts = _contexts ? _contexts().filter((c5) => this._scopeFilter.isShown(c5.scope)) : null;
        _action(contexts);
        if ("restoreFocus" in canvas) {
          canvas.restoreFocus();
        }
      });
    }
    this._addOverlay(element2, {
      hash,
      handlerHash,
      html
    });
  }
  for (const existingOverlay of existingOverlays) {
    if (!updatedOverlays.includes(existingOverlay)) {
      this._removeOverlay(existingOverlay);
    }
  }
};
ContextPads.prototype.closeContextPads = function() {
  for (const overlays of this._overlayCache.values()) {
    for (const overlay of overlays) {
      this._closeOverlay(overlay);
    }
  }
  this._overlayCache.clear();
};
ContextPads.prototype._closeOverlay = function(overlay) {
  this._overlays.remove(overlay.id);
};
ContextPads.$inject = [
  "eventBus",
  "elementRegistry",
  "overlays",
  "injector",
  "canvas",
  "scopeFilter"
];
function isAncestor2(ancestor, descendant) {
  do {
    if (ancestor === descendant) {
      return true;
    }
    descendant = descendant.parent;
  } while (descendant);
  return false;
}

// node_modules/bpmn-js-token-simulation/lib/features/context-pads/index.js
var context_pads_default = {
  __depends__: [
    scope_filter_default
  ],
  __init__: [
    "contextPads"
  ],
  contextPads: ["type", ContextPads]
};

// node_modules/bpmn-js-token-simulation/lib/features/simulation-state/SimulationState.js
function SimulationState(eventBus, simulator, elementNotifications) {
  eventBus.on(SCOPE_DESTROYED_EVENT, (event2) => {
    const {
      scope
    } = event2;
    const {
      destroyInitiator,
      element: scopeElement
    } = scope;
    if (!scope.completed || !destroyInitiator) {
      return;
    }
    const processScopes = [
      "bpmn:Process",
      "bpmn:Participant"
    ];
    if (!processScopes.includes(scopeElement.type)) {
      return;
    }
    elementNotifications.addElementNotification(destroyInitiator.element, {
      type: "success",
      icon: CheckCircleIcon(),
      text: "Finished",
      scope
    });
  });
}
SimulationState.$inject = [
  "eventBus",
  "simulator",
  "elementNotifications"
];

// node_modules/bpmn-js-token-simulation/lib/features/element-notifications/ElementNotifications.js
var OFFSET_TOP2 = -15;
var OFFSET_RIGHT = 15;
function ElementNotifications(overlays, eventBus) {
  this._overlays = overlays;
  eventBus.on([
    RESET_SIMULATION_EVENT,
    SCOPE_CREATE_EVENT,
    TOGGLE_MODE_EVENT
  ], () => {
    this.clear();
  });
}
ElementNotifications.prototype.addElementNotification = function(element, options) {
  const position = {
    top: OFFSET_TOP2,
    right: OFFSET_RIGHT
  };
  const {
    type,
    icon,
    text,
    scope = {}
  } = options;
  const colors2 = scope.colors;
  const colorMarkup = colors2 ? `style="color: ${colors2.auxiliary}; background: ${colors2.primary}"` : "";
  const html = domify$1(`
    <div class="bts-element-notification ${type || ""}" ${colorMarkup}>
      ${icon || ""}
      <span class="bts-text">${text}</span>
    </div>
  `);
  this._overlays.add(element, "bts-element-notification", {
    position,
    html,
    show: {
      minZoom: 0.5
    }
  });
};
ElementNotifications.prototype.clear = function() {
  this._overlays.remove({ type: "bts-element-notification" });
};
ElementNotifications.prototype.removeElementNotification = function(element) {
  this._overlays.remove({ element });
};
ElementNotifications.$inject = ["overlays", "eventBus"];

// node_modules/bpmn-js-token-simulation/lib/features/element-notifications/index.js
var element_notifications_default = {
  elementNotifications: ["type", ElementNotifications]
};

// node_modules/bpmn-js-token-simulation/lib/features/notifications/Notifications.js
var NOTIFICATION_TIME_TO_LIVE = 2e3;
var INFO_ICON = InfoIcon();
function Notifications(eventBus, canvas, scopeFilter) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._scopeFilter = scopeFilter;
  this._init();
  eventBus.on([
    TOGGLE_MODE_EVENT,
    RESET_SIMULATION_EVENT
  ], (event2) => {
    this.clear();
  });
}
Notifications.prototype._init = function() {
  this.container = domify$1('<div class="bts-notifications"></div>');
  this._canvas.getContainer().appendChild(this.container);
};
Notifications.prototype.showNotification = function(options) {
  const {
    text,
    type = "info",
    icon = INFO_ICON,
    scope,
    ttl = NOTIFICATION_TIME_TO_LIVE
  } = options;
  if (scope && !this._scopeFilter.isShown(scope)) {
    return;
  }
  const iconMarkup = icon.startsWith("<") ? icon : `<i class="${icon}"></i>`;
  const colors2 = scope && scope.colors;
  const colorMarkup = colors2 ? `style="color: ${colors2.auxiliary}; background: ${colors2.primary}"` : "";
  const notification = domify$1(`
    <div class="bts-notification ${type}">
      <span class="bts-icon">${iconMarkup}</span>
      <span class="bts-text" title="${text}">${text}</span>
      ${scope ? `<span class="bts-scope" ${colorMarkup}>${scope.id}</span>` : ""}
    </div>
  `);
  this.container.appendChild(notification);
  while (this.container.children.length > 5) {
    this.container.children[0].remove();
  }
  setTimeout(function() {
    notification.remove();
  }, ttl);
};
Notifications.prototype.clear = function() {
  while (this.container.children.length) {
    this.container.children[0].remove();
  }
};
Notifications.$inject = [
  "eventBus",
  "canvas",
  "scopeFilter"
];

// node_modules/bpmn-js-token-simulation/lib/features/notifications/index.js
var notifications_default = {
  __depends__: [
    scope_filter_default
  ],
  notifications: ["type", Notifications]
};

// node_modules/bpmn-js-token-simulation/lib/features/simulation-state/index.js
var simulation_state_default = {
  __depends__: [
    element_notifications_default,
    notifications_default
  ],
  __init__: [
    "simulationState"
  ],
  simulationState: ["type", SimulationState]
};

// node_modules/bpmn-js-token-simulation/lib/features/show-scopes/ShowScopes.js
var FILL_COLOR = "--token-simulation-silver-base-97";
var STROKE_COLOR = "--token-simulation-green-base-44";
var ID2 = "show-scopes";
var VERY_HIGH_PRIORITY = 3e3;
function ShowScopes(eventBus, canvas, scopeFilter, elementColors, simulationStyles) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._scopeFilter = scopeFilter;
  this._elementColors = elementColors;
  this._simulationStyles = simulationStyles;
  this._highlight = null;
  this._init();
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    const active = event2.active;
    if (active) {
      classes2(this._container).remove("hidden");
    } else {
      classes2(this._container).add("hidden");
      clear2(this._container);
      this.unhighlightScope();
    }
  });
  eventBus.on(SCOPE_FILTER_CHANGED_EVENT, (event2) => {
    const allElements = this.getScopeElements();
    for (const element of allElements) {
      const scopeId = element.dataset.scopeId;
      classes2(element).toggle("inactive", !this._scopeFilter.isShown(scopeId));
      classes2(element).toggle("focussed", this._scopeFilter.isFocused(scopeId));
    }
  });
  eventBus.on(SCOPE_CREATE_EVENT, (event2) => {
    this.addScope(event2.scope);
  });
  eventBus.on(SCOPE_DESTROYED_EVENT, (event2) => {
    this.removeScope(event2.scope);
  });
  eventBus.on(SCOPE_CHANGED_EVENT, (event2) => {
    this.updateScope(event2.scope);
  });
  eventBus.on(RESET_SIMULATION_EVENT, () => {
    this.removeAllInstances();
  });
}
ShowScopes.prototype._init = function() {
  this._container = domify$1('<div class="bts-scopes hidden"></div>');
  this._canvas.getContainer().appendChild(this._container);
};
ShowScopes.prototype.addScope = function(scope) {
  const processElements = [
    "bpmn:Process",
    "bpmn:SubProcess",
    "bpmn:Participant"
  ];
  const {
    element: scopeElement
  } = scope;
  if (!isAny(scopeElement, processElements)) {
    return;
  }
  const colors2 = scope.colors;
  const colorMarkup = colors2 ? `style="color: ${colors2.auxiliary}; background: ${colors2.primary}; outline-color: ${colors2.primary}"` : "";
  const html = domify$1(`
    <div data-scope-id="${scope.id}" class="bts-scope"
         title="Focus process instance ${scope.id}" ${colorMarkup}>
      ${scope.getTokens()}
    </div>
  `);
  event.bind(html, "click", () => {
    this._scopeFilter.toggle(scope);
  });
  event.bind(html, "mouseenter", () => {
    this.highlightScope(scopeElement);
  });
  event.bind(html, "mouseleave", () => {
    this.unhighlightScope();
  });
  if (!this._scopeFilter.isShown(scope)) {
    classes2(html).add("inactive");
  }
  classes2(html).toggle("focussed", this._scopeFilter.isFocused(scope));
  this._container.appendChild(html);
};
ShowScopes.prototype.getScopeElements = function() {
  return all("[data-scope-id]", this._container);
};
ShowScopes.prototype.getScopeElement = function(scope) {
  return query(`[data-scope-id="${scope.id}"]`, this._container);
};
ShowScopes.prototype.updateScope = function(scope) {
  const element = this.getScopeElement(scope);
  if (element) {
    element.textContent = scope.getTokens();
  }
};
ShowScopes.prototype.removeScope = function(scope) {
  const element = this.getScopeElement(scope);
  if (element) {
    element.remove();
  }
};
ShowScopes.prototype.removeAllInstances = function() {
  this._container.innerHTML = "";
};
ShowScopes.prototype.highlightScope = function(element) {
  this.unhighlightScope();
  this._highlight = element;
  this._elementColors.add(element, ID2, this._getHighlightColors(), VERY_HIGH_PRIORITY);
  if (!element.parent) {
    classes2(this._canvas.getContainer()).add("highlight");
  }
};
ShowScopes.prototype.unhighlightScope = function() {
  if (!this._highlight) {
    return;
  }
  const element = this._highlight;
  this._elementColors.remove(element, ID2);
  if (!element.parent) {
    classes2(this._canvas.getContainer()).remove("highlight");
  }
  this._highlight = null;
};
ShowScopes.prototype._getHighlightColors = function() {
  return {
    fill: this._simulationStyles.get(FILL_COLOR),
    stroke: this._simulationStyles.get(STROKE_COLOR)
  };
};
ShowScopes.$inject = [
  "eventBus",
  "canvas",
  "scopeFilter",
  "elementColors",
  "simulationStyles"
];

// node_modules/bpmn-js-token-simulation/lib/features/simulation-styles/SimulationStyles.js
function SimulationStyles() {
  this._cache = {};
}
SimulationStyles.$inject = [];
SimulationStyles.prototype.get = function(prop) {
  const cachedValue = this._cache[prop];
  if (cachedValue) {
    return cachedValue;
  }
  if (!this._computedStyle) {
    this._computedStyle = this._getComputedStyle();
  }
  return this._cache[prop] = this._computedStyle.getPropertyValue(prop).trim();
};
SimulationStyles.prototype._getComputedStyle = function() {
  const get4 = typeof getComputedStyle === "function" ? getComputedStyle : getComputedStyleMock;
  const element = typeof document !== "undefined" ? document.documentElement : {};
  return get4(element);
};
function getComputedStyleMock() {
  return {
    getPropertyValue() {
      return "";
    }
  };
}

// node_modules/bpmn-js-token-simulation/lib/features/simulation-styles/index.js
var simulation_styles_default = {
  simulationStyles: ["type", SimulationStyles]
};

// node_modules/bpmn-js-token-simulation/lib/features/show-scopes/index.js
var show_scopes_default = {
  __depends__: [
    scope_filter_default,
    simulation_styles_default
  ],
  __init__: [
    "showScopes"
  ],
  showScopes: ["type", ShowScopes]
};

// node_modules/bpmn-js-token-simulation/lib/features/log/Log.js
var ICON_INFO = InfoIcon();
function getElementName(element) {
  const name2 = element && element.businessObject.name;
  return name2 && escapeHTML(name2);
}
function getIconForIntermediateEvent(element, throwOrCatch) {
  const eventTypeString = getEventTypeString(element);
  if (eventTypeString === "none") {
    return "bpmn-icon-intermediate-event-none";
  }
  return `bpmn-icon-intermediate-event-${throwOrCatch}-${eventTypeString}`;
}
function getEventTypeString(element) {
  const bo = getBusinessObject(element);
  if (bo.get("eventDefinitions").length === 0) {
    return "none";
  }
  const eventDefinition = bo.eventDefinitions[0];
  if (is(eventDefinition, "bpmn:MessageEventDefinition")) {
    return "message";
  }
  if (is(eventDefinition, "bpmn:TimerEventDefinition")) {
    return "timer";
  }
  if (is(eventDefinition, "bpmn:SignalEventDefinition")) {
    return "signal";
  }
  if (is(eventDefinition, "bpmn:ErrorEventDefinition")) {
    return "error";
  }
  if (is(eventDefinition, "bpmn:EscalationEventDefinition")) {
    return "escalation";
  }
  if (is(eventDefinition, "bpmn:CompensateEventDefinition")) {
    return "compensation";
  }
  if (is(eventDefinition, "bpmn:ConditionalEventDefinition")) {
    return "condition";
  }
  if (is(eventDefinition, "bpmn:LinkEventDefinition")) {
    return "link";
  }
  if (is(eventDefinition, "bpmn:CancelEventDefinition")) {
    return "cancel";
  }
  if (is(eventDefinition, "bpmn:TerminateEventDefinition")) {
    return "terminate";
  }
  return "none";
}
function Log(eventBus, notifications, tokenSimulationPalette, canvas, scopeFilter, simulator) {
  this._notifications = notifications;
  this._tokenSimulationPalette = tokenSimulationPalette;
  this._canvas = canvas;
  this._scopeFilter = scopeFilter;
  this._init();
  eventBus.on(SCOPE_FILTER_CHANGED_EVENT, (event2) => {
    const allElements = all(".bts-entry[data-scope-id]", this._container);
    for (const element of allElements) {
      const scopeId = element.dataset.scopeId;
      classes2(element).toggle("inactive", !this._scopeFilter.isShown(scopeId));
    }
  });
  eventBus.on(SCOPE_DESTROYED_EVENT, (event2) => {
    const {
      scope
    } = event2;
    const {
      element: scopeElement
    } = scope;
    const completed = scope.completed;
    const processScopes = [
      "bpmn:Process",
      "bpmn:Participant",
      "bpmn:SubProcess"
    ];
    if (!isAny(scopeElement, processScopes)) {
      return;
    }
    const isSubProcess2 = is(scopeElement, "bpmn:SubProcess");
    const text = `${isSubProcess2 ? getElementName(scopeElement) || "SubProcess" : "Process"} ${completed ? "finished" : "canceled"}`;
    this.log({
      text,
      icon: completed ? CheckCircleIcon() : TimesCircleIcon(),
      scope
    });
  });
  eventBus.on(SCOPE_CREATE_EVENT, (event2) => {
    const {
      scope
    } = event2;
    const {
      element: scopeElement
    } = scope;
    const processScopes = [
      "bpmn:Process",
      "bpmn:Participant",
      "bpmn:SubProcess"
    ];
    if (!isAny(scopeElement, processScopes)) {
      return;
    }
    const isSubProcess2 = is(scopeElement, "bpmn:SubProcess");
    const text = `${isSubProcess2 ? getElementName(scopeElement) || "SubProcess" : "Process"} started`;
    this.log({
      text,
      icon: CheckCircleIcon(),
      scope
    });
  });
  eventBus.on(TRACE_EVENT, (event2) => {
    const {
      action,
      scope: elementScope,
      element
    } = event2;
    if (action !== "exit") {
      return;
    }
    const scope = elementScope.parent;
    const elementName = getElementName(element);
    if (is(element, "bpmn:ServiceTask")) {
      return this.log({
        text: elementName || "Service Task",
        icon: "bpmn-icon-service",
        scope
      });
    }
    if (is(element, "bpmn:UserTask")) {
      return this.log({
        text: elementName || "User Task",
        icon: "bpmn-icon-user",
        scope
      });
    }
    if (is(element, "bpmn:CallActivity")) {
      return this.log({
        text: elementName || "Call Activity",
        icon: "bpmn-icon-call-activity",
        scope
      });
    }
    if (is(element, "bpmn:ScriptTask")) {
      return this.log({
        text: elementName || "Script Task",
        icon: "bpmn-icon-script",
        scope
      });
    }
    if (is(element, "bpmn:BusinessRuleTask")) {
      return this.log({
        text: elementName || "Business Rule Task",
        icon: "bpmn-icon-business-rule",
        scope
      });
    }
    if (is(element, "bpmn:ManualTask")) {
      return this.log({
        text: elementName || "Manual Task",
        icon: "bpmn-icon-manual-task",
        scope
      });
    }
    if (is(element, "bpmn:ReceiveTask")) {
      return this.log({
        text: elementName || "Receive Task",
        icon: "bpmn-icon-receive",
        scope
      });
    }
    if (is(element, "bpmn:SendTask")) {
      return this.log({
        text: elementName || "Send Task",
        icon: "bpmn-icon-send",
        scope
      });
    }
    if (is(element, "bpmn:Task")) {
      return this.log({
        text: elementName || "Task",
        icon: "bpmn-icon-task",
        scope
      });
    }
    if (is(element, "bpmn:ExclusiveGateway")) {
      return this.log({
        text: elementName || "Exclusive Gateway",
        icon: "bpmn-icon-gateway-xor",
        scope
      });
    }
    if (is(element, "bpmn:ParallelGateway")) {
      return this.log({
        text: elementName || "Parallel Gateway",
        icon: "bpmn-icon-gateway-parallel",
        scope
      });
    }
    if (is(element, "bpmn:InclusiveGateway")) {
      return this.log({
        text: elementName || "Inclusive Gateway",
        icon: "bpmn-icon-gateway-or",
        scope
      });
    }
    if (is(element, "bpmn:StartEvent")) {
      return this.log({
        text: elementName || "Start Event",
        icon: `bpmn-icon-start-event-${getEventTypeString(element)}`,
        scope
      });
    }
    if (is(element, "bpmn:IntermediateCatchEvent")) {
      return this.log({
        text: elementName || "Intermediate Event",
        icon: getIconForIntermediateEvent(element, "catch"),
        scope
      });
    }
    if (is(element, "bpmn:IntermediateThrowEvent")) {
      return this.log({
        text: elementName || "Intermediate Event",
        icon: getIconForIntermediateEvent(element, "throw"),
        scope
      });
    }
    if (is(element, "bpmn:BoundaryEvent")) {
      return this.log({
        text: elementName || "Boundary Event",
        icon: getIconForIntermediateEvent(element, "catch"),
        scope
      });
    }
    if (is(element, "bpmn:EndEvent")) {
      return this.log({
        text: elementName || "End Event",
        icon: `bpmn-icon-end-event-${getEventTypeString(element)}`,
        scope
      });
    }
  });
  eventBus.on([
    TOGGLE_MODE_EVENT,
    RESET_SIMULATION_EVENT
  ], (event2) => {
    this.clear();
    this.toggle(false);
  });
}
Log.prototype._init = function() {
  this._container = domify$1(`
    <div class="bts-log hidden djs-scrollable">
      <div class="bts-header">
        ${LogIcon("bts-log-icon")}
        Simulation Log
        <button class="bts-close" aria-label="Close">
          ${TimesIcon()}
        </button>
      </div>
      <div class="bts-content">
        <p class="bts-entry placeholder">No Entries</p>
      </div>
    </div>
  `);
  this._placeholder = query(".bts-placeholder", this._container);
  this._content = query(".bts-content", this._container);
  event.bind(this._content, "mousedown", (event2) => {
    event2.stopPropagation();
  });
  this._close = query(".bts-close", this._container);
  event.bind(this._close, "click", () => {
    this.toggle(false);
  });
  this._icon = query(".bts-log-icon", this._container);
  event.bind(this._icon, "click", () => {
    this.toggle();
  });
  this._canvas.getContainer().appendChild(this._container);
  this.paletteEntry = domify$1(`
    <div class="bts-entry" title="Toggle Simulation Log">
      ${LogIcon()}
    </div>
  `);
  event.bind(this.paletteEntry, "click", () => {
    this.toggle();
  });
  this._tokenSimulationPalette.addEntry(this.paletteEntry, 3);
};
Log.prototype.isShown = function() {
  const container = this._container;
  return !classes2(container).has("hidden");
};
Log.prototype.toggle = function(shown = !this.isShown()) {
  const container = this._container;
  if (shown) {
    classes2(container).remove("hidden");
  } else {
    classes2(container).add("hidden");
  }
};
Log.prototype.log = function(options) {
  const {
    text,
    type = "info",
    icon = ICON_INFO,
    scope
  } = options;
  const content = this._content;
  classes2(this._placeholder).add("hidden");
  if (!this.isShown()) {
    this._notifications.showNotification(options);
  }
  const iconMarkup = icon.startsWith("<") ? icon : `<i class="${icon}"></i>`;
  const colors2 = scope && scope.colors;
  const colorMarkup = colors2 ? `style="background: ${colors2.primary}; color: ${colors2.auxiliary}"` : "";
  const logEntry = domify$1(`
    <p class="bts-entry ${type} ${scope && this._scopeFilter.isShown(scope) ? "" : "inactive"}" ${scope ? `data-scope-id="${scope.id}"` : ""}>
      <span class="bts-icon">${iconMarkup}</span>
      <span class="bts-text" title="${text}">${text}</span>
      ${scope ? `<span class="bts-scope" data-scope-id="${scope.id}" ${colorMarkup}>${scope.id}</span>` : ""}
    </p>
  `);
  delegate.bind(logEntry, ".bts-scope[data-scope-id]", "click", (event2) => {
    this._scopeFilter.toggle(scope);
  });
  const shouldScroll = Math.abs(content.clientHeight + content.scrollTop - content.scrollHeight) < 2;
  content.appendChild(logEntry);
  if (shouldScroll) {
    content.scrollTop = content.scrollHeight;
  }
};
Log.prototype.clear = function() {
  while (this._content.firstChild) {
    this._content.removeChild(this._content.firstChild);
  }
  this._placeholder = domify$1('<p class="bts-entry placeholder">No Entries</p>');
  this._content.appendChild(this._placeholder);
};
Log.$inject = [
  "eventBus",
  "notifications",
  "tokenSimulationPalette",
  "canvas",
  "scopeFilter",
  "simulator"
];

// node_modules/bpmn-js-token-simulation/lib/features/log/index.js
var log_default = {
  __depends__: [
    notifications_default,
    scope_filter_default
  ],
  __init__: [
    "log"
  ],
  log: ["type", Log]
};

// node_modules/bpmn-js-token-simulation/lib/features/element-support/ElementSupport.js
var UNSUPPORTED_ELEMENTS = [
  "bpmn:ComplexGateway"
];
function isLabel3(element) {
  return element.labelTarget;
}
function ElementSupport(eventBus, elementRegistry, canvas, notifications, elementNotifications) {
  this._eventBus = eventBus;
  this._elementRegistry = elementRegistry;
  this._elementNotifications = elementNotifications;
  this._notifications = notifications;
  this._canvasParent = canvas.getContainer().parentNode;
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    if (event2.active) {
      this.enable();
    } else {
      this.clear();
    }
  });
}
ElementSupport.prototype.getUnsupportedElements = function() {
  return this._unsupportedElements;
};
ElementSupport.prototype.enable = function() {
  const unsupportedElements = [];
  this._elementRegistry.forEach((element) => {
    if (isLabel3(element)) {
      return;
    }
    if (!isAny(element, UNSUPPORTED_ELEMENTS)) {
      return;
    }
    this.showWarning(element);
    unsupportedElements.push(element);
  });
  if (unsupportedElements.length) {
    this._notifications.showNotification({
      text: "Found unsupported elements",
      icon: ExclamationTriangleIcon(),
      type: "warning",
      ttl: 5e3
    });
  }
  this._unsupportedElements = unsupportedElements;
};
ElementSupport.prototype.clear = function() {
  classes2(this._canvasParent).remove("warning");
};
ElementSupport.prototype.showWarning = function(element) {
  this._elementNotifications.addElementNotification(element, {
    type: "warning",
    icon: ExclamationTriangleIcon(),
    text: "Not supported"
  });
};
ElementSupport.$inject = [
  "eventBus",
  "elementRegistry",
  "canvas",
  "notifications",
  "elementNotifications"
];

// node_modules/bpmn-js-token-simulation/lib/features/element-support/index.js
var element_support_default = {
  __depends__: [
    element_notifications_default,
    notifications_default
  ],
  __init__: ["elementSupport"],
  elementSupport: ["type", ElementSupport]
};

// node_modules/bpmn-js-token-simulation/lib/features/pause-simulation/PauseSimulation.js
var PLAY_MARKUP = PlayIcon();
var PAUSE_MARKUP = PauseIcon();
var HIGH_PRIORITY23 = 1500;
function PauseSimulation(eventBus, tokenSimulationPalette, notifications, canvas) {
  this._eventBus = eventBus;
  this._tokenSimulationPalette = tokenSimulationPalette;
  this._notifications = notifications;
  this.canvasParent = canvas.getContainer().parentNode;
  this.isActive = false;
  this.isPaused = true;
  this._init();
  eventBus.on(SCOPE_CREATE_EVENT, HIGH_PRIORITY23, (event2) => {
    this.activate();
    this.unpause();
  });
  eventBus.on([
    RESET_SIMULATION_EVENT,
    TOGGLE_MODE_EVENT
  ], () => {
    this.deactivate();
    this.pause();
  });
  eventBus.on(TRACE_EVENT, HIGH_PRIORITY23, (event2) => {
    this.unpause();
  });
}
PauseSimulation.prototype._init = function() {
  this.paletteEntry = domify$1(`
    <div class="bts-entry disabled" title="Play/Pause Simulation">
      ${PLAY_MARKUP}
    </div>
  `);
  event.bind(this.paletteEntry, "click", this.toggle.bind(this));
  this._tokenSimulationPalette.addEntry(this.paletteEntry, 1);
};
PauseSimulation.prototype.toggle = function() {
  if (this.isPaused) {
    this.unpause();
  } else {
    this.pause();
  }
};
PauseSimulation.prototype.pause = function() {
  if (!this.isActive) {
    return;
  }
  classes2(this.paletteEntry).remove("active");
  classes2(this.canvasParent).add("paused");
  this.paletteEntry.innerHTML = PLAY_MARKUP;
  this._eventBus.fire(PAUSE_SIMULATION_EVENT);
  this._notifications.showNotification({
    text: "Pause Simulation"
  });
  this.isPaused = true;
};
PauseSimulation.prototype.unpause = function() {
  if (!this.isActive || !this.isPaused) {
    return;
  }
  classes2(this.paletteEntry).add("active");
  classes2(this.canvasParent).remove("paused");
  this.paletteEntry.innerHTML = PAUSE_MARKUP;
  this._eventBus.fire(PLAY_SIMULATION_EVENT);
  this._notifications.showNotification({
    text: "Play Simulation"
  });
  this.isPaused = false;
};
PauseSimulation.prototype.activate = function() {
  this.isActive = true;
  classes2(this.paletteEntry).remove("disabled");
};
PauseSimulation.prototype.deactivate = function() {
  this.isActive = false;
  classes2(this.paletteEntry).remove("active");
  classes2(this.paletteEntry).add("disabled");
};
PauseSimulation.$inject = [
  "eventBus",
  "tokenSimulationPalette",
  "notifications",
  "canvas"
];

// node_modules/bpmn-js-token-simulation/lib/features/pause-simulation/index.js
var pause_simulation_default = {
  __depends__: [
    notifications_default
  ],
  __init__: [
    "pauseSimulation"
  ],
  pauseSimulation: ["type", PauseSimulation]
};

// node_modules/bpmn-js-token-simulation/lib/features/reset-simulation/ResetSimulation.js
function ResetSimulation(eventBus, tokenSimulationPalette, notifications) {
  this._eventBus = eventBus;
  this._tokenSimulationPalette = tokenSimulationPalette;
  this._notifications = notifications;
  this._init();
  eventBus.on(SCOPE_CREATE_EVENT, () => {
    classes2(this._paletteEntry).remove("disabled");
  });
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    const active = this._active = event2.active;
    if (!active) {
      this.resetSimulation();
    }
  });
}
ResetSimulation.prototype._init = function() {
  this._paletteEntry = domify$1(`
    <div class="bts-entry disabled" title="Reset Simulation">
      ${ResetIcon()}
    </div>
  `);
  event.bind(this._paletteEntry, "click", () => {
    this.resetSimulation();
    this._notifications.showNotification({
      text: "Reset Simulation",
      type: "info"
    });
  });
  this._tokenSimulationPalette.addEntry(this._paletteEntry, 2);
};
ResetSimulation.prototype.resetSimulation = function() {
  classes2(this._paletteEntry).add("disabled");
  this._eventBus.fire(RESET_SIMULATION_EVENT);
};
ResetSimulation.$inject = [
  "eventBus",
  "tokenSimulationPalette",
  "notifications"
];

// node_modules/bpmn-js-token-simulation/lib/features/reset-simulation/index.js
var reset_simulation_default = {
  __depends__: [
    notifications_default
  ],
  __init__: [
    "resetSimulation"
  ],
  resetSimulation: ["type", ResetSimulation]
};

// node_modules/bpmn-js-token-simulation/lib/features/token-count/TokenCount.js
var OFFSET_BOTTOM = 10;
var OFFSET_LEFT2 = -15;
var LOW_PRIORITY30 = 500;
var DEFAULT_PRIMARY_COLOR2 = "--token-simulation-green-base-44";
var DEFAULT_AUXILIARY_COLOR2 = "--token-simulation-white";
function TokenCount(eventBus, overlays, simulator, scopeFilter, simulationStyles) {
  this._overlays = overlays;
  this._scopeFilter = scopeFilter;
  this._simulator = simulator;
  this._simulationStyles = simulationStyles;
  this.overlayIds = {};
  eventBus.on(ELEMENT_CHANGED_EVENT, LOW_PRIORITY30, (event2) => {
    const {
      element
    } = event2;
    this.removeTokenCounts(element);
    this.addTokenCounts(element);
  });
  eventBus.on(SCOPE_FILTER_CHANGED_EVENT, (event2) => {
    const allElements = all(".bts-token-count[data-scope-id]", overlays._overlayRoot);
    for (const element of allElements) {
      const scopeId = element.dataset.scopeId;
      classes2(element).toggle("inactive", !this._scopeFilter.isShown(scopeId));
    }
  });
}
TokenCount.prototype.addTokenCounts = function(element) {
  if (is(element, "bpmn:MessageFlow") || is(element, "bpmn:SequenceFlow")) {
    return;
  }
  const scopes = this._simulator.findScopes((scope) => {
    return !scope.destroyed && scope.children.some((c5) => !c5.destroyed && c5.element === element);
  });
  this.addTokenCount(element, scopes);
};
TokenCount.prototype.addTokenCount = function(element, scopes) {
  if (!scopes.length) {
    return;
  }
  const tokenMarkup = scopes.map((scope) => {
    return this._getTokenHTML(element, scope);
  }).join("");
  const html = domify$1(`
    <div class="bts-token-count-parent">
      ${tokenMarkup}
    </div>
  `);
  const position = { bottom: OFFSET_BOTTOM, left: OFFSET_LEFT2 };
  const overlayId = this._overlays.add(element, "bts-token-count", {
    position,
    html,
    show: {
      minZoom: 0.5
    }
  });
  this.overlayIds[element.id] = overlayId;
};
TokenCount.prototype.removeTokenCounts = function(element) {
  this.removeTokenCount(element);
};
TokenCount.prototype.removeTokenCount = function(element) {
  const overlayId = this.overlayIds[element.id];
  if (!overlayId) {
    return;
  }
  this._overlays.remove(overlayId);
  delete this.overlayIds[element.id];
};
TokenCount.prototype._getTokenHTML = function(element, scope) {
  const colors2 = scope.colors || this._getDefaultColors();
  return `
    <div data-scope-id="${scope.id}" class="bts-token-count waiting ${this._scopeFilter.isShown(scope) ? "" : "inactive"}"
         style="color: ${colors2.auxiliary}; background: ${colors2.primary}">
      ${scope.getTokensByElement(element)}
    </div>
  `;
};
TokenCount.prototype._getDefaultColors = function() {
  return {
    primary: this._simulationStyles.get(DEFAULT_PRIMARY_COLOR2),
    auxiliary: this._simuationStyles.get(DEFAULT_AUXILIARY_COLOR2)
  };
};
TokenCount.$inject = [
  "eventBus",
  "overlays",
  "simulator",
  "scopeFilter",
  "simulationStyles"
];

// node_modules/bpmn-js-token-simulation/lib/features/token-count/index.js
var token_count_default = {
  __depends__: [
    scope_filter_default,
    simulation_styles_default
  ],
  __init__: [
    "tokenCount"
  ],
  tokenCount: ["type", TokenCount]
};

// node_modules/bpmn-js-token-simulation/lib/features/set-animation-speed/SetAnimationSpeed.js
var SPEEDS = [
  ["Slow", 0.5],
  ["Normal", 1],
  ["Fast", 2]
];
function SetAnimationSpeed(canvas, animation, eventBus) {
  this._canvas = canvas;
  this._animation = animation;
  this._eventBus = eventBus;
  this._init(animation.getAnimationSpeed());
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    const active = event2.active;
    if (!active) {
      classes2(this._container).add("hidden");
    } else {
      classes2(this._container).remove("hidden");
    }
  });
  eventBus.on(ANIMATION_SPEED_CHANGED_EVENT, (event2) => {
    this.setActive(event2.speed);
  });
}
SetAnimationSpeed.prototype.getToggleSpeed = function(element) {
  return parseFloat(element.dataset.speed);
};
SetAnimationSpeed.prototype._init = function(animationSpeed) {
  this._container = domify$1(`
    <div class="bts-set-animation-speed hidden">
      ${TachometerIcon()}
      <div class="bts-animation-speed-buttons">
        ${SPEEDS.map(([label, speed], idx) => `
            <button title="Set animation speed = ${label}" data-speed="${speed}" class="bts-animation-speed-button ${speed === animationSpeed ? "active" : ""}">
              ${Array.from({ length: idx + 1 }).map(
    () => AngleRightIcon()
  ).join("")}
            </button>
          `).join("")}
      </div>
    </div>
  `);
  delegate.bind(this._container, "[data-speed]", "click", (event2) => {
    const toggle2 = event2.delegateTarget;
    const speed = this.getToggleSpeed(toggle2);
    this._animation.setAnimationSpeed(speed);
  });
  this._canvas.getContainer().appendChild(this._container);
};
SetAnimationSpeed.prototype.setActive = function(speed) {
  all("[data-speed]", this._container).forEach((toggle2) => {
    const active = this.getToggleSpeed(toggle2) === speed;
    classes2(toggle2)[active ? "add" : "remove"]("active");
  });
};
SetAnimationSpeed.$inject = [
  "canvas",
  "animation",
  "eventBus"
];

// node_modules/bpmn-js-token-simulation/lib/features/set-animation-speed/index.js
var set_animation_speed_default = {
  __init__: [
    "setAnimationSpeed"
  ],
  setAnimationSpeed: ["type", SetAnimationSpeed]
};

// node_modules/bpmn-js-token-simulation/lib/features/exclusive-gateway-settings/ExclusiveGatewaySettings.js
var SELECTED_COLOR = "--token-simulation-grey-darken-30";
var NOT_SELECTED_COLOR = "--token-simulation-grey-lighten-56";
function getNext(gateway, sequenceFlow) {
  var outgoing = gateway.outgoing.filter(isSequenceFlow3);
  var index5 = outgoing.indexOf(sequenceFlow || gateway.sequenceFlow);
  if (outgoing[index5 + 1]) {
    return outgoing[index5 + 1];
  } else {
    return outgoing[0];
  }
}
function isSequenceFlow3(connection) {
  return is(connection, "bpmn:SequenceFlow");
}
var ID3 = "exclusive-gateway-settings";
var HIGH_PRIORITY24 = 2e3;
function ExclusiveGatewaySettings(eventBus, elementRegistry, elementColors, simulator, simulationStyles) {
  this._elementRegistry = elementRegistry;
  this._elementColors = elementColors;
  this._simulator = simulator;
  this._simulationStyles = simulationStyles;
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    if (event2.active) {
      this.setSequenceFlowsDefault();
    } else {
      this.resetSequenceFlows();
    }
  });
}
ExclusiveGatewaySettings.prototype.setSequenceFlowsDefault = function() {
  const exclusiveGateways = this._elementRegistry.filter((element) => {
    return is(element, "bpmn:ExclusiveGateway");
  });
  for (const gateway of exclusiveGateways) {
    this.setSequenceFlow(gateway);
  }
};
ExclusiveGatewaySettings.prototype.resetSequenceFlows = function() {
  const exclusiveGateways = this._elementRegistry.filter((element) => {
    return is(element, "bpmn:ExclusiveGateway");
  });
  exclusiveGateways.forEach((exclusiveGateway) => {
    if (exclusiveGateway.outgoing.filter(isSequenceFlow3).length) {
      this.resetSequenceFlow(exclusiveGateway);
    }
  });
};
ExclusiveGatewaySettings.prototype.resetSequenceFlow = function(gateway) {
  this._simulator.setConfig(gateway, { activeOutgoing: void 0 });
};
ExclusiveGatewaySettings.prototype.setSequenceFlow = function(gateway) {
  const outgoing = gateway.outgoing.filter(isSequenceFlow3);
  if (outgoing.length < 2) {
    return;
  }
  const {
    activeOutgoing
  } = this._simulator.getConfig(gateway);
  let newActiveOutgoing;
  if (activeOutgoing) {
    newActiveOutgoing = getNext(gateway, activeOutgoing);
  } else {
    newActiveOutgoing = outgoing[0];
  }
  this._simulator.setConfig(gateway, { activeOutgoing: newActiveOutgoing });
  gateway.outgoing.forEach((outgoing2) => {
    const style = outgoing2 === newActiveOutgoing ? SELECTED_COLOR : NOT_SELECTED_COLOR;
    const stroke = this._simulationStyles.get(style);
    this._elementColors.add(outgoing2, ID3, {
      stroke
    }, HIGH_PRIORITY24);
  });
};
ExclusiveGatewaySettings.$inject = [
  "eventBus",
  "elementRegistry",
  "elementColors",
  "simulator",
  "simulationStyles"
];

// node_modules/bpmn-js-token-simulation/lib/features/element-colors/ElementColors.js
var VERY_HIGH_PRIORITY2 = 5e4;
function ElementColors(elementRegistry, eventBus, graphicsFactory) {
  this._elementRegistry = elementRegistry;
  this._eventBus = eventBus;
  this._graphicsFactory = graphicsFactory;
  this._originalColors = {};
  this._customColors = {};
  eventBus.on(TOGGLE_MODE_EVENT, VERY_HIGH_PRIORITY2, (event2) => {
    const active = event2.active;
    if (active) {
      this._saveOriginalColors();
    } else {
      this._applyOriginalColors();
      this._originalColors = {};
      this._customColors = {};
    }
  });
  eventBus.on("saveXML.start", VERY_HIGH_PRIORITY2, () => {
    this._applyOriginalColors();
    eventBus.once("saveXML.done", () => this._applyCustomColors());
  });
}
ElementColors.$inject = [
  "elementRegistry",
  "eventBus",
  "graphicsFactory"
];
ElementColors.prototype.add = function(element, id, colors2, priority = 1e3) {
  let elementColors = this._customColors[element.id];
  if (!elementColors) {
    elementColors = this._customColors[element.id] = {};
  }
  elementColors[id] = {
    ...colors2,
    priority
  };
  this._applyHighestPriorityColor(element);
};
ElementColors.prototype.remove = function(element, id) {
  const elementColors = this._customColors[element.id];
  if (elementColors) {
    delete elementColors[id];
    if (!Object.keys(elementColors)) {
      delete this._customColors[element.id];
    }
  }
  this._applyHighestPriorityColor(element);
};
ElementColors.prototype._get = function(element) {
  const di = getDi(element);
  if (!di) {
    return void 0;
  }
  if (isLabel4(element)) {
    return {
      stroke: di.label && di.label.get("color")
    };
  } else if (isAny(di, ["bpmndi:BPMNEdge", "bpmndi:BPMNShape"])) {
    return {
      fill: di.get("background-color"),
      stroke: di.get("border-color")
    };
  }
};
ElementColors.prototype._set = function(element, colors2 = {}) {
  const {
    fill,
    stroke
  } = colors2;
  const di = getDi(element);
  if (!di) {
    return;
  }
  if (isLabel4(element)) {
    di.label && di.label.set("color", stroke);
  } else if (isAny(di, ["bpmndi:BPMNEdge", "bpmndi:BPMNShape"])) {
    di.set("background-color", fill);
    di.set("border-color", stroke);
  }
  this._forceRedraw(element);
};
ElementColors.prototype._saveOriginalColors = function() {
  this._originalColors = {};
  this._elementRegistry.forEach((element) => {
    this._originalColors[element.id] = this._get(element);
  });
};
ElementColors.prototype._applyOriginalColors = function() {
  this._elementRegistry.forEach((element) => {
    const colors2 = this._originalColors[element.id];
    if (colors2) {
      this._set(element, colors2);
    }
  });
};
ElementColors.prototype._applyCustomColors = function() {
  this._elementRegistry.forEach((element) => {
    const elementColors = this._customColors[element.id];
    if (elementColors) {
      this._set(element, getColorsWithHighestPriority(elementColors));
    }
  });
};
ElementColors.prototype._applyHighestPriorityColor = function(element) {
  const elementColors = this._customColors[element.id];
  if (!elementColors) {
    this._set(element, this._originalColors[element.id]);
    return;
  }
  this._set(element, getColorsWithHighestPriority(elementColors));
};
ElementColors.prototype._forceRedraw = function(element) {
  const gfx = this._elementRegistry.getGraphics(element);
  const type = element.waypoints ? "connection" : "shape";
  this._graphicsFactory.update(type, element, gfx);
};
function isLabel4(element) {
  return "labelTarget" in element;
}
function getColorsWithHighestPriority(colors2 = {}) {
  const colorsWithHighestPriority = Object.values(colors2).reduce((colorsWithHighestPriority2, colors3) => {
    const { priority = 1e3 } = colors3;
    if (!colorsWithHighestPriority2 || priority > colorsWithHighestPriority2.priority) {
      return colors3;
    }
    return colorsWithHighestPriority2;
  }, void 0);
  if (colorsWithHighestPriority) {
    const { priority, ...fillAndStroke } = colorsWithHighestPriority;
    return fillAndStroke;
  }
}

// node_modules/bpmn-js-token-simulation/lib/features/element-colors/index.js
var element_colors_default = {
  elementColors: ["type", ElementColors]
};

// node_modules/bpmn-js-token-simulation/lib/features/exclusive-gateway-settings/index.js
var exclusive_gateway_settings_default = {
  __depends__: [
    element_colors_default,
    simulation_styles_default
  ],
  exclusiveGatewaySettings: ["type", ExclusiveGatewaySettings]
};

// node_modules/bpmn-js-token-simulation/lib/features/neutral-element-colors/NeutralElementColors.js
var ID4 = "neutral-element-colors";
function NeutralElementColors(eventBus, elementRegistry, elementColors) {
  this._elementRegistry = elementRegistry;
  this._elementColors = elementColors;
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    const { active } = event2;
    if (active) {
      this._setNeutralColors();
    }
  });
}
NeutralElementColors.prototype._setNeutralColors = function() {
  this._elementRegistry.forEach((element) => {
    this._elementColors.add(element, ID4, {
      stroke: "#212121",
      fill: "#fff"
    });
  });
};
NeutralElementColors.$inject = [
  "eventBus",
  "elementRegistry",
  "elementColors"
];

// node_modules/bpmn-js-token-simulation/lib/features/neutral-element-colors/index.js
var neutral_element_colors_default = {
  __depends__: [element_colors_default],
  __init__: [
    "neutralElementColors"
  ],
  neutralElementColors: ["type", NeutralElementColors]
};

// node_modules/bpmn-js-token-simulation/lib/features/inclusive-gateway-settings/InclusiveGatewaySettings.js
var SELECTED_COLOR2 = "--token-simulation-grey-darken-30";
var NOT_SELECTED_COLOR2 = "--token-simulation-grey-lighten-56";
var COLOR_ID = "inclusive-gateway-settings";
function InclusiveGatewaySettings(eventBus, elementRegistry, elementColors, simulator, simulationStyles) {
  this._elementRegistry = elementRegistry;
  this._elementColors = elementColors;
  this._simulator = simulator;
  this._simulationStyles = simulationStyles;
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    if (event2.active) {
      this.setDefaults();
    } else {
      this.reset();
    }
  });
}
InclusiveGatewaySettings.prototype.setDefaults = function() {
  const inclusiveGateways = this._elementRegistry.filter((element) => {
    return is(element, "bpmn:InclusiveGateway");
  });
  inclusiveGateways.forEach((inclusiveGateway) => {
    if (inclusiveGateway.outgoing.filter(isSequenceFlow2).length > 1) {
      this._setGatewayDefaults(inclusiveGateway);
    }
  });
};
InclusiveGatewaySettings.prototype.reset = function() {
  const inclusiveGateways = this._elementRegistry.filter((element) => {
    return is(element, "bpmn:InclusiveGateway");
  });
  inclusiveGateways.forEach((inclusiveGateway) => {
    if (inclusiveGateway.outgoing.filter(isSequenceFlow2).length > 1) {
      this._resetGateway(inclusiveGateway);
    }
  });
};
InclusiveGatewaySettings.prototype.toggleSequenceFlow = function(gateway, sequenceFlow) {
  const activeOutgoing = this._getActiveOutgoing(gateway), defaultFlow = getDefaultFlow(gateway), nonDefaultFlows = getNonDefaultFlows(gateway);
  let newActiveOutgoing;
  if (activeOutgoing.includes(sequenceFlow)) {
    newActiveOutgoing = without2(activeOutgoing, sequenceFlow);
  } else {
    newActiveOutgoing = without2(activeOutgoing, defaultFlow).concat(sequenceFlow);
  }
  if (!newActiveOutgoing.length) {
    if (defaultFlow) {
      newActiveOutgoing = [defaultFlow];
    } else {
      newActiveOutgoing = [nonDefaultFlows.find((flow) => flow !== sequenceFlow)];
    }
  }
  this._setActiveOutgoing(gateway, newActiveOutgoing);
};
InclusiveGatewaySettings.prototype._getActiveOutgoing = function(gateway) {
  const {
    activeOutgoing
  } = this._simulator.getConfig(gateway);
  return activeOutgoing;
};
InclusiveGatewaySettings.prototype._setActiveOutgoing = function(gateway, activeOutgoing) {
  this._simulator.setConfig(gateway, { activeOutgoing });
  const sequenceFlows = gateway.outgoing.filter(isSequenceFlow2);
  sequenceFlows.forEach((outgoing) => {
    const style = !activeOutgoing || activeOutgoing.includes(outgoing) ? SELECTED_COLOR2 : NOT_SELECTED_COLOR2;
    const stroke = this._simulationStyles.get(style);
    this._elementColors.add(outgoing, COLOR_ID, {
      stroke
    });
  });
};
InclusiveGatewaySettings.prototype._setGatewayDefaults = function(gateway) {
  const sequenceFlows = gateway.outgoing.filter(isSequenceFlow2);
  const defaultFlow = getDefaultFlow(gateway);
  const nonDefaultFlows = without2(sequenceFlows, defaultFlow);
  this._setActiveOutgoing(gateway, nonDefaultFlows);
};
InclusiveGatewaySettings.prototype._resetGateway = function(gateway) {
  this._setActiveOutgoing(gateway, void 0);
};
InclusiveGatewaySettings.$inject = [
  "eventBus",
  "elementRegistry",
  "elementColors",
  "simulator",
  "simulationStyles"
];
function getDefaultFlow(gateway) {
  const defaultFlow = getBusinessObject(gateway).default;
  if (!defaultFlow) {
    return;
  }
  return gateway.outgoing.find((flow) => {
    const flowBo = getBusinessObject(flow);
    return flowBo === defaultFlow;
  });
}
function getNonDefaultFlows(gateway) {
  const defaultFlow = getDefaultFlow(gateway);
  return gateway.outgoing.filter((flow) => {
    const flowBo = getBusinessObject(flow);
    return flowBo !== defaultFlow;
  });
}
function without2(array, element) {
  return array.filter((arrayElement) => arrayElement !== element);
}

// node_modules/bpmn-js-token-simulation/lib/features/inclusive-gateway-settings/index.js
var inclusive_gateway_settings_default = {
  __depends__: [
    element_colors_default,
    simulation_styles_default
  ],
  inclusiveGatewaySettings: ["type", InclusiveGatewaySettings]
};

// node_modules/bpmn-js-token-simulation/lib/features/palette/Palette.js
function Palette2(eventBus, canvas) {
  var self2 = this;
  this._canvas = canvas;
  this.entries = [];
  this._init();
  eventBus.on(TOGGLE_MODE_EVENT, function(context) {
    var active = context.active;
    if (active) {
      classes2(self2.container).remove("hidden");
    } else {
      classes2(self2.container).add("hidden");
    }
  });
}
Palette2.prototype._init = function() {
  this.container = domify$1('<div class="bts-palette hidden"></div>');
  this._canvas.getContainer().appendChild(this.container);
};
Palette2.prototype.addEntry = function(entry, index5) {
  var childIndex = 0;
  this.entries.forEach(function(entry2) {
    if (index5 >= entry2.index) {
      childIndex++;
    }
  });
  this.container.insertBefore(entry, this.container.childNodes[childIndex]);
  this.entries.push({
    entry,
    index: index5
  });
};
Palette2.$inject = ["eventBus", "canvas"];

// node_modules/bpmn-js-token-simulation/lib/features/palette/index.js
var palette_default3 = {
  __init__: [
    "tokenSimulationPalette"
  ],
  tokenSimulationPalette: ["type", Palette2]
};

// node_modules/bpmn-js-token-simulation/lib/base.js
var base_default = {
  __depends__: [
    simulator_default,
    animation_default,
    colored_scopes_default,
    context_pads_default,
    simulation_state_default,
    show_scopes_default,
    log_default,
    element_support_default,
    pause_simulation_default,
    reset_simulation_default,
    token_count_default,
    set_animation_speed_default,
    exclusive_gateway_settings_default,
    neutral_element_colors_default,
    inclusive_gateway_settings_default,
    palette_default3
  ]
};

// node_modules/bpmn-js-token-simulation/lib/features/disable-modeling/DisableModeling.js
var HIGH_PRIORITY25 = 10001;
function DisableModeling(eventBus, contextPad, dragging, directEditing, editorActions, modeling, palette) {
  let modelingDisabled = false;
  eventBus.on(TOGGLE_MODE_EVENT, HIGH_PRIORITY25, (event2) => {
    modelingDisabled = event2.active;
    if (modelingDisabled) {
      directEditing.cancel();
      dragging.cancel();
    }
    palette._update();
  });
  function intercept(obj, fnName, cb) {
    const fn2 = obj[fnName];
    obj[fnName] = function() {
      return cb.call(this, fn2, arguments);
    };
  }
  function ignoreIfModelingDisabled(obj, fnName) {
    intercept(obj, fnName, function(fn2, args) {
      if (modelingDisabled) {
        return;
      }
      return fn2.apply(this, args);
    });
  }
  function throwIfModelingDisabled(obj, fnName) {
    intercept(obj, fnName, function(fn2, args) {
      if (modelingDisabled) {
        throw new Error("model is read-only");
      }
      return fn2.apply(this, args);
    });
  }
  ignoreIfModelingDisabled(dragging, "init");
  ignoreIfModelingDisabled(directEditing, "activate");
  ignoreIfModelingDisabled(dragging, "init");
  ignoreIfModelingDisabled(directEditing, "activate");
  throwIfModelingDisabled(modeling, "moveShape");
  throwIfModelingDisabled(modeling, "updateAttachment");
  throwIfModelingDisabled(modeling, "moveElements");
  throwIfModelingDisabled(modeling, "moveConnection");
  throwIfModelingDisabled(modeling, "layoutConnection");
  throwIfModelingDisabled(modeling, "createConnection");
  throwIfModelingDisabled(modeling, "createShape");
  throwIfModelingDisabled(modeling, "createLabel");
  throwIfModelingDisabled(modeling, "appendShape");
  throwIfModelingDisabled(modeling, "removeElements");
  throwIfModelingDisabled(modeling, "distributeElements");
  throwIfModelingDisabled(modeling, "removeShape");
  throwIfModelingDisabled(modeling, "removeConnection");
  throwIfModelingDisabled(modeling, "replaceShape");
  throwIfModelingDisabled(modeling, "pasteElements");
  throwIfModelingDisabled(modeling, "alignElements");
  throwIfModelingDisabled(modeling, "resizeShape");
  throwIfModelingDisabled(modeling, "createSpace");
  throwIfModelingDisabled(modeling, "updateWaypoints");
  throwIfModelingDisabled(modeling, "reconnectStart");
  throwIfModelingDisabled(modeling, "reconnectEnd");
  intercept(editorActions, "trigger", function(fn2, args) {
    const action = args[0];
    if (modelingDisabled && !isAnyAction([
      "toggleTokenSimulation",
      "toggleTokenSimulationLog",
      "togglePauseTokenSimulation",
      "resetTokenSimulation",
      "stepZoom",
      "zoom"
    ], action)) {
      return;
    }
    return fn2.apply(this, args);
  });
}
DisableModeling.$inject = [
  "eventBus",
  "contextPad",
  "dragging",
  "directEditing",
  "editorActions",
  "modeling",
  "palette"
];
function isAnyAction(actions, action) {
  return actions.indexOf(action) > -1;
}

// node_modules/bpmn-js-token-simulation/lib/features/disable-modeling/index.js
var disable_modeling_default = {
  __init__: [
    "disableModeling"
  ],
  disableModeling: ["type", DisableModeling]
};

// node_modules/bpmn-js-token-simulation/lib/features/toggle-mode/modeler/ToggleMode.js
function ToggleMode(eventBus, canvas, selection2, contextPad) {
  this._eventBus = eventBus;
  this._canvas = canvas;
  this._selection = selection2;
  this._contextPad = contextPad;
  this._active = false;
  eventBus.on("import.parse.start", () => {
    if (this._active) {
      this.toggleMode(false);
      eventBus.once("import.done", () => {
        this.toggleMode(true);
      });
    }
  });
  eventBus.on("diagram.init", () => {
    this._canvasParent = this._canvas.getContainer().parentNode;
    this._palette = query(".djs-palette", this._canvas.getContainer());
    this._init();
  });
}
ToggleMode.prototype._init = function() {
  this._container = domify$1(`
    <div class="bts-toggle-mode">
      Token Simulation <span class="bts-toggle">${ToggleOffIcon()}</span>
    </div>
  `);
  event.bind(this._container, "click", () => this.toggleMode());
  this._canvas.getContainer().appendChild(this._container);
};
ToggleMode.prototype.toggleMode = function(active = !this._active) {
  if (active === this._active) {
    return;
  }
  if (active) {
    this._container.innerHTML = `Token Simulation <span class="bts-toggle">${ToggleOnIcon()}</span>`;
    classes2(this._canvasParent).add("simulation");
    classes2(this._palette).add("hidden");
  } else {
    this._container.innerHTML = `Token Simulation <span class="bts-toggle">${ToggleOffIcon()}</span>`;
    classes2(this._canvasParent).remove("simulation");
    classes2(this._palette).remove("hidden");
    const elements = this._selection.get();
    if (elements.length === 1) {
      this._contextPad.open(elements[0]);
    }
  }
  this._eventBus.fire(TOGGLE_MODE_EVENT, {
    active
  });
  this._active = active;
};
ToggleMode.$inject = [
  "eventBus",
  "canvas",
  "selection",
  "contextPad"
];

// node_modules/bpmn-js-token-simulation/lib/features/toggle-mode/modeler/index.js
var modeler_default = {
  __init__: [
    "toggleMode"
  ],
  toggleMode: ["type", ToggleMode]
};

// node_modules/bpmn-js-token-simulation/lib/features/editor-actions/EditorActions.js
function EditorActions2(eventBus, toggleMode, pauseSimulation, resetSimulation, editorActions, injector) {
  var active = false;
  editorActions.register({
    toggleTokenSimulation: function() {
      toggleMode.toggleMode();
    }
  });
  editorActions.register({
    togglePauseTokenSimulation: function() {
      active && pauseSimulation.toggle();
    }
  });
  editorActions.register({
    resetTokenSimulation: function() {
      active && resetSimulation.resetSimulation();
    }
  });
  const log = injector.get("log", false);
  log && editorActions.register({
    toggleTokenSimulationLog: function() {
      log.toggle();
    }
  });
  eventBus.on(TOGGLE_MODE_EVENT, (event2) => {
    active = event2.active;
  });
}
EditorActions2.$inject = [
  "eventBus",
  "toggleMode",
  "pauseSimulation",
  "resetSimulation",
  "editorActions",
  "injector"
];

// node_modules/bpmn-js-token-simulation/lib/features/editor-actions/index.js
var editor_actions_default3 = {
  __init__: [
    "tokenSimulationEditorActions"
  ],
  tokenSimulationEditorActions: ["type", EditorActions2]
};

// node_modules/bpmn-js-token-simulation/lib/features/keyboard-bindings/KeyboardBindings.js
var VERY_HIGH_PRIORITY3 = 1e4;
function KeyboardBindings2(eventBus, injector) {
  var editorActions = injector.get("editorActions", false), keyboard = injector.get("keyboard", false);
  if (!keyboard || !editorActions) {
    return;
  }
  var isActive = false;
  function handleKeyEvent(keyEvent) {
    if (isKey2(["t", "T"], keyEvent)) {
      editorActions.trigger("toggleTokenSimulation");
      return true;
    }
    if (!isActive) {
      return;
    }
    if (isKey2(["l", "L"], keyEvent)) {
      editorActions.trigger("toggleTokenSimulationLog");
      return true;
    }
    if (isKey2([" ", "Spacebar"], keyEvent)) {
      editorActions.trigger("togglePauseTokenSimulation");
      return true;
    }
    if (isKey2(["r", "R"], keyEvent)) {
      editorActions.trigger("resetTokenSimulation");
      return true;
    }
  }
  eventBus.on("keyboard.init", function() {
    keyboard.addListener(VERY_HIGH_PRIORITY3, function(event2) {
      var keyEvent = event2.keyEvent;
      return handleKeyEvent(keyEvent);
    });
  });
  eventBus.on(TOGGLE_MODE_EVENT, function(context) {
    var active = context.active;
    if (active) {
      isActive = true;
    } else {
      isActive = false;
    }
  });
}
KeyboardBindings2.$inject = ["eventBus", "injector"];
function isKey2(keys2, event2) {
  return keys2.indexOf(event2.key) > -1;
}

// node_modules/bpmn-js-token-simulation/lib/features/keyboard-bindings/index.js
var keyboard_bindings_default = {
  __init__: [
    "tokenSimulationKeyboardBindings"
  ],
  tokenSimulationKeyboardBindings: ["type", KeyboardBindings2]
};

// node_modules/bpmn-js-token-simulation/lib/modeler.js
var modeler_default2 = {
  __depends__: [
    base_default,
    disable_modeling_default,
    modeler_default,
    editor_actions_default3,
    keyboard_bindings_default
  ]
};

// node_modules/bpmn-js-token-simulation/lib/simulation-support/SimulationTrace.js
var VERY_HIGH_PRIORITY4 = 1e5;
function SimulationTrace(eventBus) {
  this._eventBus = eventBus;
  this._events = [];
  this._log = this._log.bind(this);
}
SimulationTrace.$inject = ["eventBus"];
SimulationTrace.prototype._log = function(event2) {
  this._events.push(assign({}, event2));
};
SimulationTrace.prototype.start = function() {
  forEach(EventHelper_exports, (event2) => {
    this._eventBus.on(event2, VERY_HIGH_PRIORITY4, this._log);
  });
};
SimulationTrace.prototype.stop = function() {
  forEach(EventHelper_exports, (event2) => {
    this._eventBus.off(event2, this._log);
  });
};
SimulationTrace.prototype.getAll = function() {
  return this._events;
};

// node_modules/bpmn-js-token-simulation/lib/simulation-support/SimulationSupport.js
var ENTER_EVENT = "trace.elementEnter";
var EXIT_EVENT2 = "trace.elementExit";
function SimulationSupport(bpmnjs, toggleMode) {
  this._bpmnjs = bpmnjs;
  this._toggleMode = toggleMode;
}
SimulationSupport.$inject = [
  "bpmnjs",
  "toggleMode"
];
SimulationSupport.prototype.toggleSimulation = function(active) {
  if (typeof active === "undefined") {
    active = !this._toggleMode._active;
  }
  this._toggleMode.toggleMode(active);
};
SimulationSupport.prototype.getElementTrigger = function(id) {
  return this._bpmnjs.invoke(["bpmnjs", function(bpmnjs) {
    return query(
      `.djs-overlays[data-container-id='${id}'] .bts-context-pad:not(.hidden)`,
      bpmnjs._container
    );
  }]);
};
SimulationSupport.prototype.getScopeTrigger = function(scope) {
  return this._bpmnjs.invoke(["bpmnjs", function(bpmnjs) {
    return query(
      `.bts-scopes [data-scope-id='${scope.id}']`,
      bpmnjs._container
    );
  }]);
};
SimulationSupport.prototype.triggerElement = function(id) {
  const domElement = this.getElementTrigger(id);
  if (!domElement) {
    throw new Error(`no element trigger for <${id}>`);
  }
  this._triggerClick(domElement);
};
SimulationSupport.prototype.triggerScope = function(scope) {
  const domElement = this.getScopeTrigger(scope);
  this._triggerClick(domElement);
};
SimulationSupport.prototype.scopeDestroyed = function(scope = null) {
  return new Promise((resolve) => {
    return this._bpmnjs.invoke(["eventBus", function(eventBus) {
      const listener = function(event2) {
        if (scope && event2.scope !== scope) {
          return;
        }
        const scopeElements = [
          "bpmn:Participant",
          "bpmn:Process",
          "bpmn:SubProcess"
        ];
        if (scopeElements.every((t7) => !is(event2.scope.element, t7))) {
          return;
        }
        eventBus.off(SCOPE_DESTROYED_EVENT, listener);
        return resolve(event2);
      };
      eventBus.on(SCOPE_DESTROYED_EVENT, listener);
    }]);
  });
};
SimulationSupport.prototype.elementEnter = function(id = null) {
  return new Promise((resolve) => {
    return this._bpmnjs.invoke(["eventBus", function(eventBus) {
      const wrap2 = id ? (fn2) => ifElement(id, fn2) : (fn2) => fn2;
      const listener = wrap2(function(event2) {
        eventBus.off(ENTER_EVENT, listener);
        return resolve(event2);
      });
      eventBus.on(ENTER_EVENT, listener);
    }]);
  });
};
SimulationSupport.prototype.elementExit = function(id = null) {
  return new Promise((resolve) => {
    return this._bpmnjs.invoke(["eventBus", function(eventBus) {
      const wrap2 = id ? (fn2) => ifElement(id, fn2) : (fn2) => fn2;
      const listener = wrap2(function(event2) {
        eventBus.off(EXIT_EVENT2, listener);
        return resolve(event2);
      });
      eventBus.on(EXIT_EVENT2, listener);
    }]);
  });
};
SimulationSupport.prototype.getHistory = function(history) {
  return this._bpmnjs.invoke(["simulationTrace", function(simulationTrace) {
    return simulationTrace.getAll().filter(function(event2) {
      return event2.action === "exit" && (is(event2.element, "bpmn:StartEvent") || is(event2.element, "bpmn:BoundaryEvent")) || event2.action === "enter";
    }).map(function(event2) {
      return event2.element.id;
    });
  }]);
};
SimulationSupport.prototype._triggerClick = function(element, options = {}) {
  const defaultOptions = {
    pointerX: 0,
    pointerY: 0,
    button: 0,
    ctrlKey: false,
    altKey: false,
    shiftKey: false,
    metaKey: false,
    bubbles: true,
    cancelable: true
  };
  options = Object.assign({}, defaultOptions, options);
  const event2 = document.createEvent("MouseEvents");
  event2.initMouseEvent(
    "click",
    options.bubbles,
    options.cancelable,
    document.defaultView,
    options.button,
    options.pointerX,
    options.pointerY,
    options.pointerX,
    options.pointerY,
    options.ctrlKey,
    options.altKey,
    options.shiftKey,
    options.metaKey,
    options.button,
    element
  );
  element.dispatchEvent(event2);
};
function ifElement(id, fn2) {
  return function(event2) {
    var element = event2.element;
    if (element.id === id) {
      fn2(event2);
    }
  };
}

// node_modules/bpmn-js-token-simulation/lib/simulation-support/index.js
var simulation_support_default = {
  __init__: ["eventBus", function(eventBus) {
    eventBus.on(TRACE_EVENT, function(event2) {
      if (event2.action === "enter") {
        eventBus.fire(ENTER_EVENT, event2);
      }
      if (event2.action === "exit") {
        eventBus.fire(EXIT_EVENT2, event2);
      }
    });
  }],
  simulationTrace: ["type", SimulationTrace],
  simulationSupport: ["type", SimulationSupport]
};

// node_modules/bpmn-js-color-picker/colors/ColorContextPadProvider.js
var colorImageSvg = `<svg xmlns="http://www.w3.org/2000/svg" width="22" height="22" fill="currentColor">
  <path d="m12.5 5.5.3-.4 3.6-3.6c.5-.5 1.3-.5 1.7 0l1 1c.5.4.5 1.2 0 1.7l-3.6 3.6-.4.2v.2c0 1.4.6 2 1 2.7v.6l-1.7 1.6c-.2.2-.4.2-.6 0L7.3 6.6a.4.4 0 0 1 0-.6l.3-.3.5-.5.8-.8c.2-.2.4-.1.6 0 .9.5 1.5 1.1 3 1.1zm-9.9 6 4.2-4.2 6.3 6.3-4.2 4.2c-.3.3-.9.3-1.2 0l-.8-.8-.9-.8-2.3-2.9" />
</svg>`;
function ColorContextPadProvider(contextPad, popupMenu, canvas, translate4) {
  this._contextPad = contextPad;
  this._popupMenu = popupMenu;
  this._canvas = canvas;
  this._translate = translate4;
  contextPad.registerProvider(this);
}
ColorContextPadProvider.$inject = [
  "contextPad",
  "popupMenu",
  "canvas",
  "translate"
];
ColorContextPadProvider.prototype.getContextPadEntries = function(element) {
  return this._createPopupAction([element]);
};
ColorContextPadProvider.prototype.getMultiElementContextPadEntries = function(elements) {
  return this._createPopupAction(elements);
};
ColorContextPadProvider.prototype._createPopupAction = function(elements) {
  const translate4 = this._translate;
  const contextPad = this._contextPad;
  const popupMenu = this._popupMenu;
  return {
    "set-color": {
      group: "edit",
      className: "bpmn-icon-color",
      title: translate4("Set color"),
      html: `<div class="entry">${colorImageSvg}</div>`,
      action: {
        click: (event2, element) => {
          var position = {
            ...getStartPosition(contextPad, elements),
            cursor: {
              x: event2.x,
              y: event2.y
            }
          };
          popupMenu.open(elements, "color-picker", position);
        }
      }
    }
  };
};
function getStartPosition(contextPad, elements) {
  var Y_OFFSET = 5;
  var pad = contextPad.getPad(elements).html;
  var padRect = pad.getBoundingClientRect();
  var pos = {
    x: padRect.left,
    y: padRect.bottom + Y_OFFSET
  };
  return pos;
}

// node_modules/bpmn-js-color-picker/colors/ColorPopupProvider.js
var COLORS = [{
  label: "Default",
  fill: void 0,
  stroke: void 0
}, {
  label: "Blue",
  fill: "#BBDEFB",
  stroke: "#0D4372"
}, {
  label: "Orange",
  fill: "#FFE0B2",
  stroke: "#6B3C00"
}, {
  label: "Green",
  fill: "#C8E6C9",
  stroke: "#205022"
}, {
  label: "Red",
  fill: "#FFCDD2",
  stroke: "#831311"
}, {
  label: "Purple",
  fill: "#E1BEE7",
  stroke: "#5B176D"
}];
function ColorPopupProvider(config, bpmnRendererConfig, popupMenu, modeling, translate4) {
  this._popupMenu = popupMenu;
  this._modeling = modeling;
  this._translate = translate4;
  this._colors = config && config.colors || COLORS;
  this._defaultFillColor = bpmnRendererConfig && bpmnRendererConfig.defaultFillColor || "white";
  this._defaultStrokeColor = bpmnRendererConfig && bpmnRendererConfig.defaultStrokeColor || "rgb(34, 36, 42)";
  this._popupMenu.registerProvider("color-picker", this);
}
ColorPopupProvider.$inject = [
  "config.colorPicker",
  "config.bpmnRenderer",
  "popupMenu",
  "modeling",
  "translate"
];
ColorPopupProvider.prototype.getEntries = function(elements) {
  var self2 = this;
  var colorIconHtml = `
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 25 25" height="100%" width="100%">
      <rect rx="2" x="1" y="1" width="22" height="22" fill="var(--fill-color)" stroke="var(--stroke-color)" style="stroke-width:2"></rect>
    </svg>
  `;
  var entries = this._colors.map(function(color) {
    var entryColorIconHtml = colorIconHtml.replace("var(--fill-color)", color.fill || self2._defaultFillColor).replace("var(--stroke-color)", color.stroke || self2._defaultStrokeColor);
    return {
      title: self2._translate(color.label),
      id: color.label.toLowerCase() + "-color",
      imageHtml: entryColorIconHtml,
      action: createAction(self2._modeling, elements, color)
    };
  });
  return entries;
};
function createAction(modeling, element, color) {
  return function() {
    modeling.setColor(element, color);
  };
}

// node_modules/bpmn-js-color-picker/colors/index.js
var colors_default = {
  __init__: [
    "colorContextPadProvider",
    "colorPopupProvider"
  ],
  colorContextPadProvider: ["type", ColorContextPadProvider],
  colorPopupProvider: ["type", ColorPopupProvider]
};

// node_modules/diagram-js-grid/dist/index.esm.js
var GRID_COLOR = "#ccc";
var LAYER_NAME2 = "djs-grid";
var GRID_DIMENSIONS = {
  width: 1e5,
  height: 1e5
};
function Grid(canvas, eventBus) {
  this._canvas = canvas;
  var self2 = this;
  eventBus.on("diagram.init", function() {
    self2._init();
    self2.toggle(true);
  });
  eventBus.on("gridSnapping.toggle", function(event2) {
    var active = event2.active;
    self2.toggle(active);
    self2._centerGridAroundViewbox();
  });
  eventBus.on("canvas.viewbox.changed", function(context) {
    var viewbox = context.viewbox;
    self2._centerGridAroundViewbox(viewbox);
  });
}
Grid.prototype._init = function() {
  var defs = query("defs", this._canvas._svg);
  if (!defs) {
    defs = create("defs");
    append(this._canvas._svg, defs);
  }
  var pattern = this._pattern = create("pattern");
  var patternId = "djs-grid-pattern-" + randomNumber();
  attr(pattern, {
    id: patternId,
    width: SPACING,
    height: SPACING,
    patternUnits: "userSpaceOnUse"
  });
  var circle = this._circle = create("circle");
  attr(circle, {
    cx: 0.5,
    cy: 0.5,
    r: 0.5,
    fill: GRID_COLOR
  });
  append(pattern, circle);
  append(defs, pattern);
  var grid = this._gfx = create("rect");
  attr(grid, {
    x: -(GRID_DIMENSIONS.width / 2),
    y: -(GRID_DIMENSIONS.height / 2),
    width: GRID_DIMENSIONS.width,
    height: GRID_DIMENSIONS.height,
    fill: `url(#${patternId})`
  });
};
Grid.prototype._centerGridAroundViewbox = function(viewbox) {
  if (!viewbox) {
    viewbox = this._canvas.viewbox();
  }
  var mid4 = getMid(viewbox);
  attr(this._gfx, {
    x: -(GRID_DIMENSIONS.width / 2) + quantize(mid4.x, SPACING),
    y: -(GRID_DIMENSIONS.height / 2) + quantize(mid4.y, SPACING)
  });
};
Grid.prototype.isVisible = function() {
  return this._visible;
};
Grid.prototype.toggle = function(visible) {
  if (typeof visible === "undefined") {
    visible = !this._visible;
  }
  if (visible === this._visible) {
    return;
  }
  var parent = this._getParent();
  if (visible) {
    append(parent, this._gfx);
  } else {
    clear(parent);
  }
  this._visible = visible;
};
Grid.prototype._getParent = function() {
  return this._canvas.getLayer(LAYER_NAME2, -2);
};
Grid.$inject = [
  "canvas",
  "eventBus"
];
function randomNumber() {
  return Math.trunc(Math.random() * 1e6);
}
var index3 = {
  __init__: ["grid"],
  grid: ["type", Grid]
};

// node_modules/diagram-js-minimap/dist/index.esm.js
var MINIMAP_VIEWBOX_PADDING = 50;
var IDS = new IdGenerator();
var RANGE2 = { min: 0.2, max: 4 };
var NUM_STEPS2 = 10;
var DELTA_THRESHOLD2 = 0.1;
var LOW_PRIORITY31 = 250;
function Minimap(config, injector, eventBus, canvas, elementRegistry) {
  var self2 = this;
  this._canvas = canvas;
  this._elementRegistry = elementRegistry;
  this._eventBus = eventBus;
  this._injector = injector;
  this._state = {
    isOpen: void 0,
    isDragging: false,
    initialDragPosition: null,
    offsetViewport: null,
    cachedViewbox: null,
    dragger: null,
    svgClientRect: null,
    parentClientRect: null,
    zoomDelta: 0
  };
  this._minimapId = IDS.next();
  this._init();
  this.toggle(config && config.open || false);
  function centerViewbox(point) {
    if (!self2._state._svgClientRect || isZeroDimensional(self2._state._svgClientRect)) {
      self2._state._svgClientRect = self2._svg.getBoundingClientRect();
    }
    var diagramPoint = mapMousePositionToDiagramPoint({
      x: point.x - self2._state._svgClientRect.left,
      y: point.y - self2._state._svgClientRect.top
    }, self2._svg, self2._lastViewbox);
    setViewboxCenteredAroundPoint(diagramPoint, self2._canvas);
    self2._update();
  }
  function mousedown(center2) {
    return function onMousedown(event$1) {
      var point = getPoint(event$1);
      if (!self2._state._svgClientRect || isZeroDimensional(self2._state._svgClientRect)) {
        self2._state._svgClientRect = self2._svg.getBoundingClientRect();
      }
      if (center2) {
        centerViewbox(point);
      }
      var diagramPoint = mapMousePositionToDiagramPoint({
        x: point.x - self2._state._svgClientRect.left,
        y: point.y - self2._state._svgClientRect.top
      }, self2._svg, self2._lastViewbox);
      var viewbox = canvas.viewbox();
      var offsetViewport = getOffsetViewport(diagramPoint, viewbox);
      var initialViewportDomRect = self2._viewportDom.getBoundingClientRect();
      var offsetViewportDom = {
        x: point.x - initialViewportDomRect.left + 1,
        y: point.y - initialViewportDomRect.top + 1
      };
      assign(self2._state, {
        cachedViewbox: viewbox,
        initialDragPosition: {
          x: point.x,
          y: point.y
        },
        isDragging: true,
        offsetViewport,
        offsetViewportDom,
        viewportClientRect: self2._viewport.getBoundingClientRect(),
        parentClientRect: self2._parent.getBoundingClientRect()
      });
      event.bind(document, "mousemove", onMousemove);
      event.bind(document, "mouseup", onMouseup);
    };
  }
  function onMousemove(event2) {
    var point = getPoint(event2);
    if (self2._state.isDragging) {
      if (!self2._state._svgClientRect || isZeroDimensional(self2._state._svgClientRect)) {
        self2._state._svgClientRect = self2._svg.getBoundingClientRect();
      }
      var offsetViewportDom = self2._state.offsetViewportDom, viewportClientRect = self2._state.viewportClientRect, parentClientRect = self2._state.parentClientRect;
      assign(self2._viewportDom.style, {
        top: point.y - offsetViewportDom.y - parentClientRect.top + "px",
        left: point.x - offsetViewportDom.x - parentClientRect.left + "px"
      });
      var clipPath = getOverlayClipPath(parentClientRect, {
        top: point.y - offsetViewportDom.y - parentClientRect.top,
        left: point.x - offsetViewportDom.x - parentClientRect.left,
        width: viewportClientRect.width,
        height: viewportClientRect.height
      });
      assign(self2._overlay.style, {
        clipPath
      });
      var diagramPoint = mapMousePositionToDiagramPoint({
        x: point.x - self2._state._svgClientRect.left,
        y: point.y - self2._state._svgClientRect.top
      }, self2._svg, self2._lastViewbox);
      setViewboxCenteredAroundPoint({
        x: diagramPoint.x - self2._state.offsetViewport.x,
        y: diagramPoint.y - self2._state.offsetViewport.y
      }, self2._canvas);
    }
  }
  function onMouseup(event$1) {
    var point = getPoint(event$1);
    if (self2._state.isDragging) {
      if (self2._state.initialDragPosition.x === point.x && self2._state.initialDragPosition.y === point.y) {
        centerViewbox(event$1);
      }
      self2._update();
      assign(self2._state, {
        cachedViewbox: null,
        initialDragPosition: null,
        isDragging: false,
        offsetViewport: null,
        offsetViewportDom: null
      });
      event.unbind(document, "mousemove", onMousemove);
      event.unbind(document, "mouseup", onMouseup);
    }
  }
  event.bind(this._viewportDom, "mousedown", mousedown(false));
  event.bind(this._svg, "mousedown", mousedown(true));
  event.bind(this._parent, "wheel", function(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    if (!event2.ctrlKey) {
      return;
    }
    if (!self2._state._svgClientRect || isZeroDimensional(self2._state._svgClientRect)) {
      self2._state._svgClientRect = self2._svg.getBoundingClientRect();
    }
    if (!isPointInside(event2, self2._state._svgClientRect)) {
      return;
    }
    var factor = event2.deltaMode === 0 ? 0.02 : 0.32;
    var delta2 = Math.sqrt(
      Math.pow(event2.deltaY, 2) + Math.pow(event2.deltaX, 2)
    ) * sign2(event2.deltaY) * -factor;
    self2._state.zoomDelta += delta2;
    if (Math.abs(self2._state.zoomDelta) > DELTA_THRESHOLD2) {
      var direction = delta2 > 0 ? 1 : -1;
      var currentLinearZoomLevel = Math.log(canvas.zoom()) / Math.log(10);
      var stepSize = getStepSize2(RANGE2, NUM_STEPS2 * 2);
      var newLinearZoomLevel = Math.round(currentLinearZoomLevel / stepSize) * stepSize;
      newLinearZoomLevel += stepSize * direction;
      var newLogZoomLevel = Math.pow(10, newLinearZoomLevel);
      canvas.zoom(cap2(RANGE2, newLogZoomLevel), diagramPoint);
      self2._state.zoomDelta = 0;
      var diagramPoint = mapMousePositionToDiagramPoint({
        x: event2.clientX - self2._state._svgClientRect.left,
        y: event2.clientY - self2._state._svgClientRect.top
      }, self2._svg, self2._lastViewbox);
      setViewboxCenteredAroundPoint(diagramPoint, self2._canvas);
      self2._update();
    }
  });
  event.bind(this._toggle, "click", function(event2) {
    event2.preventDefault();
    event2.stopPropagation();
    self2.toggle();
  });
  eventBus.on(["shape.added", "connection.added"], function(context) {
    var element = context.element;
    self2._addElement(element);
    self2._update();
  });
  eventBus.on(["shape.removed", "connection.removed"], function(context) {
    var element = context.element;
    self2._removeElement(element);
    self2._update();
  });
  eventBus.on("elements.changed", LOW_PRIORITY31, function(context) {
    var elements = context.elements;
    elements.forEach(function(element) {
      self2._updateElement(element);
    });
    self2._update();
  });
  eventBus.on("element.updateId", function(context) {
    var element = context.element, newId = context.newId;
    self2._updateElementId(element, newId);
  });
  eventBus.on("canvas.viewbox.changed", function() {
    if (!self2._state.isDragging) {
      self2._update();
    }
  });
  eventBus.on("canvas.resized", function() {
    if (document.body.contains(self2._parent)) {
      if (!self2._state.isDragging) {
        self2._update();
      }
      self2._state._svgClientRect = self2._svg.getBoundingClientRect();
    }
  });
  eventBus.on(["root.set", "plane.set"], function(event2) {
    self2._clear();
    var element = event2.element || event2.plane.rootElement;
    element.children.forEach(function(el) {
      self2._addElement(el);
    });
    self2._update();
  });
}
Minimap.$inject = [
  "config.minimap",
  "injector",
  "eventBus",
  "canvas",
  "elementRegistry"
];
Minimap.prototype._init = function() {
  var canvas = this._canvas, container = canvas.getContainer();
  var parent = this._parent = document.createElement("div");
  classes2(parent).add("djs-minimap");
  container.appendChild(parent);
  var toggle2 = this._toggle = document.createElement("div");
  classes2(toggle2).add("toggle");
  parent.appendChild(toggle2);
  var map4 = this._map = document.createElement("div");
  classes2(map4).add("map");
  parent.appendChild(map4);
  var svg = this._svg = create("svg");
  attr(svg, { width: "100%", height: "100%" });
  append(map4, svg);
  var elementsGroup = this._elementsGroup = create("g");
  append(svg, elementsGroup);
  var viewportGroup = this._viewportGroup = create("g");
  append(svg, viewportGroup);
  var viewport = this._viewport = create("rect");
  classes(viewport).add("viewport");
  append(viewportGroup, viewport);
  event.bind(parent, "mousedown", function(event2) {
    event2.stopPropagation();
  });
  var viewportDom = this._viewportDom = document.createElement("div");
  classes2(viewportDom).add("viewport-dom");
  this._parent.appendChild(viewportDom);
  var overlay = this._overlay = document.createElement("div");
  classes2(overlay).add("overlay");
  this._parent.appendChild(overlay);
};
Minimap.prototype._update = function() {
  var viewbox = this._canvas.viewbox(), innerViewbox = viewbox.inner, outerViewbox = viewbox.outer;
  if (!validViewbox(viewbox)) {
    return;
  }
  var x6, y5, width, height;
  var widthDifference = outerViewbox.width - innerViewbox.width, heightDifference = outerViewbox.height - innerViewbox.height;
  if (innerViewbox.width < outerViewbox.width) {
    x6 = innerViewbox.x - widthDifference / 2;
    width = outerViewbox.width;
    if (innerViewbox.x + innerViewbox.width < outerViewbox.width) {
      x6 = Math.min(0, innerViewbox.x);
    }
  } else {
    x6 = innerViewbox.x;
    width = innerViewbox.width;
  }
  if (innerViewbox.height < outerViewbox.height) {
    y5 = innerViewbox.y - heightDifference / 2;
    height = outerViewbox.height;
    if (innerViewbox.y + innerViewbox.height < outerViewbox.height) {
      y5 = Math.min(0, innerViewbox.y);
    }
  } else {
    y5 = innerViewbox.y;
    height = innerViewbox.height;
  }
  x6 = x6 - MINIMAP_VIEWBOX_PADDING;
  y5 = y5 - MINIMAP_VIEWBOX_PADDING;
  width = width + MINIMAP_VIEWBOX_PADDING * 2;
  height = height + MINIMAP_VIEWBOX_PADDING * 2;
  this._lastViewbox = {
    x: x6,
    y: y5,
    width,
    height
  };
  attr(this._svg, {
    viewBox: x6 + ", " + y5 + ", " + width + ", " + height
  });
  attr(this._viewport, {
    x: viewbox.x,
    y: viewbox.y,
    width: viewbox.width,
    height: viewbox.height
  });
  var parentClientRect = this._state._parentClientRect = this._parent.getBoundingClientRect();
  var viewportClientRect = this._viewport.getBoundingClientRect();
  var withoutParentOffset = {
    top: viewportClientRect.top - parentClientRect.top,
    left: viewportClientRect.left - parentClientRect.left,
    width: viewportClientRect.width,
    height: viewportClientRect.height
  };
  assign(this._viewportDom.style, {
    top: withoutParentOffset.top + "px",
    left: withoutParentOffset.left + "px",
    width: withoutParentOffset.width + "px",
    height: withoutParentOffset.height + "px"
  });
  var clipPath = getOverlayClipPath(parentClientRect, withoutParentOffset);
  assign(this._overlay.style, {
    clipPath
  });
};
Minimap.prototype.open = function() {
  assign(this._state, { isOpen: true });
  classes2(this._parent).add("open");
  var translate4 = this._injector.get("translate", false) || function(s5) {
    return s5;
  };
  attr2(this._toggle, "title", translate4("Close minimap"));
  this._update();
  this._eventBus.fire("minimap.toggle", { open: true });
};
Minimap.prototype.close = function() {
  assign(this._state, { isOpen: false });
  classes2(this._parent).remove("open");
  var translate4 = this._injector.get("translate", false) || function(s5) {
    return s5;
  };
  attr2(this._toggle, "title", translate4("Open minimap"));
  this._eventBus.fire("minimap.toggle", { open: false });
};
Minimap.prototype.toggle = function(open3) {
  var currentOpen = this.isOpen();
  if (typeof open3 === "undefined") {
    open3 = !currentOpen;
  }
  if (open3 == currentOpen) {
    return;
  }
  if (open3) {
    this.open();
  } else {
    this.close();
  }
};
Minimap.prototype.isOpen = function() {
  return this._state.isOpen;
};
Minimap.prototype._updateElement = function(element) {
  try {
    if (element.parent !== void 0 && element.parent !== null) {
      this._removeElement(element);
      this._addElement(element);
    }
  } catch (error4) {
    console.warn("Minimap#_updateElement errored", error4);
  }
};
Minimap.prototype._updateElementId = function(element, newId) {
  try {
    var elementGfx = query("#" + escapeCSS(this._prefixId(element.id)), this._elementsGroup);
    if (elementGfx) {
      elementGfx.id = this._prefixId(newId);
    }
  } catch (error4) {
    console.warn("Minimap#_updateElementId errored", error4);
  }
};
Minimap.prototype.isOnActivePlane = function(element) {
  var canvas = this._canvas;
  if (canvas.findRoot) {
    return canvas.findRoot(element) === canvas.getRootElement();
  }
  if (canvas.findPlane) {
    return canvas.findPlane(element) === canvas.getActivePlane();
  }
  return true;
};
Minimap.prototype._addElement = function(element) {
  var self2 = this;
  this._removeElement(element);
  if (!this.isOnActivePlane(element)) {
    return;
  }
  var parent, x6, y5;
  var newElementGfx = this._createElement(element);
  var newElementParentGfx = query("#" + escapeCSS(this._prefixId(element.parent.id)), this._elementsGroup);
  if (newElementGfx) {
    var elementGfx = this._elementRegistry.getGraphics(element);
    var parentGfx = this._elementRegistry.getGraphics(element.parent);
    var index5 = getIndexOfChildInParentChildren(elementGfx, parentGfx);
    if (index5 !== "undefined") {
      if (newElementParentGfx) {
        if (newElementParentGfx.childNodes.length > index5) {
          insertChildAtIndex(newElementGfx, newElementParentGfx, index5);
        } else {
          insertChildAtIndex(newElementGfx, newElementParentGfx, newElementParentGfx.childNodes.length - 1);
        }
      } else {
        this._elementsGroup.appendChild(newElementGfx);
      }
    } else {
      this._elementsGroup.appendChild(newElementGfx);
    }
    if (isConnection2(element)) {
      parent = element.parent;
      x6 = 0;
      y5 = 0;
      if (typeof parent.x !== "undefined" && typeof parent.y !== "undefined") {
        x6 = -parent.x;
        y5 = -parent.y;
      }
      attr(newElementGfx, { transform: "translate(" + x6 + " " + y5 + ")" });
    } else {
      x6 = element.x;
      y5 = element.y;
      if (newElementParentGfx) {
        parent = element.parent;
        x6 -= parent.x;
        y5 -= parent.y;
      }
      attr(newElementGfx, { transform: "translate(" + x6 + " " + y5 + ")" });
    }
    if (element.children && element.children.length) {
      element.children.forEach(function(child) {
        self2._addElement(child);
      });
    }
    return newElementGfx;
  }
};
Minimap.prototype._removeElement = function(element) {
  var elementGfx = this._svg.getElementById(this._prefixId(element.id));
  if (elementGfx) {
    remove(elementGfx);
  }
};
Minimap.prototype._createElement = function(element) {
  var gfx = this._elementRegistry.getGraphics(element), visual;
  if (gfx) {
    visual = getVisual(gfx);
    if (visual) {
      var elementGfx = sanitize(clone(visual));
      attr(elementGfx, { id: this._prefixId(element.id) });
      return elementGfx;
    }
  }
};
Minimap.prototype._clear = function() {
  clear(this._elementsGroup);
};
Minimap.prototype._prefixId = function(id) {
  return "djs-minimap-" + id + "-" + this._minimapId;
};
function isConnection2(element) {
  return element.waypoints;
}
function getOffsetViewport(diagramPoint, viewbox) {
  var viewboxCenter = {
    x: viewbox.x + viewbox.width / 2,
    y: viewbox.y + viewbox.height / 2
  };
  return {
    x: diagramPoint.x - viewboxCenter.x,
    y: diagramPoint.y - viewboxCenter.y
  };
}
function mapMousePositionToDiagramPoint(position, svg, lastViewbox) {
  var boundingClientRect = svg.getBoundingClientRect();
  var bBox = fitAspectRatio(lastViewbox, boundingClientRect.width / boundingClientRect.height);
  var diagramX = map3(position.x, 0, boundingClientRect.width, bBox.x, bBox.x + bBox.width), diagramY = map3(position.y, 0, boundingClientRect.height, bBox.y, bBox.y + bBox.height);
  return {
    x: diagramX,
    y: diagramY
  };
}
function setViewboxCenteredAroundPoint(point, canvas) {
  var cachedViewbox = canvas.viewbox(), cachedViewboxWidth = cachedViewbox.width, cachedViewboxHeight = cachedViewbox.height;
  canvas.viewbox({
    x: point.x - cachedViewboxWidth / 2,
    y: point.y - cachedViewboxHeight / 2,
    width: cachedViewboxWidth,
    height: cachedViewboxHeight
  });
}
function fitAspectRatio(bounds, targetAspectRatio) {
  var aspectRatio = bounds.width / bounds.height;
  var newBounds = assign({}, {
    x: bounds.x,
    y: bounds.y,
    width: bounds.width,
    height: bounds.height
  });
  if (aspectRatio > targetAspectRatio) {
    var height = newBounds.width * (1 / targetAspectRatio), y5 = newBounds.y - (height - newBounds.height) / 2;
    assign(newBounds, {
      y: y5,
      height
    });
  } else if (aspectRatio < targetAspectRatio) {
    var width = newBounds.height * targetAspectRatio, x6 = newBounds.x - (width - newBounds.width) / 2;
    assign(newBounds, {
      x: x6,
      width
    });
  }
  return newBounds;
}
function map3(x6, inMin, inMax, outMin, outMax) {
  var inRange2 = inMax - inMin, outRange = outMax - outMin;
  return (x6 - inMin) * outRange / inRange2 + outMin;
}
function getIndexOfChildInParentChildren(childGfx, parentGfx) {
  var childrenGroup = query(".djs-children", parentGfx.parentNode);
  if (!childrenGroup) {
    return;
  }
  var childrenArray = [].slice.call(childrenGroup.childNodes);
  var indexOfChild = -1;
  childrenArray.forEach(function(childGroup, index5) {
    if (query(".djs-element", childGroup) === childGfx) {
      indexOfChild = index5;
    }
  });
  return indexOfChild;
}
function insertChildAtIndex(childGfx, parentGfx, index5) {
  var childContainer = getChildContainer(parentGfx);
  var childrenArray = [].slice.call(childContainer.childNodes);
  var childAtIndex = childrenArray[index5];
  if (childAtIndex) {
    parentGfx.insertBefore(childGfx, childAtIndex.nextSibling);
  } else {
    parentGfx.appendChild(childGfx);
  }
}
function getChildContainer(parentGfx) {
  var container = query(".children", parentGfx);
  if (!container) {
    container = create("g", { class: "children" });
    append(parentGfx, container);
  }
  return container;
}
function isZeroDimensional(clientRect) {
  return clientRect.width === 0 && clientRect.height === 0;
}
function isPointInside(point, rect) {
  return point.x > rect.left && point.x < rect.left + rect.width && point.y > rect.top && point.y < rect.top + rect.height;
}
var sign2 = Math.sign || function(n4) {
  return n4 >= 0 ? 1 : -1;
};
function getStepSize2(range, steps) {
  var minLinearRange = Math.log(range.min) / Math.log(10), maxLinearRange = Math.log(range.max) / Math.log(10);
  var absoluteLinearRange = Math.abs(minLinearRange) + Math.abs(maxLinearRange);
  return absoluteLinearRange / steps;
}
function cap2(range, scale) {
  return Math.max(range.min, Math.min(range.max, scale));
}
function getOverlayClipPath(outer, inner) {
  var coordinates = [
    toCoordinatesString(inner.left, inner.top),
    toCoordinatesString(inner.left + inner.width, inner.top),
    toCoordinatesString(inner.left + inner.width, inner.top + inner.height),
    toCoordinatesString(inner.left, inner.top + inner.height),
    toCoordinatesString(inner.left, outer.height),
    toCoordinatesString(outer.width, outer.height),
    toCoordinatesString(outer.width, 0),
    toCoordinatesString(0, 0),
    toCoordinatesString(0, outer.height),
    toCoordinatesString(inner.left, outer.height)
  ].join(", ");
  return "polygon(" + coordinates + ")";
}
function toCoordinatesString(x6, y5) {
  return x6 + "px " + y5 + "px";
}
function validViewbox(viewBox) {
  return every(viewBox, function(value) {
    if (isObject(value)) {
      return validViewbox(value);
    }
    return isNumber(value) && isFinite(value);
  });
}
function getPoint(event2) {
  if (event2.center) {
    return event2.center;
  }
  return {
    x: event2.clientX,
    y: event2.clientY
  };
}
function sanitize(gfx) {
  all("[id]", gfx).forEach(function(element) {
    element.remove();
  });
  return gfx;
}
var index4 = {
  __init__: ["minimap"],
  minimap: ["type", Minimap]
};

// node_modules/heatmap-ts/dist/index.esm.js
var t6 = { defaultRadius: 40, defaultGradient: { 0.25: "rgb(0,0,255)", 0.55: "rgb(0,255,0)", 0.85: "yellow", 1: "rgb(255,0,0)" }, defaultMaxOpacity: 1, defaultMinOpacity: 0, defaultBlur: 0.85, defaultXField: "x", defaultYField: "y", defaultValueField: "value", plugins: {} };
var i6 = function() {
  function t7() {
    this.eStore = {};
  }
  return t7.prototype.on = function(t8, i7, a6) {
    this.eStore[t8] || (this.eStore[t8] = []), this.eStore[t8].push(function(t9) {
      return i7.call(a6, t9);
    });
  }, t7.prototype.emit = function(t8, i7) {
    this.eStore[t8] && this.eStore[t8].forEach(function(t9) {
      return t9(i7);
    });
  }, t7;
}();
var a5 = function() {
  function a6(a7) {
    this.coordinator = new i6(), this.data = [], this.radi = [], this.min = 10, this.max = 1, this.xField = a7.xField || t6.defaultXField, this.yField = a7.yField || t6.defaultYField, this.valueField = a7.valueField || t6.defaultValueField, this.radius = a7.radius || t6.defaultRadius;
  }
  return a6.prototype._organiseData = function(t7, i7) {
    var a7 = t7[this.xField], e8 = t7[this.yField], r7 = this.radi, n4 = this.data, s5 = this.max, h5 = this.min, o5 = t7[this.valueField] || 1, d5 = t7.radius || this.radius;
    r7[a7] || (n4[a7] = [], r7[a7] = []), r7[a7][e8] ? n4[a7][e8] += o5 : (n4[a7][e8] = o5, r7[a7][e8] = d5);
    var u6 = n4[a7][e8];
    return u6 ? u6 > s5 ? (i7 ? this.setDataMax(u6) : this.max = u6, false) : u6 < h5 ? (i7 ? this.setDataMin(u6) : this.min = u6, false) : void 0 : { x: a7, y: e8, value: o5, radius: d5, min: h5, max: s5 };
  }, a6.prototype._unOrganizeData = function() {
    for (var t7 = [], i7 = 0; i7 < this.radi.length; i7++) for (var a7 = 0; a7 < this.radi[i7].length; a7++) t7.push({ x: i7, y: a7, radius: this.radi[i7][a7], value: this.radi[i7][a7] });
    return { min: this.min, max: this.max, data: t7 };
  }, a6.prototype._onExtremaChange = function() {
    this.coordinator.emit("extremachange", { min: this.min, max: this.max });
  }, a6.prototype.addData = function(t7) {
    var i7 = this._organiseData(t7, true);
    i7 && (0 === this.data.length && (this.min = i7.value, this.max = i7.value), this.coordinator.emit("renderpartial", { min: this.min, max: this.max, data: [i7] }));
  }, a6.prototype.setData = function(t7) {
    var i7 = t7.data;
    this.data = [], this.radi = [];
    for (var a7 = 0; a7 < i7.length; a7++) this._organiseData(i7[a7], false);
    return this.min = t7.min || 0, this.max = t7.max || 100, this._onExtremaChange(), this.coordinator.emit("renderall", this._getInternalData()), this;
  }, a6.prototype.setDataMax = function(t7) {
    return this.max = t7, this._onExtremaChange(), this.coordinator.emit("renderall", this._getInternalData()), this;
  }, a6.prototype.setDataMin = function(t7) {
    return this.min = t7, this._onExtremaChange(), this.coordinator.emit("renderall", this._getInternalData()), this;
  }, a6.prototype._getInternalData = function() {
    return { max: this.max, min: this.min, data: this.data, radi: this.radi };
  }, a6.prototype.getData = function() {
    return this._unOrganizeData();
  }, a6;
}();
var e7 = function() {
  function i7(t7) {
    this.canvas = t7.canvas || document.createElement("canvas"), this.ctx = this.canvas.getContext("2d"), this.shadowCanvas = t7.shadowCanvas || document.createElement("canvas"), this.shadowCtx = this.shadowCanvas.getContext("2d"), this.width = t7.width || 512, this.height = t7.height || 512, this.max = 100, this.min = 1, this.radius = t7.radius || 50, this.blur = 1, this.opacity = 1, this.maxOpacity = 1, this.minOpacity = 0, this.useGradientOpacity = false, this.canvas.style.cssText = this.shadowCanvas.style.cssText = "position:absolute;left:0;top:0;", t7.container && (t7.container.style.position = "relative", t7.container.appendChild(this.canvas)), this.renderBoundaries = [1e4, 1e4, 0, 0], this.palette = this._getColorPalette(t7), this.templates = [], this._setStyles(t7);
  }
  return i7.prototype.renderPartial = function(t7) {
    t7.data.length > 0 && (this._drawAlpha(t7), this._colorize());
  }, i7.prototype.renderAll = function(t7) {
    this._clear(), t7.data.length > 0 && (this._drawAlpha(this._prepareData(t7)), this._colorize());
  }, i7.prototype.updateConfig = function(t7) {
    t7.gradient && this._updateGradient(t7), this._setStyles(t7);
  }, i7.prototype.setDimensions = function(t7, i8) {
    this.width = this.canvas.width = this.shadowCanvas.width = t7, this.height = this.canvas.height = this.shadowCanvas.height = i8;
  }, i7.prototype.getValueAt = function(t7) {
    if (!this.shadowCtx) return 0;
    var i8 = this.shadowCtx.getImageData(t7.x, t7.y, 1, 1);
    return Math.abs(this.max - this.min) * (i8.data[3] / 255) >> 0;
  }, i7.prototype.getDataURL = function() {
    return this.canvas.toDataURL();
  }, i7.prototype._getColorPalette = function(i8) {
    var a6 = i8.gradient || t6.defaultGradient, e8 = document.createElement("canvas"), r7 = e8.getContext("2d");
    if (e8.width = 256, e8.height = 1, !r7) return new Uint8ClampedArray(1024);
    var n4 = r7.createLinearGradient(0, 0, 256, 1);
    for (var s5 in a6) n4.addColorStop(Number(s5), a6[s5]);
    return r7.fillStyle = n4, r7.fillRect(0, 0, 256, 1), r7.getImageData(0, 0, 256, 1).data;
  }, i7.prototype._getPointTemplate = function(t7, i8) {
    var a6 = document.createElement("canvas"), e8 = a6.getContext("2d");
    if (!e8) return a6;
    var r7 = t7, n4 = t7;
    if (a6.width = a6.height = 2 * t7, 1 === i8) e8.beginPath(), e8.arc(r7, n4, t7, 0, 2 * Math.PI, false), e8.fillStyle = "rgba(0,0,0,1)", e8.fill();
    else {
      var s5 = e8.createRadialGradient(r7, n4, t7 * i8, r7, n4, t7);
      s5.addColorStop(0, "rgba(0,0,0,1)"), s5.addColorStop(1, "rgba(0,0,0,0)"), e8.fillStyle = s5, e8.fillRect(0, 0, 2 * t7, 2 * t7);
    }
    return a6;
  }, i7.prototype._prepareData = function(t7) {
    for (var i8 = [], a6 = t7.min, e8 = t7.max, r7 = t7.radi, n4 = t7.data, s5 = Object.keys(n4), h5 = s5.length; h5--; ) for (var o5 = s5[h5], d5 = Object.keys(n4[o5]), u6 = d5.length; u6--; ) {
      var l5 = d5[u6], c5 = n4[o5][l5], p5 = r7[o5][l5];
      i8.push({ x: Number(o5), y: Number(l5), value: c5, radius: p5 });
    }
    return { min: a6, max: e8, data: i8 };
  }, i7.prototype._setStyles = function(i8) {
    this.blur = 0 === i8.blur ? 0 : i8.blur || t6.defaultBlur, i8.backgroundColor && (this.canvas.style.backgroundColor = i8.backgroundColor), this.width = this.canvas.width = this.shadowCanvas.width = i8.width || this.width, this.height = this.canvas.height = this.shadowCanvas.height = i8.height || this.height, this.opacity = 255 * (i8.opacity || 0), this.maxOpacity = 255 * (i8.maxOpacity || t6.defaultMaxOpacity), this.minOpacity = 255 * (i8.minOpacity || t6.defaultMinOpacity), this.useGradientOpacity = !!i8.useGradientOpacity;
  }, i7.prototype._updateGradient = function(t7) {
    this.palette = this._getColorPalette(t7);
  }, i7.prototype._drawAlpha = function(t7) {
    for (var i8 = this.min = t7.min || 0, a6 = this.max = t7.max || 100, e8 = t7.data || [], r7 = e8.length, n4 = 1 - this.blur; r7--; ) {
      var s5 = e8[r7], h5 = s5.x, o5 = s5.y, d5 = s5.radius || this.radius, u6 = Math.min(s5.value, a6), l5 = h5 - d5, c5 = o5 - d5;
      if (!this.shadowCtx) return;
      var p5 = void 0;
      this.templates[d5] ? p5 = this.templates[d5] : this.templates[d5] = p5 = this._getPointTemplate(d5, n4);
      var m6 = (u6 - i8) / (a6 - i8);
      this.shadowCtx.globalAlpha = m6 < 0.01 ? 0.01 : m6, this.shadowCtx.drawImage(p5, l5, c5), l5 < this.renderBoundaries[0] && (this.renderBoundaries[0] = l5), c5 < this.renderBoundaries[1] && (this.renderBoundaries[1] = c5), l5 + 2 * d5 > this.renderBoundaries[2] && (this.renderBoundaries[2] = l5 + 2 * d5), c5 + 2 * d5 > this.renderBoundaries[3] && (this.renderBoundaries[3] = c5 + 2 * d5);
    }
  }, i7.prototype._colorize = function() {
    var t7 = this.renderBoundaries[0], i8 = this.renderBoundaries[1], a6 = this.renderBoundaries[2] - t7, e8 = this.renderBoundaries[3] - i8, r7 = this.width, n4 = this.height;
    if (t7 < 0 && (t7 = 0), i8 < 0 && (i8 = 0), t7 + a6 > r7 && (a6 = r7 - t7), i8 + e8 > n4 && (e8 = n4 - i8), this.ctx && this.shadowCtx) {
      for (var s5 = this.shadowCtx.getImageData(t7, i8, a6, e8), h5 = 3; h5 < s5.data.length; h5 += 4) {
        var o5, d5 = s5.data[h5], u6 = 4 * d5;
        if (u6) o5 = this.opacity > 0 ? this.opacity : d5 < this.maxOpacity ? d5 < this.minOpacity ? this.minOpacity : d5 : this.maxOpacity, s5.data[h5 - 3] = this.palette[u6], s5.data[h5 - 2] = this.palette[u6 + 1], s5.data[h5 - 1] = this.palette[u6 + 2], s5.data[h5] = this.useGradientOpacity ? this.palette[u6 + 3] : o5;
      }
      this.ctx.putImageData(s5, t7, i8), this.renderBoundaries = [1e3, 1e3, 0, 0];
    }
  }, i7.prototype._clear = function() {
    this.ctx && this.shadowCtx && (this.ctx.clearRect(0, 0, this.width, this.height), this.shadowCtx.clearRect(0, 0, this.width, this.height));
  }, i7;
}();
var r6 = function() {
  function i7(t7) {
    this.config = t7, this.renderer = new e7(this.config), this.store = new a5(this.config), this._init();
  }
  return i7.prototype._init = function() {
    var i8 = this;
    this.store.coordinator.on("renderpartial", this.renderer.renderPartial, this.renderer), this.store.coordinator.on("renderall", this.renderer.renderAll, this.renderer), this.store.coordinator.on("extremachange", function(a6) {
      i8.config.onExtremaChange && i8.config.onExtremaChange({ min: a6.min, max: a6.max, gradient: i8.config.gradient || t6.defaultGradient });
    });
  }, i7.prototype.addData = function(t7) {
    return this.store.addData(t7), this;
  }, i7.prototype.setData = function(t7) {
    return this.store.setData(t7), this;
  }, i7.prototype.setDataMaxx = function(t7) {
    return this.store.setDataMax(t7), this;
  }, i7.prototype.setDataMin = function(t7) {
    return this.store.setDataMin(t7), this;
  }, i7.prototype.repaint = function() {
    return this.store.coordinator.emit("renderall", this.store._getInternalData()), this;
  }, i7.prototype.getData = function() {
    return this.store.getData();
  }, i7.prototype.getDataURL = function() {
    return this.renderer.getDataURL();
  }, i7.prototype.getValueAt = function(t7) {
    return this.renderer.getValueAt(t7);
  }, i7;
}();
var index_esm_default2 = r6;

// src/bpmnModeler.ts
var VIEW_TYPE_BPMN = "bpmn-view";
var BpmnModelerView = class extends import_obsidian2.TextFileView {
  constructor(leaf, settings) {
    super(leaf);
    this.leaf = leaf;
    this.settings = settings;
  }
  getViewData() {
    return this.data;
  }
  setViewData(data, clear3) {
    this.bpmnXml = data;
    this.bpmnModeler.importXML(this.bpmnXml).catch(function(err) {
      console.error(err);
    });
  }
  async onOpen() {
    let contentEl = this.contentEl.createEl("div", { cls: "bpmn-content" });
    let buttonbar = contentEl.createEl("div");
    let bpmnSave = buttonbar.createEl("button", { text: "Save", attr: { "aria-label": "Save" } });
    let bpmnUndo = buttonbar.createEl("button", { text: "Undo", attr: { "aria-label": "Undo" } });
    let bpmnRedo = buttonbar.createEl("button", { text: "Redo", attr: { "aria-label": "Redo" } });
    let bpmnProperties = buttonbar.createEl("button", {
      text: "Properties",
      attr: { "aria-label": "Show properties" }
    });
    let bpmnSaveSvg = buttonbar.createEl("button", {
      text: "Export SVG",
      attr: { "aria-label": "Export as SVG" }
    });
    let bpmnSavePng = buttonbar.createEl("button", {
      text: "Export PNG",
      attr: { "aria-label": "Export as PNG" }
    });
    let bpmn_view_classes = "bpmn-view bpmn-view-modeler";
    this.bpmnDiv = contentEl.createEl("div", { cls: bpmn_view_classes });
    let propertyPanel = contentEl.createEl("div", { cls: "bpmn-properties-panel hide" });
    let modules = [
      index$3,
      index$2,
      colors_default
    ];
    if (this.settings.enable_token_simulator) {
      modules.push(modeler_default2);
      modules.push(simulation_support_default);
    }
    if (this.settings.enable_minimap) {
      modules.push(index4);
    }
    if (this.settings.enable_grid) {
      modules.push(index3);
    }
    let textRenderer = void 0;
    if (this.settings.enable_sketchy) {
      modules.push(index);
      textRenderer = {
        defaultStyle: {
          fontFamily: '"Comic Sans MS"',
          fontWeight: "normal",
          fontSize: 14,
          lineHeight: 1.1
        },
        externalStyle: {
          fontSize: 14,
          lineHeight: 1.1
        }
      };
    }
    this.bpmnModeler = new Modeler({
      container: this.bpmnDiv,
      propertiesPanel: {
        parent: propertyPanel
      },
      additionalModules: modules,
      textRenderer
    });
    if (this.settings.force_white_background_by_default) {
      this.bpmnDiv.addClass("bpmn-view-white-background");
    }
    const bpmnModeler = this.bpmnModeler;
    const canvas = bpmnModeler.get("canvas");
    const thisRef = this;
    this.bpmnModeler.on("commandStack.changed", function() {
      bpmnModeler.saveXML({ format: true }).then(function(data) {
        const { xml: xml2 } = data;
        thisRef.data = xml2;
      });
    });
    if (this.settings.enable_token_simulator && this.settings.enable_simulation_heatmap) {
      let updateHeatmap = function() {
        let history = simulationSupport.getHistory();
        for (let i7 = last_index; i7 < history.length; i7++) {
          if (!history[i7].startsWith("Flow")) {
            currentHistory.set(history[i7], (currentHistory.get(history[i7]) || 0) + 1);
          }
          last_index = i7 + 1;
        }
        let data = [];
        const viewbox = canvas.viewbox();
        const x_off = viewbox.x;
        const y_off = viewbox.y;
        const scale = viewbox.scale;
        for (const [key, value] of currentHistory) {
          const element = registry.get(key);
          const centerx = scale * (element.x + element.width / 2 - x_off);
          const centery = scale * (element.y + element.height / 2 - y_off);
          data.push({
            x: centerx,
            y: centery,
            value: value * 4
          });
        }
        heatMap.setData({
          data
        });
      };
      const currentHistory = /* @__PURE__ */ new Map();
      let last_index = 0;
      const heatMap = new index_esm_default2({
        container: this.bpmnDiv,
        maxOpacity: 0.8,
        radius: 50,
        blur: 0.8,
        width: this.bpmnDiv.innerWidth,
        height: this.bpmnDiv.innerHeight
      });
      const simulationTrace = bpmnModeler.get("simulationTrace");
      const registry = bpmnModeler.get("elementRegistry");
      const simulationSupport = bpmnModeler.get("simulationSupport");
      simulationTrace.start();
      this.intervalId = setInterval(updateHeatmap, 1e3);
      this.bpmnModeler.on("tokenSimulation.toggleMode", function() {
        simulationTrace.stop();
        simulationTrace._events = [];
        let data = [];
        heatMap.setData({
          data
        });
        currentHistory.clear();
        last_index = 0;
        simulationTrace.start();
      });
      (0, import_obsidian2.setIcon)(bpmnSave, "save");
    }
    bpmnSave.addEventListener("click", function(e8) {
      thisRef.requestSave();
    });
    (0, import_obsidian2.setIcon)(bpmnSave, "save");
    bpmnUndo.addEventListener("click", function(e8) {
      bpmnModeler.get("commandStack").undo();
    });
    (0, import_obsidian2.setIcon)(bpmnUndo, "undo");
    bpmnRedo.addEventListener("click", function(e8) {
      bpmnModeler.get("commandStack").redo();
    });
    (0, import_obsidian2.setIcon)(bpmnRedo, "redo");
    bpmnProperties.addEventListener("click", function(e8) {
      propertyPanel.classList.toggle("hide");
    });
    (0, import_obsidian2.setIcon)(bpmnProperties, "settings");
    bpmnSaveSvg.addEventListener("click", async function(e8) {
      let result = await bpmnModeler.saveSVG();
      await thisRef.saveImageFile(result.svg, "svg");
    });
    (0, import_obsidian2.setIcon)(bpmnSaveSvg, "image");
    bpmnSavePng.addEventListener("click", async function(e8) {
      const svg = (await bpmnModeler.saveSVG()).svg;
      const pngString = void 0;
      if (pngString !== void 0) {
        await thisRef.saveImageFile(pngString, "png");
      }
    });
    bpmnSavePng.hide();
  }
  async saveImageFile(data, format2) {
    let path = "/";
    const currentFile = this.app.workspace.getActiveFile();
    if (currentFile != null) {
      path = currentFile.path.replace(".bpmn", "." + format2);
    }
    const existingFile = await this.app.vault.getAbstractFileByPath(path);
    if (existingFile !== null) {
      await this.app.vault.delete(existingFile);
    }
    let newFile = await this.app.vault.create(path, data);
    let leaf = this.app.workspace.getMostRecentLeaf();
    if (leaf != null) {
      await leaf.openFile(newFile);
    }
  }
  async onClose() {
    await this.save();
    this.contentEl.empty();
    clearInterval(this.intervalId);
  }
  clear() {
  }
  getViewType() {
    return VIEW_TYPE_BPMN;
  }
};

// src/main.ts
var emptyBpmn = '<?xml version="1.0" encoding="UTF-8"?>\n<bpmn2:definitions xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xmlns:bpmn2="http://www.omg.org/spec/BPMN/20100524/MODEL" xmlns:bpmndi="http://www.omg.org/spec/BPMN/20100524/DI" xmlns:dc="http://www.omg.org/spec/DD/20100524/DC" xmlns:di="http://www.omg.org/spec/DD/20100524/DI" xsi:schemaLocation="http://www.omg.org/spec/BPMN/20100524/MODEL BPMN20.xsd" id="sample-diagram" targetNamespace="http://bpmn.io/schema/bpmn">\n  <bpmn2:process id="Process_1" isExecutable="false">\n    <bpmn2:startEvent id="StartEvent_1"/>\n  </bpmn2:process>\n  <bpmndi:BPMNDiagram id="BPMNDiagram_1">\n    <bpmndi:BPMNPlane id="BPMNPlane_1" bpmnElement="Process_1">\n      <bpmndi:BPMNShape id="_BPMNShape_StartEvent_2" bpmnElement="StartEvent_1">\n        <dc:Bounds height="36.0" width="36.0" x="412.0" y="240.0"/>\n      </bpmndi:BPMNShape>\n    </bpmndi:BPMNPlane>\n  </bpmndi:BPMNDiagram>\n</bpmn2:definitions>';
var ObsidianBPMNPlugin = class extends import_obsidian3.Plugin {
  async onload() {
    console.log("BPMN loading...");
    this.settings = Object.assign(new ObsidianBpmnPluginSettings(), await this.loadData());
    this.addSettingTab(new ObsidianBpmnPluginSettingsTab(this.app, this));
    this.registerView(
      VIEW_TYPE_BPMN,
      (leaf) => new BpmnModelerView(leaf, this.settings)
    );
    this.registerExtensions(["bpmn"], VIEW_TYPE_BPMN);
    this.registerMarkdownCodeBlockProcessor("bpmn", async (src, el, ctx) => {
      let parameters = null;
      try {
        parameters = this.readParameters(src);
      } catch (e8) {
        el.createEl("h3", { text: "BPMN parameters invalid: \n" + e8.message });
        return;
      }
      console.log("Try to render a BPMN");
      try {
        if (parameters.url.startsWith("./")) {
          const filePath = ctx.sourcePath;
          const folderPath = filePath.substring(0, filePath.lastIndexOf("/"));
          parameters.url = folderPath + "/" + parameters.url.substring(2, parameters.url.length);
        }
        const rootDiv = el.createEl("div");
        if (parameters.opendiagram) {
          const href = rootDiv.createEl("a", { text: "Open diagram" });
          href.href = parameters.url;
          href.className = "internal-link";
          (0, import_obsidian3.setIcon)(href, "file-edit");
        }
        let bpmn_view_classes = "bpmn-view";
        const bpmnDiv = rootDiv.createEl("div", { cls: bpmn_view_classes });
        if (parameters.forcewhitebackground) {
          bpmnDiv.addClass("bpmn-view-white-background");
        } else {
          const theme3 = this.app.getTheme();
          if (theme3 === "obsidian") {
            bpmnDiv.addClass("bpmn-view-obsidian-theme");
          } else if (theme3 === "moonstone") {
            bpmnDiv.addClass("bpmn-view-moonstone-theme");
          }
        }
        const xml2 = await this.app.vault.adapter.read(parameters.url);
        bpmnDiv.setAttribute("style", "height: " + parameters.height + "px;");
        let modules = [];
        if (this.settings.enable_sketchy) {
          modules.push(index);
        }
        let textRenderer = void 0;
        if (this.settings.enable_sketchy) {
          modules.push(index);
          textRenderer = {
            defaultStyle: {
              fontFamily: '"Comic Sans MS"',
              fontWeight: "normal",
              fontSize: 14,
              lineHeight: 1.1
            },
            externalStyle: {
              fontSize: 14,
              lineHeight: 1.1
            }
          };
        }
        const bpmn = parameters.enablepanzoom ? new NavigatedViewer({
          container: bpmnDiv,
          additionalModules: modules,
          textRenderer
        }) : new Viewer({
          container: bpmnDiv,
          additionalModules: modules,
          textRenderer
        });
        const p_zoom = parameters.zoom;
        const p_x = parameters.x;
        const p_y = parameters.y;
        bpmn.importXML(xml2).then(function(result) {
          const canvas = bpmn.get("canvas");
          if (p_zoom === void 0) {
            canvas.zoom("fit-viewport");
          } else {
            canvas.zoom(p_zoom, { x: p_x, y: p_y });
          }
        }).catch(function(err) {
          const { warnings, message } = err;
          console.error("something went wrong:", warnings, message);
          bpmn.destroy();
          rootDiv.createEl("h3", { text: warnings + " " + message });
        });
        if (parameters.showzoom && parameters.enablepanzoom) {
          const zoomDiv = rootDiv.createEl("div");
          const zoomInBtn = zoomDiv.createEl("button", { "text": "+" });
          zoomInBtn.addEventListener("click", (e8) => bpmn.get("zoomScroll").stepZoom(0.5));
          const zoomOutBtn = zoomDiv.createEl("button", { "text": "-" });
          zoomOutBtn.addEventListener("click", (e8) => bpmn.get("zoomScroll").stepZoom(-0.5));
          (0, import_obsidian3.setIcon)(zoomInBtn, "zoom-in");
          (0, import_obsidian3.setIcon)(zoomOutBtn, "zoom-out");
        }
      } catch (error4) {
        el.createEl("h3", { text: error4 });
        console.error(error4);
      }
    });
    this.addRibbonIcon("file-input", "New BPMN", async () => {
      let path = "/";
      const currentFile = this.app.workspace.getActiveFile();
      if (currentFile != null && currentFile.parent != null) {
        path = currentFile.parent.path + "/";
      }
      path += "model";
      for (let i7 = 1; i7 < 99; i7++) {
        const newPath = path + "_" + i7 + ".bpmn";
        if (!await this.app.vault.adapter.exists(newPath)) {
          path = newPath;
          break;
        }
      }
      let newBpmnContent = emptyBpmn;
      const randomId = (Math.random() + 1).toString(36).substring(7);
      newBpmnContent = newBpmnContent.replace("Process_1", "Process_" + randomId).replace("BPMNDiagram_1", "BPMNDiagram_" + randomId).replace("BPMNPlane_1", "BPMNPlane_" + randomId);
      let newBpmnFile = await this.app.vault.create(path, newBpmnContent);
      let leaf = this.app.workspace.getMostRecentLeaf();
      if (leaf != null) {
        await leaf.openFile(newBpmnFile);
      }
    });
  }
  readParameters(jsonString) {
    if (jsonString.contains("[[") && !jsonString.contains('"[[')) {
      jsonString = jsonString.replace("[[", '"[[');
      jsonString = jsonString.replace("]]", ']]"');
    }
    const parameters = (0, import_obsidian3.parseYaml)(jsonString);
    if (parameters.url.startsWith("[[")) {
      parameters.url = parameters.url.substring(2, parameters.url.length - 2);
      parameters.url = this.app.metadataCache.getFirstLinkpathDest(
        parameters.url,
        ""
      ).path;
    }
    if (parameters.showzoom === void 0) {
      parameters.showzoom = this.settings.showzoom_by_default;
    }
    if (parameters.enablepanzoom === void 0) {
      parameters.enablepanzoom = this.settings.enablepanzoom_by_default;
    }
    if (parameters.opendiagram === void 0) {
      parameters.opendiagram = this.settings.opendiagram_by_default;
    }
    if (parameters.height === void 0) {
      parameters.height = this.settings.height_by_default;
    }
    if (parameters.x === void 0) {
      parameters.x = 0;
    }
    parameters.x *= 10;
    if (parameters.y === void 0) {
      parameters.y = 0;
    }
    parameters.y *= 10;
    if (parameters.forcewhitebackground === void 0) {
      parameters.forcewhitebackground = this.settings.force_white_background_by_default;
    }
    return parameters;
  }
  onunload() {
    console.log("Unloading BPMN plugin...");
  }
};
/*! Bundled license information:

classnames/index.js:
  (*!
  	Copyright (c) 2018 Jed Watson.
  	Licensed under the MIT License (MIT), see
  	http://jedwatson.github.io/classnames
  *)

tabbable/dist/index.esm.js:
  (*!
  * tabbable 6.2.0
  * @license MIT, https://github.com/focus-trap/tabbable/blob/master/LICENSE
  *)

focus-trap/dist/focus-trap.esm.js:
  (*!
  * focus-trap 7.6.4
  * @license MIT, https://github.com/focus-trap/focus-trap/blob/master/LICENSE
  *)
*/

/* nosourcemap */